{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUyOTIxMjk3", "number": 5718, "title": "Feature/#5390 segment indexing reload status api", "bodyText": "Description\nThis PR adds an APIs on the controller and one new API on the server. The purpose of the APIs is to provide segment metadata from the Pinot Server.\nFollowing updates need to be made in the documentation:\n\nNeed to update documentation for querying segment metadata from the server\n\nSample response:\n{\n  \"baseballStats_OFFLINE_0\": {\n    \"segmentName\": \"baseballStats_OFFLINE_0\",\n    \"schemaName\": null,\n    \"crc\": 2400783875,\n    \"creationTimeMillis\": 1599866671163,\n    \"creationTimeReadable\": \"2020-09-11T23:24:31:163 UTC\",\n    \"timeGranularitySec\": null,\n    \"startTimeMillis\": null,\n    \"startTimeReadable\": null,\n    \"endTimeMillis\": null,\n    \"endTimeReadable\": null,\n    \"pushTimeMillis\": -9223372036854776000,\n    \"pushTimeReadable\": null,\n    \"refreshTimeMillis\": -9223372036854776000,\n    \"refreshTimeReadable\": null,\n    \"segmentVersion\": \"v3\",\n    \"creatorName\": null,\n    \"paddingCharacter\": \"\\u0000\",\n    \"columns\": [],\n    \"indexes\": {\n      \"homeRuns\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"$hostName\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"YES\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"playerStint\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"groundedIntoDoublePlays\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"numberOfGames\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"$segmentName\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"YES\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"AtBatting\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"stolenBases\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"tripples\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"hitsByPitch\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"teamID\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"YES\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"numberOfGamesAsBatter\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"strikeouts\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"sacrificeFlies\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"caughtStealing\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"baseOnBalls\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"playerName\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"league\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"YES\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"doules\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"$docId\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"YES\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"yearID\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"YES\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"hits\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"runsBattedIn\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"G_old\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"sacrificeHits\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"intentionalWalks\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"runs\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"NO\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      },\n      \"playerID\": {\n        \"bloom-filter\": \"NO\",\n        \"dictionary\": \"YES\",\n        \"forward-index\": \"YES\",\n        \"inverted-index\": \"YES\",\n        \"null-value-vector-reader\": \"NO\",\n        \"range-index\": \"NO\"\n      }\n    }\n  }\n}\n\nDocumentation\nThe documentation to the PR is here.", "createdAt": "2020-07-20T00:59:34Z", "url": "https://github.com/apache/pinot/pull/5718", "merged": true, "mergeCommit": {"oid": "dc772712f3d52c0c91caa774c320f9ca54b855dd"}, "closed": true, "closedAt": "2020-09-14T16:28:05Z", "author": {"login": "guruguha"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc2qOEFAH2gAyNDUyOTIxMjk3OmU5YTFjOTM1MjA5ZmQ2ZGUwNjVkZWVmYmUwMzM1MjY5NGI0M2VjN2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdICxW0gFqTQ4NzIwMzk1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e9a1c935209fd6de065deefbe03352694b43ec7e", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/e9a1c935209fd6de065deefbe03352694b43ec7e", "committedDate": "2020-07-20T04:49:22Z", "message": "- initial feature push"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1aa8980d26a5e5b3d5c61b5a52f8459b68b8ea5", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/e1aa8980d26a5e5b3d5c61b5a52f8459b68b8ea5", "committedDate": "2020-07-20T04:55:03Z", "message": "Segment Reload API\n- added a new API endpoint for users to query segment reload status\n\nAPI - Table metadata from Server\n- added a new endpoint to fetch segment metadata\n\n- added helper classes and methods to fetch metadata from the server\n\nTests\n- added test to server API to fetch metadata including indexing information"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/6914c3249a31572d29a6f00e5b8f378aabfca3e1", "committedDate": "2020-07-20T06:55:13Z", "message": "Merge remote-tracking branch 'origin/feature/#5390-segment-indexing-reload-status-api' into feature/#5390-segment-indexing-reload-status-api\n\n# Conflicts:\n#\tpinot-core/src/main/java/org/apache/pinot/core/indexsegment/immutable/ImmutableSegmentImpl.java\n#\tpinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java\n#\tpinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java"}, "afterCommit": {"oid": "422c76a7c7bc3291a41970a21825a4ef2bded208", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/422c76a7c7bc3291a41970a21825a4ef2bded208", "committedDate": "2020-07-21T01:49:25Z", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/7e31c1136090a48823c1a159d8608f37375a0096", "committedDate": "2020-07-21T02:43:09Z", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "422c76a7c7bc3291a41970a21825a4ef2bded208", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/422c76a7c7bc3291a41970a21825a4ef2bded208", "committedDate": "2020-07-21T01:49:25Z", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature"}, "afterCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/7e31c1136090a48823c1a159d8608f37375a0096", "committedDate": "2020-07-21T02:43:09Z", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNzgwMTI2", "url": "https://github.com/apache/pinot/pull/5718#pullrequestreview-453780126", "createdAt": "2020-07-23T01:04:15Z", "commit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMTowNDoxNVrOG15OPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMTowNTo0OFrOG15PnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTI0NA==", "bodyText": "there seems to be some unnecessary formatting/whitespaces on all methods of this file. Could you revert those? you should be able to auto-format using the IDE\nsame comment for TablesResourceTest file", "url": "https://github.com/apache/pinot/pull/5718#discussion_r459165244", "createdAt": "2020-07-23T01:04:15Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -128,20 +137,33 @@\n @Api(tags = Constants.SEGMENT_TAG)\n @Path(\"/\")\n public class PinotSegmentRestletResource {\n-  private static Logger LOGGER = LoggerFactory.getLogger(PinotSegmentRestletResource.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PinotSegmentRestletResource.class);\n+\n+  @Inject\n+  ControllerConf _controllerConf;\n \n   @Inject\n   PinotHelixResourceManager _pinotHelixResourceManager;\n \n+  @Inject\n+  Executor _executor;\n+\n+  @Inject\n+  HttpConnectionManager _connectionManager;\n+\n+  @Inject\n+  ControllerMetrics _controllerMetrics;\n+\n+\n   @GET\n   @Produces(MediaType.APPLICATION_JSON)\n   @Path(\"/segments/{tableName}\")\n   @ApiOperation(value = \"List all segments\", notes = \"List all segments\")\n   public List<Map<TableType, List<String>>> getSegments(\n-      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTU5Ng==", "bodyText": "i could spot no change in this method vs same method moved at the bottom. can we keep it here, so that the scope of review stays limited to the actual changes?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r459165596", "createdAt": "2020-07-23T01:05:48Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -246,21 +268,7 @@\n       return segmentMetadata;\n     } else {\n       throw new ControllerApplicationException(LOGGER,\n-          \"Failed to find segment: \" + segmentName + \" in table: \" + tableName, Status.NOT_FOUND);\n-    }\n-  }\n-\n-  @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 172}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MzI3MzE0", "url": "https://github.com/apache/pinot/pull/5718#pullrequestreview-455327314", "createdAt": "2020-07-26T02:38:29Z", "commit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQwMjozODoyOVrOG3I03Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQwNDowMDowMlrOG3JJwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ2OTQ2OQ==", "bodyText": "is there a better return code for this? NOT_FOUND suggests that the table was not found", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460469469", "createdAt": "2020-07-26T02:38:29Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTMxMg==", "bodyText": "nit: How about String.format for constructing these", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471312", "createdAt": "2020-07-26T03:07:07Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTM3NQ==", "bodyText": "nit: for readability\ns/serversToSegmentsMap/serverToSegments\ns/endpoints/serverToEndpoint", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471375", "createdAt": "2020-07-26T03:08:17Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";\n+  }\n+\n+  public List<SegmentStatus> getSegmentReloadTime(String tableNameWithType,\n+                                                  Map<String, List<String>> serversToSegmentsMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTYxMA==", "bodyText": "how about logging the message also here?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471610", "createdAt": "2020-07-26T03:12:07Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";\n+  }\n+\n+  public List<SegmentStatus> getSegmentReloadTime(String tableNameWithType,\n+                                                  Map<String, List<String>> serversToSegmentsMap,\n+                                                  BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTg2Mg==", "bodyText": "can tableReloadStatus ever be null? you'll either catch exception above, or have a non-null reload status", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471862", "createdAt": "2020-07-26T03:15:41Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 379}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjAxNw==", "bodyText": "In the TableReloadStatus, can we also add a message telling the caller how many segments failed to report?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472017", "createdAt": "2020-07-26T03:18:21Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjIxNw==", "bodyText": "Let's specify that this metadata includes metadata from server. Was this the api name that we finally settled on? It's too similar to the other \"metadata\" endpoint and bound to cause confusion", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472217", "createdAt": "2020-07-26T03:21:21Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjM2OQ==", "bodyText": "nit: wrap this in {}", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472369", "createdAt": "2020-07-26T03:23:29Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjM5MQ==", "bodyText": "you already have tableType 3 lines above", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472391", "createdAt": "2020-07-26T03:24:00Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjUzNg==", "bodyText": "does this call return the CONSUMING (mutable) segments and do we need to skip them here?\nAlso how come we're supporting realtime table in reload-status, but not in metadata? I thought we're only planning to skip the CONSUMING segment in both endpoints", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472536", "createdAt": "2020-07-26T03:25:45Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjYzNw==", "bodyText": "some validation to check if table was not found?\nsame for the metadata endpoint", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472637", "createdAt": "2020-07-26T03:27:45Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3Mjc3Mw==", "bodyText": "if table is not found, line 546 itself will throw exception.", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472773", "createdAt": "2020-07-26T03:30:02Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 419}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjgwNw==", "bodyText": "nit: remove trace logs?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472807", "createdAt": "2020-07-26T03:30:27Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+    return segmentsMetadata;\n+  }\n+\n+  private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n+          throws InvalidConfigException, IOException {\n+    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw==", "bodyText": "can we move call to fetch serverToSegmentsMap inside this method, so that it's consistent with the getSegmentsMetadata Method?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473077", "createdAt": "2020-07-26T03:34:57Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.exception.InvalidConfigException;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.controller.api.resources.ServerSegmentMetadataReader;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TableMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TableMetadataReader.class);\n+\n+  private final Executor executor;\n+  private final HttpConnectionManager connectionManager;\n+  private final PinotHelixResourceManager pinotHelixResourceManager;\n+\n+  public TableMetadataReader(Executor executor, HttpConnectionManager connectionManager,\n+                             PinotHelixResourceManager helixResourceManager) {\n+    this.executor = executor;\n+    this.connectionManager = connectionManager;\n+    this.pinotHelixResourceManager = helixResourceManager;\n+  }\n+\n+  public TableReloadStatus getReloadStatus(String tableNameWithType, Map<String, List<String>> serverToSegmentsMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzIzNA==", "bodyText": "didnt understand why this needs to be copied to another ObjectNode. Can we get it directly from JsonNode?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473234", "createdAt": "2020-07-26T03:36:50Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.exception.InvalidConfigException;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.controller.api.resources.ServerSegmentMetadataReader;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TableMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TableMetadataReader.class);\n+\n+  private final Executor executor;\n+  private final HttpConnectionManager connectionManager;\n+  private final PinotHelixResourceManager pinotHelixResourceManager;\n+\n+  public TableMetadataReader(Executor executor, HttpConnectionManager connectionManager,\n+                             PinotHelixResourceManager helixResourceManager) {\n+    this.executor = executor;\n+    this.connectionManager = connectionManager;\n+    this.pinotHelixResourceManager = helixResourceManager;\n+  }\n+\n+  public TableReloadStatus getReloadStatus(String tableNameWithType, Map<String, List<String>> serverToSegmentsMap,\n+                                           int timeoutMs)\n+          throws InvalidConfigException {\n+    BiMap<String, String> endpoints = pinotHelixResourceManager.getDataInstanceAdminEndpoints(serverToSegmentsMap.keySet());\n+    ServerSegmentMetadataReader serverSegmentMetadataReader = new ServerSegmentMetadataReader(executor, connectionManager);\n+\n+    List<SegmentStatus> segmentStatus = serverSegmentMetadataReader.getSegmentReloadTime(tableNameWithType, serverToSegmentsMap, endpoints, timeoutMs);\n+    TableReloadStatus tableReloadStatus = new TableReloadStatus();\n+    tableReloadStatus._tableName = tableNameWithType;\n+    tableReloadStatus._segmentStatus = segmentStatus;\n+    return tableReloadStatus;\n+  }\n+\n+  public Map<String, String> getSegmentsMetadata(String tableNameWithType, int timeoutMs) throws InvalidConfigException, IOException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    BiMap<String, String> endpoints = pinotHelixResourceManager.getDataInstanceAdminEndpoints(serversToSegmentsMap.keySet());\n+    ServerSegmentMetadataReader serverSegmentMetadataReader = new ServerSegmentMetadataReader(executor, connectionManager);\n+\n+    List<String> segmentsMetadata = serverSegmentMetadataReader.getSegmentMetadataFromServer(tableNameWithType,\n+            serversToSegmentsMap, endpoints, timeoutMs);\n+\n+    Map<String, String> response = new HashMap<>();\n+    for (String segmentMetadata : segmentsMetadata) {\n+      JsonNode responseJson = JsonUtils.stringToJsonNode(segmentMetadata);\n+      ObjectNode objectNode = responseJson.deepCopy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg==", "bodyText": "How about moving this also to TableReader just like TableReloadStatus? Also, if  you need the equals and hashcode, use EqualityUtils (look at Schema  class for example)", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473352", "createdAt": "2020-07-26T03:39:03Z", "author": {"login": "npawar"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import java.util.Objects;\n+\n+public class SegmentStatus {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzUzOQ==", "bodyText": "nit: this log is misleading \"Updated metadata\"", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473539", "createdAt": "2020-07-26T03:41:30Z", "author": {"login": "npawar"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDMyNA==", "bodyText": "remove comment", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474324", "createdAt": "2020-07-26T03:52:58Z", "author": {"login": "npawar"}, "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDUyNQ==", "bodyText": "nit: wrap all the if else using {}\ncreate private static final constants for the keys and values that are being put in indexesNode.", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474525", "createdAt": "2020-07-26T03:55:48Z", "author": {"login": "npawar"}, "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();\n+        Map<String, ColumnIndexContainer> columnIndexContainerMap = immutableSegmentImpl.getIndexContainerMap();\n+        columnsIndexMetadata.add(getImmutableSegmentColumnIndexes(columnIndexContainerMap, columnSet));\n+      }\n+    }\n+    return columnsIndexMetadata;\n+  }\n+\n+  private static ObjectNode getImmutableSegmentColumnIndexes(Map<String, ColumnIndexContainer> columnIndexContainerMap,\n+                                                             Set<String> columnSet) {\n+    ObjectNode columnIndexMap = JsonUtils.newObjectNode();\n+\n+    for (Map.Entry<String, ColumnIndexContainer> e : columnIndexContainerMap.entrySet()) {\n+      if (columnSet != null && !columnSet.contains(e.getKey())) {\n+        continue;\n+      }\n+      ColumnIndexContainer columnIndexContainer = e.getValue();\n+      ObjectNode indexesNode = JsonUtils.newObjectNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDU1Ng==", "bodyText": "any reason you're using ObjectNode instead of Map?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474556", "createdAt": "2020-07-26T03:56:26Z", "author": {"login": "npawar"}, "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();\n+        Map<String, ColumnIndexContainer> columnIndexContainerMap = immutableSegmentImpl.getIndexContainerMap();\n+        columnsIndexMetadata.add(getImmutableSegmentColumnIndexes(columnIndexContainerMap, columnSet));\n+      }\n+    }\n+    return columnsIndexMetadata;\n+  }\n+\n+  private static ObjectNode getImmutableSegmentColumnIndexes(Map<String, ColumnIndexContainer> columnIndexContainerMap,\n+                                                             Set<String> columnSet) {\n+    ObjectNode columnIndexMap = JsonUtils.newObjectNode();\n+\n+    for (Map.Entry<String, ColumnIndexContainer> e : columnIndexContainerMap.entrySet()) {\n+      if (columnSet != null && !columnSet.contains(e.getKey())) {\n+        continue;\n+      }\n+      ColumnIndexContainer columnIndexContainer = e.getValue();\n+      ObjectNode indexesNode = JsonUtils.newObjectNode();\n+      if (Objects.isNull(columnIndexContainer.getBloomFilter())) indexesNode.put(\"bloom-filter\", \"NO\");\n+      else indexesNode.put(\"bloom-filter\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getDictionary())) indexesNode.put(\"dictionary\", \"NO\");\n+      else indexesNode.put(\"dictionary\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getForwardIndex())) indexesNode.put(\"forward-index\", \"NO\");\n+      else indexesNode.put(\"forward-index\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getInvertedIndex())) indexesNode.put(\"inverted-index\", \"NO\");\n+      else indexesNode.put(\"inverted-index\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getNullValueVector()))\n+        indexesNode.put(\"null-value-vector-reader\", \"NO\");\n+      else indexesNode.put(\"null-value-vector-reader\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getNullValueVector())) indexesNode.put(\"range-index\", \"NO\");\n+      else indexesNode.put(\"range-index\", \"YES\");\n+\n+      columnIndexMap.set(e.getKey(), indexesNode);\n+    }\n+    return columnIndexMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDgxNg==", "bodyText": "remove all the unnecessary whitespace additions in this file", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474816", "createdAt": "2020-07-26T04:00:02Z", "author": {"login": "npawar"}, "path": "pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java", "diffHunk": "@@ -44,7 +48,7 @@\n \n   @Test\n   public void getTables()\n-      throws Exception {\n+          throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "committedDate": "2020-07-26T08:38:36Z", "message": "Code Review Changes\n- Updating code as per PR review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "committedDate": "2020-07-28T04:46:07Z", "message": "Adding comments to new classes and methods added as part of this feature\nRemoving SegmentMetadataFetcher as it seemed redundant\nRefactoring code to save failed segment reload status API calls as part of response"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNzM4ODU0", "url": "https://github.com/apache/pinot/pull/5718#pullrequestreview-451738854", "createdAt": "2020-07-20T15:52:12Z", "commit": {"oid": "6914c3249a31572d29a6f00e5b8f378aabfca3e1"}, "state": "DISMISSED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTo1MjoxMlrOG0Ue1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxODoxMVrOG5CU0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNDcxMA==", "bodyText": "Is your IDE set to pinot coding guidelines?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457514710", "createdAt": "2020-07-20T15:52:12Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -176,23 +198,23 @@\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)\", notes = \"Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)\")\n   public List<Map<String, String>> getServerToSegmentsMapDeprecated1(\n-      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-      @ApiParam(value = \"MUST be null\") @QueryParam(\"state\") String stateStr,\n-      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr)\n-      throws JsonProcessingException {\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6914c3249a31572d29a6f00e5b8f378aabfca3e1"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNzkzNA==", "bodyText": "If you are returning 404 (NOT_FOUND) then please do not use \"Failed\" in the exception message. Since the exception is invalid config, determine what is invalid and throw that exception, may be as 400 (BAD_REQUEST)", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457517934", "createdAt": "2020-07-20T15:56:08Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6914c3249a31572d29a6f00e5b8f378aabfca3e1"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxODc1NA==", "bodyText": "The exception message reads as if the table is not found. That is not the case, right?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457518754", "createdAt": "2020-07-20T15:57:08Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6914c3249a31572d29a6f00e5b8f378aabfca3e1"}, "originalPosition": 380}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxODk2MA==", "bodyText": "If there are no tables found, then this is the place to throw 404", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457518960", "createdAt": "2020-07-20T15:57:26Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6914c3249a31572d29a6f00e5b8f378aabfca3e1"}, "originalPosition": 370}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMTY0Nw==", "bodyText": "remove these trace logs please", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457521647", "createdAt": "2020-07-20T16:00:46Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+    return segmentsMetadata;\n+  }\n+\n+  private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n+          throws InvalidConfigException, IOException {\n+    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6914c3249a31572d29a6f00e5b8f378aabfca3e1"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMjkzNg==", "bodyText": "thy is this class in controller/api/resources? It should be inside controller/util", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457522936", "createdAt": "2020-07-20T16:02:26Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6914c3249a31572d29a6f00e5b8f378aabfca3e1"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0MTA3NQ==", "bodyText": "So, you are using this same class in both Controller as well as Server APIs. That is nice but has its pit falls. Imagine a case when we add a new field to this object. We cannot upgrade controllers and servers at the same time. So, there can exist a situation where servers are sending the old object (serialized) and the controller is trying to deserialize them using the new object. Or, vice versa.\nAt the minimum:\n\nWrite a block of comment at the top of the class that this class is upgrade sensitive explaining what may happen if it is changed without regard to upgrade consideration.\nSpecifically mention that fields cannot be removed from the class (I suppose, unless there are proper defaults)\nAdd an annotation to ignore unknown fields at the class level.", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462441075", "createdAt": "2020-07-29T16:47:02Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import java.util.Objects;\n+\n+public class SegmentStatus {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MzI1Nw==", "bodyText": "I strongly suggest we return a different object to the user instead of returning this one. It will enable us to evolve the internal interface independent of interface exposed to the user.\nAlso, the controller returned status could include other run-time status about a segment. For example:\n\nHelix externalview of the server so we know if it is online or not.\nThe crc, size, date uploaded/refreshed, etc. from segment metadata\nOther info as wee want to add later (e.g. number of times segment was hit/searched/selected since reboot, etc.)", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462453257", "createdAt": "2020-07-29T17:07:04Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import java.util.Objects;\n+\n+public class SegmentStatus {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NDQ2Nw==", "bodyText": "Why is this a \"String\"? Why not 'long'?\nPlease clearly indicate the time unit in the field name. e.g. segmentReloadTimeUTCMs\nWhat is the value in this field if the segment was never reloaded, or the server restarts after the reload? Or, the reload faced an error and failed?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462454467", "createdAt": "2020-07-29T17:09:05Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+/**\n+ * Holds segment last reload time status along with any errors for a segment with unsuccessful call to get reload times.\n+ */\n+public class SegmentStatus {\n+  public String _segmentName;\n+  public String _segmentReloadTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NDk3NA==", "bodyText": "Please document each member in this object clearly, what it contains in various situations", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462454974", "createdAt": "2020-07-29T17:09:52Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import java.util.Objects;\n+\n+public class SegmentStatus {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NjAyNg==", "bodyText": "Let us call it \"loadStatus\" or \"runTimeStatus\" (I think all our APIs are in camel case). And change the comments/String below appropriately", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462456026", "createdAt": "2020-07-29T17:11:38Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NzE4OA==", "bodyText": "Seems like a debug level log.", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462457188", "createdAt": "2020-07-29T17:13:24Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Nzk2OQ==", "bodyText": "Indicate the server name here that caused the error (unless that is logged elsewhere)", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462457969", "createdAt": "2020-07-29T17:14:41Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg==", "bodyText": "I strongly suggest adding a verbosity level and/or a limit here. Can be added later if you wish. Imagine a table with a million segments. Do we really want to kill the servers trying to query all the segments? Or, output them only to let the client time out?\nAn example could be: limit=100 by default, verbosity=5. A level of 4, 3, 2,1 will show less information for each segment. Maybe 0 will only show how many segments that are online/offline etc.?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462460112", "createdAt": "2020-07-29T17:18:11Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NTkyMTAw", "url": "https://github.com/apache/pinot/pull/5718#pullrequestreview-465592100", "createdAt": "2020-08-12T05:01:42Z", "commit": {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "committedDate": "2020-08-12T05:28:00Z", "message": "Code refactor to accommodate PR comments\nPinot codestyle corrections\nMoving ServerSegmentMetadataReader to util"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d14f14300ff6053d3f2e2194a88790e636baeead", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/d14f14300ff6053d3f2e2194a88790e636baeead", "committedDate": "2020-08-12T05:55:19Z", "message": "Updating API definition for loadStatus"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MTA3NjUw", "url": "https://github.com/apache/pinot/pull/5718#pullrequestreview-466107650", "createdAt": "2020-08-12T17:03:49Z", "commit": {"oid": "d14f14300ff6053d3f2e2194a88790e636baeead"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5b7d1c56828ea195fb0ceeb2dee0244fe2fe8d8", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/b5b7d1c56828ea195fb0ceeb2dee0244fe2fe8d8", "committedDate": "2020-08-13T20:26:36Z", "message": "Code refactor to remove duplicate code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ee255fb4bf05af46d0006e6c2c9cb0174820905", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/8ee255fb4bf05af46d0006e6c2c9cb0174820905", "committedDate": "2020-08-13T20:30:03Z", "message": "Code refactor to remove duplicate code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "committedDate": "2020-08-13T20:30:33Z", "message": "Merge remote-tracking branch 'origin/feature/#5390-segment-indexing-reload-status-api' into feature/#5390-segment-indexing-reload-status-api\n\n# Conflicts:\n#\tpinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzYwMzUy", "url": "https://github.com/apache/pinot/pull/5718#pullrequestreview-471760352", "createdAt": "2020-08-20T15:57:04Z", "commit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo1NzowNFrOHEIYJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjoxNTo1NFrOHEJHHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MzYwNQ==", "bodyText": "Not all comments have been addressed. Please justify the use of the same class to return values to the user. It makes upgrades bad. Add json ignore case so that the pain is at least reduced a bit.", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474093605", "createdAt": "2020-08-20T15:57:04Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import java.util.Objects;\n+\n+public class SegmentStatus {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, "originalCommit": {"oid": "7e31c1136090a48823c1a159d8608f37375a0096"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NzQ5MQ==", "bodyText": "Add the server name to this log", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474097491", "createdAt": "2020-08-20T16:03:14Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java", "diffHunk": "@@ -64,40 +62,25 @@ public ServerTableSizeReader(Executor executor, HttpConnectionManager connection\n       serverUrls.add(tableSizeUri);\n     }\n \n-    // TODO: use some service other than completion service so that we know which server encounters the error\n-    CompletionService<GetMethod> completionService =\n-        new MultiGetRequest(_executor, _connectionManager).execute(serverUrls, timeoutMs);\n+    // Helper service to run a httpget call to the server\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager,\n+        endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverUrls, tableNameWithType, timeoutMs);\n     Map<String, List<SegmentSizeInfo>> serverToSegmentSizeInfoListMap = new HashMap<>();\n-\n-    for (int i = 0; i < numServers; i++) {\n-      GetMethod getMethod = null;\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n       try {\n-        getMethod = completionService.take().get();\n-        URI uri = getMethod.getURI();\n-        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n-        if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n-          continue;\n-        }\n         TableSizeInfo tableSizeInfo =\n-            JsonUtils.inputStreamToObject(getMethod.getResponseBodyAsStream(), TableSizeInfo.class);\n-        serverToSegmentSizeInfoListMap.put(instance, tableSizeInfo.segments);\n-      } catch (Exception e) {\n-        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n-        // Log the number of failed servers after gathering all responses\n-      } finally {\n-        if (getMethod != null) {\n-          getMethod.releaseConnection();\n-        }\n+            JsonUtils.stringToObject(streamResponse.getValue(), TableSizeInfo.class);\n+        serverToSegmentSizeInfoListMap.put(streamResponse.getKey(), tableSizeInfo.segments);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTMyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment size info responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment size info responses from {} servers.\", failedParses);\n          \n      \n    \n    \n  \n\nIf possible, add the total number of servers to this message as well", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474099326", "createdAt": "2020-08-20T16:06:00Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java", "diffHunk": "@@ -64,40 +62,25 @@ public ServerTableSizeReader(Executor executor, HttpConnectionManager connection\n       serverUrls.add(tableSizeUri);\n     }\n \n-    // TODO: use some service other than completion service so that we know which server encounters the error\n-    CompletionService<GetMethod> completionService =\n-        new MultiGetRequest(_executor, _connectionManager).execute(serverUrls, timeoutMs);\n+    // Helper service to run a httpget call to the server\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager,\n+        endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverUrls, tableNameWithType, timeoutMs);\n     Map<String, List<SegmentSizeInfo>> serverToSegmentSizeInfoListMap = new HashMap<>();\n-\n-    for (int i = 0; i < numServers; i++) {\n-      GetMethod getMethod = null;\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n       try {\n-        getMethod = completionService.take().get();\n-        URI uri = getMethod.getURI();\n-        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n-        if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n-          continue;\n-        }\n         TableSizeInfo tableSizeInfo =\n-            JsonUtils.inputStreamToObject(getMethod.getResponseBodyAsStream(), TableSizeInfo.class);\n-        serverToSegmentSizeInfoListMap.put(instance, tableSizeInfo.segments);\n-      } catch (Exception e) {\n-        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n-        // Log the number of failed servers after gathering all responses\n-      } finally {\n-        if (getMethod != null) {\n-          getMethod.releaseConnection();\n-        }\n+            JsonUtils.stringToObject(streamResponse.getValue(), TableSizeInfo.class);\n+        serverToSegmentSizeInfoListMap.put(streamResponse.getKey(), tableSizeInfo.segments);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n       }\n     }\n-\n-    int numServersResponded = serverToSegmentSizeInfoListMap.size();\n-    if (numServersResponded != numServers) {\n-      LOGGER.warn(\"Finish reading segment sizes for table: {} with {}/{} servers responded\", tableNameWithType,\n-          numServersResponded, numServers);\n-    } else {\n-      LOGGER.info(\"Finish reading segment sizes for table: {}\", tableNameWithType);\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment size info responses from server.\", failedParses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDc5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      numServersResponded, serverURLs);\n          \n          \n            \n                      numServersResponded, serverURLs.size());", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474100793", "createdAt": "2020-08-20T16:08:21Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.controller.util;\n+\n+import com.google.common.collect.BiMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that can be used to make HttpGet (MultiGet) calls and get the responses back.\n+ * The responses are returned as a string.\n+ *\n+ * The helper also records number of failed responses so that the caller knows if any of the calls\n+ * failed to respond. The failed instance is logged for debugging.\n+ */\n+public class CompletionServiceHelper {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompletionServiceHelper.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _httpConnectionManager;\n+  private final BiMap<String, String> _endpointsToServers;\n+\n+  public CompletionServiceHelper(Executor executor, HttpConnectionManager httpConnectionManager,\n+                                 BiMap<String, String> endpointsToServers) {\n+    _executor = executor;\n+    _httpConnectionManager = httpConnectionManager;\n+    _endpointsToServers = endpointsToServers;\n+  }\n+\n+  public CompletionServiceResponse doMultiGetRequest(List<String> serverURLs, String tableNameWithType, int timeoutMs) {\n+    CompletionServiceResponse completionServiceResponse = new CompletionServiceResponse();\n+\n+    // TODO: use some service other than completion service so that we know which server encounters the error\n+    CompletionService<GetMethod> completionService =\n+        new MultiGetRequest(_executor, _httpConnectionManager).execute(serverURLs, timeoutMs);\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = _endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          completionServiceResponse._failedResponseCount++;\n+          continue;\n+        }\n+        completionServiceResponse._httpResponses.put(instance, getMethod.getResponseBodyAsString());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (getMethod != null) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+\n+    int numServersResponded = completionServiceResponse._httpResponses.size();\n+    if (numServersResponded != serverURLs.size()) {\n+      LOGGER.warn(\"Finish reading information for table: {} with {}/{} server responses\", tableNameWithType,\n+          numServersResponded, serverURLs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTU0MQ==", "bodyText": "Add server name in the log", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474101541", "createdAt": "2020-08-20T16:09:30Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMjE0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment metadata responses from {} servers.\", failedParses);\n          \n      \n    \n    \n  \n\nIf possible add total number of servers to this message as well", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474102143", "createdAt": "2020-08-20T16:10:22Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMjk4MQ==", "bodyText": "add the number of servers to this log message", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474102981", "createdAt": "2020-08-20T16:11:40Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzM4Ng==", "bodyText": "add server name", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103386", "createdAt": "2020-08-20T16:12:15Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzU2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment load status responses from {} servers.\", failedParses);", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103561", "createdAt": "2020-08-20T16:12:32Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzcyMA==", "bodyText": "nit: typo", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103720", "createdAt": "2020-08-20T16:12:47Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);\n+    }\n+\n+    TableReloadStatus tableReloadStatus = new TableReloadStatus();\n+    tableReloadStatus._tableName = tableNameWithType;\n+    tableReloadStatus._segmentStatus = segmentsStatus;\n+    tableReloadStatus._numSegmentsFailed = serviceResponse._failedResponseCount;\n+    return tableReloadStatus;\n+  }\n+\n+  /**\n+   * Structure to hold the reload statsus for all segments of a given table.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNDg3NQ==", "bodyText": "Why is this a String and not long?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474104875", "createdAt": "2020-08-20T16:14:41Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+/**\n+ * Holds segment last reload time status along with any errors for a segment with unsuccessful call to get reload times.\n+ *\n+ * NOTE: This class is being used in both the controller and the server. There is tight coupling between them.\n+ * So, the API contract cannot be changed without changing or refactoring this class.\n+ *\n+ * TODO: refactor this class to be handled better. Make sure to have an extensible design that helps add more\n+ */\n+public class SegmentStatus {\n+  // Name of the segment itself\n+  public String _segmentName;\n+  // The last segment reload time in ISO date format (yyyy-MM-dd HH:mm:ss:SSS UTC)\n+  // If the segment reload failed for a segment, then the value will be the previous segment reload was successful\n+  public String _segmentReloadTimeUTC;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNTYzMA==", "bodyText": "Ideally we should have timeout declared in milliseconds, so that we can configure sub-second values for fast responses. I suppose you are re-using a previously declared config here?", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474105630", "createdAt": "2020-08-20T16:15:54Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +504,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/loadStatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Load status of a table segment\", notes = \"Load status of a table segment\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/6e03c9b384d0eb1ab668bb01228885b26105d2a4", "committedDate": "2020-08-22T15:32:50Z", "message": "Code refactor as per PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3e67e788932097cf92219bb7e41cb9a159d2144", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/f3e67e788932097cf92219bb7e41cb9a159d2144", "committedDate": "2020-08-22T15:30:17Z", "message": "Code refactor as per PR comments"}, "afterCommit": {"oid": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/6e03c9b384d0eb1ab668bb01228885b26105d2a4", "committedDate": "2020-08-22T15:32:50Z", "message": "Code refactor as per PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a1cc16e2e871d8b47c71d9ba37ca38e3733037f", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/2a1cc16e2e871d8b47c71d9ba37ca38e3733037f", "committedDate": "2020-08-28T20:21:27Z", "message": "Updating segment loadStatus API to return long time than readable string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "563e56c9555250f2020efa016f43a069c2534d8f", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/563e56c9555250f2020efa016f43a069c2534d8f", "committedDate": "2020-08-29T02:26:55Z", "message": "- Bug fix on the server API endpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d23434502cc83f96aa72f086fe936a0689c83079", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/d23434502cc83f96aa72f086fe936a0689c83079", "committedDate": "2020-08-29T02:37:16Z", "message": "Adding pretty print for server metadata response"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d13c91e180fb80a0b1770122c16a4250c7c8c36e", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/d13c91e180fb80a0b1770122c16a4250c7c8c36e", "committedDate": "2020-09-01T02:56:41Z", "message": "Reverting incorrect filename refactoring\nUpdating variable names to reflect their value type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac98a410431f598e3b60f4980fc40b63f32c8e2b", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/ac98a410431f598e3b60f4980fc40b63f32c8e2b", "committedDate": "2020-09-02T04:16:59Z", "message": "removing unused method variable"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f26a5aa9c83c6a103a206987f1cd8d5a8bdc8195", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/f26a5aa9c83c6a103a206987f1cd8d5a8bdc8195", "committedDate": "2020-09-02T04:15:08Z", "message": "Updating segment metadata to return index information for all columns"}, "afterCommit": {"oid": "ac98a410431f598e3b60f4980fc40b63f32c8e2b", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/ac98a410431f598e3b60f4980fc40b63f32c8e2b", "committedDate": "2020-09-02T04:16:59Z", "message": "removing unused method variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cf562909c7465b428df3a0a8b1d5ef5421b83d2", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/2cf562909c7465b428df3a0a8b1d5ef5421b83d2", "committedDate": "2020-09-09T01:06:26Z", "message": "Enabling Pretty print of server response.\nCode refactor to clean up lines that went beyond line length"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b36d4cf84d880efee931c8f8c4aa379311da7880", "author": {"user": {"login": "guruguha", "name": "Guruguha"}}, "url": "https://github.com/apache/pinot/commit/b36d4cf84d880efee931c8f8c4aa379311da7880", "committedDate": "2020-09-09T03:08:00Z", "message": "Removing reload status API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f98c9949a7a280bc52b29488e6d8800f90e5852", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/3f98c9949a7a280bc52b29488e6d8800f90e5852", "committedDate": "2020-09-11T23:33:16Z", "message": "Pretty print result"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec3603b051f92369402743bb48b7b8c88ce74ac7", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/ec3603b051f92369402743bb48b7b8c88ce74ac7", "committedDate": "2020-09-12T00:32:15Z", "message": "Fix test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae2ce79e401da94092d6d53691fb5d7c78c2c6b4", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/ae2ce79e401da94092d6d53691fb5d7c78c2c6b4", "committedDate": "2020-09-12T00:25:20Z", "message": "Fix test"}, "afterCommit": {"oid": "ec3603b051f92369402743bb48b7b8c88ce74ac7", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/ec3603b051f92369402743bb48b7b8c88ce74ac7", "committedDate": "2020-09-12T00:32:15Z", "message": "Fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjAzOTUz", "url": "https://github.com/apache/pinot/pull/5718#pullrequestreview-487203953", "createdAt": "2020-09-12T05:02:21Z", "commit": {"oid": "ec3603b051f92369402743bb48b7b8c88ce74ac7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 390, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}