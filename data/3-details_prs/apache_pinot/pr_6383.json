{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1NDgzNzYx", "number": 6383, "title": "Introduce 'LOOKUP' Transform Function", "bodyText": "Description\nIntroducing a new transform function; LookupTransformFunction as a part of Join project as described in Lookup UDF Join In Pinot. This is a followup to the addition of DimensionTableManager in #6346.\nLOOKUP is a regular transform function which uses the previously added DimensionTableDataManager to execute a lookup from a Dimension table. Call signature is as follows:\nLOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\n\nTableName: name of the dimension table which will be used\nColumnName: column name from the dimension table to look up\nJoinKey: primary key column name for the dimension table. Note: Only primary key is supported for JoinKey\nJoinValue: primary key value\n*If the dimension table has more then one primary keys (composite PK), you can add more keys and values for the rest of the args: JoinKey2, JoinValue2 ... etc.\nExample Query:\nSELECT\n    baseballStats.playerName,\n    baseballStats.teamID,\n    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\nFROM\n    baseballStats\nLIMIT 10\nAbove example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key. Lookup function returns the value of the column 'teamName'.\nTo see the function in action you can also fire JoinQuickstart and test it as follows:\n\nTesting\n\nUnit tests are included to cover basic functionality and I also added a sample usage (table creation + query) in JoinQuickstart.\nEnd to end functionality is also tested in a previous POC pull request here.\n\nDocumentation\n\nComprehensive documentation explaining the usage of 'Dimension' tables is being worked on and will be added to the https://github.com/pinot-contrib/pinot-docs repository in a separate PR.\nLookupTransformFuncion usage and a sample query is added as a JavaDoc .", "createdAt": "2020-12-25T00:07:53Z", "url": "https://github.com/apache/pinot/pull/6383", "merged": true, "mergeCommit": {"oid": "d04785c83f5740a5cec0a2c30d570949304cb8ad"}, "closed": true, "closedAt": "2021-01-08T02:00:33Z", "author": {"login": "cbalci"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdpLRDpgH2gAyNTQ1NDgzNzYxOmZlYzhkODEwMWI0YzQxOTgyMTIxMmJkNWIyYTE5Y2E5M2QxZTI0ZmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdt-Zx7AFqTU2Mzk0NDE0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "fec8d8101b4c419821212bd5b2a19ca93d1e24fb", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/fec8d8101b4c419821212bd5b2a19ca93d1e24fb", "committedDate": "2020-12-24T03:35:43Z", "message": "Add 'lookUp' transform function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/1b141d893f73695b6363a12b3efdf2c93ca96ee5", "committedDate": "2020-12-24T03:52:30Z", "message": "Add sample lookup query to join quickstart"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4ODQwMTEy", "url": "https://github.com/apache/pinot/pull/6383#pullrequestreview-558840112", "createdAt": "2020-12-25T23:30:03Z", "commit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQyMzozMDowM1rOILfiGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQyMzozODowMVrOILfkNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTg4MQ==", "bodyText": "Do we need to assume a dim table is always an offline table?", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548921881", "createdAt": "2020-12-25T23:30:03Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTk2MA==", "bodyText": "Can you update it with an ANSI SQL query here?\nE.g.\nSELECT baseballstats.playername,\n       baseballstats.teamid,\n       baseballteams.teamname\nFROM   baseballstats\n       JOIN baseballteams\n         ON baseballteams.teamid = baseballstats.teamid\nLIMIT  10", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548921960", "createdAt": "2020-12-25T23:32:05Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMjQyMw==", "bodyText": "format: identation.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548922423", "createdAt": "2020-12-25T23:38:01Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4OTUzNjkz", "url": "https://github.com/apache/pinot/pull/6383#pullrequestreview-558953693", "createdAt": "2020-12-27T19:16:31Z", "commit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxOToxNjozMlrOILtsMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QyMzowNTo0MVrOILu8pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1Mzg0Mw==", "bodyText": "takes", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549153843", "createdAt": "2020-12-27T19:16:32Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw==", "bodyText": "also check that all the primary keys are provided.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549174187", "createdAt": "2020-12-27T23:02:54Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA==", "bodyText": "how about byte?", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549174438", "createdAt": "2020-12-27T23:05:41Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,\n+                    String.format(\"Primary key column doesn't exist in dimension table: %s:%s\",_dimTableName, joinKey));\n+            _joinValueFieldSpecs.add(pkColumnSpec);\n+        }\n+    }\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+            _lookupColumnFieldSpec.isSingleValueField(),\n+            false);\n+    }\n+\n+    private Object[] lookup(ProjectionBlock projectionBlock) {\n+        int numPkColumns = _joinKeys.size();\n+        int numDocuments = projectionBlock.getNumDocs();\n+        Object[][] pkColumns = new Object[numPkColumns][];\n+        for (int i=0; i<numPkColumns; i++) {\n+            FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+            TransformFunction tf = _joinValueFunctions.get(i);\n+            switch (colType) {\n+                case STRING:\n+                    pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+                    break;\n+                case INT:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+                    break;\n+                case LONG:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown column type for primary key\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "345b1f77307724ae20d685650efcfc9c498bca4d", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/345b1f77307724ae20d685650efcfc9c498bca4d", "committedDate": "2020-12-28T01:24:19Z", "message": "Fix formatting and whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/fc5a0ee3d64889303470b814f0b9b3ace2541a10", "committedDate": "2020-12-28T02:42:20Z", "message": "Small fix."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MjY1NTMx", "url": "https://github.com/apache/pinot/pull/6383#pullrequestreview-559265531", "createdAt": "2020-12-28T19:00:45Z", "commit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowMDo0NVrOIMABRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMDo1MToyOVrOIMByxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDE0OA==", "bodyText": "List the expected arguments in the message", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454148", "createdAt": "2020-12-28T19:00:45Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDU1Ng==", "bodyText": "Handle table name with suffix\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n          \n          \n            \n                _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(((LiteralTransformFunction) dimTableNameFunction).getLiteral());", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454556", "createdAt": "2020-12-28T19:02:21Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDYyOA==", "bodyText": "Use TableNameBuilder instead", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454628", "createdAt": "2020-12-28T19:02:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw==", "bodyText": "(nit) extract joinArguments.size() as a local variable", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454913", "createdAt": "2020-12-28T19:03:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjIzMg==", "bodyText": "Please support all data types (usually we order them as followings: INT, LONG, FLOAT, DOUBLE, STRING, BYTES)", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549482232", "createdAt": "2020-12-28T20:47:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjgwNQ==", "bodyText": "Need to check null, same for other places", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549482805", "createdAt": "2020-12-28T20:49:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n+      if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n+        resultSet[i] = row.getValue(_dimColumnName);\n+      }\n+    }\n+    return resultSet;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    Object[] lookupObjects = lookup(projectionBlock);\n+    int[] resultSet = new int[lookupObjects.length];\n+    Arrays.fill(resultSet, ((Number) _lookupColumnFieldSpec.getDefaultNullValue()).intValue());\n+    for (int i = 0; i < lookupObjects.length; i++) {\n+      resultSet[i] = ((Number) lookupObjects[i]).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MzIwNA==", "bodyText": "We can save one map lookup\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n          \n          \n            \n                    resultSet[i] = row.getValue(_dimColumnName);\n          \n          \n            \n                  }\n          \n          \n            \n                  if (row != null) {\n          \n          \n            \n                    resultSet[i] = row.getValue(_dimColumnName);\n          \n          \n            \n                  }", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549483204", "createdAt": "2020-12-28T20:51:29Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n+      if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n+        resultSet[i] = row.getValue(_dimColumnName);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 169}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cee23d70630c40a2f0efd9afd65ff999dea3f7c7", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/cee23d70630c40a2f0efd9afd65ff999dea3f7c7", "committedDate": "2020-12-28T22:22:47Z", "message": "Support all possible PK types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91b635c4443e32631cd46c2274ff454fc55e9f48", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/91b635c4443e32631cd46c2274ff454fc55e9f48", "committedDate": "2020-12-29T01:11:04Z", "message": "Address review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/1bc88ca3b4c97d263c1756c3fc45c59471e26433", "committedDate": "2020-12-29T05:44:44Z", "message": "Small fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjgzMDQ0", "url": "https://github.com/apache/pinot/pull/6383#pullrequestreview-559683044", "createdAt": "2020-12-29T20:07:20Z", "commit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDowNzoyMFrOIMXE3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDoyODoxOVrOIMXZpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMTkwMw==", "bodyText": "(nit) no need to make a copy of the array (save the garbage). We don't usually guard the callers from modifying the list as it is internal code.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549831903", "createdAt": "2020-12-29T20:07:20Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -161,4 +168,8 @@ public GenericRow lookupRowByPrimaryKey(PrimaryKey pk) {\n   public FieldSpec getColumnFieldSpec(String columnName) {\n     return _tableSchema.getFieldSpecFor(columnName);\n   }\n+\n+  public List<String> getPrimaryKeyColumns() {\n+    return new ArrayList<>(_primaryKeyColumns);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMjU4NQ==", "bodyText": "No need to format string as Preconditions supports %s, same for other places", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549832585", "createdAt": "2020-12-29T20:10:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjIyNw==", "bodyText": "(nit) move STRING after DOUBLE for consistency", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549836227", "createdAt": "2020-12-29T20:24:38Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw==", "bodyText": "pkColumns should be stored as ByteArray[numDocuments]. Please add a test for all these data types to ensure them working", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549836457", "createdAt": "2020-12-29T20:25:33Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw==", "bodyText": "Reuse this Object[] instead of creating a new one per iteration", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549837013", "createdAt": "2020-12-29T20:27:34Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzIyMQ==", "bodyText": "PrimaryKey object can also be reused", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549837221", "createdAt": "2020-12-29T20:28:19Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 188}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77e5a779a4c26e04b62a1b6cfa5226dd4ae85637", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/77e5a779a4c26e04b62a1b6cfa5226dd4ae85637", "committedDate": "2020-12-29T23:39:48Z", "message": "Address review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4577c217f65ecabdc615174da7b3c0e7fbd17003", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/4577c217f65ecabdc615174da7b3c0e7fbd17003", "committedDate": "2020-12-30T02:09:05Z", "message": "Fix PK hash match issue for byte[] type columns"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMTY2NDA1", "url": "https://github.com/apache/pinot/pull/6383#pullrequestreview-560166405", "createdAt": "2020-12-30T19:00:42Z", "commit": {"oid": "4577c217f65ecabdc615174da7b3c0e7fbd17003"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDM1NDE4", "url": "https://github.com/apache/pinot/pull/6383#pullrequestreview-561435418", "createdAt": "2021-01-05T00:13:25Z", "commit": {"oid": "4577c217f65ecabdc615174da7b3c0e7fbd17003"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzOTQ0MTQz", "url": "https://github.com/apache/pinot/pull/6383#pullrequestreview-563944143", "createdAt": "2021-01-08T01:26:06Z", "commit": {"oid": "4577c217f65ecabdc615174da7b3c0e7fbd17003"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1694, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}