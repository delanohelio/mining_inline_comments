{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNzQ3MTIz", "number": 5654, "title": "[Part 1] Add geo support", "bodyText": "Description\nFirst part of #5280. Design doc\nThis PR added the following\nadd geo-spatial data model\nThe data model includes both geometry and geography, which is differentiated by a spatial reference identifier (SRID). Notably, uses SRID=4326 as the coordinate system of lat/lng per https://epsg.io/4326.\nadd serde\nAdded the serialization/deserialization from geo-spatial value to bytes with kryo library. Also added a benchmark for performance evaluation\nBenchmark result: https://gist.github.com/yupeng9/8e2b081ffb372593492ebb6a41da97fd\nadd geospatial functions\ngeo constructors\n\nST_GEOG_FROM_TEXT\nST_GEOG_FROM_WKB\nST_GEOM_FROM_TEXT\nST_GEOM_FROM_WKB\nST_POINT\nST_POLYGON\n\ngeo measurements\n\nST_AREA (the geography area implementation is similar to Presto's)\nST_DISTANCE (the great circle distance implementation is similar to Presto's)\nST_GEOMETRY_TYPE\n\ngeo outputs\n\nST_AS_BINARY\nST_AS_TEXT\n\ngeo relationship\n\nST_CONTAINS\nST_EQUALS\n\nUpdates to MeetupRsvp quickstart example\nAdded a new location field from the longitude and latitude of the event, using an inbuilt stPoint transform function\nUpgrade Notes\nDoes this PR prevent a zero down-time upgrade? (Assume upgrade order: Controller, Broker, Server, Minion)\n\n No\n\nDoes this PR fix a zero-downtime upgrade introduced earlier?\n\n No\n\nDoes this PR otherwise need attention when creating release notes? Things to consider:\n\nNew configuration options\nDeprecation of configurations\nSignature changes to public methods/interfaces\nNew plugins added or old plugins removed\n\n\n Yes (Please label this PR as release-notes and complete the section on Release Notes)\n\nRelease Notes\nYes, added a new experimental feature\nDocumentation\nIf you have introduced a new feature or configuration, please add it to the documentation as well.\nSee https://docs.pinot.apache.org/developers/developers-and-contributors/update-document", "createdAt": "2020-07-02T21:20:46Z", "url": "https://github.com/apache/pinot/pull/5654", "merged": true, "mergeCommit": {"oid": "112489786834825da13834ca22d5b492befd62d4"}, "closed": true, "closedAt": "2020-07-23T04:20:44Z", "author": {"login": "yupeng9"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxFppPgFqTQ0MjAyNjg4OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3mOYWgH2gAyNDQzNzQ3MTIzOjBkNjI4NWZjMjRhZjNiNjg2OWJhODY1YzIwMjA1ZDkxZjM4YmI5NTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMDI2ODg4", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-442026888", "createdAt": "2020-07-02T21:23:22Z", "commit": {"oid": "f84b1a9c9e9213c7f37aafd77ea1b4000e4cfb60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyMzoyMlrOGsdZpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyMzoyMlrOGsdZpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MjIzMQ==", "bodyText": "plz ignore this, seems some search/replace error", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449272231", "createdAt": "2020-07-02T21:23:22Z", "author": {"login": "yupeng9"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -96,7 +96,7 @@ public HelixTaskResult handleMessage() {\n \n     @Override\n     public void onError(Exception e, ErrorCode code, ErrorType type) {\n-      LOGGER.error(\"Got error while refreshing segment: {} of table: {} (error code: {}, error type: {})\", _segmentName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f84b1a9c9e9213c7f37aafd77ea1b4000e4cfb60"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNTQ3NDQx", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-442547441", "createdAt": "2020-07-03T19:55:05Z", "commit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOTo1NTowNVrOGs3E3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxOTo1MDozM1rOGs9pug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY5Mjg5NQ==", "bodyText": "move version to pom.properties", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449692895", "createdAt": "2020-07-03T19:55:05Z", "author": {"login": "kishoreg"}, "path": "pinot-core/pom.xml", "diffHunk": "@@ -223,5 +230,17 @@\n       <artifactId>lucene-analyzers-common</artifactId>\n       <version>${lucene.version}</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.openjdk.jmh</groupId>\n+      <artifactId>jmh-core</artifactId>\n+      <version>1.21</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ0MA==", "bodyText": "what does this function do? please add java docs", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800440", "createdAt": "2020-07-04T19:47:33Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class ConstructFromTextFunction extends BaseTransformFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ4MQ==", "bodyText": "function -> functions", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800481", "createdAt": "2020-07-04T19:48:16Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDU3OA==", "bodyText": "sweet", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800578", "createdAt": "2020-07-04T19:49:42Z", "author": {"login": "kishoreg"}, "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -87,11 +90,14 @@ public void onMessage(String message) {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n+                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));\n                   if (group != null) {\n                     extracted.set(\"group_city\", group.get(\"group_city\"));\n                     extracted.set(\"group_country\", group.get(\"group_country\"));\n                     extracted.set(\"group_id\", group.get(\"group_id\"));\n                     extracted.set(\"group_name\", group.get(\"group_name\"));\n+                    extracted.set(\"group_lat\", group.get(\"group_lat\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDYwMg==", "bodyText": "logger?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800602", "createdAt": "2020-07-04T19:50:05Z", "author": {"login": "kishoreg"}, "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -101,18 +107,18 @@ public void onMessage(String message) {\n                     producer.produce(\"meetupRSVPEvents\", extracted.toString().getBytes(StandardCharsets.UTF_8));\n                   }\n                 } catch (Exception e) {\n-                  //LOGGER.error(\"error processing raw event \", e);\n+                  LOGGER.error(\"error processing raw event \", e);\n                 }\n               }\n             });\n             session.getBasicRemote().sendText(\"\");\n           } catch (IOException e) {\n-            //LOGGER.error(\"found an event where data did not have all the fields, don't care about for quickstart\");\n+            LOGGER.error(\"found an event where data did not have all the fields, don't care about for quickstart\", e);\n           }\n         }\n       }, cec, new URI(\"ws://stream.meetup.com/2/rsvps\"));\n     } catch (Exception e) {\n-      //e.printStackTrace();\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDYzNA==", "bodyText": "Great to see this work", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800634", "createdAt": "2020-07-04T19:50:33Z", "author": {"login": "kishoreg"}, "path": "pinot-tools/src/main/resources/examples/stream/meetupRsvp/meetupRsvp_schema.json", "diffHunk": "@@ -37,6 +37,19 @@\n     {\n       \"dataType\": \"STRING\",\n       \"name\": \"group_name\"\n+    },\n+    {\n+      \"dataType\": \"DOUBLE\",\n+      \"name\": \"group_lat\"\n+    },\n+    {\n+      \"dataType\": \"DOUBLE\",\n+      \"name\": \"group_lon\"\n+    },\n+    {\n+      \"dataType\": \"BYTES\",\n+      \"name\": \"location\",\n+      \"transformFunction\": \"stPoint(group_lon, group_lat)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNjQyODIy", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-442642822", "createdAt": "2020-07-05T03:07:06Z", "commit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQwMzowNzowNlrOGs_ORw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQwMzo1MTo0OFrOGs_gTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNjM3NQ==", "bodyText": "Is Eclipse license ok to add? So far we have taken Apache/MIT/Gnu.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449826375", "createdAt": "2020-07-05T03:07:06Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/pom.xml", "diffHunk": "@@ -159,7 +159,14 @@\n       <groupId>com.jayway.jsonpath</groupId>\n       <artifactId>json-path</artifactId>\n     </dependency>\n-\n+    <dependency>\n+      <groupId>org.locationtech.jts</groupId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNjQ4Mg==", "bodyText": "Tab space indicates not following Pinot code-styling.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449826482", "createdAt": "2020-07-05T03:09:56Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNjU1OQ==", "bodyText": "Initialize list with size if known.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449826559", "createdAt": "2020-07-05T03:11:02Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+    @Override\n+    public void write(Kryo kryo, Output output, Object object) {\n+        if (!(object instanceof Geometry)) {\n+            throw new UnsupportedOperationException(\"Cannot serialize object of type \" +\n+                    object.getClass().getName());\n+        }\n+        writeGeometry(output, (Geometry) object);\n+    }\n+\n+    @Override\n+    public Object read(Kryo kryo, Input input, Class aClass) {\n+        byte typeByte = input.readByte();\n+        GeometrySerializationType type = readGeometryType(typeByte);\n+        GeometryFactory factory = getGeometryFactory(typeByte);\n+\n+        return readGeometry(input, type, factory);\n+    }\n+\n+    private Geometry readGeometry(Input input, GeometrySerializationType type, GeometryFactory factory) {\n+        switch (type) {\n+            case POINT:\n+                return readPoint(input, factory);\n+            case MULTI_POINT:\n+                return readMultiPoint(input, factory);\n+            case LINE_STRING:\n+                return readPolyline(input, false, factory);\n+            case MULTI_LINE_STRING:\n+                return readPolyline(input, true, factory);\n+            case POLYGON:\n+                return readPolygon(input, false, factory);\n+            case MULTI_POLYGON:\n+                return readPolygon(input, true, factory);\n+            case GEOMETRY_COLLECTION:\n+                return readGeometryCollection(input, factory);\n+            default:\n+                throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+        }\n+    }\n+\n+    private Point readPoint(Input input, GeometryFactory factory) {\n+        Coordinate coordinates = readCoordinate(input);\n+        if (isNaN(coordinates.x) || isNaN(coordinates.y)) {\n+            return factory.createPoint();\n+        }\n+        return factory.createPoint(coordinates);\n+    }\n+\n+    private Coordinate readCoordinate(Input input) {\n+        return new Coordinate(input.readDouble(), input.readDouble());\n+    }\n+\n+    private Coordinate[] readCoordinates(Input input, int count) {\n+        requireNonNull(input, \"input is null\");\n+        verify(count > 0);\n+        Coordinate[] coordinates = new Coordinate[count];\n+        for (int i = 0; i < count; i++) {\n+            coordinates[i] = readCoordinate(input);\n+        }\n+        return coordinates;\n+    }\n+\n+    private Geometry readMultiPoint(Input input, GeometryFactory factory) {\n+        int pointCount = input.readInt();\n+        Point[] points = new Point[pointCount];\n+        for (int i = 0; i < pointCount; i++) {\n+            points[i] = readPoint(input, factory);\n+        }\n+        return factory.createMultiPoint(points);\n+    }\n+\n+    private GeometrySerializationType readGeometryType(byte typeByte) {\n+        return GeometrySerializationType.fromID(typeByte & GEOGRAPHY_GET_MASK);\n+    }\n+\n+    private Geometry readPolyline(Input input, boolean multitype, GeometryFactory factory) {\n+        int partCount = input.readInt();\n+        if (partCount == 0) {\n+            if (multitype) {\n+                return factory.createMultiLineString();\n+            }\n+            return factory.createLineString();\n+        }\n+\n+        int pointCount = input.readInt();\n+        int[] startIndexes = new int[partCount];\n+        for (int i = 0; i < partCount; i++) {\n+            startIndexes[i] = input.readInt();\n+        }\n+\n+        int[] partLengths = new int[partCount];\n+        if (partCount > 1) {\n+            partLengths[0] = startIndexes[1];\n+            for (int i = 1; i < partCount - 1; i++) {\n+                partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n+            }\n+        }\n+        partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n+\n+        LineString[] lineStrings = new LineString[partCount];\n+\n+        for (int i = 0; i < partCount; i++) {\n+            lineStrings[i] = factory.createLineString(readCoordinates(input, partLengths[i]));\n+        }\n+\n+        if (multitype) {\n+            return factory.createMultiLineString(lineStrings);\n+        }\n+        verify(lineStrings.length == 1);\n+        return lineStrings[0];\n+    }\n+\n+    private Geometry readPolygon(Input input, boolean multitype, GeometryFactory factory) {\n+        int partCount = input.readInt();\n+        if (partCount == 0) {\n+            if (multitype) {\n+                return factory.createMultiPolygon();\n+            }\n+            return factory.createPolygon();\n+        }\n+\n+        int pointCount = input.readInt();\n+        int[] startIndexes = new int[partCount];\n+        for (int i = 0; i < partCount; i++) {\n+            startIndexes[i] = input.readInt();\n+        }\n+\n+        int[] partLengths = new int[partCount];\n+        if (partCount > 1) {\n+            partLengths[0] = startIndexes[1];\n+            for (int i = 1; i < partCount - 1; i++) {\n+                partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n+            }\n+        }\n+        partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n+\n+        LinearRing shell = null;\n+        List<LinearRing> holes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDE0OA==", "bodyText": "Please use Pinot code style (name of member variables starts with _ to avoid qualifying with this.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830148", "createdAt": "2020-07-05T03:38:55Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+public enum GeometrySerializationType\n+{\n+    POINT(0, GeometryType.POINT),\n+    MULTI_POINT(1, GeometryType.MULTI_POINT),\n+    LINE_STRING(2, GeometryType.LINE_STRING),\n+    MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+    POLYGON(4, GeometryType.POLYGON),\n+    MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+    GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+    ENVELOPE(7, GeometryType.POLYGON);\n+\n+    private final int id;\n+    private final GeometryType geometryType;\n+\n+    GeometrySerializationType(int id, GeometryType geometryType)\n+    {\n+        this.id = id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDMxMw==", "bodyText": "Consider using a Static Map, if this list has a chance to grow.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830313", "createdAt": "2020-07-05T03:41:04Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+public enum GeometrySerializationType\n+{\n+    POINT(0, GeometryType.POINT),\n+    MULTI_POINT(1, GeometryType.MULTI_POINT),\n+    LINE_STRING(2, GeometryType.LINE_STRING),\n+    MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+    POLYGON(4, GeometryType.POLYGON),\n+    MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+    GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+    ENVELOPE(7, GeometryType.POLYGON);\n+\n+    private final int id;\n+    private final GeometryType geometryType;\n+\n+    GeometrySerializationType(int id, GeometryType geometryType)\n+    {\n+        this.id = id;\n+        this.geometryType = geometryType;\n+    }\n+\n+    public int id()\n+    {\n+        return id;\n+    }\n+\n+    public GeometryType getGeometryType()\n+    {\n+        return geometryType;\n+    }\n+\n+    public static GeometrySerializationType fromID(int id)\n+    {\n+        switch (id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDM1MA==", "bodyText": "Please add Java doc to all classes and their public methods.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830350", "createdAt": "2020-07-05T03:41:36Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Geometry;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+\n+public class GeometrySerializer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDQ2Mg==", "bodyText": "Utils.rethrow will preserve the original exception.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830462", "createdAt": "2020-07-05T03:42:57Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+    private TransformFunction _transformFunction;\n+    private byte[][] _results;\n+    private WKTReader _reader;\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        Preconditions\n+                .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\",\n+                        getName());\n+        TransformFunction transformFunction = arguments.get(0);\n+        Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+                \"The argument must be single-valued for transform function: %s\", getName());\n+        _transformFunction = transformFunction;\n+        _reader = new WKTReader(getGeometryFactory());\n+    }\n+\n+    abstract protected GeometryFactory getGeometryFactory();\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return BYTES_SV_NO_DICTIONARY_METADATA;\n+    }\n+\n+    @Override\n+    public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+        if (_results == null) {\n+            _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+        }\n+        String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+        int length = projectionBlock.getNumDocs();\n+        for (int i = 0; i < length; i++) {\n+            try {\n+                Geometry geometry = _reader.read(argumentValues[i]);\n+                _results[i] = GeometrySerializer.serialize(geometry);\n+            } catch (ParseException e) {\n+                throw new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDczMQ==", "bodyText": "Would be good to add the benchmark results in the PR description.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830731", "createdAt": "2020-07-05T03:47:55Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/geospatial/serde/BenchmarkSerde.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.io.Resources;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+\n+import static com.google.common.io.Resources.getResource;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.openjdk.jmh.annotations.Mode.Throughput;\n+\n+import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.serialize;\n+import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.deserialize;\n+\n+@State(Scope.Thread)\n+@Fork(2)\n+@Warmup(iterations = 3, time = 3, timeUnit = SECONDS)\n+@Measurement(iterations = 5, time = 4, timeUnit = SECONDS)\n+@OutputTimeUnit(SECONDS)\n+@BenchmarkMode(Throughput)\n+public class BenchmarkSerde", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDg3Nw==", "bodyText": "Unsure if LOGGER should be used here?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830877", "createdAt": "2020-07-05T03:50:23Z", "author": {"login": "mayankshriv"}, "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -87,11 +90,14 @@ public void onMessage(String message) {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n+                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDkxMA==", "bodyText": "+1", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830910", "createdAt": "2020-07-05T03:50:50Z", "author": {"login": "mayankshriv"}, "path": "pinot-tools/src/main/resources/examples/stream/meetupRsvp/meetupRsvp_schema.json", "diffHunk": "@@ -37,6 +37,19 @@\n     {\n       \"dataType\": \"STRING\",\n       \"name\": \"group_name\"\n+    },\n+    {\n+      \"dataType\": \"DOUBLE\",\n+      \"name\": \"group_lat\"\n+    },\n+    {\n+      \"dataType\": \"DOUBLE\",\n+      \"name\": \"group_lon\"\n+    },\n+    {\n+      \"dataType\": \"BYTES\",\n+      \"name\": \"location\",\n+      \"transformFunction\": \"stPoint(group_lon, group_lat)\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDYzNA=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDk5MQ==", "bodyText": "This seems unrelated to this PR? Would be good to call it out in the description, along with the motivation for the change.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830991", "createdAt": "2020-07-05T03:51:48Z", "author": {"login": "mayankshriv"}, "path": "pinot-tools/src/main/resources/log4j2.xml", "diffHunk": "@@ -44,7 +44,7 @@\n \n   </Appenders>\n   <Loggers>\n-    <Root level=\"info\" additivity=\"false\">\n+    <Root level=\"warn\" additivity=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNTgwNTYw", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-443580560", "createdAt": "2020-07-07T05:53:43Z", "commit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNTo1Mzo0M1rOGtwCwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzozNDoyN1rOGuIyhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNjI0Mg==", "bodyText": "My understanding is okay to include.\nPer https://www.apache.org/legal/resolved.html#category-a, Eclipse Distribution License 1.0 can be included. And JTS is dual-licensed under Eclipse Public License 2.0 and Eclipse Distribution License 1.0 (https://github.com/locationtech/jts#license)", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450626242", "createdAt": "2020-07-07T05:53:43Z", "author": {"login": "yupeng9"}, "path": "pinot-core/pom.xml", "diffHunk": "@@ -159,7 +159,14 @@\n       <groupId>com.jayway.jsonpath</groupId>\n       <artifactId>json-path</artifactId>\n     </dependency>\n-\n+    <dependency>\n+      <groupId>org.locationtech.jts</groupId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNjM3NQ=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyODgwMw==", "bodyText": "Sure. thanks.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450628803", "createdAt": "2020-07-07T06:02:22Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+public enum GeometrySerializationType\n+{\n+    POINT(0, GeometryType.POINT),\n+    MULTI_POINT(1, GeometryType.MULTI_POINT),\n+    LINE_STRING(2, GeometryType.LINE_STRING),\n+    MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+    POLYGON(4, GeometryType.POLYGON),\n+    MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+    GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+    ENVELOPE(7, GeometryType.POLYGON);\n+\n+    private final int id;\n+    private final GeometryType geometryType;\n+\n+    GeometrySerializationType(int id, GeometryType geometryType)\n+    {\n+        this.id = id;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDE0OA=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyOTQ3OA==", "bodyText": "This list is unlikely to grow, given the OGC geo is a well-defined standard per https://www.ogc.org/standards/sfa", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450629478", "createdAt": "2020-07-07T06:04:43Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+public enum GeometrySerializationType\n+{\n+    POINT(0, GeometryType.POINT),\n+    MULTI_POINT(1, GeometryType.MULTI_POINT),\n+    LINE_STRING(2, GeometryType.LINE_STRING),\n+    MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+    POLYGON(4, GeometryType.POLYGON),\n+    MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+    GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+    ENVELOPE(7, GeometryType.POLYGON);\n+\n+    private final int id;\n+    private final GeometryType geometryType;\n+\n+    GeometrySerializationType(int id, GeometryType geometryType)\n+    {\n+        this.id = id;\n+        this.geometryType = geometryType;\n+    }\n+\n+    public int id()\n+    {\n+        return id;\n+    }\n+\n+    public GeometryType getGeometryType()\n+    {\n+        return geometryType;\n+    }\n+\n+    public static GeometrySerializationType fromID(int id)\n+    {\n+        switch (id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDMxMw=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5NDk1MA==", "bodyText": "Added. This is an abstract class for implementing the geo constructor functions like StGeomFromText and StGeogFromText", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450994950", "createdAt": "2020-07-07T16:32:22Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class ConstructFromTextFunction extends BaseTransformFunction {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ0MA=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNzIyMQ==", "bodyText": "Good to see this util", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451027221", "createdAt": "2020-07-07T17:26:36Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+    private TransformFunction _transformFunction;\n+    private byte[][] _results;\n+    private WKTReader _reader;\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        Preconditions\n+                .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\",\n+                        getName());\n+        TransformFunction transformFunction = arguments.get(0);\n+        Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+                \"The argument must be single-valued for transform function: %s\", getName());\n+        _transformFunction = transformFunction;\n+        _reader = new WKTReader(getGeometryFactory());\n+    }\n+\n+    abstract protected GeometryFactory getGeometryFactory();\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return BYTES_SV_NO_DICTIONARY_METADATA;\n+    }\n+\n+    @Override\n+    public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+        if (_results == null) {\n+            _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+        }\n+        String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+        int length = projectionBlock.getNumDocs();\n+        for (int i = 0; i < length; i++) {\n+            try {\n+                Geometry geometry = _reader.read(argumentValues[i]);\n+                _results[i] = GeometrySerializer.serialize(geometry);\n+            } catch (ParseException e) {\n+                throw new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDQ2Mg=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNzcyNw==", "bodyText": "Sounds good", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451027727", "createdAt": "2020-07-07T17:27:32Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/geospatial/serde/BenchmarkSerde.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.io.Resources;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+\n+import static com.google.common.io.Resources.getResource;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.openjdk.jmh.annotations.Mode.Throughput;\n+\n+import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.serialize;\n+import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.deserialize;\n+\n+@State(Scope.Thread)\n+@Fork(2)\n+@Warmup(iterations = 3, time = 3, timeUnit = SECONDS)\n+@Measurement(iterations = 5, time = 4, timeUnit = SECONDS)\n+@OutputTimeUnit(SECONDS)\n+@BenchmarkMode(Throughput)\n+public class BenchmarkSerde", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDczMQ=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyOTg3Mg==", "bodyText": "removed. it was for debugging purpose.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451029872", "createdAt": "2020-07-07T17:31:06Z", "author": {"login": "yupeng9"}, "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -87,11 +90,14 @@ public void onMessage(String message) {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n+                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDg3Nw=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzMTY4NQ==", "bodyText": "You are right. Reverted this since it was for local debugging purpose.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451031685", "createdAt": "2020-07-07T17:34:27Z", "author": {"login": "yupeng9"}, "path": "pinot-tools/src/main/resources/log4j2.xml", "diffHunk": "@@ -44,7 +44,7 @@\n \n   </Appenders>\n   <Loggers>\n-    <Root level=\"info\" additivity=\"false\">\n+    <Root level=\"warn\" additivity=\"false\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDk5MQ=="}, "originalCommit": {"oid": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MzY2NTQ1", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-444366545", "createdAt": "2020-07-08T02:14:55Z", "commit": {"oid": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjoxNDo1NlrOGuVrYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjoxNDo1NlrOGuVrYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0Mjg1MA==", "bodyText": "Please follow the Pinot coding convention of using underscore as the prefix for member variables. Same for other classes", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451242850", "createdAt": "2020-07-08T02:14:56Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean multitype;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MzY2NzQz", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-444366743", "createdAt": "2020-07-08T02:15:41Z", "commit": {"oid": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjoxNTo0MVrOGuVsDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjoxNTo0MVrOGuVsDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw==", "bodyText": "As an example of Pinot coding convention\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                this.multitype = multitype;\n          \n          \n            \n                _multitype = multitype;", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451243023", "createdAt": "2020-07-08T02:15:41Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean multitype;\n+  private final String name;\n+\n+  GeometryType(boolean multitype, String name) {\n+    this.multitype = multitype;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MjAyNTQx", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-445202541", "createdAt": "2020-07-08T23:52:10Z", "commit": {"oid": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/5329f2fb56cf3b7c43c11371f91f39d98be5df39", "committedDate": "2020-07-16T03:56:34Z", "message": "add geo support\n\n - add geo-spatial data model\n - add serde\n - add benchmark\n - add geospatial functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e778f612067ad12f6b007339b2b413003b4efa54", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/e778f612067ad12f6b007339b2b413003b4efa54", "committedDate": "2020-07-16T03:56:34Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4cf2ad048c6127ce5f69350c5cd8f2577455a64", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/b4cf2ad048c6127ce5f69350c5cd8f2577455a64", "committedDate": "2020-07-16T03:56:36Z", "message": "revert id/code change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ac9fe3a6ecc078d9cc69fa5a2b7f386a3c364ea", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/2ac9fe3a6ecc078d9cc69fa5a2b7f386a3c364ea", "committedDate": "2020-07-16T03:57:20Z", "message": "more cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/d548d2488bb52bd2915c89dfa7782fd030e381c5", "committedDate": "2020-07-16T03:57:20Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ebb9c5078119d7d8ad7918d9221ab775995b00a", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/0ebb9c5078119d7d8ad7918d9221ab775995b00a", "committedDate": "2020-07-16T03:57:20Z", "message": "more styling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "committedDate": "2020-07-17T01:57:30Z", "message": "Change the relationship function not applicable to geographical functions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6a741bf3debba62612c24da7d6437e6eb13acacc", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/6a741bf3debba62612c24da7d6437e6eb13acacc", "committedDate": "2020-07-09T17:44:30Z", "message": "more styling"}, "afterCommit": {"oid": "b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "committedDate": "2020-07-17T01:57:30Z", "message": "Change the relationship function not applicable to geographical functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/bb51f43a4419008e9a727d7c8355330d232ec9b9", "committedDate": "2020-07-17T02:36:04Z", "message": "fix test failure"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDcxNTU0", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-451071554", "createdAt": "2020-07-18T17:38:03Z", "commit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "state": "COMMENTED", "comments": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxNzozODowM1rOGzpjfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQyMToxMTowNlrOGzqlqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTM4OQ==", "bodyText": "(nit) Add an empty line in front, and capitalize the comment", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811389", "createdAt": "2020-07-18T17:38:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTM5NQ==", "bodyText": "(nit) Empty line after", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811395", "createdAt": "2020-07-18T17:38:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors\n+  ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n+  ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n+  ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n+  ST_GEOM_FROM_WKB(\"ST_GeomFromWKB\"),\n+  ST_POINT(\"ST_Point\"),\n+  ST_POLYGON(\"ST_Polygon\"),\n \n+  // geo measurements\n+  ST_AREA(\"ST_Area\"),\n+  ST_DISTANCE(\"ST_Distance\"),\n+  ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),\n+\n+  // geo outputs\n+  ST_AS_BINARY(\"ST_AsBinary\"),\n+  ST_AS_TEXT(\"ST_AsText\"),\n+\n+  // geo relationship\n+  ST_CONTAINS(\"ST_Contains\"),\n+  ST_EQUALS(\"ST_Equals\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),\n          \n          \n            \n              ST_GEOMETRY_TYPE(\"ST_GeometryType\"),", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811665", "createdAt": "2020-07-18T17:41:30Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors\n+  ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n+  ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n+  ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n+  ST_GEOM_FROM_WKB(\"ST_GeomFromWKB\"),\n+  ST_POINT(\"ST_Point\"),\n+  ST_POLYGON(\"ST_Polygon\"),\n \n+  // geo measurements\n+  ST_AREA(\"ST_Area\"),\n+  ST_DISTANCE(\"ST_Distance\"),\n+  ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjEzNQ==", "bodyText": "Thanks for updating the javadoc. Add BYTES here as well", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456812135", "createdAt": "2020-07-18T17:47:23Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/Schema.java", "diffHunk": "@@ -400,7 +400,7 @@ public String toSingleLineJsonString() {\n    * Validates a pinot schema.\n    * <p>The following validations are performed:\n    * <ul>\n-   *   <li>For dimension, time, date time fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE, STRING</li>\n+   *   <li>For dimension, time, date time fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE, STRING, BYTES</li>\n    *   <li>For non-derived metric fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjIzNw==", "bodyText": "Move these to the root pom and specify the version there", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456812237", "createdAt": "2020-07-18T17:48:45Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-perf/pom.xml", "diffHunk": "@@ -98,7 +98,7 @@\n     <dependency>\n       <groupId>org.openjdk.jmh</groupId>\n       <artifactId>jmh-core</artifactId>\n-      <version>1.21</version>\n+      <version>${jmh.version}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjMxMw==", "bodyText": "Don't include jmh in pinot-core, you can move the benchmark class to the pinot-perf package", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456812313", "createdAt": "2020-07-18T17:49:36Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/pom.xml", "diffHunk": "@@ -227,5 +234,17 @@\n       <artifactId>lucene-analyzers-common</artifactId>\n       <version>${lucene.version}</version>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjY4Ng==", "bodyText": "Where is this used?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456812686", "createdAt": "2020-07-18T17:53:52Z", "author": {"login": "Jackie-Jiang"}, "path": "pom.xml", "diffHunk": "@@ -1186,6 +1189,22 @@\n         <artifactId>grpc-stub</artifactId>\n         <version>${grpc.version}</version>\n       </dependency>\n+      <dependency>\n+        <groupId>org.objenesis</groupId>\n+        <artifactId>objenesis</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzM2OQ==", "bodyText": "Avoid static import.\nPlease re-order the imports using PinotStyle within config/codestyle-intellij.xml or config/codestyle-eclipse.xml", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813369", "createdAt": "2020-07-18T18:02:08Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzQ3Nw==", "bodyText": "Is there a standard function to return the SRID of the geometry? (Identify whether it is geometry or geography)", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813477", "createdAt": "2020-07-18T18:03:21Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors\n+  ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n+  ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n+  ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n+  ST_GEOM_FROM_WKB(\"ST_GeomFromWKB\"),\n+  ST_POINT(\"ST_Point\"),\n+  ST_POLYGON(\"ST_Polygon\"),\n \n+  // geo measurements\n+  ST_AREA(\"ST_Area\"),\n+  ST_DISTANCE(\"ST_Distance\"),\n+  ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final boolean _multitype;\n          \n          \n            \n              private final boolean _multiType;", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813707", "createdAt": "2020-07-18T18:06:00Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean _multitype;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcyNQ==", "bodyText": "Seems never used. How are you planning to use the multi-type info?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813725", "createdAt": "2020-07-18T18:06:20Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean _multitype;\n+  private final String _name;\n+\n+  GeometryType(boolean multitype, String name) {\n+    _multitype = multitype;\n+    _name = name;\n+  }\n+\n+  public boolean isMultitype() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxOTkzNw==", "bodyText": "Checked the Kryo implementation, it is only providing a buffer to the stream (very similar to BufferedInputStream and BufferedOutputStream). So I'm pretty sure reading/writing with pre-sized ByteBuffer will be much faster and the garbage generated will be much less. Also, with ByteBuffer we can store values with LITTLE_ENDIEN (linux native) to further improve the performance.\nI'd recommend revisiting this part because once the data is persistent, it will be hard to change", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456819937", "createdAt": "2020-07-18T19:24:15Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+  @Override\n+  public void write(Kryo kryo, Output output, Object object) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDA1OQ==", "bodyText": "Can we use GeometryType instead of introducing this extra type? I don't think ENVELOPE is used", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456820059", "createdAt": "2020-07-18T19:25:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDEyMg==", "bodyText": "You can keep a static array with id as the index to prevent the branching of switch", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456820122", "createdAt": "2020-07-18T19:26:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {\n+  POINT(0, GeometryType.POINT),\n+  MULTI_POINT(1, GeometryType.MULTI_POINT),\n+  LINE_STRING(2, GeometryType.LINE_STRING),\n+  MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+  POLYGON(4, GeometryType.POLYGON),\n+  MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+  GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+  ENVELOPE(7, GeometryType.POLYGON);\n+\n+  private final int _id;\n+  private final GeometryType _geometryType;\n+\n+  GeometrySerializationType(int id, GeometryType geometryType) {\n+    _id = id;\n+    _geometryType = geometryType;\n+  }\n+\n+  /**\n+   * @return the id of the serialization type\n+   */\n+  public int id() {\n+    return _id;\n+  }\n+\n+  /**\n+   * @return the type in the geometry model\n+   */\n+  public GeometryType getGeometryType() {\n+    return _geometryType;\n+  }\n+\n+  /**\n+   * Constructs the serialization type from the id\n+   * @param id id of the serialization type\n+   * @return the serialization type\n+   */\n+  public static GeometrySerializationType fromID(int id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMjk0OA==", "bodyText": "Based on https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/Geometry.html, there is another type LINEAR_RING. Should we include that?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456822948", "createdAt": "2020-07-18T20:01:59Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzEwMg==", "bodyText": "Seems the code is borrowed from Presto? (https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java)\nCan you please include that in the javadoc?\nAlso, do we need to keep the same serialization format as presto? Using LITTLE_ENDIEN (linux native order) can improve the performance of ser/de", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823102", "createdAt": "2020-07-18T20:04:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzI3NA==", "bodyText": "Javadoc describing the format of the serialized bytes will be preferred", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823274", "createdAt": "2020-07-18T20:06:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+  @Override\n+  public void write(Kryo kryo, Output output, Object object) {\n+    if (!(object instanceof Geometry)) {\n+      throw new UnsupportedOperationException(\"Cannot serialize object of type \" + object.getClass().getName());\n+    }\n+    writeGeometry(output, (Geometry) object);\n+  }\n+\n+  @Override\n+  public Object read(Kryo kryo, Input input, Class aClass) {\n+    byte typeByte = input.readByte();\n+    GeometrySerializationType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+\n+    return readGeometry(input, type, factory);\n+  }\n+\n+  private Geometry readGeometry(Input input, GeometrySerializationType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(input, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(input, factory);\n+      case LINE_STRING:\n+        return readPolyline(input, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(input, true, factory);\n+      case POLYGON:\n+        return readPolygon(input, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(input, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(input, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(Input input, GeometryFactory factory) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzUyMw==", "bodyText": "Also check the data type, should be STRING", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823523", "createdAt": "2020-07-18T20:09:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzYzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823633", "createdAt": "2020-07-18T20:10:38Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i])));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzY1NA==", "bodyText": "(nit) re-order imports. Same for other classes", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823654", "createdAt": "2020-07-18T20:11:09Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzY4Ng==", "bodyText": "Also check data type, should be BYTES", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823686", "createdAt": "2020-07-18T20:11:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzc1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from bytes %s\", argumentValues[i]));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from bytes: %s\", BytesUtils.toHexString(argumentValues[i])));", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823759", "createdAt": "2020-07-18T20:12:31Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKBReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    byte[][] argumentValues = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        throw new RuntimeException(String.format(\"Failed to parse geometry from bytes %s\", argumentValues[i]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzNA==", "bodyText": "Move this line out of the try-catch", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823834", "createdAt": "2020-07-18T20:13:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzOA==", "bodyText": "Move this line out of the try-catch", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823838", "createdAt": "2020-07-18T20:13:47Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKBReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    byte[][] argumentValues = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzg3OQ==", "bodyText": "Also check data type, should be BYTES. Same for other classes", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823879", "createdAt": "2020-07-18T20:14:37Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ==", "bodyText": "(nit) Cache numDocs, same for other classes\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Geometry geometry;\n          \n          \n            \n                for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n          \n          \n            \n                  geometry = GeometrySerializer.deserialize(values[i]);\n          \n          \n            \n                int numDocs = projectionBlock.getNumDocs();\n          \n          \n            \n                for (int i = 0; i < numDocs; i++) {\n          \n          \n            \n                  Geometry geometry = GeometrySerializer.deserialize(values[i]);", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824301", "createdAt": "2020-07-18T20:19:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDQ4Nw==", "bodyText": "I don't quite follow the comment. Where is isExteriorRing() used?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824487", "createdAt": "2020-07-18T20:22:07Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDY3Ng==", "bodyText": "Prefix with _ for member variables", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824676", "createdAt": "2020-07-18T20:24:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;\n+\n+    for (int i = start; i < lineString.getNumPoints(); i++) {\n+      calculator.add(lineString.getPointN(i));\n+    }\n+    return calculator.computeSphericalExcess();\n+  }\n+\n+  private static class SphericalExcessCalculator {\n+    private static final double TWO_PI = 2 * Math.PI;\n+    private static final double THREE_PI = 3 * Math.PI;\n+\n+    private double sphericalExcess;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTU4MQ==", "bodyText": "I believe start point is always the same as end point? Or the more than 3 points check does not stand?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456825581", "createdAt": "2020-07-18T20:35:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTkwMw==", "bodyText": "Cool, thanks for adding the reference of the algorithm.\nDidn't review the algorithm implementation carefully, please make sure it is covered by test", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456825903", "createdAt": "2020-07-18T20:39:58Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjA5Mg==", "bodyText": "Do you mean should be close to 2Pi or -2Pi?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826092", "createdAt": "2020-07-18T20:42:22Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;\n+\n+    for (int i = start; i < lineString.getNumPoints(); i++) {\n+      calculator.add(lineString.getPointN(i));\n+    }\n+    return calculator.computeSphericalExcess();\n+  }\n+\n+  private static class SphericalExcessCalculator {\n+    private static final double TWO_PI = 2 * Math.PI;\n+    private static final double THREE_PI = 3 * Math.PI;\n+\n+    private double sphericalExcess;\n+    private double courseDelta;\n+\n+    private boolean firstPoint;\n+    private double firstInitialBearing;\n+    private double previousFinalBearing;\n+\n+    private double previousPhi;\n+    private double previousCos;\n+    private double previousSin;\n+    private double previousTan;\n+    private double previousLongitude;\n+\n+    private boolean done;\n+\n+    public SphericalExcessCalculator(Point endPoint) {\n+      previousPhi = toRadians(endPoint.getY());\n+      previousSin = Math.sin(previousPhi);\n+      previousCos = Math.cos(previousPhi);\n+      previousTan = Math.tan(previousPhi / 2);\n+      previousLongitude = toRadians(endPoint.getX());\n+      firstPoint = true;\n+    }\n+\n+    private void add(Point point)\n+        throws IllegalStateException {\n+      checkState(!done, \"Computation of spherical excess is complete\");\n+\n+      double phi = toRadians(point.getY());\n+      double tan = Math.tan(phi / 2);\n+      double longitude = toRadians(point.getX());\n+\n+      // We need to check for that specifically\n+      // Otherwise calculating the bearing is not deterministic\n+      if (longitude == previousLongitude && phi == previousPhi) {\n+        throw new RuntimeException(\"Polygon is not valid: it has two identical consecutive vertices\");\n+      }\n+\n+      double deltaLongitude = longitude - previousLongitude;\n+      sphericalExcess += 2 * Math.atan2(Math.tan(deltaLongitude / 2) * (previousTan + tan), 1 + previousTan * tan);\n+\n+      double cos = Math.cos(phi);\n+      double sin = Math.sin(phi);\n+      double sinOfDeltaLongitude = Math.sin(deltaLongitude);\n+      double cosOfDeltaLongitude = Math.cos(deltaLongitude);\n+\n+      // Initial bearing from previous to current\n+      double y = sinOfDeltaLongitude * cos;\n+      double x = previousCos * sin - previousSin * cos * cosOfDeltaLongitude;\n+      double initialBearing = (Math.atan2(y, x) + TWO_PI) % TWO_PI;\n+\n+      // Final bearing from previous to current = opposite of bearing from current to previous\n+      double finalY = -sinOfDeltaLongitude * previousCos;\n+      double finalX = previousSin * cos - previousCos * sin * cosOfDeltaLongitude;\n+      double finalBearing = (Math.atan2(finalY, finalX) + PI) % TWO_PI;\n+\n+      // When processing our first point we don't yet have a previousFinalBearing\n+      if (firstPoint) {\n+        // So keep our initial bearing around, and we'll use it at the end\n+        // with the last final bearing\n+        firstInitialBearing = initialBearing;\n+        firstPoint = false;\n+      } else {\n+        courseDelta += (initialBearing - previousFinalBearing + THREE_PI) % TWO_PI - PI;\n+      }\n+\n+      courseDelta += (finalBearing - initialBearing + THREE_PI) % TWO_PI - PI;\n+\n+      previousFinalBearing = finalBearing;\n+      previousCos = cos;\n+      previousSin = sin;\n+      previousPhi = phi;\n+      previousTan = tan;\n+      previousLongitude = longitude;\n+    }\n+\n+    public double computeSphericalExcess() {\n+      if (!done) {\n+        // Now that we have our last final bearing, we can calculate the remaining course delta\n+        courseDelta += (firstInitialBearing - previousFinalBearing + THREE_PI) % TWO_PI - PI;\n+\n+        // The courseDelta should be 2Pi or - 2Pi, unless a pole is enclosed (and then it should be ~ 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjgwOQ==", "bodyText": "Maybe better to use a separate class for all the scalar functions?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826809", "createdAt": "2020-07-18T20:51:52Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Returns the text representation of the geometry object.\n+ */\n+public class StAsTextFunction extends BaseTransformFunction {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StAsTextFunction.class);\n+  private TransformFunction _transformFunction;\n+  private static WKTWriter _writer;\n+  public static final String FUNCTION_NAME = \"ST_AsText\";\n+  private String[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _writer = new WKTWriter();\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return STRING_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = _writer.write(geometry);\n+    }\n+    return _results;\n+  }\n+\n+  @ScalarFunction\n+  public static String stAsText(byte[] bytes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw==", "bodyText": "null cannot be added to double[]\nCheck empty point before calculating the distance (for both geometry and geography)", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826997", "createdAt": "2020-07-18T20:54:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzA2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new RuntimeException(\n          \n          \n            \n                        String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n          \n          \n            \n                    throw new RuntimeException(\"The first and second arguments shall either all be geometry or all geography\");", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827062", "createdAt": "2020-07-18T20:55:20Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzI3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n          \n          \n            \n                  throw new RuntimeException(\"Latitude must be between -90 and 90\");\n          \n          \n            \n                }\n          \n          \n            \n                Preconditions.checkArgument(latitude >= MIN_LATITUDE && latitude <= MAX_LATITUDE, \"Latitude must be between -90 and 90\");", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827270", "createdAt": "2020-07-18T20:57:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzQyMw==", "bodyText": "Return primitive double, or it will throw NPE", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827423", "createdAt": "2020-07-18T20:59:39Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ==", "bodyText": "Does it work on line across dateline?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827621", "createdAt": "2020-07-18T21:01:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));\n+    validateGeographyType(\"ST_Distance\", rightGeometry, EnumSet.of(GeometryType.POINT));\n+    Point leftPoint = (Point) leftGeometry;\n+    Point rightPoint = (Point) rightGeometry;\n+\n+    // greatCircleDistance returns distance in KM.\n+    return greatCircleDistance(leftPoint.getY(), leftPoint.getX(), rightPoint.getY(), rightPoint.getX()) * 1000;\n+  }\n+\n+  /**\n+   * Calculate the distance between two points on Earth.\n+   * <p>\n+   * This assumes a spherical Earth, and uses the Vincenty formula. (https://en.wikipedia\n+   * .org/wiki/Great-circle_distance)\n+   */\n+  public static double greatCircleDistance(double latitude1, double longitude1, double latitude2, double longitude2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA==", "bodyText": "Can be simplified to geometry instanceof Point", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827738", "createdAt": "2020-07-18T21:03:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzc3Mw==", "bodyText": "Directly return value in meter instead of km?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827773", "createdAt": "2020-07-18T21:04:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));\n+    validateGeographyType(\"ST_Distance\", rightGeometry, EnumSet.of(GeometryType.POINT));\n+    Point leftPoint = (Point) leftGeometry;\n+    Point rightPoint = (Point) rightGeometry;\n+\n+    // greatCircleDistance returns distance in KM.\n+    return greatCircleDistance(leftPoint.getY(), leftPoint.getX(), rightPoint.getY(), rightPoint.getX()) * 1000;\n+  }\n+\n+  /**\n+   * Calculate the distance between two points on Earth.\n+   * <p>\n+   * This assumes a spherical Earth, and uses the Vincenty formula. (https://en.wikipedia\n+   * .org/wiki/Great-circle_distance)\n+   */\n+  public static double greatCircleDistance(double latitude1, double longitude1, double latitude2, double longitude2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzgxOQ==", "bodyText": "Make all helper methods private", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827819", "createdAt": "2020-07-18T21:04:39Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzkzNA==", "bodyText": "Equals should work on geography as well?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827934", "createdAt": "2020-07-18T21:05:34Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StEqualsFunction.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Function that returns true if the given geometries represent the same geometry.\n+ */\n+public class StEqualsFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"ST_Equals\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private int[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) || GeometryUtils.isGeography(secondGeometry)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODI3OA==", "bodyText": "This doesn't seem right that St_Polygon is the same as ST_GeomFromText", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456828278", "createdAt": "2020-07-18T21:10:25Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.GeometryFactory;\n+\n+\n+/**\n+ * Constructor function for polygon object from text.\n+ */\n+public class StPolygonFunction extends ConstructFromTextFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODMyOA==", "bodyText": "Remove?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456828328", "createdAt": "2020-07-18T21:11:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BaseTransformFunction.java", "diffHunk": "@@ -41,7 +41,10 @@\n       new TransformResultMetadata(DataType.STRING, true, false);\n   protected static final TransformResultMetadata STRING_MV_NO_DICTIONARY_METADATA =\n       new TransformResultMetadata(DataType.STRING, false, false);\n+  protected static final TransformResultMetadata BYTES_SV_NO_DICTIONARY_METADATA =\n+          new TransformResultMetadata(DataType.BYTES, true, false);\n \n+  private boolean[] _booleanValuesSV;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "committedDate": "2020-07-22T03:36:50Z", "message": "addressed comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMTUwMDAy", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-452150002", "createdAt": "2020-07-21T06:06:05Z", "commit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNjowNjowNVrOG0pZBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMjo1MzozNVrOG1Q0mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NzI4Ng==", "bodyText": "Yes, it returns the type of the geometry as a string. EG: 'ST_Linestring', 'ST_Polygon','ST_MultiPolygon' etc", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457857286", "createdAt": "2020-07-21T06:06:05Z", "author": {"login": "yupeng9"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors\n+  ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n+  ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n+  ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n+  ST_GEOM_FROM_WKB(\"ST_GeomFromWKB\"),\n+  ST_POINT(\"ST_Point\"),\n+  ST_POLYGON(\"ST_Polygon\"),\n \n+  // geo measurements\n+  ST_AREA(\"ST_Area\"),\n+  ST_DISTANCE(\"ST_Distance\"),\n+  ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1OTYzMQ==", "bodyText": "moved it to pinot-perf project.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457859631", "createdAt": "2020-07-21T06:12:59Z", "author": {"login": "yupeng9"}, "path": "pinot-core/pom.xml", "diffHunk": "@@ -227,5 +234,17 @@\n       <artifactId>lucene-analyzers-common</artifactId>\n       <version>${lucene.version}</version>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjMxMw=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MDcxNw==", "bodyText": "LINEAR_RING is a subtype of LINEAR_STRING", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457860717", "createdAt": "2020-07-21T06:16:03Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMjk0OA=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MTYzMw==", "bodyText": "not in this PR. It's useful in function like https://postgis.net/docs/ST_GeometryN.html", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457861633", "createdAt": "2020-07-21T06:18:38Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean _multitype;\n+  private final String _name;\n+\n+  GeometryType(boolean multitype, String name) {\n+    _multitype = multitype;\n+    _name = name;\n+  }\n+\n+  public boolean isMultitype() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcyNQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM2MjU4MA==", "bodyText": "They are not exactly same, in particular, the differences are:\n\nPresto uses schema to indicate geometry vs geography info, while we encode this in the type byte.\nPresto serializes additional information such as envelope to be compatible with ESRI serialization, but the serde here does not, which is simpler and faster\n\nAdded this to the comments", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458362580", "createdAt": "2020-07-21T20:18:16Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzEwMg=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3NDk5Ng==", "bodyText": "Thanks. This is a very good suggestion. It's true that using pre-sized ByteBuffer would be more performant than the stream API. I run a benchmark on three implementations: stream, ByteBuffer with Big_Endian, ByteBuffer with Little_Endian: https://docs.google.com/spreadsheets/d/1ANkC7I4N-TxtzFI-fDbchJ9uGmyQtOG_ViYY0mSstNM/edit#gid=0.\nThe benchmark confirms the performance gain. Also, the result shows BIG_ENDIAN is more performant, as it's Java's default order. I will go with the default order.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458374996", "createdAt": "2020-07-21T20:41:40Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+  @Override\n+  public void write(Kryo kryo, Output output, Object object) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxOTkzNw=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3OTgzNw==", "bodyText": "removed.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458379837", "createdAt": "2020-07-21T20:51:06Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDA1OQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3Nzc4Ng==", "bodyText": "added", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458477786", "createdAt": "2020-07-22T01:18:40Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzUyMw=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3ODE4NA==", "bodyText": "then i have to have another line to initialize geometry", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458478184", "createdAt": "2020-07-22T01:20:00Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzNA=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MTA5OA==", "bodyText": "good catch", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458481098", "createdAt": "2020-07-22T01:30:36Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKBReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    byte[][] argumentValues = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        throw new RuntimeException(String.format(\"Failed to parse geometry from bytes %s\", argumentValues[i]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzc1OQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MjQ3MQ==", "bodyText": "I don't think it's needed. JIT will take care of it", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458482471", "createdAt": "2020-07-22T01:35:34Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4NTc5Mg==", "bodyText": "true. can be optimized.", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458485792", "createdAt": "2020-07-22T01:48:08Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTU4MQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5NDMwMA==", "bodyText": "it shall be 2PI or 2PI per https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\nSince it makes 360 degree complete turn", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458494300", "createdAt": "2020-07-22T02:19:21Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;\n+\n+    for (int i = start; i < lineString.getNumPoints(); i++) {\n+      calculator.add(lineString.getPointN(i));\n+    }\n+    return calculator.computeSphericalExcess();\n+  }\n+\n+  private static class SphericalExcessCalculator {\n+    private static final double TWO_PI = 2 * Math.PI;\n+    private static final double THREE_PI = 3 * Math.PI;\n+\n+    private double sphericalExcess;\n+    private double courseDelta;\n+\n+    private boolean firstPoint;\n+    private double firstInitialBearing;\n+    private double previousFinalBearing;\n+\n+    private double previousPhi;\n+    private double previousCos;\n+    private double previousSin;\n+    private double previousTan;\n+    private double previousLongitude;\n+\n+    private boolean done;\n+\n+    public SphericalExcessCalculator(Point endPoint) {\n+      previousPhi = toRadians(endPoint.getY());\n+      previousSin = Math.sin(previousPhi);\n+      previousCos = Math.cos(previousPhi);\n+      previousTan = Math.tan(previousPhi / 2);\n+      previousLongitude = toRadians(endPoint.getX());\n+      firstPoint = true;\n+    }\n+\n+    private void add(Point point)\n+        throws IllegalStateException {\n+      checkState(!done, \"Computation of spherical excess is complete\");\n+\n+      double phi = toRadians(point.getY());\n+      double tan = Math.tan(phi / 2);\n+      double longitude = toRadians(point.getX());\n+\n+      // We need to check for that specifically\n+      // Otherwise calculating the bearing is not deterministic\n+      if (longitude == previousLongitude && phi == previousPhi) {\n+        throw new RuntimeException(\"Polygon is not valid: it has two identical consecutive vertices\");\n+      }\n+\n+      double deltaLongitude = longitude - previousLongitude;\n+      sphericalExcess += 2 * Math.atan2(Math.tan(deltaLongitude / 2) * (previousTan + tan), 1 + previousTan * tan);\n+\n+      double cos = Math.cos(phi);\n+      double sin = Math.sin(phi);\n+      double sinOfDeltaLongitude = Math.sin(deltaLongitude);\n+      double cosOfDeltaLongitude = Math.cos(deltaLongitude);\n+\n+      // Initial bearing from previous to current\n+      double y = sinOfDeltaLongitude * cos;\n+      double x = previousCos * sin - previousSin * cos * cosOfDeltaLongitude;\n+      double initialBearing = (Math.atan2(y, x) + TWO_PI) % TWO_PI;\n+\n+      // Final bearing from previous to current = opposite of bearing from current to previous\n+      double finalY = -sinOfDeltaLongitude * previousCos;\n+      double finalX = previousSin * cos - previousCos * sin * cosOfDeltaLongitude;\n+      double finalBearing = (Math.atan2(finalY, finalX) + PI) % TWO_PI;\n+\n+      // When processing our first point we don't yet have a previousFinalBearing\n+      if (firstPoint) {\n+        // So keep our initial bearing around, and we'll use it at the end\n+        // with the last final bearing\n+        firstInitialBearing = initialBearing;\n+        firstPoint = false;\n+      } else {\n+        courseDelta += (initialBearing - previousFinalBearing + THREE_PI) % TWO_PI - PI;\n+      }\n+\n+      courseDelta += (finalBearing - initialBearing + THREE_PI) % TWO_PI - PI;\n+\n+      previousFinalBearing = finalBearing;\n+      previousCos = cos;\n+      previousSin = sin;\n+      previousPhi = phi;\n+      previousTan = tan;\n+      previousLongitude = longitude;\n+    }\n+\n+    public double computeSphericalExcess() {\n+      if (!done) {\n+        // Now that we have our last final bearing, we can calculate the remaining course delta\n+        courseDelta += (firstInitialBearing - previousFinalBearing + THREE_PI) % TWO_PI - PI;\n+\n+        // The courseDelta should be 2Pi or - 2Pi, unless a pole is enclosed (and then it should be ~ 0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjA5Mg=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5ODMyMw==", "bodyText": "sure. moved", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458498323", "createdAt": "2020-07-22T02:34:06Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Returns the text representation of the geometry object.\n+ */\n+public class StAsTextFunction extends BaseTransformFunction {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StAsTextFunction.class);\n+  private TransformFunction _transformFunction;\n+  private static WKTWriter _writer;\n+  public static final String FUNCTION_NAME = \"ST_AsText\";\n+  private String[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _writer = new WKTWriter();\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return STRING_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = _writer.write(geometry);\n+    }\n+    return _results;\n+  }\n+\n+  @ScalarFunction\n+  public static String stAsText(byte[] bytes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjgwOQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5OTAzNw==", "bodyText": "hmm, without null handling, what's the default value we return for bytes?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458499037", "createdAt": "2020-07-22T02:36:42Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMDU4MA==", "bodyText": "try to reuse the same error msg template of several functions", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458500580", "createdAt": "2020-07-22T02:43:03Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMTAwNw==", "bodyText": "yes, per https://en.wikipedia.org/wiki/Great-circle_distance", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458501007", "createdAt": "2020-07-22T02:44:51Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));\n+    validateGeographyType(\"ST_Distance\", rightGeometry, EnumSet.of(GeometryType.POINT));\n+    Point leftPoint = (Point) leftGeometry;\n+    Point rightPoint = (Point) rightGeometry;\n+\n+    // greatCircleDistance returns distance in KM.\n+    return greatCircleDistance(leftPoint.getY(), leftPoint.getX(), rightPoint.getY(), rightPoint.getX()) * 1000;\n+  }\n+\n+  /**\n+   * Calculate the distance between two points on Earth.\n+   * <p>\n+   * This assumes a spherical Earth, and uses the Vincenty formula. (https://en.wikipedia\n+   * .org/wiki/Great-circle_distance)\n+   */\n+  public static double greatCircleDistance(double latitude1, double longitude1, double latitude2, double longitude2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMTc2OA==", "bodyText": "yes, it should", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458501768", "createdAt": "2020-07-22T02:47:39Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StEqualsFunction.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Function that returns true if the given geometries represent the same geometry.\n+ */\n+public class StEqualsFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"ST_Equals\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private int[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) || GeometryUtils.isGeography(secondGeometry)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzkzNA=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMjk3Mg==", "bodyText": "yup, added the constraint of checking polygon type", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458502972", "createdAt": "2020-07-22T02:52:23Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.GeometryFactory;\n+\n+\n+/**\n+ * Constructor function for polygon object from text.\n+ */\n+public class StPolygonFunction extends ConstructFromTextFunction {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODI3OA=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMzMyMA==", "bodyText": "it's already there", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458503320", "createdAt": "2020-07-22T02:53:35Z", "author": {"login": "yupeng9"}, "path": "pinot-perf/pom.xml", "diffHunk": "@@ -98,7 +98,7 @@\n     <dependency>\n       <groupId>org.openjdk.jmh</groupId>\n       <artifactId>jmh-core</artifactId>\n-      <version>1.21</version>\n+      <version>${jmh.version}</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjIzNw=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNTc4NjAw", "url": "https://github.com/apache/pinot/pull/5654#pullrequestreview-453578600", "createdAt": "2020-07-22T18:30:07Z", "commit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "state": "APPROVED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODozMDowOFrOG1vB3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyMzozNFrOG1w5ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5ODIzNw==", "bodyText": "(nit) reformat", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458998237", "createdAt": "2020-07-22T18:30:08Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5ODkwOA==", "bodyText": "(nit) _multiType? (IDE identify multitype as typo)", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458998908", "createdAt": "2020-07-22T18:31:15Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n+\n+  private final boolean _multitype;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5OTE4MQ==", "bodyText": "Remove this class", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458999181", "createdAt": "2020-07-22T18:31:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwMTEzMQ==", "bodyText": "Keep an static GeometryType array\nprivate static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...};\nThen you can avoid the switch branching for better performance\nreturn ID_TO_TYPE_MAP[id];", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459001131", "createdAt": "2020-07-22T18:34:51Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n+\n+  private final boolean _multitype;\n+  private final int _id;\n+  private final String _name;\n+\n+  GeometryType(boolean multitype, int id, String name) {\n+    _multitype = multitype;\n+    _id = id;\n+    _name = name;\n+  }\n+\n+  public boolean isMultitype() {\n+    return _multitype;\n+  }\n+\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  /**\n+   * @return the id of the serialization type\n+   */\n+  public int id() {\n+    return _id;\n+  }\n+\n+  /**\n+   * Constructs the serialization type from the id\n+   * @param id id of the serialization type\n+   * @return the serialization type\n+   */\n+  public static GeometryType fromID(int id) {\n+    switch (id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwMjI3Ng==", "bodyText": "(nit) Remove the unused LOGGER (we don't want to log within serde as it is per-value based and can easily flood the log)", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459002276", "createdAt": "2020-07-22T18:36:44Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwNDcxNQ==", "bodyText": "Merge GeometrySerde into this class? I don't see the value of keeping them separate", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459004715", "createdAt": "2020-07-22T18:40:57Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+/**\n+ * A serializer that serializes a geometry object into bytes and vice versa.\n+ */\n+public class GeometrySerializer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxMDQ4NQ==", "bodyText": "(nit) Redundant check", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459010485", "createdAt": "2020-07-22T18:50:29Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+  private static final int TYPE_SIZE = Byte.BYTES;\n+  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n+\n+  byte[] writeGeometry(Geometry geometry) {\n+    byte[] bytes = new byte[getByteSize(geometry)];\n+    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+    writeGeometryByteBuffer(byteBuffer, geometry);\n+    return bytes;\n+  }\n+\n+  public Geometry readGeometry(byte[] bytes) {\n+    return readGeometry(ByteBuffer.wrap(bytes));\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer) {\n+    byte typeByte = byteBuffer.get();\n+    GeometryType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+    Geometry geometry = readGeometry(byteBuffer, type, factory);\n+    return geometry;\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(byteBuffer, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(byteBuffer, factory);\n+      case LINE_STRING:\n+        return readPolyline(byteBuffer, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(byteBuffer, true, factory);\n+      case POLYGON:\n+        return readPolygon(byteBuffer, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(byteBuffer, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(byteBuffer, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n+    Coordinate coordinates = readCoordinate(byteBuffer);\n+    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n+      return factory.createPoint();\n+    }\n+    return factory.createPoint(coordinates);\n+  }\n+\n+  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n+    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n+  }\n+\n+  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n+    Objects.requireNonNull(byteBuffer, \"input is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxNTQxNA==", "bodyText": "Let's use Preconditions for argument check. Same for other places", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459015414", "createdAt": "2020-07-22T18:59:05Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+  private static final int TYPE_SIZE = Byte.BYTES;\n+  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n+\n+  byte[] writeGeometry(Geometry geometry) {\n+    byte[] bytes = new byte[getByteSize(geometry)];\n+    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+    writeGeometryByteBuffer(byteBuffer, geometry);\n+    return bytes;\n+  }\n+\n+  public Geometry readGeometry(byte[] bytes) {\n+    return readGeometry(ByteBuffer.wrap(bytes));\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer) {\n+    byte typeByte = byteBuffer.get();\n+    GeometryType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+    Geometry geometry = readGeometry(byteBuffer, type, factory);\n+    return geometry;\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(byteBuffer, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(byteBuffer, factory);\n+      case LINE_STRING:\n+        return readPolyline(byteBuffer, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(byteBuffer, true, factory);\n+      case POLYGON:\n+        return readPolygon(byteBuffer, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(byteBuffer, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(byteBuffer, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n+    Coordinate coordinates = readCoordinate(byteBuffer);\n+    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n+      return factory.createPoint();\n+    }\n+    return factory.createPoint(coordinates);\n+  }\n+\n+  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n+    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n+  }\n+\n+  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n+    Objects.requireNonNull(byteBuffer, \"input is null\");\n+    Verify.verify(count > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxODcyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459018723", "createdAt": "2020-07-22T19:04:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  protected TransformFunction _transformFunction;\n+  protected byte[][] _results;\n+  protected WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().getDataType() == FieldSpec.DataType.STRING,\n+        \"The argument must be of string type\");\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyMDIyOA==", "bodyText": "(Major) Should this be GEOGRAPHY_FACTORY for longitude and latitude?", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459020228", "createdAt": "2020-07-22T19:07:25Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ScalarFunctions.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.io.WKTWriter;\n+\n+\n+/**\n+ * Geospatial scalar functions that can be used in transformation.\n+ */\n+public class ScalarFunctions {\n+\n+  /**\n+   * Creates a point.\n+   *\n+   * @param longitude longitude\n+   * @param latitude latitude\n+   * @return the created point\n+   */\n+  @ScalarFunction\n+  public static byte[] stPoint(double longitude, double latitude) {\n+    return GeometrySerializer\n+        .serialize(GeometryUtils.GEOMETRY_FACTORY.createPoint(new Coordinate(longitude, latitude)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyMzc0MA==", "bodyText": "Not necessary. I did some benchmark on this and there is performance difference", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459023740", "createdAt": "2020-07-22T19:14:00Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyNjE4MA==", "bodyText": "There will be quite big performance difference, especially for per-value check", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459026180", "createdAt": "2020-07-22T19:18:32Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODI5Nw==", "bodyText": "I think you can return Double.NaN here to indicate empty geometry", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459028297", "createdAt": "2020-07-22T19:22:19Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw=="}, "originalCommit": {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODkyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459028922", "createdAt": "2020-07-22T19:23:34Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.EnumSet;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.io.ParseException;\n+\n+\n+/**\n+ * Constructor function for polygon object from text.\n+ */\n+public class StPolygonFunction extends ConstructFromTextFunction {\n+  public static final String FUNCTION_NAME = \"ST_Polygon\";\n+\n+  @Override\n+  protected GeometryFactory getGeometryFactory() {\n+    return GeometryUtils.GEOMETRY_FACTORY;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        Preconditions.checkArgument(geometry instanceof Polygon, \"The geometry object must be polygon\");\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d6285fc24af3b6869ba865c20205d91f38bb958", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/0d6285fc24af3b6869ba865c20205d91f38bb958", "committedDate": "2020-07-23T02:44:01Z", "message": "more comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 765, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}