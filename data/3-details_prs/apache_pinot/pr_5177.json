{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyODAwMzcy", "number": 5177, "title": "Lucene DocId to PinotDocId cache", "bodyText": "Cache the lucene docID to pinot docID mapping per text index. This has to be thread safe since it is shared by all threads (query threads) reading the index.\nStoring this mapping on-heap structures (concurrent hash map, atomic int array etc) will add significant heap overhead.  Take an example of 10million docs per segment and we store a 4 byte doc id. This leads to 40MB per indexes. If there are 100 text indexes across segments on a server, we are looking at 4GB of heap overhead.\nSo the mapping has to be in off-heap memory (direct or mmap'd). The current solution builds the mapping upfront during segment load in a memory mapped file. During query processing, we avoid all calls to indexSearcher.doc(int docID).\nWe had noticed in our internal perf testing that as QPS is increased, performance degrades. The docID converter (lucene to Pinot) is a CPU hogger (confirmed through FlameGraphs in YourKit) and was becoming a bottleneck for QPS based testing. On the other hand, when running the same set of expensive queries as one-off, the execution time of the each query was drastically improved.\nThis change should provide significant improvements for throughput testing.  Verified by running PerfBenchmarkRunner with and without the changes.", "createdAt": "2020-03-24T06:21:55Z", "url": "https://github.com/apache/pinot/pull/5177", "merged": true, "mergeCommit": {"oid": "8dfa51af244f911d52824f94e95f983ffc50b5fb"}, "closed": true, "closedAt": "2020-03-31T04:47:22Z", "author": {"login": "siddharthteotia"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQ3VsugFqTM4MDU5MjEzNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcS5utyABqjMxODEyNjQ2MzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNTkyMTM2", "url": "https://github.com/apache/pinot/pull/5177#pullrequestreview-380592136", "createdAt": "2020-03-24T18:34:22Z", "commit": {"oid": "a9d171a0a93a946fbf781f2cf541cb796f9950b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxODozNDoyMlrOF698JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxODozNDoyMlrOF698JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3NjU0OQ==", "bodyText": "Please use computeIfAbsent instead", "url": "https://github.com/apache/pinot/pull/5177#discussion_r397376549", "createdAt": "2020-03-24T18:34:22Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -148,8 +153,12 @@ private MutableRoaringBitmap getPinotDocIds(MutableRoaringBitmap luceneDocIds) {\n     try {\n       while (luceneDocIDIterator.hasNext()) {\n         int luceneDocId = luceneDocIDIterator.next();\n-        Document document = _indexSearcher.doc(luceneDocId);\n-        int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+        Integer pinotDocId = _luceneDocIDToPinotDocIDCache.get(luceneDocId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9d171a0a93a946fbf781f2cf541cb796f9950b5"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a9d171a0a93a946fbf781f2cf541cb796f9950b5", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/a9d171a0a93a946fbf781f2cf541cb796f9950b5", "committedDate": "2020-03-24T06:21:02Z", "message": "Lucene DocId to PinotDocId cache"}, "afterCommit": {"oid": "845f98d63073efc0edaa64a998b64fe1c2cf1212", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/845f98d63073efc0edaa64a998b64fe1c2cf1212", "committedDate": "2020-03-30T16:55:16Z", "message": "Lucene DocId to PinotDocId cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "845f98d63073efc0edaa64a998b64fe1c2cf1212", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/845f98d63073efc0edaa64a998b64fe1c2cf1212", "committedDate": "2020-03-30T16:55:16Z", "message": "Lucene DocId to PinotDocId cache"}, "afterCommit": {"oid": "26e88ea6b9c7ad48f583b526c19b2f8c153cbaba", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/26e88ea6b9c7ad48f583b526c19b2f8c153cbaba", "committedDate": "2020-03-30T17:04:17Z", "message": "Lucene DocId to PinotDocId cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "26e88ea6b9c7ad48f583b526c19b2f8c153cbaba", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/26e88ea6b9c7ad48f583b526c19b2f8c153cbaba", "committedDate": "2020-03-30T17:04:17Z", "message": "Lucene DocId to PinotDocId cache"}, "afterCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/0db1d2e4a3623f87297fd652c66d4b7600594f9d", "committedDate": "2020-03-30T17:13:17Z", "message": "Lucene DocId to PinotDocId cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MDY3MTkw", "url": "https://github.com/apache/pinot/pull/5177#pullrequestreview-384067190", "createdAt": "2020-03-30T17:17:43Z", "commit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxNzo0M1rOF90CBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzozNzowN1rOF90zPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1OTk0MQ==", "bodyText": "Revert the change in this file?\nAlso suggesting rename the test to TextSearchQueriesTest for naming convention.", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400359941", "createdAt": "2020-03-30T17:17:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/test/java/org/apache/pinot/queries/TestTextSearchQueries.java", "diffHunk": "@@ -89,7 +91,7 @@\n   private RecordReader _recordReader;\n   Schema _schema;\n \n-  private List<IndexSegment> _indexSegments = new ArrayList<>(1);\n+  private static List<IndexSegment> _indexSegments = new ArrayList<>(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MDMwNA==", "bodyText": "private final", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400360304", "createdAt": "2020-03-30T17:18:13Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -51,6 +54,9 @@\n   private final IndexSearcher _indexSearcher;\n   private final QueryParser _queryParser;\n   private final String _column;\n+  private DocIdReaderWriter _docIdReaderWriter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2NzM3NA==", "bodyText": "We build the mapping every time we load the index? You saved the mapping into a file right?", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400367374", "createdAt": "2020-03-30T17:29:09Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -70,6 +76,10 @@ public LuceneTextIndexReader(String column, File segmentIndexDir) {\n       // Disable Lucene query result cache. While it helps a lot with performance for\n       // repeated queries, on the downside it cause heap issues.\n       _indexSearcher.setQueryCache(null);\n+      // TODO: consider using a threshold of num docs per segment to decide between building\n+      // mapping file upfront on segment load v/s on-the-fly during query processing\n+      _docIdReaderWriter = new DocIdReaderWriter(segmentIndexDir, _column, numDocs);\n+      _docIdReaderWriter.buildDocIdMapping(numDocs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2OTY2OA==", "bodyText": "For segment refresh, this file should not exist as we delete the old segment", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400369668", "createdAt": "2020-03-30T17:32:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,49 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs) throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // For newly added segments, this file will not exist.\n+      // For segment refresh, segment reload and server restart, file will exist,\n+      // but we don't know if we are here for refresh v/s reload v/s restart.\n+      // In case of refresh, we have to build the mapping again, but in case of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MDQyOQ==", "bodyText": "For better performance, I would probably choose native order as this index is always local to one instance?", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400370429", "createdAt": "2020-03-30T17:33:48Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,49 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs) throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // For newly added segments, this file will not exist.\n+      // For segment refresh, segment reload and server restart, file will exist,\n+      // but we don't know if we are here for refresh v/s reload v/s restart.\n+      // In case of refresh, we have to build the mapping again, but in case of\n+      // reload and restart, we don't. Also, reload has a sub-case where this text index\n+      // was indeed created during reload (user enabled on existing or newly added column).\n+      // Since there is no way to distinguish why we are here, we build the mapping again\n+      // regardless.\n+      // TODO: see if we can prefetch the pages\n+      _buffer =\n+          PinotDataBuffer.mapFile(docIdMappingFile, false, 0, length, ByteOrder.BIG_ENDIAN, getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MTk5Mw==", "bodyText": "Please include the column name into the description (last argument) to distinguish different columns", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400371993", "createdAt": "2020-03-30T17:36:14Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,49 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs) throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // For newly added segments, this file will not exist.\n+      // For segment refresh, segment reload and server restart, file will exist,\n+      // but we don't know if we are here for refresh v/s reload v/s restart.\n+      // In case of refresh, we have to build the mapping again, but in case of\n+      // reload and restart, we don't. Also, reload has a sub-case where this text index\n+      // was indeed created during reload (user enabled on existing or newly added column).\n+      // Since there is no way to distinguish why we are here, we build the mapping again\n+      // regardless.\n+      // TODO: see if we can prefetch the pages\n+      _buffer =\n+          PinotDataBuffer.mapFile(docIdMappingFile, false, 0, length, ByteOrder.BIG_ENDIAN, getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MjU0Mw==", "bodyText": "Throw this exception out instead of logging an ERROR. If this step fails, JVM will crash when reading the buffer.", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400372543", "createdAt": "2020-03-30T17:37:07Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,49 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs) throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // For newly added segments, this file will not exist.\n+      // For segment refresh, segment reload and server restart, file will exist,\n+      // but we don't know if we are here for refresh v/s reload v/s restart.\n+      // In case of refresh, we have to build the mapping again, but in case of\n+      // reload and restart, we don't. Also, reload has a sub-case where this text index\n+      // was indeed created during reload (user enabled on existing or newly added column).\n+      // Since there is no way to distinguish why we are here, we build the mapping again\n+      // regardless.\n+      // TODO: see if we can prefetch the pages\n+      _buffer =\n+          PinotDataBuffer.mapFile(docIdMappingFile, false, 0, length, ByteOrder.BIG_ENDIAN, getClass().getSimpleName());\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {\n+      for (int i = 0; i < numDocs; i++) {\n+        try {\n+          Document document = _indexSearcher.doc(i);\n+          int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+          _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+        } catch (Exception e) {\n+          LOGGER.error(\"Failed to build doc id mapping during segment load for column:{},docID:{},error:{}. Will continue and build mapping on the fly\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d"}, "originalPosition": 114}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/0db1d2e4a3623f87297fd652c66d4b7600594f9d", "committedDate": "2020-03-30T17:13:17Z", "message": "Lucene DocId to PinotDocId cache"}, "afterCommit": {"oid": "50855dcf42f06f5cb050263c14c96fb4135807f8", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/50855dcf42f06f5cb050263c14c96fb4135807f8", "committedDate": "2020-03-30T23:19:06Z", "message": "Lucene DocId to PinotDocId cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MzA2MTIz", "url": "https://github.com/apache/pinot/pull/5177#pullrequestreview-384306123", "createdAt": "2020-03-30T23:37:16Z", "commit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMzozNzoxNlrOF-AF2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDoxNDowNlrOF-Ayhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1NzUyOA==", "bodyText": "Remove?", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400557528", "createdAt": "2020-03-30T23:37:16Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/test/java/org/apache/pinot/queries/TextSearchQueriesTest.java", "diffHunk": "@@ -18,6 +18,7 @@\n  */\n package org.apache.pinot.queries;\n \n+import com.google.common.base.Stopwatch;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1ODY2Mw==", "bodyText": "By convention, we use indexDir for top level directory, and segmentDirectory for the direct directory (indexDir for v1, or v3 for v3). If you follow the same naming convention, it will be clearer.", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400558663", "createdAt": "2020-03-30T23:40:38Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -154,6 +152,11 @@ private void createTextIndexForColumn(ColumnMetadata columnMetadata)\n     int numDocs = columnMetadata.getTotalDocs();\n     LOGGER.info(\"Creating new text index for column: {} in segment: {}\", column, _segmentName);\n     File segmentIndexDir = SegmentDirectoryPaths.segmentDirectoryFor(_indexDir, _segmentVersion);\n+    // The handlers are always invoked by the preprocessor. Before this ImmutableSegmentLoader would have already", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1OTEyMQ==", "bodyText": "Not related to this pr, but seems this file needs reformat", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400559121", "createdAt": "2020-03-30T23:42:12Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -61,8 +61,26 @@\n import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.getKeyFor;\n \n \n+/**\n+ * Helper class for text indexes used by {@link org.apache.pinot.core.segment.index.loader.SegmentPreProcessor}.\n+ * to create text index for column during segment load time. Currently text index is always\n+ * created (if enabled on a column) during segment generation\n+ *\n+ * (1) A new segment with text index is created/refreshed. Server loads the segment. The handler\n+ * detects the existence of text index and returns.\n+ *\n+ * (2) A reload is issued on an existing segment with existing text index. The handler\n+ * detects the existence of text index and returns.\n+ *\n+ * (3) A reload is issued on an existing segment after text index is enabled on an existing\n+ * column. Read the forward index to create text index.\n+ *\n+ * (4) A reload is issued on an existing segment after text index is enabled on a newly\n+ * added column. In this case, the default column handler would have taken care of adding\n+ * forward index for the new column. Read the forward index to create text index.\n+ */\n public class TextIndexHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MDU1OQ==", "bodyText": "Not related to this pr, but can you make this method similar to copyForwardIndex() and call it in copyIndexData() based on the metadata?", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400560559", "createdAt": "2020-03-30T23:46:48Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java", "diffHunk": "@@ -241,6 +242,22 @@ public boolean accept(File dir, String name) {\n         Files.copy(indexFile.toPath(), v3LuceneIndexFile.toPath());\n       }\n     }\n+    // if segment reload is issued asking for up-conversion of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NDY3Mw==", "bodyText": "final PinotDataBuffer _buffer (class itself is private)", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400564673", "createdAt": "2020-03-30T23:59:57Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NDcyOA==", "bodyText": "private static class", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400564728", "createdAt": "2020-03-31T00:00:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTAzOA==", "bodyText": "Integer.parseInt()", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400565038", "createdAt": "2020-03-31T00:01:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      } else {\n+        _mappingExists = false;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      }\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {\n+      if (!_mappingExists) {\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = _indexSearcher.doc(i);\n+            int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTUzOA==", "bodyText": "Merge this into the constructor, no need to track an extra boolean.", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400565538", "createdAt": "2020-03-31T00:02:56Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      } else {\n+        _mappingExists = false;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      }\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTg3Mg==", "bodyText": "Recommend making second argument indexDir to denote that it is top level dir", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400565872", "createdAt": "2020-03-31T00:04:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -60,7 +66,7 @@\n    * @param column column name\n    * @param segmentIndexDir segment index directory\n    */\n-  public LuceneTextIndexReader(String column, File segmentIndexDir) {\n+  public LuceneTextIndexReader(String column, File segmentIndexDir, int numDocs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjExOA==", "bodyText": "I prefer the original name", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400566118", "createdAt": "2020-03-31T00:04:45Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -121,7 +131,7 @@ public MutableRoaringBitmap getDocIds(Object value) {\n     try {\n       Query query = _queryParser.parse(searchQuery);\n       _indexSearcher.search(query, docIDCollector);\n-      return getPinotDocIds(docIDs);\n+      return getPinotDocIdsFromMappingFile(docIDs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjYyOA==", "bodyText": "You don't really need to log the error if you are going to throw out the exception. The catcher will log it with the stack trace", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400566628", "createdAt": "2020-03-31T00:06:25Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -121,7 +131,7 @@ public MutableRoaringBitmap getDocIds(Object value) {\n     try {\n       Query query = _queryParser.parse(searchQuery);\n       _indexSearcher.search(query, docIDCollector);\n-      return getPinotDocIds(docIDs);\n+      return getPinotDocIdsFromMappingFile(docIDs);\n     } catch (Exception e) {\n       LOGGER.error(\"Failed while searching the text index for column {}, search query {}, exception {}\", _column,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2Njc1OA==", "bodyText": "No need to catch, you can directly throw the exception", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400566758", "createdAt": "2020-03-31T00:06:54Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -142,18 +152,17 @@ public MutableRoaringBitmap getDocIds(Object value) {\n    *\n    * TODO: Explore optimizing this path to avoid building the second bitmap\n    */\n-  private MutableRoaringBitmap getPinotDocIds(MutableRoaringBitmap luceneDocIds) {\n+  private MutableRoaringBitmap getPinotDocIdsFromMappingFile(MutableRoaringBitmap luceneDocIds) {\n     IntIterator luceneDocIDIterator = luceneDocIds.getIntIterator();\n     MutableRoaringBitmap actualDocIDs = new MutableRoaringBitmap();\n     try {\n       while (luceneDocIDIterator.hasNext()) {\n         int luceneDocId = luceneDocIDIterator.next();\n-        Document document = _indexSearcher.doc(luceneDocId);\n-        int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+        int pinotDocId = _docIdReaderWriter.getInt(luceneDocId * Integer.BYTES);\n         actualDocIDs.add(pinotDocId);\n       }\n     } catch (Exception e) {\n-      throw new RuntimeException(\"Error: failed while retrieving document from index: \" + e);\n+      throw new RuntimeException(\"Error: failed while retrieving pinot doc id from mapping file: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODA3Mg==", "bodyText": "\"Text index docId mapping buffer: \" + _column", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400568072", "createdAt": "2020-03-31T00:11:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODQwNQ==", "bodyText": "int getPinotDocId(int luceneDocId) for better abstraction", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400568405", "createdAt": "2020-03-31T00:12:24Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      } else {\n+        _mappingExists = false;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      }\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {\n+      if (!_mappingExists) {\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = _indexSearcher.doc(i);\n+            int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+            _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to build doc id mapping during segment load: \" + e);\n+          }\n+        }\n+      }\n+    }\n+\n+    int getInt(int offset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODk2Nw==", "bodyText": "I would recommend renaming it to DocIdTranslator", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400568967", "createdAt": "2020-03-31T00:14:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MzIzNzA0", "url": "https://github.com/apache/pinot/pull/5177#pullrequestreview-384323704", "createdAt": "2020-03-31T00:27:16Z", "commit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDoyNzoxNlrOF-BBWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDoyNzo0M1rOF-BB3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mjc2Mg==", "bodyText": "Can we reuse FixedByteReaderWriter?", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400572762", "createdAt": "2020-03-31T00:27:16Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mjg5Mw==", "bodyText": ", e", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400572893", "createdAt": "2020-03-31T00:27:43Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      } else {\n+        _mappingExists = false;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      }\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {\n+      if (!_mappingExists) {\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = _indexSearcher.doc(i);\n+            int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+            _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to build doc id mapping during segment load: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 121}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "044ee794da64288ab9d1a569e84669c52a9c0b1f", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/044ee794da64288ab9d1a569e84669c52a9c0b1f", "committedDate": "2020-03-31T00:47:12Z", "message": "review comments"}, "afterCommit": {"oid": "c63bb40b1be47cab59a84e765d1a77c1bb00fcbf", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c63bb40b1be47cab59a84e765d1a77c1bb00fcbf", "committedDate": "2020-03-31T00:52:10Z", "message": "Lucene DocId to PinotDocId cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MzMyNjU5", "url": "https://github.com/apache/pinot/pull/5177#pullrequestreview-384332659", "createdAt": "2020-03-31T00:54:34Z", "commit": {"oid": "c63bb40b1be47cab59a84e765d1a77c1bb00fcbf"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDo1NDozNFrOF-BfSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMTowNDo1NFrOF-Bqmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MDQyNw==", "bodyText": "I was referring to the usage (check metadata and copy instead of filtering on file names). Not critical, you can address later", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400580427", "createdAt": "2020-03-31T00:54:34Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java", "diffHunk": "@@ -241,6 +242,22 @@ public boolean accept(File dir, String name) {\n         Files.copy(indexFile.toPath(), v3LuceneIndexFile.toPath());\n       }\n     }\n+    // if segment reload is issued asking for up-conversion of", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MDU1OQ=="}, "originalCommit": {"oid": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MTI1NA==", "bodyText": "If you want to keep the context of the exception, put it into the RuntimeException", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400581254", "createdAt": "2020-03-31T00:57:41Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -123,8 +133,7 @@ public MutableRoaringBitmap getDocIds(Object value) {\n       _indexSearcher.search(query, docIDCollector);\n       return getPinotDocIds(docIDs);\n     } catch (Exception e) {\n-      LOGGER.error(\"Failed while searching the text index for column {}, search query {}, exception {}\", _column,\n-          searchQuery, e.getMessage());\n+      LOGGER.error(\"Failed while searching the text index for column {}, search query {},\", _column, searchQuery);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf80eef3101b78c15ff4504e77c364324567b506"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MTg4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new RuntimeException(\"Failed to build doc id mapping during segment load, \" + e);\n          \n          \n            \n                        throw new RuntimeException(\"Caught exception while building doc id mapping for text index column: \" + column, e);", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400581886", "createdAt": "2020-03-31T00:59:53Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +173,50 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdTranslator.close();\n+  }\n+\n+  private static class DocIdTranslator implements Closeable {\n+    final PinotDataBuffer _buffer;\n+\n+    DocIdTranslator(File segmentIndexDir, String column, int numDocs, IndexSearcher indexSearcher)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      String desc = \"Text index docId mapping buffer: \" + column;\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _buffer =\n+            PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN, desc);\n+      } else {\n+        _buffer =\n+            PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN, desc);\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = indexSearcher.doc(i);\n+            int pinotDocId = Integer.parseInt(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+            _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to build doc id mapping during segment load, \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf80eef3101b78c15ff4504e77c364324567b506"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4Mjg0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new RuntimeException(e);\n          \n          \n            \n                  throw new RuntimeException(\"Caught exception while searching the text index column: \" + _column + \" with query: \" + searchQuery, e);", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400582841", "createdAt": "2020-03-31T01:03:18Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -123,8 +133,7 @@ public MutableRoaringBitmap getDocIds(Object value) {\n       _indexSearcher.search(query, docIDCollector);\n       return getPinotDocIds(docIDs);\n     } catch (Exception e) {\n-      LOGGER.error(\"Failed while searching the text index for column {}, search query {}, exception {}\", _column,\n-          searchQuery, e.getMessage());\n+      LOGGER.error(\"Failed while searching the text index for column {}, search query {},\", _column, searchQuery);\n       throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf80eef3101b78c15ff4504e77c364324567b506"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MzMyMw==", "bodyText": "Pass in luceneDocId and wrap the _buffer.getInt(luceneDocId * Integer.BYTES) logic inside", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400583323", "createdAt": "2020-03-31T01:04:54Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +173,50 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdTranslator.close();\n+  }\n+\n+  private static class DocIdTranslator implements Closeable {\n+    final PinotDataBuffer _buffer;\n+\n+    DocIdTranslator(File segmentIndexDir, String column, int numDocs, IndexSearcher indexSearcher)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      String desc = \"Text index docId mapping buffer: \" + column;\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _buffer =\n+            PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN, desc);\n+      } else {\n+        _buffer =\n+            PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN, desc);\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = indexSearcher.doc(i);\n+            int pinotDocId = Integer.parseInt(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+            _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to build doc id mapping during segment load, \" + e);\n+          }\n+        }\n+      }\n+    }\n+\n+    int getPinotDocId(int offset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf80eef3101b78c15ff4504e77c364324567b506"}, "originalPosition": 125}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cf80eef3101b78c15ff4504e77c364324567b506", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/cf80eef3101b78c15ff4504e77c364324567b506", "committedDate": "2020-03-31T00:54:06Z", "message": "address review comments"}, "afterCommit": {"oid": "b74c28c2e98185ecd545933208f35fed65724e40", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/b74c28c2e98185ecd545933208f35fed65724e40", "committedDate": "2020-03-31T01:23:39Z", "message": "Lucene DocId to PinotDocId cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e46afb7b62ade04754530eacf3ac6309aeb9fa04", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/e46afb7b62ade04754530eacf3ac6309aeb9fa04", "committedDate": "2020-03-31T02:31:28Z", "message": "Lucene DocId to PinotDocId cache to improve performance"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b74c28c2e98185ecd545933208f35fed65724e40", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/b74c28c2e98185ecd545933208f35fed65724e40", "committedDate": "2020-03-31T01:23:39Z", "message": "Lucene DocId to PinotDocId cache"}, "afterCommit": {"oid": "e46afb7b62ade04754530eacf3ac6309aeb9fa04", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/e46afb7b62ade04754530eacf3ac6309aeb9fa04", "committedDate": "2020-03-31T02:31:28Z", "message": "Lucene DocId to PinotDocId cache to improve performance"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1104, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}