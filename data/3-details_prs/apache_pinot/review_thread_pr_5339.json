{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzODg1Mjgy", "number": 5339, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODozNDowM1rOD58byw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODozOTo1MFrOD58kbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDg1NTc5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/TransformPlanNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODozNDowM1rOGRgMJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDowMzoyMVrOGRjWFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNjM3NQ==", "bodyText": "This logic should also be handle in the upper level (SelectionPlanNode) and passed to this class", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421006375", "createdAt": "2020-05-06T18:34:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/TransformPlanNode.java", "diffHunk": "@@ -43,76 +39,70 @@\n \n   private final String _segmentName;\n   private final ProjectionPlanNode _projectionPlanNode;\n-  private final Set<String> _projectionColumns = new HashSet<>();\n-  private final Set<TransformExpressionTree> _expressions = new HashSet<>();\n+  private final Set<TransformExpressionTree> _expressions;\n   private int _maxDocPerNextCall = DocIdSetPlanNode.MAX_DOC_PER_CALL;\n \n-  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest) {\n+  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest,\n+      Set<TransformExpressionTree> expressionsToPlan) {\n     _segmentName = indexSegment.getSegmentName();\n-    extractColumnsAndTransforms(brokerRequest, indexSegment);\n-    _projectionPlanNode = new ProjectionPlanNode(indexSegment, _projectionColumns,\n+\n+    setMaxDocsForSelection(brokerRequest);\n+    Set<String> projectionColumns = new HashSet<>();\n+    extractProjectionColumns(expressionsToPlan, projectionColumns);\n+\n+    _expressions = expressionsToPlan;\n+    _projectionPlanNode = new ProjectionPlanNode(indexSegment, projectionColumns,\n         new DocIdSetPlanNode(indexSegment, brokerRequest, _maxDocPerNextCall));\n   }\n \n+  private void extractProjectionColumns(Set<TransformExpressionTree> expressionsToPlan, Set<String> projectionColumns) {\n+    for (TransformExpressionTree expression : expressionsToPlan) {\n+      extractProjectionColumns(expression, projectionColumns);\n+    }\n+  }\n+\n+  private void extractProjectionColumns(TransformExpressionTree expression, Set<String> projectionColumns) {\n+    TransformExpressionTree.ExpressionType expressionType = expression.getExpressionType();\n+    switch (expressionType) {\n+      case FUNCTION:\n+        for (TransformExpressionTree child : expression.getChildren()) {\n+          extractProjectionColumns(child, projectionColumns);\n+        }\n+        break;\n+\n+      case IDENTIFIER:\n+        projectionColumns.add(expression.getValue());\n+        break;\n+\n+      case LITERAL:\n+        // Do nothing.\n+        break;\n+\n+      default:\n+        throw new UnsupportedOperationException(\"Unsupported expression type: \" + expressionType);\n+    }\n+  }\n+\n   /**\n-   * Helper method to extract projection columns and transform expressions from the given broker request.\n+   * Helper method to set the max number of docs to return for selection queries\n    */\n-  private void extractColumnsAndTransforms(BrokerRequest brokerRequest, IndexSegment indexSegment) {\n-    Set<String> columns = new HashSet<>();\n-    if (brokerRequest.isSetAggregationsInfo()) {\n-      // Extract aggregation expressions\n-      for (AggregationInfo aggregationInfo : brokerRequest.getAggregationsInfo()) {\n-        if (aggregationInfo.getAggregationType().equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName())) {\n-          // 'DISTINCT(col1, col2 ...)' is modeled as one single aggregation function\n-          List<String> distinctColumns = AggregationFunctionUtils.getAggregationExpressions(aggregationInfo);\n-          columns.addAll(distinctColumns);\n-        } else if (!aggregationInfo.getAggregationType().equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n-          columns.addAll(AggregationFunctionUtils.getAggregationExpressions(aggregationInfo));\n-        }\n-      }\n-      // Extract group-by expressions\n-      if (brokerRequest.isSetGroupBy()) {\n-        columns.addAll(brokerRequest.getGroupBy().getExpressions());\n-      }\n-    } else {\n+  private void setMaxDocsForSelection(BrokerRequest brokerRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1ODA2OQ==", "bodyText": "Yeah I thought so too. But upper levels can be aggregation as well, which will now have this field leaked. For now I tend to keep it here (as was the case before) until the full cleanup happens.", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421058069", "createdAt": "2020-05-06T20:03:21Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/TransformPlanNode.java", "diffHunk": "@@ -43,76 +39,70 @@\n \n   private final String _segmentName;\n   private final ProjectionPlanNode _projectionPlanNode;\n-  private final Set<String> _projectionColumns = new HashSet<>();\n-  private final Set<TransformExpressionTree> _expressions = new HashSet<>();\n+  private final Set<TransformExpressionTree> _expressions;\n   private int _maxDocPerNextCall = DocIdSetPlanNode.MAX_DOC_PER_CALL;\n \n-  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest) {\n+  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest,\n+      Set<TransformExpressionTree> expressionsToPlan) {\n     _segmentName = indexSegment.getSegmentName();\n-    extractColumnsAndTransforms(brokerRequest, indexSegment);\n-    _projectionPlanNode = new ProjectionPlanNode(indexSegment, _projectionColumns,\n+\n+    setMaxDocsForSelection(brokerRequest);\n+    Set<String> projectionColumns = new HashSet<>();\n+    extractProjectionColumns(expressionsToPlan, projectionColumns);\n+\n+    _expressions = expressionsToPlan;\n+    _projectionPlanNode = new ProjectionPlanNode(indexSegment, projectionColumns,\n         new DocIdSetPlanNode(indexSegment, brokerRequest, _maxDocPerNextCall));\n   }\n \n+  private void extractProjectionColumns(Set<TransformExpressionTree> expressionsToPlan, Set<String> projectionColumns) {\n+    for (TransformExpressionTree expression : expressionsToPlan) {\n+      extractProjectionColumns(expression, projectionColumns);\n+    }\n+  }\n+\n+  private void extractProjectionColumns(TransformExpressionTree expression, Set<String> projectionColumns) {\n+    TransformExpressionTree.ExpressionType expressionType = expression.getExpressionType();\n+    switch (expressionType) {\n+      case FUNCTION:\n+        for (TransformExpressionTree child : expression.getChildren()) {\n+          extractProjectionColumns(child, projectionColumns);\n+        }\n+        break;\n+\n+      case IDENTIFIER:\n+        projectionColumns.add(expression.getValue());\n+        break;\n+\n+      case LITERAL:\n+        // Do nothing.\n+        break;\n+\n+      default:\n+        throw new UnsupportedOperationException(\"Unsupported expression type: \" + expressionType);\n+    }\n+  }\n+\n   /**\n-   * Helper method to extract projection columns and transform expressions from the given broker request.\n+   * Helper method to set the max number of docs to return for selection queries\n    */\n-  private void extractColumnsAndTransforms(BrokerRequest brokerRequest, IndexSegment indexSegment) {\n-    Set<String> columns = new HashSet<>();\n-    if (brokerRequest.isSetAggregationsInfo()) {\n-      // Extract aggregation expressions\n-      for (AggregationInfo aggregationInfo : brokerRequest.getAggregationsInfo()) {\n-        if (aggregationInfo.getAggregationType().equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName())) {\n-          // 'DISTINCT(col1, col2 ...)' is modeled as one single aggregation function\n-          List<String> distinctColumns = AggregationFunctionUtils.getAggregationExpressions(aggregationInfo);\n-          columns.addAll(distinctColumns);\n-        } else if (!aggregationInfo.getAggregationType().equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n-          columns.addAll(AggregationFunctionUtils.getAggregationExpressions(aggregationInfo));\n-        }\n-      }\n-      // Extract group-by expressions\n-      if (brokerRequest.isSetGroupBy()) {\n-        columns.addAll(brokerRequest.getGroupBy().getExpressions());\n-      }\n-    } else {\n+  private void setMaxDocsForSelection(BrokerRequest brokerRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNjM3NQ=="}, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDg2MzgyOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/TransformPlanNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODozNjoxM1rOGRgRBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDowNTo1M1rOGRjblw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzYyMw==", "bodyText": "(nit) expressionsToPlan -> expressions?\nAlso pass maxDocsPerBlock from upper level?", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421007623", "createdAt": "2020-05-06T18:36:13Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/TransformPlanNode.java", "diffHunk": "@@ -43,76 +39,70 @@\n \n   private final String _segmentName;\n   private final ProjectionPlanNode _projectionPlanNode;\n-  private final Set<String> _projectionColumns = new HashSet<>();\n-  private final Set<TransformExpressionTree> _expressions = new HashSet<>();\n+  private final Set<TransformExpressionTree> _expressions;\n   private int _maxDocPerNextCall = DocIdSetPlanNode.MAX_DOC_PER_CALL;\n \n-  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest) {\n+  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest,\n+      Set<TransformExpressionTree> expressionsToPlan) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1OTQ3OQ==", "bodyText": "expressions was too generic and being used in too many places for different purposes, so I thought to call it expressionsToPlan.\nReplied on maxDocsPerBlock above.", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421059479", "createdAt": "2020-05-06T20:05:53Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/TransformPlanNode.java", "diffHunk": "@@ -43,76 +39,70 @@\n \n   private final String _segmentName;\n   private final ProjectionPlanNode _projectionPlanNode;\n-  private final Set<String> _projectionColumns = new HashSet<>();\n-  private final Set<TransformExpressionTree> _expressions = new HashSet<>();\n+  private final Set<TransformExpressionTree> _expressions;\n   private int _maxDocPerNextCall = DocIdSetPlanNode.MAX_DOC_PER_CALL;\n \n-  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest) {\n+  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest,\n+      Set<TransformExpressionTree> expressionsToPlan) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzYyMw=="}, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDg3MDk4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODozNzo1NVrOGRgVTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDowNzoxNVrOGRjefg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwODcxNg==", "bodyText": "(nit) We don't have return argument documented in this file, maybe keep it consistent?", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421008716", "createdAt": "2020-05-06T18:37:55Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunction.java", "diffHunk": "@@ -49,6 +51,13 @@\n    */\n   String getResultColumnName();\n \n+  /**\n+   * Returns a list of input expressions needed for performing aggregation.\n+   *\n+   * @return List of input expressions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MDIyMg==", "bodyText": "Ok, will remove. It does not enough value to go out of the norm I guess.", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421060222", "createdAt": "2020-05-06T20:07:15Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunction.java", "diffHunk": "@@ -49,6 +51,13 @@\n    */\n   String getResultColumnName();\n \n+  /**\n+   * Returns a list of input expressions needed for performing aggregation.\n+   *\n+   * @return List of input expressions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwODcxNg=="}, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDg3NTE3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODozOTowNVrOGRgX9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDowODoxMlrOGRjgfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTM5OQ==", "bodyText": "No need to specialize this. Just make CountAggregationFunction return empty list", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421009399", "createdAt": "2020-05-06T18:39:05Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -182,4 +187,37 @@ public static String concatArgs(List<String> arguments) {\n     return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n         : arguments.get(0);\n   }\n+\n+  /**\n+   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n+   * and order-by\n+   *\n+   * @param brokerRequest Broker Request\n+   * @param functionContexts Aggregation Function contexts\n+   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   */\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n+      AggregationFunctionContext[] functionContexts) {\n+\n+    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n+    for (AggregationFunctionContext functionContext : functionContexts) {\n+      AggregationFunction function = functionContext.getAggregationFunction();\n+\n+      // Count is always treated as count(*) and does not need any columns to be projected.\n+      if (!function.getType().equals(AggregationFunctionType.COUNT)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MDczNA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421060734", "createdAt": "2020-05-06T20:08:12Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -182,4 +187,37 @@ public static String concatArgs(List<String> arguments) {\n     return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n         : arguments.get(0);\n   }\n+\n+  /**\n+   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n+   * and order-by\n+   *\n+   * @param brokerRequest Broker Request\n+   * @param functionContexts Aggregation Function contexts\n+   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   */\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n+      AggregationFunctionContext[] functionContexts) {\n+\n+    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n+    for (AggregationFunctionContext functionContext : functionContexts) {\n+      AggregationFunction function = functionContext.getAggregationFunction();\n+\n+      // Count is always treated as count(*) and does not need any columns to be projected.\n+      if (!function.getType().equals(AggregationFunctionType.COUNT)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTM5OQ=="}, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDg3NzkxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/CountAggregationFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODozOTo1MFrOGRgZnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDoxMDozN1rOGRjllQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTgyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return null;\n          \n          \n            \n                return Collections.emptyList();", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421009821", "createdAt": "2020-05-06T18:39:50Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/CountAggregationFunction.java", "diffHunk": "@@ -57,6 +59,11 @@ public String getResultColumnName() {\n     return AggregationFunctionType.COUNT.getName().toLowerCase() + \"(*)\";\n   }\n \n+  @Override\n+  public List<TransformExpressionTree> getInputExpressions() {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MjAzNw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421062037", "createdAt": "2020-05-06T20:10:37Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/CountAggregationFunction.java", "diffHunk": "@@ -57,6 +59,11 @@ public String getResultColumnName() {\n     return AggregationFunctionType.COUNT.getName().toLowerCase() + \"(*)\";\n   }\n \n+  @Override\n+  public List<TransformExpressionTree> getInputExpressions() {\n+    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTgyMQ=="}, "originalCommit": {"oid": "f02f5f382155389e847943e93aca915b0829bcd2"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3242, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}