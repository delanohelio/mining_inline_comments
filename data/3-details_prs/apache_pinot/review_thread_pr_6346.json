{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM2NTI4MTkw", "number": 6346, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo1NjoyM1rOFFVmZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoxMzo1OFrOFHZtVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQxMDk1OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo1NjoyM1rOIFzz-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo1NjoyM1rOIFzz-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2MjY4Mg==", "bodyText": "(nit)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private DimensionTableDataManager() {}\n          \n          \n            \n              private DimensionTableDataManager() {\n          \n          \n            \n              }", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542962682", "createdAt": "2020-12-15T00:56:23Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQxMjI4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo1Njo0OVrOIFz0rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0NzoyNlrOIGlG5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Mjg2MA==", "bodyText": "For clarity\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n          \n          \n            \n              public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542962860", "createdAt": "2020-12-15T00:56:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDM0MA==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543770340", "createdAt": "2020-12-15T23:47:26Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Mjg2MA=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQxMzI3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo1NzowNlrOIFz1Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo1MDozNFrOIGlLxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Mjk4Mw==", "bodyText": "For clarity\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n          \n          \n            \n              public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542962983", "createdAt": "2020-12-15T00:57:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU5MQ==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543771591", "createdAt": "2020-12-15T23:50:34Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Mjk4Mw=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQyMTg2OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowMDoxMFrOIFz53Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjo0MDoyOVrOIG1JJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NDE4OQ==", "bodyText": "Always create a new one instead of reusing the existing one (there should be no existing one normally)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n          \n          \n            \n                return _instances.get(tableName);\n          \n          \n            \n                DimensionTableDataManager instance = new DimensionTableDataManager();\n          \n          \n            \n                _instances.put(tableNameWithType, instance);\n          \n          \n            \n                return instance;", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542964189", "createdAt": "2020-12-15T01:00:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5Njc5NA==", "bodyText": "Updated as suggested, however now this method is technically non thread-safe. It doesn't look like this method will ever be called from multiple threads, but let me know if you think this is something we should address.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543796794", "createdAt": "2020-12-16T00:54:43Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NDE4OQ=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgwMDI5OA==", "bodyText": "It is still thread-safe unless multiple threads are trying to get the instance for the same table. But to be completely thread-safe, you may use:\nreturn _instances.computeIfAbsent(tableName, k -> new DimensionTableDataManager());\nThe difference is that this method won't always create a new instance of the data manager.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543800298", "createdAt": "2020-12-16T01:04:01Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NDE4OQ=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzMzA2Mg==", "bodyText": "Hmm, this is actually what I wanted to do with putIfAbsent. computeIfAbsent seems more succinct anyways, updating accordingly. \ud83d\udc4d", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544033062", "createdAt": "2020-12-16T06:40:29Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NDE4OQ=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQzMzcyOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowNDoyMFrOIF0AGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0Nzo0MFrOIGlHRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NTc4Nw==", "bodyText": "(nit)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n          \n          \n            \n                  _logger.info(\"Successfully loaded lookup table: {}\", getTableName());", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542965787", "createdAt": "2020-12-15T01:04:20Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDQzNw==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543770437", "createdAt": "2020-12-15T23:47:40Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NTc4Nw=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQzOTEzOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowNjowNlrOIF0C9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0ODowNVrOIGlH0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NjUxNg==", "bodyText": "(nit) reformat", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542966516", "createdAt": "2020-12-15T01:06:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDU3OA==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543770578", "createdAt": "2020-12-15T23:48:05Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NjUxNg=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQ0MDIyOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowNjoyNlrOIF0Dgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0ODoxNFrOIGlIDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NjY1OA==", "bodyText": "(nit)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n          \n          \n            \n                  _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542966658", "createdAt": "2020-12-15T01:06:26Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDYzOA==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543770638", "createdAt": "2020-12-15T23:48:14Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NjY1OA=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQ0MTkwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowNzowMVrOIF0EYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0ODoyNFrOIGlIXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Njg4Mg==", "bodyText": "Wrap it into a RuntimeException and throw it", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542966882", "createdAt": "2020-12-15T01:07:01Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDcxOA==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543770718", "createdAt": "2020-12-15T23:48:24Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Njg4Mg=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQ3MjkyOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMToxODoyOFrOIF0VWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjo0Mjo1MVrOIG1Qsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTIyNg==", "bodyText": "To simplify the logic, clear the lookup table first, then load it", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542971226", "createdAt": "2020-12-15T01:18:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDE2Nw==", "bodyText": "Applied your suggestion, however I think the older way was safer in the case where loading of the segment is interrupted with an exception in segment reader. Now, if an exception happens, older content is lost. Let me know if you think this is some edge case worth thinking about.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543770167", "createdAt": "2020-12-15T23:47:06Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTIyNg=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5ODAyMQ==", "bodyText": "I think it is the same as the loading happens after you clear the map even in the old code. If it throws exception, segment will get into ERROR state, and we'll have to wait until the next segment triggers this method again.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543798021", "createdAt": "2020-12-16T00:57:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTIyNg=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzNDk5NQ==", "bodyText": "Agreed that the previous approach doesn't save a lot either. Leaving as is, thanks.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544034995", "createdAt": "2020-12-16T06:42:51Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTIyNg=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQ3MzQ1OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMToxODozOVrOIF0VoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0ODo0MlrOIGlIyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTI5Nw==", "bodyText": "Remove", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542971297", "createdAt": "2020-12-15T01:18:39Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        _lookupTable.clear();\n+        return;\n+      }\n+\n+      List<File> indexDirs = new ArrayList<>();\n+      for (SegmentDataManager segmentManager: segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        System.out.println(indexSegment.getSegmentName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDgyNw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543770827", "createdAt": "2020-12-15T23:48:42Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        _lookupTable.clear();\n+        return;\n+      }\n+\n+      List<File> indexDirs = new ArrayList<>();\n+      for (SegmentDataManager segmentManager: segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        System.out.println(indexSegment.getSegmentName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTI5Nw=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQ3NjMxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMToxOTo0NlrOIF0XMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0OTo0NlrOIGlKhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTY5Nw==", "bodyText": "No need to use MultiplePinotSegmentRecordReader here, use PinotSegmentRecordReader instead on each segment. Use try-with-resource to close the reader after the reading", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542971697", "createdAt": "2020-12-15T01:19:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        _lookupTable.clear();\n+        return;\n+      }\n+\n+      List<File> indexDirs = new ArrayList<>();\n+      for (SegmentDataManager segmentManager: segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        System.out.println(indexSegment.getSegmentName());\n+        indexDirs.add(indexSegment.getSegmentMetadata().getIndexDir());\n+      }\n+      MultiplePinotSegmentRecordReader reader = new MultiplePinotSegmentRecordReader(indexDirs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTI2OQ==", "bodyText": "Good suggestion, ended up cleaning the code a bit, thanks.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543771269", "createdAt": "2020-12-15T23:49:46Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        _lookupTable.clear();\n+        return;\n+      }\n+\n+      List<File> indexDirs = new ArrayList<>();\n+      for (SegmentDataManager segmentManager: segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        System.out.println(indexSegment.getSegmentName());\n+        indexDirs.add(indexSegment.getSegmentMetadata().getIndexDir());\n+      }\n+      MultiplePinotSegmentRecordReader reader = new MultiplePinotSegmentRecordReader(indexDirs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTY5Nw=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQ3ODYwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/test/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManagerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMToyMDozM1rOIF0YhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0OTo1OFrOIGlK6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MjAzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @BeforeSuite\n          \n          \n            \n              @BeforeClass", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542972036", "createdAt": "2020-12-15T01:20:33Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManagerTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.yammer.metrics.core.MetricsRegistry;\n+import java.io.File;\n+import java.net.URL;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.metrics.ServerMetrics;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.config.TableDataManagerConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.SegmentIndexCreationDriver;\n+import org.apache.pinot.core.segment.creator.impl.SegmentCreationDriverFactory;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.index.loader.LoaderTest;\n+import org.apache.pinot.segments.v1.creator.SegmentTestUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.*;\n+\n+\n+public class DimensionTableDataManagerTest {\n+  private static final String TABLE_NAME = \"dimBaseballTeams\";\n+  private static final File INDEX_DIR = new File(LoaderTest.class.getName());\n+  private static final String AVRO_DATA_PATH = \"data/dimBaseballTeams.avro\";\n+\n+  private File _indexDir;\n+  private IndexLoadingConfig _indexLoadingConfig;\n+\n+  @BeforeSuite", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTM2OA==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543771368", "createdAt": "2020-12-15T23:49:58Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManagerTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.yammer.metrics.core.MetricsRegistry;\n+import java.io.File;\n+import java.net.URL;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.metrics.ServerMetrics;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.config.TableDataManagerConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.SegmentIndexCreationDriver;\n+import org.apache.pinot.core.segment.creator.impl.SegmentCreationDriverFactory;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.index.loader.LoaderTest;\n+import org.apache.pinot.segments.v1.creator.SegmentTestUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.*;\n+\n+\n+public class DimensionTableDataManagerTest {\n+  private static final String TABLE_NAME = \"dimBaseballTeams\";\n+  private static final File INDEX_DIR = new File(LoaderTest.class.getName());\n+  private static final String AVRO_DATA_PATH = \"data/dimBaseballTeams.avro\";\n+\n+  private File _indexDir;\n+  private IndexLoadingConfig _indexLoadingConfig;\n+\n+  @BeforeSuite", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MjAzNg=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQ3ODg2OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/test/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManagerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMToyMDo0MlrOIF0YsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0OTo1NVrOIGlK3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MjA4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @AfterSuite\n          \n          \n            \n              @AfterClass", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542972081", "createdAt": "2020-12-15T01:20:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManagerTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.yammer.metrics.core.MetricsRegistry;\n+import java.io.File;\n+import java.net.URL;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.metrics.ServerMetrics;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.config.TableDataManagerConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.SegmentIndexCreationDriver;\n+import org.apache.pinot.core.segment.creator.impl.SegmentCreationDriverFactory;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.index.loader.LoaderTest;\n+import org.apache.pinot.segments.v1.creator.SegmentTestUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.*;\n+\n+\n+public class DimensionTableDataManagerTest {\n+  private static final String TABLE_NAME = \"dimBaseballTeams\";\n+  private static final File INDEX_DIR = new File(LoaderTest.class.getName());\n+  private static final String AVRO_DATA_PATH = \"data/dimBaseballTeams.avro\";\n+\n+  private File _indexDir;\n+  private IndexLoadingConfig _indexLoadingConfig;\n+\n+  @BeforeSuite\n+  public void setUp()\n+      throws Exception {\n+    // prepare segment data\n+    URL resourceUrl = getClass().getClassLoader().getResource(AVRO_DATA_PATH);\n+    Assert.assertNotNull(resourceUrl);\n+    File avroFile = new File(resourceUrl.getFile());\n+\n+    // create segment\n+    SegmentGeneratorConfig segmentGeneratorConfig =\n+        SegmentTestUtils.getSegmentGeneratorConfigWithoutTimeColumn(avroFile, INDEX_DIR, TABLE_NAME);\n+    segmentGeneratorConfig.setSegmentVersion(SegmentVersion.v3);\n+    SegmentIndexCreationDriver driver = SegmentCreationDriverFactory.get(null);\n+    driver.init(segmentGeneratorConfig);\n+    driver.build();\n+    _indexDir = new File(INDEX_DIR, driver.getSegmentName());\n+\n+    _indexLoadingConfig = new IndexLoadingConfig();\n+    _indexLoadingConfig.setReadMode(ReadMode.mmap);\n+    _indexLoadingConfig.setSegmentVersion(SegmentVersion.v3);\n+  }\n+\n+  @AfterSuite", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTM1Ng==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543771356", "createdAt": "2020-12-15T23:49:55Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManagerTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.yammer.metrics.core.MetricsRegistry;\n+import java.io.File;\n+import java.net.URL;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.metrics.ServerMetrics;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.config.TableDataManagerConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.SegmentIndexCreationDriver;\n+import org.apache.pinot.core.segment.creator.impl.SegmentCreationDriverFactory;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.index.loader.LoaderTest;\n+import org.apache.pinot.segments.v1.creator.SegmentTestUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.*;\n+\n+\n+public class DimensionTableDataManagerTest {\n+  private static final String TABLE_NAME = \"dimBaseballTeams\";\n+  private static final File INDEX_DIR = new File(LoaderTest.class.getName());\n+  private static final String AVRO_DATA_PATH = \"data/dimBaseballTeams.avro\";\n+\n+  private File _indexDir;\n+  private IndexLoadingConfig _indexLoadingConfig;\n+\n+  @BeforeSuite\n+  public void setUp()\n+      throws Exception {\n+    // prepare segment data\n+    URL resourceUrl = getClass().getClassLoader().getResource(AVRO_DATA_PATH);\n+    Assert.assertNotNull(resourceUrl);\n+    File avroFile = new File(resourceUrl.getFile());\n+\n+    // create segment\n+    SegmentGeneratorConfig segmentGeneratorConfig =\n+        SegmentTestUtils.getSegmentGeneratorConfigWithoutTimeColumn(avroFile, INDEX_DIR, TABLE_NAME);\n+    segmentGeneratorConfig.setSegmentVersion(SegmentVersion.v3);\n+    SegmentIndexCreationDriver driver = SegmentCreationDriverFactory.get(null);\n+    driver.init(segmentGeneratorConfig);\n+    driver.build();\n+    _indexDir = new File(INDEX_DIR, driver.getSegmentName());\n+\n+    _indexLoadingConfig = new IndexLoadingConfig();\n+    _indexLoadingConfig.setReadMode(ReadMode.mmap);\n+    _indexLoadingConfig.setSegmentVersion(SegmentVersion.v3);\n+  }\n+\n+  @AfterSuite", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MjA4MQ=="}, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNjk2NTMwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDowNzo1NlrOIGloDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDo0MjoyMlrOIGmcAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3ODgzMA==", "bodyText": "Use @link to reference classes and methods. The nice thing is that IDE can help you track it and refactor it.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543778830", "createdAt": "2020-12-16T00:07:56Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /*\n+   * `createInstanceByTableName` should only be used by the `TableDataManagerProvider` and the returned instance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5MjEyOA==", "bodyText": "Updated, thanks for the tip!", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543792128", "createdAt": "2020-12-16T00:42:22Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /*\n+   * `createInstanceByTableName` should only be used by the `TableDataManagerProvider` and the returned instance", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3ODgzMA=="}, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNjk2NjE0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDowODoyMFrOIGlokA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDo0MjozMlrOIGmcXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3ODk2MA==", "bodyText": "extra line", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543778960", "createdAt": "2020-12-16T00:08:20Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /*\n+   * `createInstanceByTableName` should only be used by the `TableDataManagerProvider` and the returned instance\n+   * should be properly initialized via `TableDataManager::init` method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    DimensionTableDataManager instance = new DimensionTableDataManager();\n+    _instances.put(tableNameWithType, instance);\n+    return instance;\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5MjIyMw==", "bodyText": "Cleaned", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543792223", "createdAt": "2020-12-16T00:42:32Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /*\n+   * `createInstanceByTableName` should only be used by the `TableDataManagerProvider` and the returned instance\n+   * should be properly initialized via `TableDataManager::init` method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    DimensionTableDataManager instance = new DimensionTableDataManager();\n+    _instances.put(tableNameWithType, instance);\n+    return instance;\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3ODk2MA=="}, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzAwMzc5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/TableDataManagerProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDoyMTo1MlrOIGl9Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDo0Mjo0MFrOIGmciw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4NDIyMw==", "bodyText": "nit: use else to be clearer", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543784223", "createdAt": "2020-12-16T00:21:52Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/TableDataManagerProvider.java", "diffHunk": "@@ -53,6 +53,11 @@ public static TableDataManager getTableDataManager(@Nonnull TableDataManagerConf\n     TableDataManager tableDataManager;\n     switch (TableType.valueOf(tableDataManagerConfig.getTableDataManagerType())) {\n       case OFFLINE:\n+        if (tableDataManagerConfig.isDimTable()) {\n+          tableDataManager =\n+              DimensionTableDataManager.createInstanceByTableName(tableDataManagerConfig.getTableName());\n+          break;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5MjI2Nw==", "bodyText": "Updated", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543792267", "createdAt": "2020-12-16T00:42:40Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/TableDataManagerProvider.java", "diffHunk": "@@ -53,6 +53,11 @@ public static TableDataManager getTableDataManager(@Nonnull TableDataManagerConf\n     TableDataManager tableDataManager;\n     switch (TableType.valueOf(tableDataManagerConfig.getTableDataManagerType())) {\n       case OFFLINE:\n+        if (tableDataManagerConfig.isDimTable()) {\n+          tableDataManager =\n+              DimensionTableDataManager.createInstanceByTableName(tableDataManagerConfig.getTableName());\n+          break;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4NDIyMw=="}, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzEwODc0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDo1OTozNVrOIGm1mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjoyNTo1M1rOIG0aUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5ODY4Mg==", "bodyText": "(Critical) release these segment data managers after reading them", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543798682", "createdAt": "2020-12-16T00:59:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    DimensionTableDataManager instance = new DimensionTableDataManager();\n+    _instances.put(tableNameWithType, instance);\n+    return instance;\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8fd8bfa22ee0e9c17b5870c97292cfa96c03d46"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyMTA3NA==", "bodyText": "Good catch, \ud83d\udc4d. Updated to release the segment after usage. Also added an assertion to the unit test to make sure reference count is preserved.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544021074", "createdAt": "2020-12-16T06:25:53Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    DimensionTableDataManager instance = new DimensionTableDataManager();\n+    _instances.put(tableNameWithType, instance);\n+    return instance;\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5ODY4Mg=="}, "originalCommit": {"oid": "c8fd8bfa22ee0e9c17b5870c97292cfa96c03d46"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjQ4MDUzOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMDo1NjoyNlrOIHYykw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMDoyNzozM1rOIIOTow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxNzEwNw==", "bodyText": "We might want to put release in the finally block so that it is always released even with exceptions:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    releaseSegment(segmentManager);\n          \n          \n            \n              try {\n          \n          \n            \n                for (SegmentDataManager segmentManager : segmentManagers) {\n          \n          \n            \n                  ...\n          \n          \n            \n                }\n          \n          \n            \n              } finally {\n          \n          \n            \n                for (SegmentDataManager segmentManager : segmentManagers) {\n          \n          \n            \n                  releaseSegment(segmentManager);\n          \n          \n            \n                }\n          \n          \n            \n              }", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544617107", "createdAt": "2020-12-16T20:56:26Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYzMzg4OA==", "bodyText": "Good suggestion. How about creating the try..finally block inside the for loop like:\nfor (SegmentDataManager segmentManager: segmentManagers) {\n  try {\n     //... read contents...\n  } finally {\n    releaseSegment(segmentManager);\n  }\n}", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544633888", "createdAt": "2020-12-16T21:25:28Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxNzEwNw=="}, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMxNDg2OQ==", "bodyText": "This won't work because if the loading throws exception, it will only release one segment manager", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545314869", "createdAt": "2020-12-17T18:37:37Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxNzEwNw=="}, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MzkyMw==", "bodyText": "Oh, you're right, missed that completely. Updating as suggested.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545493923", "createdAt": "2020-12-18T00:27:33Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxNzEwNw=="}, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE0MDE1OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowODowNlrOIHeqLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMToxMDo0MlrOIIPK1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzI2Mg==", "bodyText": "Please annotate as visiblefortesting.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544713262", "createdAt": "2020-12-17T00:08:06Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);\n+      }\n+    } finally {\n+      _lookupTableWriteLock.unlock();\n+    }\n+  }\n+\n+  public GenericRow lookupRowByPrimaryKey(PrimaryKey pk) {\n+    _lookupTableReadLock.lock();\n+    try {\n+      return _lookupTable.get(pk);\n+    } finally {\n+      _lookupTableReadLock.unlock();\n+    }\n+  }\n+\n+  public FieldSpec getColumnFieldSpec(String columnName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5NTg1MA==", "bodyText": "Hi Subbu! This is actually one of the two public methods which, the proposed LookupUDF will use. So it is not visible for testing only. To see how the UDF will interact, please take a look at the POC implementation here.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545495850", "createdAt": "2020-12-18T00:33:32Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);\n+      }\n+    } finally {\n+      _lookupTableWriteLock.unlock();\n+    }\n+  }\n+\n+  public GenericRow lookupRowByPrimaryKey(PrimaryKey pk) {\n+    _lookupTableReadLock.lock();\n+    try {\n+      return _lookupTable.get(pk);\n+    } finally {\n+      _lookupTableReadLock.unlock();\n+    }\n+  }\n+\n+  public FieldSpec getColumnFieldSpec(String columnName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzI2Mg=="}, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUwODA1Mg==", "bodyText": "OK", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545508052", "createdAt": "2020-12-18T01:10:42Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);\n+      }\n+    } finally {\n+      _lookupTableWriteLock.unlock();\n+    }\n+  }\n+\n+  public GenericRow lookupRowByPrimaryKey(PrimaryKey pk) {\n+    _lookupTableReadLock.lock();\n+    try {\n+      return _lookupTable.get(pk);\n+    } finally {\n+      _lookupTableReadLock.unlock();\n+    }\n+  }\n+\n+  public FieldSpec getColumnFieldSpec(String columnName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzI2Mg=="}, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE0MTgyOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowODo0NVrOIHerIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMTowMDoyOVrOIIO-MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzUwNg==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n          \n          \n            \n                  _logger.info(\"Successfully added segment {} and loaded lookup table: {}\", getTableName());", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544713506", "createdAt": "2020-12-17T00:08:45Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUwNDgxNw==", "bodyText": "Added", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545504817", "createdAt": "2020-12-18T01:00:29Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzUwNg=="}, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE0MjEzOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowODo1NlrOIHerVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMTowMDozM1rOIIO-PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzU1Nw==", "bodyText": "Good to add segment name in the log", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544713557", "createdAt": "2020-12-17T00:08:56Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUwNDgyOQ==", "bodyText": "Added", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545504829", "createdAt": "2020-12-18T01:00:33Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzU1Nw=="}, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE2MDkxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxNTozOFrOIHe1Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODo1MDo1NVrOIIuqEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjEwNg==", "bodyText": "Please move this check to the table creation code in the controller.\nAlso ensure that the other checks are there as well:\n(1) table type must be OFFLINE\n(2) table ingestion should be REFRESH", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544716106", "createdAt": "2020-12-17T00:15:38Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MDc4NA==", "bodyText": "Good points Subbu. This is actually something @yupeng9 also mentioned in the original POC review, but seems like I forgot to add in this PR.\nNow, I added validations to TableConfigUtils to capture 'TableType', 'IngestionType' and 'PrimaryKey' requirements for Dimension tables. Please take a look.\nAlso, I would prefer to keep the 'PrimaryKey' precondition here, since I think it documents the constraint very well and is better than doing a null check deep down. Let me know what you think.\nThanks", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545540784", "createdAt": "2020-12-18T02:54:56Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjEwNg=="}, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MjU0MA==", "bodyText": "If we already check at the time of adding the table config, then it should never be null here, right?", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545972540", "createdAt": "2020-12-18T17:15:16Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjEwNg=="}, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyMzk1Mw==", "bodyText": "Yeah, guess you're right, it looks a bit too defensive now. Removing.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r546023953", "createdAt": "2020-12-18T18:50:55Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjEwNg=="}, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzI0MDE0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDo0NDo0M1rOIHfgEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMToxMjowOFrOIIPMkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyNzA1OA==", "bodyText": "is this table going to use heap or non-heap memory?", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544727058", "createdAt": "2020-12-17T00:44:43Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5NDQwOQ==", "bodyText": "This is going to be in-heap, using the _lookupTable HashMap declared below.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545494409", "createdAt": "2020-12-18T00:28:57Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyNzA1OA=="}, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUwODQ5OQ==", "bodyText": "I think @chenboat  is asking if the loadMode setting is going to be HEAP or MMAP. Perhaps the answer is that it does not matter, since the contents are instantiated into the hash table.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545508499", "createdAt": "2020-12-18T01:12:08Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyNzA1OA=="}, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTcwOTY3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzoxNjo1MlrOIIrkig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoxMjoyMVrOII38UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MzM4Ng==", "bodyText": "Since we want that a lookup table should be small, it may be worth asserting that the table has to be in one segment?", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545973386", "createdAt": "2020-12-18T17:16:52Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully added segment {} and loaded lookup table: {}\", indexDir.getName(), getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment {} and reloaded lookup table: {}\", segmentName, getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String\n+          .format(\"Error reloading lookup table after segment remove ({}) for table: {}\", segmentName, getTableName()),\n+          e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      try {\n+        for (SegmentDataManager segmentManager : segmentManagers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ae2beda4f452345f9d30603cd8401f7ac7728aa"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMTU0Mg==", "bodyText": "Right, I listed the table size issue in the description as one of the things I'd like to addresses subsequently.\nWhat I'm thinking is putting a 'default maximum' value for Dimension table size quota, say something like 200MB. But I also think this value should be configurable via server config (by the Pinot admin, not the user). This should allow use cases for larger tables if you have the hardware resources to handle them. I think restricting the table to be a single segment is somewhat arbitrary and doesn't help us that much. Happy to hear you and @Jackie-Jiang 's thoughts though.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r546031542", "createdAt": "2020-12-18T19:01:53Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully added segment {} and loaded lookup table: {}\", indexDir.getName(), getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment {} and reloaded lookup table: {}\", segmentName, getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String\n+          .format(\"Error reloading lookup table after segment remove ({}) for table: {}\", segmentName, getTableName()),\n+          e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      try {\n+        for (SegmentDataManager segmentManager : segmentManagers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MzM4Ng=="}, "originalCommit": {"oid": "3ae2beda4f452345f9d30603cd8401f7ac7728aa"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NjA4MQ==", "bodyText": "OK yes, we can address it later.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r546176081", "createdAt": "2020-12-19T02:12:21Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully added segment {} and loaded lookup table: {}\", indexDir.getName(), getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment {} and reloaded lookup table: {}\", segmentName, getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String\n+          .format(\"Error reloading lookup table after segment remove ({}) for table: {}\", segmentName, getTableName()),\n+          e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      try {\n+        for (SegmentDataManager segmentManager : segmentManagers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MzM4Ng=="}, "originalCommit": {"oid": "3ae2beda4f452345f9d30603cd8401f7ac7728aa"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzA1NTU5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/SegmentDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoxMzo1OFrOII39Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoyMDoyMFrOII3__A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NjI4Mg==", "bodyText": "I hope this API is still only for testing. The API does not make sense in production since the ref count could change any time after you get it. Please confirm.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r546176282", "createdAt": "2020-12-19T02:13:58Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/SegmentDataManager.java", "diffHunk": "@@ -29,7 +29,7 @@\n   private int _referenceCount = 1;\n \n   @VisibleForTesting\n-  synchronized int getReferenceCount() {\n+  public synchronized int getReferenceCount() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f719a847c811ee35d6af68e1724c69004d36c7e8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NzAyMA==", "bodyText": "Yes, we are using for testing only, to assert that the DimensionTable correctly releases segments after loading.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r546177020", "createdAt": "2020-12-19T02:20:20Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/SegmentDataManager.java", "diffHunk": "@@ -29,7 +29,7 @@\n   private int _referenceCount = 1;\n \n   @VisibleForTesting\n-  synchronized int getReferenceCount() {\n+  public synchronized int getReferenceCount() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NjI4Mg=="}, "originalCommit": {"oid": "f719a847c811ee35d6af68e1724c69004d36c7e8"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3028, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}