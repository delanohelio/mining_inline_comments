{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMDgzNjg3", "number": 6046, "title": "Deep Extraction Support for ORC, Thrift, and ProtoBuf Records", "bodyText": "Description\n\nPR for issue #5507. ORC, Thrift, and ProtoBuf readers now convert:\n\nNested structures to Map\nCollection to Object[]\nNumber/String/bytebuffer to single value\n\n\nAll extractors now support extracting all fields if fieldsToRead is null/empty (issue #5677). This support was\nadded to ORCRecordExtractor, ThriftRecordExtractor, ProtoBufRecordExtractor, and CSVRecordRecord.\nExtractor Util Cleanup:\nThere were duplicate implementations for extractor converters across RecordReaderUtils, JsonRecordExtractorUtils,\nand AvroUtils. This PR adds a new method, Object convert(Object value), to the RecordExtractor interface, as\nthis is a method that all extractors should implement to convert each field of the file format. A new abstract\nclass was created that extends RecordExtractor to contain the repeated logic across RecordReaderUtils,\nJsonRecordExtractorUtils, and AvroUtils. The abstract class also defines the common methods for recursively\nhandling maps, collections, records and single values.\n\nRelease Notes\nORC Records\nBefore this PR:\n\nAll single value ORC types were converted to number/string/byte[]\nList type as Object[]\nMap type as Map<Object, Object>\nThere was no case for handling ORC struct types. An IllegalArgumentException would have been thrown if a struct type field was present.\nOnly 1 level of nesting was handled in Map and Array.\n\nAfter this PR:\n\nAll single value ORC types were converted to number/string/byte[]\nList type as Object[]\nMap type as Map<Object, Object>\nORC struct type as Map<Object, Object>\nNested extraction is supported for List, Map and Struct types. Only nested Map values are supported (keys are handled as a single value).\n\nThrift Records\nBefore this PR:\n\nAll single value Thrift types were converted to number/string/byte[]\nList types as Object[] with only 1 level of nesting\nMaps or Thrift structs were converted by calling .toString() on it and as a result, would not preserve nested object structures.\nPrior to this change, it was assumed that each field ID in the Thrift record was consecutive, but this assumption is not enforced by Thrift compiler.\n\nAfter this PR:\n\nAll single value Thrift types are converted to number/string/byte[]\nList types as Object[]\nMap as Map<Object, Object>\nTBase type (Thrift struct) as Map<Object, Object>\nNested extraction is supported for List, Map and Struct types. Only nested Map values are supported (keys are handled as a single value).\nThe initialization of fields is modified such that the field IDs are taken from the structMetataMap of the Thrift Object therefore field IDs do not need to be consecutive.\n\nProtoBuf Records\nBefore this PR:\n\nAll single value ProtoBuf types were converted to number/string/byte[]\nRepeated type (array) as Object[] with only 1 level of nesting\nMap types were incorrectly handled as a collection and ProtoBuf Messages were converted by calling .toString() on it and as a result, would not preserve nested object structures.\n\nAfter this PR:\n\nAll single value ProtoBuf types are converted to number/string/byte[]\nRepeated type (array) as Object[]\nMap as Map<Object, Object>\nProtoBuf nested messages as Map<String, Object>\nNested extraction is supported for List, Map and Struct types. Only nested Map values are supported (keys are handled as a single value).\n\nBackwards incompatibility\nWith the new extraction support of nested fields/complex objects, if a Thrift, ProtoBuf or ORC record had Map/Collection fields with complex objects, those objects will be now retained, instead of converting them using .toString(). Therefore, any client expecting the old treatment of nested fields will be impacted.\nIn addition, if the fieldsToRead param is ever null/empty for the RecordReader, all fields of the record will now be read. Prior to this change, no field would have been read by the RecordReader.", "createdAt": "2020-09-22T17:16:21Z", "url": "https://github.com/apache/pinot/pull/6046", "merged": true, "mergeCommit": {"oid": "2cd6abbe407abb1e24e2c910158f9b4c3e4fc68d"}, "closed": true, "closedAt": "2020-10-19T20:36:20Z", "author": {"login": "timsants"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLjAO4AFqTQ5Mzk3NTQ2Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUJWoRgFqTUxMjA5MjQyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTc1NDYz", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-493975463", "createdAt": "2020-09-23T01:52:52Z", "commit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTo1Mjo1MlrOHWS5dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjoxNjo1NFrOHWT0Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MDM0MQ==", "bodyText": "Recommend not adding this generic type V as in most cases it is Object (the field can be of lots of types for the same file format)", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493140341", "createdAt": "2020-09-23T01:52:52Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -27,8 +28,9 @@\n  * 2) Collections become Object[] i.e. multi-value column\n  * 3) Nested/Complex fields (e.g. json maps, avro maps, avro records) become Map<Object, Object>\n  * @param <T> The format of the input record\n+ * @param <V> The input record's field to be converted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTA4NA==", "bodyText": "Put nullable annotation before fields", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493141084", "createdAt": "2020-09-23T01:54:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -27,8 +28,9 @@\n  * 2) Collections become Object[] i.e. multi-value column\n  * 3) Nested/Complex fields (e.g. json maps, avro maps, avro records) become Map<Object, Object>\n  * @param <T> The format of the input record\n+ * @param <V> The input record's field to be converted\n  */\n-public interface RecordExtractor<T> {\n+public interface RecordExtractor<T, V> {\n \n   /**\n    * Initialize the record extractor with its config", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MzQzOQ==", "bodyText": "We should return byte[] instead of ByteBuffer", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493143439", "createdAt": "2020-09-23T01:57:44Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw==", "bodyText": "We might not want to pass null into the convert(). Check the value before calling convert()", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493144557", "createdAt": "2020-09-23T01:59:24Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value\n+   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   *\n+   * @param value the field value to be converted\n+   * @return The converted field value\n+   */\n+  Object convert(@Nullable V value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NTUyMQ==", "bodyText": "Are we returning null for empty array/collection/map? If so, let's add the behavior to the javadoc and annotate the return value as nullable", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493145521", "createdAt": "2020-09-23T02:00:50Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value\n+   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   *\n+   * @param value the field value to be converted\n+   * @return The converted field value\n+   */\n+  Object convert(@Nullable V value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1MjcxNw==", "bodyText": "Suggest renaming it to BaseRecordExtractor", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493152717", "createdAt": "2020-09-23T02:12:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDUzNw==", "bodyText": "Not sure how much value this generic type V can provide. IMO convertRecord(Object value) should be good enough (similar to convertMap(Object value) etc.)", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493154537", "createdAt": "2020-09-23T02:15:33Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDkzOQ==", "bodyText": "Return false for default implementation?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493154939", "createdAt": "2020-09-23T02:16:09Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NTEzNg==", "bodyText": "Throw UnsupportedOperationException for default implementation?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493155136", "createdAt": "2020-09-23T02:16:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format.\n+   */\n+  @Nullable\n+  protected abstract Object convertRecord(V value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NTQyNw==", "bodyText": "The argument will never be null", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493155427", "createdAt": "2020-09-23T02:16:54Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format.\n+   */\n+  @Nullable\n+  protected abstract Object convertRecord(V value);\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = convert(element);\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      convertedMap.put(convertSingleValue(key), convert(map.get(key)));\n+    }\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values. Returns {@code null} for {@code null} input values.\n+   */\n+  @Nullable\n+  protected Object convertSingleValue(@Nullable Object value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTA2ODQ0", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-496106844", "createdAt": "2020-09-25T04:44:34Z", "commit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNDo0NDozNVrOHX0ywA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNDo0NDozNVrOHX0ywA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng==", "bodyText": "It'd be good to avoid using the non-functional way for performance concern. Please refer to the way that AvroRecordExtractor uses. Same to the other Extractors.", "url": "https://github.com/apache/pinot/pull/6046#discussion_r494744256", "createdAt": "2020-09-25T04:44:35Z", "author": {"login": "jackjlli"}, "path": "pinot-plugins/pinot-input-format/pinot-json/src/main/java/org/apache/pinot/plugin/inputformat/json/JSONRecordExtractor.java", "diffHunk": "@@ -45,18 +45,32 @@ public void init(Set<String> fields, @Nullable RecordExtractorConfig recordExtra\n   @Override\n   public GenericRow extract(Map<String, Object> from, GenericRow to) {\n     if (_extractAll) {\n-      from.forEach((fieldName, value) -> to.putValue(fieldName, JSONRecordExtractorUtils.convertValue(value)));\n+      from.forEach((fieldName, value) -> to.putValue(fieldName, convert(value)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "893b3e12628b1005714f2bbb679bfc3689d7eeb3"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3OTg3MTY2", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-497987166", "createdAt": "2020-09-29T00:39:52Z", "commit": {"oid": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwMDozOTo1M1rOHZUXdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwMDo0NTowMlrOHZUcoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDEzNA==", "bodyText": "You can still use the method you added such as isInstanceOfRecord here. So in the method:\n  protected boolean isInstanceOfRecord(Object value) {\n    return (TypeDescription.Category) value == TypeDescription.Category.STRUCT;\n  }", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310134", "createdAt": "2020-09-29T00:39:53Z", "author": {"login": "jackjlli"}, "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDE3OQ==", "bodyText": "Same here.", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310179", "createdAt": "2020-09-29T00:40:02Z", "author": {"login": "jackjlli"}, "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {\n+      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n+      if (!structColumnVector.isNull[rowId]) {\n+        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n+        List<String> childrenFieldNames = fieldType.getFieldNames();\n+\n+        Map<Object, Object> convertedMap = new HashMap<>();\n+        for (int i = 0; i < childrenFieldNames.size(); i++) {\n+          convertedMap.put(childrenFieldNames.get(i),\n+              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n         }\n-      } else if (category == TypeDescription.Category.MAP) {\n-        // Map field\n-        List<TypeDescription> children = fieldType.getChildren();\n-        TypeDescription.Category keyCategory = children.get(0).getCategory();\n-        TypeDescription.Category valueCategory = children.get(1).getCategory();\n-        MapColumnVector mapColumnVector = (MapColumnVector) _rowBatch.cols[i];\n-        int rowId = mapColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((mapColumnVector.noNulls || !mapColumnVector.isNull[rowId])) {\n-          int offset = (int) mapColumnVector.offsets[rowId];\n-          int length = (int) mapColumnVector.lengths[rowId];\n-          Map<Object, Object> map = new HashMap<>();\n-          for (int j = 0; j < length; j++) {\n-            int childRowId = offset + j;\n-            Object key = extractSingleValue(field, mapColumnVector.keys, childRowId, keyCategory);\n-            Object value = extractSingleValue(field, mapColumnVector.values, childRowId, valueCategory);\n-            map.put(key, value);\n+        return convertedMap;\n+      } else {\n+        return null;\n+      }\n+    } else if (category == TypeDescription.Category.LIST) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDIyNw==", "bodyText": "Same here.", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310227", "createdAt": "2020-09-29T00:40:13Z", "author": {"login": "jackjlli"}, "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {\n+      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n+      if (!structColumnVector.isNull[rowId]) {\n+        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n+        List<String> childrenFieldNames = fieldType.getFieldNames();\n+\n+        Map<Object, Object> convertedMap = new HashMap<>();\n+        for (int i = 0; i < childrenFieldNames.size(); i++) {\n+          convertedMap.put(childrenFieldNames.get(i),\n+              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n         }\n-      } else if (category == TypeDescription.Category.MAP) {\n-        // Map field\n-        List<TypeDescription> children = fieldType.getChildren();\n-        TypeDescription.Category keyCategory = children.get(0).getCategory();\n-        TypeDescription.Category valueCategory = children.get(1).getCategory();\n-        MapColumnVector mapColumnVector = (MapColumnVector) _rowBatch.cols[i];\n-        int rowId = mapColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((mapColumnVector.noNulls || !mapColumnVector.isNull[rowId])) {\n-          int offset = (int) mapColumnVector.offsets[rowId];\n-          int length = (int) mapColumnVector.lengths[rowId];\n-          Map<Object, Object> map = new HashMap<>();\n-          for (int j = 0; j < length; j++) {\n-            int childRowId = offset + j;\n-            Object key = extractSingleValue(field, mapColumnVector.keys, childRowId, keyCategory);\n-            Object value = extractSingleValue(field, mapColumnVector.values, childRowId, valueCategory);\n-            map.put(key, value);\n+        return convertedMap;\n+      } else {\n+        return null;\n+      }\n+    } else if (category == TypeDescription.Category.LIST) {\n+      TypeDescription childType = fieldType.getChildren().get(0);\n+      ListColumnVector listColumnVector = (ListColumnVector) columnVector;\n+      if (columnVector.isRepeating) {\n+        rowId = 0;\n+      }\n+      if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n+        int offset = (int) listColumnVector.offsets[rowId];\n+        int length = (int) listColumnVector.lengths[rowId];\n+        List<Object> values = new ArrayList<>(length);\n+        for (int j = 0; j < length; j++) {\n+          Object value = extractValue(field, listColumnVector.child, childType,offset + j);\n+          // NOTE: Only keep non-null values\n+          if (value != null) {\n+            values.add(value);\n           }\n-          reuse.putValue(field, map);\n+        }\n+        if (!values.isEmpty()) {\n+          return values.toArray();\n         } else {\n-          reuse.putValue(field, null);\n+          // NOTE: Treat empty list as null\n+          return null;\n         }\n       } else {\n-        // Single-value field\n-        reuse.putValue(field, extractSingleValue(field, _rowBatch.cols[i], _nextRowId, category));\n+        return null;\n       }\n-    }\n+    } else if (category == TypeDescription.Category.MAP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDcyNw==", "bodyText": "And pls adjust the sequence to make it consistent in all extractors (first check collection, then map, then record, and finally single value).", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310727", "createdAt": "2020-09-29T00:42:06Z", "author": {"login": "jackjlli"}, "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMTQ1Ng==", "bodyText": "Can we have an extractor for ORC as the other RecordReaders do?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496311456", "createdAt": "2020-09-29T00:45:02Z", "author": {"login": "jackjlli"}, "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -72,7 +73,7 @@\n   private int _nextRowId;\n \n   @Override\n-  public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReaderConfig recordReaderConfig)\n+  public void init(File dataFile, @Nullable Set<String> fieldsToRead, @Nullable RecordReaderConfig recordReaderConfig)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNDU5ODk0", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-502459894", "createdAt": "2020-10-05T22:18:09Z", "commit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMjoxODoxMFrOHcvp9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMjoyODo0M1rOHcv4Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMjk2Nw==", "bodyText": "Suggest renaming some methods:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Object convertedValue;\n          \n          \n            \n                if (isInstanceOfMultiValue(value)) {\n          \n          \n            \n                  convertedValue = convertMultiValue(value);\n          \n          \n            \n                } else if (isInstanceOfMap(value)) {\n          \n          \n            \n                  convertedValue = convertMap(value);\n          \n          \n            \n                } else if (isInstanceOfRecord(value)) {\n          \n          \n            \n                  convertedValue = convertRecord(value);\n          \n          \n            \n                } else {\n          \n          \n            \n                  convertedValue = convertSingleValue(value);\n          \n          \n            \n                }\n          \n          \n            \n                return convertedValue;\n          \n          \n            \n                if (isMultiValue(value)) {\n          \n          \n            \n                  return convertMultiValue(value);\n          \n          \n            \n                } else if (isMap(value)) {\n          \n          \n            \n                  return convertMap(value);\n          \n          \n            \n                } else if (isRecord(value)) {\n          \n          \n            \n                  return convertRecord(value);\n          \n          \n            \n                } else {\n          \n          \n            \n                  return convertSingleValue(value);\n          \n          \n            \n                }", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499902967", "createdAt": "2020-10-05T22:18:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNTA3Ng==", "bodyText": "Please double-check the current behavior of handling empty string. I think we should include them into the MV array", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499905076", "createdAt": "2020-10-05T22:24:09Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNTQ1NA==", "bodyText": "Use map.entrySet() to avoid the unnecessary lookups", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499905454", "createdAt": "2020-10-05T22:25:13Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjEzNw==", "bodyText": "We don't allow either key or value as null inside the map because we don't allow null inside the MV and map is handled with MV columns", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906137", "createdAt": "2020-10-05T22:27:15Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjQwMA==", "bodyText": "Return null for empty map?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906400", "createdAt": "2020-10-05T22:28:00Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);\n+    }\n+    return convertedMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjY1NQ==", "bodyText": "value should never be null here?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906655", "createdAt": "2020-10-05T22:28:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);\n+    }\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values. Returns {@code null} for {@code null} input values.\n+   */\n+  @Nullable\n+  protected Object convertSingleValue(@Nullable Object value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 155}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODgzMDQz", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-505883043", "createdAt": "2020-10-09T17:56:54Z", "commit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNzo1Njo1NFrOHfTlmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNzo1Njo1NFrOHfTlmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4ODgyNQ==", "bodyText": "For this method (and similarly all the ones in BaseRecordExtractor), please add a javadoc for value.\nPreviously we used to cast upfront and the param was directly the type (Collection, GenericRecord etc). But now, we are expecting the right type be provided in value, and casting here without any check. So it would be nice to have a description for the value for all the methods of this nature.", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502588825", "createdAt": "2020-10-09T17:56:54Z", "author": {"login": "npawar"}, "path": "pinot-plugins/pinot-input-format/pinot-avro-base/src/main/java/org/apache/pinot/plugin/inputformat/avro/AvroRecordExtractor.java", "diffHunk": "@@ -49,13 +51,53 @@ public GenericRow extract(GenericRecord from, GenericRow to) {\n       List<Schema.Field> fields = from.getSchema().getFields();\n       for (Schema.Field field : fields) {\n         String fieldName = field.name();\n-        to.putValue(fieldName, AvroUtils.convert(from.get(fieldName)));\n+        Object value = from.get(fieldName);\n+        if (value != null) {\n+          value = convert(value);\n+        }\n+        to.putValue(fieldName, value);\n       }\n     } else {\n       for (String fieldName : _fields) {\n-        to.putValue(fieldName, AvroUtils.convert(from.get(fieldName)));\n+        Object value = from.get(fieldName);\n+        if (value != null) {\n+          value = convert(value);\n+        }\n+        to.putValue(fieldName, value);\n       }\n     }\n     return to;\n   }\n+\n+  /**\n+   * Returns whether the object is an Avro GenericRecord.\n+   */\n+  @Override\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return value instanceof GenericRecord;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the Avro GenericRecord.\n+   */\n+  @Override\n+  @Nullable\n+  protected Object convertRecord(Object value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODg2OTY3", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-505886967", "createdAt": "2020-10-09T18:03:02Z", "commit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxODowMzowMlrOHfTxLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxODowMzowMlrOHfTxLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTc4OQ==", "bodyText": "I think you missed removing this code from extract and also calling convert  above in the extract.", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502591789", "createdAt": "2020-10-09T18:03:02Z", "author": {"login": "npawar"}, "path": "pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordExtractor.java", "diffHunk": "@@ -69,4 +70,32 @@ public GenericRow extract(CSVRecord from, GenericRow to) {\n     }\n     return to;\n   }\n+\n+  @Override\n+  @Nullable\n+  public Object convert(@Nullable Object value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODkyMDY2", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-505892066", "createdAt": "2020-10-09T18:11:24Z", "commit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxODoxMToyNVrOHfUBMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxODoxMToyNVrOHfUBMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ==", "bodyText": "i see that in CSV case where fieldsToRead is null, we get fields to read in the RecordReader. Versus, in the JSON/AVRO case we used to make that decision inside the RecordExtractor.\nIs it possible to keep these consistent and always let the RecordExtractor make this decision?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502595891", "createdAt": "2020-10-09T18:11:25Z", "author": {"login": "npawar"}, "path": "pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordReader.java", "diffHunk": "@@ -95,8 +95,13 @@ public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReader\n     _recordExtractor = new CSVRecordExtractor();\n     CSVRecordExtractorConfig recordExtractorConfig = new CSVRecordExtractorConfig();\n     recordExtractorConfig.setMultiValueDelimiter(multiValueDelimiter);\n-    _recordExtractor.init(fieldsToRead, recordExtractorConfig);\n+\n     init();\n+\n+    if (fieldsToRead == null || fieldsToRead.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTI4Nzc3", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-505928777", "createdAt": "2020-10-09T19:12:21Z", "commit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxOToxMjoyMlrOHfVx_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxOToxMjoyMlrOHfVx_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNDc2Ng==", "bodyText": "if this is true for all extractor tests now, can we remove this method and just default to testing extractAll?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502624766", "createdAt": "2020-10-09T19:12:22Z", "author": {"login": "npawar"}, "path": "pinot-plugins/pinot-input-format/pinot-thrift/src/test/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordExtractorTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.inputformat.thrift;\n+\n+import com.google.common.collect.Sets;\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.pinot.spi.data.readers.AbstractRecordExtractorTest;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.apache.thrift.TException;\n+import org.apache.thrift.protocol.TBinaryProtocol;\n+import org.apache.thrift.transport.TIOStreamTransport;\n+\n+\n+/**\n+ * Tests for the {@link ThriftRecordExtractor}\n+ */\n+public class ThriftRecordExtractorTest extends AbstractRecordExtractorTest {\n+\n+  private File _tempFile = new File(_tempDir, \"test_complex_thrift.data\");\n+\n+  private static final String INT_FIELD = \"intField\";\n+  private static final String LONG_FIELD = \"longField\";\n+  private static final String BOOL_FIELD = \"booleanField\";\n+  private static final String DOUBLE_FIELD = \"doubleField\";\n+  private static final String STRING_FIELD = \"stringField\";\n+  private static final String ENUM_FIELD = \"enumField\";\n+  private static final String OPTIONAL_STRING_FIELD = \"optionalStringField\";\n+  private static final String NESTED_STRUCT_FIELD = \"nestedStructField\";\n+  private static final String SIMPLE_LIST = \"simpleListField\";\n+  private static final String COMPLEX_LIST = \"complexListField\";\n+  private static final String SIMPLE_MAP = \"simpleMapField\";\n+  private static final String COMPLEX_MAP = \"complexMapField\";\n+  private static final String NESTED_STRING_FIELD = \"nestedStringField\";\n+  private static final String NESTED_INT_FIELD = \"nestedIntField\";\n+\n+  @Override\n+  protected List<Map<String, Object>> getInputRecords() {\n+    return Arrays.asList(createRecord1(), createRecord2());\n+  }\n+\n+  @Override\n+  protected Set<String> getSourceFields() {\n+    return Sets.newHashSet(INT_FIELD, LONG_FIELD, BOOL_FIELD, DOUBLE_FIELD, STRING_FIELD, ENUM_FIELD,\n+        OPTIONAL_STRING_FIELD, NESTED_STRUCT_FIELD, SIMPLE_LIST, COMPLEX_LIST, SIMPLE_MAP, COMPLEX_MAP);\n+  }\n+\n+  /**\n+   * Creates a ThriftRecordReader\n+   */\n+  @Override\n+  protected RecordReader createRecordReader(Set<String> fieldsToRead)\n+      throws IOException {\n+    ThriftRecordReader recordReader = new ThriftRecordReader();\n+    recordReader.init(_tempFile, getSourceFields(), getThriftRecordReaderConfig());\n+    return recordReader;\n+  }\n+\n+  private ThriftRecordReaderConfig getThriftRecordReaderConfig() {\n+    ThriftRecordReaderConfig config = new ThriftRecordReaderConfig();\n+    config.setThriftClass(\"org.apache.pinot.plugin.inputformat.thrift.ComplexTypes\");\n+    return config;\n+  }\n+\n+  /**\n+   * Create a data input file using input records containing various Thrift record types\n+   */\n+  @Override\n+  protected void createInputFile()\n+      throws IOException {\n+    List<ComplexTypes> thriftRecords = new ArrayList<>(2);\n+\n+    for (Map<String, Object> inputRecord : _inputRecords) {\n+      ComplexTypes thriftRecord = new ComplexTypes();\n+      thriftRecord.setIntField((int) inputRecord.get(INT_FIELD));\n+      thriftRecord.setLongField((long) inputRecord.get(LONG_FIELD));\n+\n+      Map<String, Object> nestedStructValues = (Map<String, Object>) inputRecord.get(NESTED_STRUCT_FIELD);\n+      thriftRecord.setNestedStructField(createNestedType(\n+          (String) nestedStructValues.get(NESTED_STRING_FIELD),\n+          (int) nestedStructValues.get(NESTED_INT_FIELD))\n+      );\n+\n+      thriftRecord.setSimpleListField((List<String>) inputRecord.get(SIMPLE_LIST));\n+\n+      List<NestedType> nestedTypeList = new ArrayList<>();\n+      for (Map element : (List<Map>) inputRecord.get(COMPLEX_LIST)) {\n+        nestedTypeList.add(createNestedType((String) element.get(NESTED_STRING_FIELD),\n+            (Integer) element.get(NESTED_INT_FIELD)));\n+      }\n+\n+      thriftRecord.setComplexListField(nestedTypeList);\n+      thriftRecord.setBooleanField(Boolean.valueOf((String) inputRecord.get(BOOL_FIELD)));\n+      thriftRecord.setDoubleField((Double) inputRecord.get(DOUBLE_FIELD));\n+      thriftRecord.setStringField((String) inputRecord.get(STRING_FIELD));\n+      thriftRecord.setEnumField(TestEnum.valueOf((String) inputRecord.get(ENUM_FIELD)));\n+      thriftRecord.setSimpleMapField((Map<String, Integer>) inputRecord.get(SIMPLE_MAP));\n+\n+      Map<String, NestedType> complexMap = new HashMap<>();\n+      for (Map.Entry<String, Map<String, Object>> entry :\n+          ((Map<String, Map<String, Object>>) inputRecord.get(COMPLEX_MAP)).entrySet()) {\n+        complexMap.put(entry.getKey(), createNestedType(\n+            (String) entry.getValue().get(NESTED_STRING_FIELD),\n+            (int) entry.getValue().get(NESTED_INT_FIELD)));\n+      }\n+      thriftRecord.setComplexMapField(complexMap);\n+      thriftRecords.add(thriftRecord);\n+    }\n+\n+    BufferedOutputStream bufferedOut = new BufferedOutputStream(new FileOutputStream(_tempFile));\n+    TBinaryProtocol binaryOut = new TBinaryProtocol(new TIOStreamTransport(bufferedOut));\n+    for (ComplexTypes record : thriftRecords) {\n+      try {\n+        record.write(binaryOut);\n+      } catch (TException e) {\n+        throw new IOException(e);\n+      }\n+    }\n+    bufferedOut.close();\n+  }\n+\n+  private Map<String, Object> createRecord1() {\n+    Map<String, Object> record = new HashMap<>();\n+    record.put(STRING_FIELD, \"hello\");\n+    record.put(INT_FIELD, 10);\n+    record.put(LONG_FIELD, 1000L);\n+    record.put(DOUBLE_FIELD, 1.0);\n+    record.put(BOOL_FIELD, \"false\");\n+    record.put(ENUM_FIELD, TestEnum.DELTA.toString());\n+    record.put(NESTED_STRUCT_FIELD, createNestedMap(NESTED_STRING_FIELD, \"ice cream\", NESTED_INT_FIELD, 5));\n+    record.put(SIMPLE_LIST, Arrays.asList(\"aaa\", \"bbb\", \"ccc\"));\n+    record.put(COMPLEX_LIST,\n+        Arrays.asList(\n+            createNestedMap(NESTED_STRING_FIELD, \"hows\", NESTED_INT_FIELD, 10),\n+            createNestedMap(NESTED_STRING_FIELD, \"it\", NESTED_INT_FIELD, 20),\n+            createNestedMap(NESTED_STRING_FIELD, \"going\", NESTED_INT_FIELD, 30)\n+        )\n+    );\n+    record.put(SIMPLE_MAP, createNestedMap(\"Tuesday\", 3, \"Wednesday\", 4));\n+    record.put(\n+        COMPLEX_MAP,\n+        createNestedMap(\n+            \"fruit1\", createNestedMap(NESTED_STRING_FIELD, \"apple\", NESTED_INT_FIELD, 1),\n+            \"fruit2\", createNestedMap(NESTED_STRING_FIELD, \"orange\", NESTED_INT_FIELD, 2)\n+        )\n+    );\n+    return record;\n+  }\n+\n+  private Map<String, Object> createRecord2() {\n+    Map<String, Object> record = new HashMap<>();\n+    record.put(STRING_FIELD, \"world\");\n+    record.put(INT_FIELD, 20);\n+    record.put(LONG_FIELD, 2000L);\n+    record.put(DOUBLE_FIELD, 2.0);\n+    record.put(BOOL_FIELD, \"false\");\n+    record.put(ENUM_FIELD, TestEnum.GAMMA.toString());\n+    record.put(NESTED_STRUCT_FIELD, createNestedMap(NESTED_STRING_FIELD, \"ice cream\", NESTED_INT_FIELD, 5));\n+    record.put(SIMPLE_LIST, Arrays.asList(\"aaa\", \"bbb\", \"ccc\"));\n+    record.put(COMPLEX_LIST,\n+        Arrays.asList(\n+            createNestedMap(NESTED_STRING_FIELD, \"hows\", NESTED_INT_FIELD, 10),\n+            createNestedMap(NESTED_STRING_FIELD, \"it\", NESTED_INT_FIELD, 20),\n+            createNestedMap(NESTED_STRING_FIELD, \"going\", NESTED_INT_FIELD, 30)\n+        )\n+    );\n+    record.put(SIMPLE_MAP, createNestedMap(\"Tuesday\", 3, \"Wednesday\", 4));\n+    record.put(\n+        COMPLEX_MAP,\n+        createNestedMap(\n+            \"fruit1\", createNestedMap(NESTED_STRING_FIELD, \"apple\", NESTED_INT_FIELD, 1),\n+            \"fruit2\", createNestedMap(NESTED_STRING_FIELD, \"orange\", NESTED_INT_FIELD, 2)\n+        )\n+    );\n+    return record;\n+  }\n+\n+  private Map<String, Object> createNestedMap(String key1, Object value1, String key2, Object value2) {\n+    Map<String, Object> nestedMap = new HashMap<>(2);\n+    nestedMap.put(key1, value1);\n+    nestedMap.put(key2, value2);\n+    return nestedMap;\n+  }\n+\n+  private NestedType createNestedType(String stringField, int intField) {\n+    NestedType nestedRecord = new NestedType();\n+    nestedRecord.setNestedStringField(stringField);\n+    nestedRecord.setNestedIntField(intField);\n+    return nestedRecord;\n+  }\n+\n+  @Override\n+  protected boolean testExtractAll() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTMwNTk5", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-505930599", "createdAt": "2020-10-09T19:15:34Z", "commit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxOToxNTozNFrOHfV3Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxOToxNTozNFrOHfV3Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNjExNA==", "bodyText": "I didn't follow this change, could you explain what's happening here?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502626114", "createdAt": "2020-10-09T19:15:34Z", "author": {"login": "npawar"}, "path": "pinot-plugins/pinot-input-format/pinot-thrift/src/main/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordReader.java", "diffHunk": "@@ -61,12 +62,13 @@ public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReader\n     } catch (Exception e) {\n       throw new RuntimeException(e);\n     }\n-    int index = 1;\n-    TFieldIdEnum tFieldIdEnum;\n-    while ((tFieldIdEnum = tObject.fieldForId(index)) != null) {\n-      _fieldIds.put(tFieldIdEnum.getFieldName(), index);\n-      index++;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f17705d48d5dc1fade270134fd77c611c5c5343", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/6f17705d48d5dc1fade270134fd77c611c5c5343", "committedDate": "2020-10-12T05:13:50Z", "message": "Deep Extraction Support for ORC, Thrift, and ProtoBuf Records\n\n1. PR for issue #5507. ORC, Thrift, and ProtoBuf readers now convert:\n  - Nested structures to Map\n  - Collection to Object[]\n  - Number/String/bytebuffer to single value\n2. All extractors now support extracting all fields if fieldsToRead is null/empty (issue #5677). This support was\n   added to ORCRecordExtractor, ThriftRecordExtractor, ProtoBufRecordExtractor, and CSVRecordRecord.\n3. Extractor Util Cleanup:\n     There were duplicate implementations for extractors converters across RecordReaderUtils, JsonRecordExtractorUtils,\n     and AvroUtils. This PR adds a new method, \u201cObject convert(Object value)\u201d, to the RecordExtractor interface, as\n     this is a method that all extractors should implement to convert each field of the file format. A new abstract\n     class was created that extends RecordExtractor to contain the repeated logic across RecordReaderUtils,\n     JsonRecordExtractorUtils, and AvroUtils. The abstract class also defines the common methods for recursively\n     handling maps, collections, records and single values."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2c4a779e71e3d63d0bb18acf98b4ee5f730d3d0", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/d2c4a779e71e3d63d0bb18acf98b4ee5f730d3d0", "committedDate": "2020-10-12T05:13:50Z", "message": "Removed javax annotation from Thrift autogenerated Java files to be complaint with JDK11"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/e1b352eb9c72d7cc9780e9953a13cb2db2248604", "committedDate": "2020-10-12T05:13:50Z", "message": "Changed name of AbstractDefaultRecordExtractor -> BaseRecordExtractor. Also removed unecessary generic type added to RecordExtractor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afa97cf21dafd8d3ea1136b4de85ed27271b7ec1", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/afa97cf21dafd8d3ea1136b4de85ed27271b7ec1", "committedDate": "2020-10-12T05:13:51Z", "message": "Removing the use of lambda expressions when extracting all fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "522005d39776d495a3427d60134bfde442c3c11a", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/522005d39776d495a3427d60134bfde442c3c11a", "committedDate": "2020-10-12T05:13:51Z", "message": "Checking for null values before calling extractor convert. Also re-ordering the sequence of checks to be collection -> map -> record -> single-value in ORCRecordReader to be consistent with the other extractors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de8ad5e223e40aedec88ab8eab3a955e949c0b2e", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/de8ad5e223e40aedec88ab8eab3a955e949c0b2e", "committedDate": "2020-10-12T05:13:52Z", "message": "Made handling of null map keys/values consistent with multi-value. Added documentation for the value passed to the map, multivalue, and record converters."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MTIyNjgy", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-507122682", "createdAt": "2020-10-13T07:01:09Z", "commit": {"oid": "de8ad5e223e40aedec88ab8eab3a955e949c0b2e"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f528abdce161366cdc728e4032f2277463d26e14", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/f528abdce161366cdc728e4032f2277463d26e14", "committedDate": "2020-10-14T06:00:47Z", "message": "Move read all fields responsibility from CSVRecordReader to CSVRecordExtractor. Also making CSVRecordExtractor extend BaseRecordExtractor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0Mjg2", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-509874286", "createdAt": "2020-10-15T23:22:56Z", "commit": {"oid": "f528abdce161366cdc728e4032f2277463d26e14"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMzoyMjo1NlrOHie0pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMzoyODoyNlrOHie7Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkxODYyOQ==", "bodyText": "Shall we add some comments here about the behavior of the empty string?", "url": "https://github.com/apache/pinot/pull/6046#discussion_r505918629", "createdAt": "2020-10-15T23:22:56Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   *\n+   * @param value should be verified to be a record type prior to calling this method as it will be handled with this\n+   *              assumption\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   *\n+   * @param value should be verified to be a Collection type prior to calling this method as it will be casted\n+   *              to a Collection without checking\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f528abdce161366cdc728e4032f2277463d26e14"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMDMxOQ==", "bodyText": "We should also preserve byte[]\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (value instanceof Number) {\n          \n          \n            \n                if (value instanceof Number || value instanceof byte[]) {", "url": "https://github.com/apache/pinot/pull/6046#discussion_r505920319", "createdAt": "2020-10-15T23:28:26Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   *\n+   * @param value should be verified to be a record type prior to calling this method as it will be handled with this\n+   *              assumption\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   *\n+   * @param value should be verified to be a Collection type prior to calling this method as it will be casted\n+   *              to a Collection without checking\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   *\n+   * @param value should be verified to be a Map type prior to calling this method as it will be casted to a Map\n+   *              without checking\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map<Object, Object> map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Map.Entry<Object, Object> entry : map.entrySet()) {\n+      Object mapKey = entry.getKey();\n+      Object mapValue = entry.getValue();\n+      if (mapKey != null) {\n+        Object convertedMapValue = null;\n+        if (mapValue != null) {\n+          convertedMapValue = convert(mapValue);\n+        }\n+\n+        if (convertedMapValue != null) {\n+          convertedMap.put(convertSingleValue(entry.getKey()), convertedMapValue);\n+        }\n+      }\n+    }\n+\n+    if (convertedMap.isEmpty()) {\n+      return null;\n+    }\n+\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values.\n+   */\n+  protected Object convertSingleValue(Object value) {\n+    if (value instanceof ByteBuffer) {\n+      ByteBuffer byteBufferValue = (ByteBuffer) value;\n+\n+      // Use byteBufferValue.remaining() instead of byteBufferValue.capacity() so that it still works when buffer is\n+      // over-sized\n+      byte[] bytesValue = new byte[byteBufferValue.remaining()];\n+      byteBufferValue.get(bytesValue);\n+      return bytesValue;\n+    }\n+    if (value instanceof Number) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f528abdce161366cdc728e4032f2277463d26e14"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd6618924809944ed92619fccef230ab1967c439", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/bd6618924809944ed92619fccef230ab1967c439", "committedDate": "2020-10-16T05:01:22Z", "message": "Adding comment for how empty string is handled for multivalues. Also preserving byte[] in single value conversion."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjk3MzQz", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-510697343", "createdAt": "2020-10-16T18:09:07Z", "commit": {"oid": "bd6618924809944ed92619fccef230ab1967c439"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDkyNDI3", "url": "https://github.com/apache/pinot/pull/6046#pullrequestreview-512092427", "createdAt": "2020-10-19T19:29:35Z", "commit": {"oid": "bd6618924809944ed92619fccef230ab1967c439"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 93, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}