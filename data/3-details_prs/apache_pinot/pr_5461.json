{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0Mzk4NTgw", "number": 5461, "title": "Adding Support for SQL CASE Statement", "bodyText": "Description\nAdding Support for SQL CASE Statement\nCASE\n    WHEN condition1 THEN result1\n    WHEN condition2 THEN result2\n    WHEN conditionN THEN resultN\n    ELSE result\nEND;\n\nMajor Changes\n\nAdding SQL Parsing logic for CASE Statement in CalciteSQLParser. Note that the query syntax is not further supported in PQL.\nAdding BinaryOperatorTransformFunctions for (=, <>, >, >=, <, <=)\nModeled CASE as a TransformFunction takes N conditions, N+1 results as arguments.\n\ncondition is a BinaryOperatorTransformFunction,\nresult is a TransformFunction.\n\n\n\nSample queries:\nSELECT\n    CASE\n      WHEN price > 30 THEN 3\n      WHEN price > 20 THEN 2\n      WHEN price > 10 THEN 1\n      ELSE 0\n    END AS price_category \nFROM\n    myTable\n\nSELECT\n  SUM(\n    CASE\n      WHEN price > 30 THEN 30\n      WHEN price > 20 THEN 20\n      WHEN price > 10 THEN 10\n      ELSE 0\n    END) AS weighted_price\nFROM\n    myTable\n\nRelease Notes\nAdding Support for SQL CASE Statement", "createdAt": "2020-05-28T10:35:37Z", "url": "https://github.com/apache/pinot/pull/5461", "merged": true, "mergeCommit": {"oid": "b3833737bb5a45f350bec18bb28c753378c8e528"}, "closed": true, "closedAt": "2020-06-10T08:12:39Z", "author": {"login": "xiangfu0"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclsDuHABqjMzODIzMjA3NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpzBBTgBqjM0Mjc5MDQ2Mzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e7d64f82cfc51fda4840dc17aa94bd7d0d79dbb", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/3e7d64f82cfc51fda4840dc17aa94bd7d0d79dbb", "committedDate": "2020-05-28T10:35:19Z", "message": "Adding transform function support for case-when-else"}, "afterCommit": {"oid": "ceef9615ad511ce320343c77568db49e0eec5cc5", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/ceef9615ad511ce320343c77568db49e0eec5cc5", "committedDate": "2020-05-28T11:21:02Z", "message": "Adding transform function support for case-when-else"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ceef9615ad511ce320343c77568db49e0eec5cc5", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/ceef9615ad511ce320343c77568db49e0eec5cc5", "committedDate": "2020-05-28T11:21:02Z", "message": "Adding transform function support for case-when-else"}, "afterCommit": {"oid": "fbace8bc8959c3dae7405c08b893816a7ad9ae1f", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/fbace8bc8959c3dae7405c08b893816a7ad9ae1f", "committedDate": "2020-05-28T11:21:51Z", "message": "Adding transform function support for case-when-else"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fbace8bc8959c3dae7405c08b893816a7ad9ae1f", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/fbace8bc8959c3dae7405c08b893816a7ad9ae1f", "committedDate": "2020-05-28T11:21:51Z", "message": "Adding transform function support for case-when-else"}, "afterCommit": {"oid": "5667776b055edaa9ae0850d6fbb740a3742ad6ef", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/5667776b055edaa9ae0850d6fbb740a3742ad6ef", "committedDate": "2020-05-28T17:23:23Z", "message": "Adding transform function support for case-when-else"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTM5ODcw", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-420539870", "createdAt": "2020-05-28T22:37:46Z", "commit": {"oid": "fbace8bc8959c3dae7405c08b893816a7ad9ae1f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjozOToxMFrOGcJG-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjozOTo1OFrOGcJIEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MjU1Mw==", "bodyText": "we should have two separate switch statements for left and right transform functions right?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432162553", "createdAt": "2020-05-28T22:39:10Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ *\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() != 2) {\n+      throw new IllegalArgumentException(\"Exact 2 arguments are required for greater transform function\");\n+    }\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    FieldSpec.DataType dataType = _leftTransformFunction.getResultMetadata().getDataType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5667776b055edaa9ae0850d6fbb740a3742ad6ef"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MjgzMg==", "bodyText": "also, check that the return types are comparable, for e.g. if one returns string and other is int, we should throw exception", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432162832", "createdAt": "2020-05-28T22:39:58Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ *\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() != 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5667776b055edaa9ae0850d6fbb740a3742ad6ef"}, "originalPosition": 45}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5667776b055edaa9ae0850d6fbb740a3742ad6ef", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/5667776b055edaa9ae0850d6fbb740a3742ad6ef", "committedDate": "2020-05-28T17:23:23Z", "message": "Adding transform function support for case-when-else"}, "afterCommit": {"oid": "385a8b8756699b0ee739e6a8c1f74f617d68ebb1", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/385a8b8756699b0ee739e6a8c1f74f617d68ebb1", "committedDate": "2020-05-29T07:46:12Z", "message": "Adding transform function support for case-when-else"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjI0MDk3", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-421224097", "createdAt": "2020-05-29T19:23:48Z", "commit": {"oid": "385a8b8756699b0ee739e6a8c1f74f617d68ebb1"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOToyMzo0OVrOGcpNcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOToyMzo0OVrOGcpNcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4ODQ5Nw==", "bodyText": "we want to make add a validation that none of them are agg functions since current implementation only handles transform functions", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432688497", "createdAt": "2020-05-29T19:23:49Z", "author": {"login": "kishoreg"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -610,6 +611,25 @@ private static Expression toExpression(SqlNode node) {\n         }\n         asFuncExpr.getFunctionCall().addToOperands(RequestUtils.getIdentifierExpression(aliasName));\n         return asFuncExpr;\n+      case CASE:\n+        // CASE WHEN Statement is model as a function with variable length parameters.\n+        // Assume N is number of WHEN Statements, total number of parameters is (2 * N + 1).\n+        // - N: Convert each WHEN Statement into a function Expression;\n+        // - N: Convert each THEN Statement into an Expression;\n+        // - 1: Convert ELSE Statement into an Expression.\n+        SqlCase caseSqlNode = (SqlCase) node;\n+        SqlNodeList whenOperands = caseSqlNode.getWhenOperands();\n+        SqlNodeList thenOperands = caseSqlNode.getThenOperands();\n+        SqlNode elseOperand = caseSqlNode.getElseOperand();\n+        Expression caseFuncExpr = RequestUtils.getFunctionExpression(SqlKind.CASE.name());\n+        for (SqlNode whenSqlNode : whenOperands.getList()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385a8b8756699b0ee739e6a8c1f74f617d68ebb1"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjIxOTcy", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-423221972", "createdAt": "2020-06-03T05:10:19Z", "commit": {"oid": "8e0051385fb824ae5e169439760086620d3ac2ca"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNToxMDoxOVrOGeMPfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNToyMjowOVrOGeMb8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMTAzNg==", "bodyText": "Any reason to not use Preconditions.checkArgument()?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434311036", "createdAt": "2020-06-03T05:10:19Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    if (arguments.size() != 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0051385fb824ae5e169439760086620d3ac2ca"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMjEzNQ==", "bodyText": "Isn't this as simple as:\nif (leftType == BYTES || rightType == BYTES) { Preconditions.checkState(leftType == BYTES && rightType == BYTES) }", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434312135", "createdAt": "2020-06-03T05:14:27Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    if (arguments.size() != 2) {\n+      throw new IllegalArgumentException(\"Exact 2 arguments are required for binary operator transform function\");\n+    }\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    switch (_leftDataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0051385fb824ae5e169439760086620d3ac2ca"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMzA1MQ==", "bodyText": "Is the Transform function expected to treat operands as numbers and not comparable strings?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434313051", "createdAt": "2020-06-03T05:17:48Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    if (arguments.size() != 2) {\n+      throw new IllegalArgumentException(\"Exact 2 arguments are required for binary operator transform function\");\n+    }\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    switch (_leftDataType) {\n+      case INT:\n+      case LONG:\n+      case FLOAT:\n+      case DOUBLE:\n+      case STRING:\n+        switch (_rightDataType) {\n+          case INT:\n+          case LONG:\n+          case FLOAT:\n+          case DOUBLE:\n+          case STRING:\n+            break;\n+          default:\n+            throw new IllegalStateException(String.format(\n+                \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+                _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+        }\n+        break;\n+      case BYTES:\n+        if (_rightDataType != FieldSpec.DataType.BYTES) {\n+          throw new IllegalStateException(String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(String.format(\n+            \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+            _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));\n+            }\n+            break;\n+          case LONG:\n+            long[] rightLongValues = _rightTransformFunction.transformToLongValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Long.compare(leftIntValues[i], rightLongValues[i]));\n+            }\n+            break;\n+          case FLOAT:\n+            float[] rightFloatValues = _rightTransformFunction.transformToFloatValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Double.compare(leftIntValues[i], rightFloatValues[i]));\n+            }\n+            break;\n+          case DOUBLE:\n+            double[] rightDoubleValues = _rightTransformFunction.transformToDoubleValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Double.compare(leftIntValues[i], rightDoubleValues[i]));\n+            }\n+            break;\n+          case STRING:\n+            String[] rightStringValues = _rightTransformFunction.transformToStringValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(\n+                  BigDecimal.valueOf(leftIntValues[i]).compareTo(new BigDecimal(rightStringValues[i])));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0051385fb824ae5e169439760086620d3ac2ca"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxNDIyNA==", "bodyText": "The NxN combination makes me wonder if the code explosion is worth the performance gain over using non primitive objects temporarily? Will the usage be in the aggr/group-by path?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434314224", "createdAt": "2020-06-03T05:22:09Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    if (arguments.size() != 2) {\n+      throw new IllegalArgumentException(\"Exact 2 arguments are required for binary operator transform function\");\n+    }\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    switch (_leftDataType) {\n+      case INT:\n+      case LONG:\n+      case FLOAT:\n+      case DOUBLE:\n+      case STRING:\n+        switch (_rightDataType) {\n+          case INT:\n+          case LONG:\n+          case FLOAT:\n+          case DOUBLE:\n+          case STRING:\n+            break;\n+          default:\n+            throw new IllegalStateException(String.format(\n+                \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+                _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+        }\n+        break;\n+      case BYTES:\n+        if (_rightDataType != FieldSpec.DataType.BYTES) {\n+          throw new IllegalStateException(String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(String.format(\n+            \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+            _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0051385fb824ae5e169439760086620d3ac2ca"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQyOTkw", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425042990", "createdAt": "2020-06-05T07:02:55Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMjo1NVrOGfiqeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMjo1NVrOGfiqeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNjk2OA==", "bodyText": "Can THEN part itself have a CASE statement or we can assume they will always be literal expressions?\n\n\nRight now we are only supporting as part of SELECT list?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435726968", "createdAt": "2020-06-05T07:02:55Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -610,6 +611,40 @@ private static Expression toExpression(SqlNode node) {\n         }\n         asFuncExpr.getFunctionCall().addToOperands(RequestUtils.getIdentifierExpression(aliasName));\n         return asFuncExpr;\n+      case CASE:\n+        // CASE WHEN Statement is model as a function with variable length parameters.\n+        // Assume N is number of WHEN Statements, total number of parameters is (2 * N + 1).\n+        // - N: Convert each WHEN Statement into a function Expression;\n+        // - N: Convert each THEN Statement into an Expression;\n+        // - 1: Convert ELSE Statement into an Expression.\n+        SqlCase caseSqlNode = (SqlCase) node;\n+        SqlNodeList whenOperands = caseSqlNode.getWhenOperands();\n+        SqlNodeList thenOperands = caseSqlNode.getThenOperands();\n+        SqlNode elseOperand = caseSqlNode.getElseOperand();\n+        Expression caseFuncExpr = RequestUtils.getFunctionExpression(SqlKind.CASE.name());\n+        for (SqlNode whenSqlNode : whenOperands.getList()) {\n+          Expression whenExpression = toExpression(whenSqlNode);\n+          if (isAggregateExpression(whenExpression)) {\n+            throw new SqlCompilationException(\n+                \"Aggregation functions inside WHEN Clause is not supported - \" + whenSqlNode);\n+          }\n+          caseFuncExpr.getFunctionCall().addToOperands(whenExpression);\n+        }\n+        for (SqlNode thenSqlNode : thenOperands.getList()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQzMDQ1", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425043045", "createdAt": "2020-06-05T07:03:02Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzowMlrOGfiqnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzowMlrOGfiqnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzAwNw==", "bodyText": "IIUC, this is used to model the WHEN part as a function expression (transform function)?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727007", "createdAt": "2020-06-05T07:03:02Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQzMDg5", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425043089", "createdAt": "2020-06-05T07:03:08Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzowOFrOGfiqwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzowOFrOGfiqwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA0MA==", "bodyText": "If we can force left type is same as right type, we can get rid of switch on the right side. For example:\nWHEN price > 30\nif price is of type LONG, we typecast 30 to Long and accordingly create the literal transform function for it. So, we need switch only on the left side type. Right?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727040", "createdAt": "2020-06-05T07:03:08Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQzMTE3", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425043117", "createdAt": "2020-06-05T07:03:12Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzoxMlrOGfiq0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzoxMlrOGfiq0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA1Ng==", "bodyText": "Generally we should do this what databases actually do -- generate code at runtime for the exact types to avoid the interpretation overhead of gigantic switch blocks.\nSince we don't have that yet, may be we can consider (not necessarily in this PR), hand-writing type specific versions of this  -- IntBinaryOperatorTransformFunction, LongBinaryOperatorTransformFunction so that during execution there are minimal (probably none) branches and there is no interpretation overhead at the expense of duplicate code ?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727056", "createdAt": "2020-06-05T07:03:12Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQzMTky", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425043192", "createdAt": "2020-06-05T07:03:22Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzoyMlrOGfirDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzoyMlrOGfirDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzExOA==", "bodyText": "Can we say that for now THEN will always be a LiteralTransformFunction?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727118", "createdAt": "2020-06-05T07:03:22Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQzMjQ2", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425043246", "createdAt": "2020-06-05T07:03:27Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzoyN1rOGfirQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzoyN1rOGfirQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzE2OQ==", "bodyText": "So the size of this array is _whenStatements.size() + 1 ? If so, can we assert for this?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727169", "createdAt": "2020-06-05T07:03:27Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQzMjk2", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425043296", "createdAt": "2020-06-05T07:03:33Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzozM1rOGfirag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzozM1rOGfirag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzIxMA==", "bodyText": "So this is gathering the bitmap by invoking the BinaryOperatorTransformFunction?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727210", "createdAt": "2020-06-05T07:03:33Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    return new TransformResultMetadata(dataType, true, false);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _resultMetadata;\n+  }\n+\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    int[] selected = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 185}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQzMzYw", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425043360", "createdAt": "2020-06-05T07:03:40Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzo0MVrOGfirlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzo0MVrOGfirlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzI1NA==", "bodyText": "I am not sure why we need to have types here. If the THEN is a literal expression of type string (the value itself could be numerical), then we are always  going to project string values. Why do we need to run over types here?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727254", "createdAt": "2020-06-05T07:03:41Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    return new TransformResultMetadata(dataType, true, false);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _resultMetadata;\n+  }\n+\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    int[] selected = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      TransformFunction transformFunction = _whenStatements.get(i);\n+      int[] conditions = transformFunction.transformToIntValuesSV(projectionBlock);\n+      for (int j = 0; j < conditions.length; j++) {\n+        if (selected[j] == 0 && conditions[j] == 1) {\n+          selected[j] = i + 1;\n+        }\n+      }\n+    }\n+    return selected;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    int[] results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      switch (dataType) {\n+        case INT:\n+          int[] evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalInts[j];\n+            }\n+          }\n+          break;\n+        case LONG:\n+          long[] evalLongs = transformFunction.transformToLongValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (int) evalLongs[j];\n+            }\n+          }\n+          break;\n+        case FLOAT:\n+          float[] evalFloats = transformFunction.transformToFloatValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (int) evalFloats[j];\n+            }\n+          }\n+          break;\n+        case DOUBLE:\n+          double[] evalDoubles = transformFunction.transformToDoubleValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (int) evalDoubles[j];\n+            }\n+          }\n+          break;\n+        case STRING:\n+          String[] evalStrings = transformFunction.transformToStringValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = new BigDecimal(evalStrings[i]).intValue();\n+            }\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(String\n+              .format(\"Cannot convert result type [%s] to [INT] for transform function [%s]\", dataType,\n+                  transformFunction));\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public long[] transformToLongValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    long[] results = new long[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      switch (dataType) {\n+        case INT:\n+          int[] evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalInts[j];\n+            }\n+          }\n+          break;\n+        case LONG:\n+          long[] evalLongs = transformFunction.transformToLongValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalLongs[j];\n+            }\n+          }\n+          break;\n+        case FLOAT:\n+          float[] evalFloats = transformFunction.transformToFloatValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (long) evalFloats[j];\n+            }\n+          }\n+          break;\n+        case DOUBLE:\n+          double[] evalDoubles = transformFunction.transformToDoubleValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (long) evalDoubles[j];\n+            }\n+          }\n+          break;\n+        case STRING:\n+          String[] evalStrings = transformFunction.transformToStringValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = new BigDecimal(evalStrings[i]).longValue();\n+            }\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(String\n+              .format(\"Cannot convert result type [%s] to [LONG] for transform function [%s]\", dataType,\n+                  transformFunction));\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public float[] transformToFloatValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    float[] results = new float[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      switch (dataType) {\n+        case INT:\n+          int[] evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalInts[j];\n+            }\n+          }\n+          break;\n+        case LONG:\n+          long[] evalLongs = transformFunction.transformToLongValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalLongs[j];\n+            }\n+          }\n+          break;\n+        case FLOAT:\n+          float[] evalFloats = transformFunction.transformToFloatValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalFloats[j];\n+            }\n+          }\n+          break;\n+        case DOUBLE:\n+          double[] evalDoubles = transformFunction.transformToDoubleValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (float) evalDoubles[j];\n+            }\n+          }\n+          break;\n+        case STRING:\n+          String[] evalStrings = transformFunction.transformToStringValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = new BigDecimal(evalStrings[i]).floatValue();\n+            }\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(String\n+              .format(\"Cannot convert result type [%s] to [FLOAT] for transform function [%s]\", dataType,\n+                  transformFunction));\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    double[] results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      switch (dataType) {\n+        case INT:\n+          int[] evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalInts[j];\n+            }\n+          }\n+          break;\n+        case LONG:\n+          long[] evalLongs = transformFunction.transformToLongValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalLongs[j];\n+            }\n+          }\n+          break;\n+        case FLOAT:\n+          float[] evalFloats = transformFunction.transformToFloatValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalFloats[j];\n+            }\n+          }\n+          break;\n+        case DOUBLE:\n+          double[] evalDoubles = transformFunction.transformToDoubleValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalDoubles[j];\n+            }\n+          }\n+          break;\n+        case STRING:\n+          String[] evalStrings = transformFunction.transformToStringValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = new BigDecimal(evalStrings[i]).doubleValue();\n+            }\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(String\n+              .format(\"Cannot convert result type [%s] to [DOUBLE] for transform function [%s]\", dataType,\n+                  transformFunction));\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 427}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDQzNTE0", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425043514", "createdAt": "2020-06-05T07:03:58Z", "commit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzo1OFrOGfisBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzowMzo1OFrOGfisBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzM2NQ==", "bodyText": "We can make this part of the base class?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727365", "createdAt": "2020-06-05T07:03:58Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LessThanOrEqualTransformFunction.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.TransformFunctionType;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+\n+\n+/**\n+ * The <code>GreaterThanOrEqualTransformFunction</code> extends <code>BinaryOperatorTransformFunction</code> to\n+ * implement the binary operator(<=).\n+ *\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ *\n+ * SQL Syntax:\n+ *    columnA <= 12\n+ *    columnA <= 12.0\n+ *    columnA <= 'fooBar'\n+ *\n+ * Sample Usage:\n+ *    LESS_THAN_OR_EQUAL(columnA, 12)\n+ *    LESS_THAN_OR_EQUAL(columnA, 12.0)\n+ *    LESS_THAN_OR_EQUAL(columnA, 'fooBar')\n+ *\n+ */\n+public class LessThanOrEqualTransformFunction extends BinaryOperatorTransformFunction {\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    super.init(arguments, dataSourceMap);\n+  }\n+\n+  @Override\n+  int getBinaryFuncResult(int result) {\n+    return (result <= 0) ? 1 : 0;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return TransformFunctionType.LESS_THAN_OR_EQUAL.getName();\n+  }\n+\n+  @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 62}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df4ab4a18781cb45293ac572422a795f754d8c95", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/df4ab4a18781cb45293ac572422a795f754d8c95", "committedDate": "2020-06-05T08:08:05Z", "message": "Address comments"}, "afterCommit": {"oid": "6fadc02e79034e90954bd009692ba2ff727ee40d", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/6fadc02e79034e90954bd009692ba2ff727ee40d", "committedDate": "2020-06-05T08:08:21Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6fadc02e79034e90954bd009692ba2ff727ee40d", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/6fadc02e79034e90954bd009692ba2ff727ee40d", "committedDate": "2020-06-05T08:08:21Z", "message": "Address comments"}, "afterCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/f793defa49d562c5cea5fc0ecd0074d3c4380377", "committedDate": "2020-06-05T09:25:29Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTMxNzI5", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-425531729", "createdAt": "2020-06-05T18:28:10Z", "commit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODoyODoxMFrOGf5Ecg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyNzozMFrOGf6uPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5NDA2Ng==", "bodyText": "@fx19880617 The TransformFunction itself can handle the data type conversion (check BaseTransformFunction which is the middle layer you mentioned). You can use the left & right data type to decide the type of data to transform and directly compare.", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436094066", "createdAt": "2020-06-05T18:28:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA1Ng=="}, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5NjczNA==", "bodyText": "Actually this is redundant check because you already check the number of arguments is odd", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436096734", "createdAt": "2020-06-05T18:33:23Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5ODk1Ng==", "bodyText": "(nit) no need to pass in argument", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436098956", "createdAt": "2020-06-05T18:37:48Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMDUyOQ==", "bodyText": "We can support MV right? I think we can add limitation of not supporting mixed SV and MV? Or for now not allowing MV at all? Add some comments and add TODO maybe?", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436100529", "createdAt": "2020-06-05T18:41:14Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMTkwOQ==", "bodyText": "Also, the check for the first statement is missing", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436101909", "createdAt": "2020-06-05T18:44:08Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMDUyOQ=="}, "originalCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMjM5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          dataType = resultMetadata.getDataType();\n          \n          \n            \n                          dataType = FieldSpec.DataType.STRING;", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436102394", "createdAt": "2020-06-05T18:45:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNDg3Ng==", "bodyText": "+1 for some comments. The algorithm is smart, but not very intuitive", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436104876", "createdAt": "2020-06-05T18:50:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    return new TransformResultMetadata(dataType, true, false);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _resultMetadata;\n+  }\n+\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    int[] selected = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzIxMA=="}, "originalCommit": {"oid": "4fea059583332a723e215db327346b78f79cbb3a"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjc0NQ==", "bodyText": "Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436106745", "createdAt": "2020-06-05T18:54:27Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    return new TransformResultMetadata(dataType, true, false);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _resultMetadata;\n+  }\n+\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    int[] selected = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      TransformFunction transformFunction = _whenStatements.get(i);\n+      int[] conditions = transformFunction.transformToIntValuesSV(projectionBlock);\n+      for (int j = 0; j < conditions.length; j++) {\n+        if (selected[j] == 0 && conditions[j] == 1) {\n+          selected[j] = i + 1;\n+        }\n+      }\n+    }\n+    return selected;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwOTkxOQ==", "bodyText": "Also, why do we have compare here? It will make the BinaryOperator not suitable for other Functions other than comparison.\nFor performance concern, we should pass the array into the getBinaryFuncResult, where you can have one getBinaryFuncResult for each data type.", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436109919", "createdAt": "2020-06-05T19:01:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    fillResultArray(projectionBlock);\n+    return _results;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMTE0OQ==", "bodyText": "Can we follow the same convention as in the ArrayCopyUtils so that the behavior is consistent everywhere? (Use Integer.parseInt, Long.parseLong, Float.parseFloat, Double.parseDouble, BytesUtils.toBytes)\nIf the String is not of the target value format, the current behavior is to throw exception.\nFor this PR, I don't think you need to change this class because the binary operator first check the data type and always fetch String value from Literal. Ideally it should check for Literal and call getLiteral()", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436121149", "createdAt": "2020-06-05T19:27:30Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LiteralTransformFunction.java", "diffHunk": "@@ -75,22 +82,40 @@ public Dictionary getDictionary() {\n \n   @Override\n   public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n-    throw new UnsupportedOperationException();\n+    if (_intResult == null) {\n+      _intResult = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+      Arrays.fill(_intResult, Double.valueOf(_literal).intValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377"}, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a6a68ea3c3614f05014923f7d9952ebd7cb29bcb", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/a6a68ea3c3614f05014923f7d9952ebd7cb29bcb", "committedDate": "2020-06-06T05:42:38Z", "message": "Address comments"}, "afterCommit": {"oid": "ff53c75284d19721723ada88b5bb1781ad719f46", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/ff53c75284d19721723ada88b5bb1781ad719f46", "committedDate": "2020-06-06T05:54:26Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ff53c75284d19721723ada88b5bb1781ad719f46", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/ff53c75284d19721723ada88b5bb1781ad719f46", "committedDate": "2020-06-06T05:54:26Z", "message": "Address comments"}, "afterCommit": {"oid": "1df11d2e796e3341d554a864a5f61223e713a251", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/1df11d2e796e3341d554a864a5f61223e713a251", "committedDate": "2020-06-06T06:22:15Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1df11d2e796e3341d554a864a5f61223e713a251", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/1df11d2e796e3341d554a864a5f61223e713a251", "committedDate": "2020-06-06T06:22:15Z", "message": "Address comments"}, "afterCommit": {"oid": "d61d9505714bb7e2a6fa7d5a2244bc4c1df10396", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/d61d9505714bb7e2a6fa7d5a2244bc4c1df10396", "committedDate": "2020-06-06T20:18:02Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d61d9505714bb7e2a6fa7d5a2244bc4c1df10396", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/d61d9505714bb7e2a6fa7d5a2244bc4c1df10396", "committedDate": "2020-06-06T20:18:02Z", "message": "Address comments"}, "afterCommit": {"oid": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "committedDate": "2020-06-07T03:00:41Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDk4NjM4", "url": "https://github.com/apache/pinot/pull/5461#pullrequestreview-426498638", "createdAt": "2020-06-08T18:20:17Z", "commit": {"oid": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoyMDoxN1rOGgqgZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODo0MToyMlrOGgrNqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNDAzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          _results[i] = getBinaryFuncResult(Double.compare(leftIntValues[i], rightFloatValues[i]));\n          \n          \n            \n                          _results[i] = getBinaryFuncResult(Float.compare(leftIntValues[i], rightFloatValues[i]));", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436904039", "createdAt": "2020-06-08T18:20:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    fillResultArray(projectionBlock);\n+    return _results;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));\n+            }\n+            break;\n+          case LONG:\n+            long[] rightLongValues = _rightTransformFunction.transformToLongValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Long.compare(leftIntValues[i], rightLongValues[i]));\n+            }\n+            break;\n+          case FLOAT:\n+            float[] rightFloatValues = _rightTransformFunction.transformToFloatValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Double.compare(leftIntValues[i], rightFloatValues[i]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzQ3Nw==", "bodyText": "(nit) Readability\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (resultMetadata.isSingleValue() ^ isSingleValueField) {\n          \n          \n            \n                  if (resultMetadata.isSingleValue() != isSingleValueField) {", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436907477", "createdAt": "2020-06-08T18:26:20Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.core.util.ArrayCopyUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+  private int[] _selectedResults;\n+  private int[] _intResults;\n+  private long[] _longResults;\n+  private float[] _floatResults;\n+  private double[] _doubleResults;\n+  private String[] _stringResults;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    getResultMetadata();\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    if (_resultMetadata != null) {\n+      return _resultMetadata;\n+    }\n+    FieldSpec.DataType dataType = _elseThenStatements.get(0).getResultMetadata().getDataType();\n+    boolean isSingleValueField = _elseThenStatements.get(0).getResultMetadata().isSingleValue();\n+    for (int i = 1; i < _elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = _elseThenStatements.get(i).getResultMetadata();\n+      if (resultMetadata.isSingleValue() ^ isSingleValueField) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTYyNg==", "bodyText": "You don't need to check data type here, but directly call evalInts = transformFunction.transformToIntValuesSV(projectionBlock);. The transformFunction can handle the type casting. Same for other places", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436915626", "createdAt": "2020-06-08T18:41:22Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.core.util.ArrayCopyUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+  private int[] _selectedResults;\n+  private int[] _intResults;\n+  private long[] _longResults;\n+  private float[] _floatResults;\n+  private double[] _doubleResults;\n+  private String[] _stringResults;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    getResultMetadata();\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    if (_resultMetadata != null) {\n+      return _resultMetadata;\n+    }\n+    FieldSpec.DataType dataType = _elseThenStatements.get(0).getResultMetadata().getDataType();\n+    boolean isSingleValueField = _elseThenStatements.get(0).getResultMetadata().isSingleValue();\n+    for (int i = 1; i < _elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = _elseThenStatements.get(i).getResultMetadata();\n+      if (resultMetadata.isSingleValue() ^ isSingleValueField) {\n+        throw new IllegalStateException(\n+            String.format(\"Mixed Single/Multi Value results in expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    _resultMetadata = new TransformResultMetadata(dataType, true, false);\n+    return _resultMetadata;\n+  }\n+\n+  /**\n+   * Evaluate the ProjectionBlock for the WHEN statements, returns an array with the\n+   * index(1 to N) of matched WHEN clause, 0 means nothing matched, so go to ELSE.\n+   *\n+   * @param projectionBlock\n+   * @return\n+   */\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    if (_selectedResults == null) {\n+      _selectedResults = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    } else {\n+      Arrays.fill(_selectedResults, 0);\n+    }\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      TransformFunction transformFunction = _whenStatements.get(i);\n+      int[] conditions = transformFunction.transformToIntValuesSV(projectionBlock);\n+      for (int j = 0; j < conditions.length; j++) {\n+        if (_selectedResults[j] == 0 && conditions[j] == 1) {\n+          _selectedResults[j] = i + 1;\n+        }\n+      }\n+    }\n+    return _selectedResults;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    if (_intResults == null) {\n+      _intResults = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      int blockNumDocs = projectionBlock.getNumDocs();\n+      int[] evalInts;\n+      if (dataType == FieldSpec.DataType.INT) {\n+        evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+      } else {\n+        evalInts = new int[blockNumDocs];\n+        switch (dataType) {\n+          case LONG:\n+            ArrayCopyUtils.copy(transformFunction.transformToLongValuesSV(projectionBlock), evalInts, blockNumDocs);\n+            break;\n+          case FLOAT:\n+            ArrayCopyUtils.copy(transformFunction.transformToFloatValuesSV(projectionBlock), evalInts, blockNumDocs);\n+            break;\n+          case DOUBLE:\n+            ArrayCopyUtils.copy(transformFunction.transformToDoubleValuesSV(projectionBlock), evalInts, blockNumDocs);\n+            break;\n+          case STRING:\n+            ArrayCopyUtils.copy(transformFunction.transformToStringValuesSV(projectionBlock), evalInts, blockNumDocs);\n+            break;\n+          default:\n+            throw new IllegalStateException(String\n+                .format(\"Cannot convert result type [%s] to [INT] for transform function [%s]\", dataType,\n+                    transformFunction));\n+        }\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b"}, "originalPosition": 250}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "committedDate": "2020-06-07T03:00:41Z", "message": "Address comments"}, "afterCommit": {"oid": "d6c0ca86ed04eadbd46dac4bd830a0652643be54", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/d6c0ca86ed04eadbd46dac4bd830a0652643be54", "committedDate": "2020-06-09T07:38:41Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6c0ca86ed04eadbd46dac4bd830a0652643be54", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/d6c0ca86ed04eadbd46dac4bd830a0652643be54", "committedDate": "2020-06-09T07:38:41Z", "message": "Address comments"}, "afterCommit": {"oid": "82955f60cac5da0afa8721666e52e54c16330967", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/82955f60cac5da0afa8721666e52e54c16330967", "committedDate": "2020-06-09T18:58:12Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82955f60cac5da0afa8721666e52e54c16330967", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/82955f60cac5da0afa8721666e52e54c16330967", "committedDate": "2020-06-09T18:58:12Z", "message": "Address comments"}, "afterCommit": {"oid": "496c44c4dcb267de09f90cdfcbb018ab40268690", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/496c44c4dcb267de09f90cdfcbb018ab40268690", "committedDate": "2020-06-09T18:58:56Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "012776add381972710d7e4426e242c87a6666bc8", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/012776add381972710d7e4426e242c87a6666bc8", "committedDate": "2020-06-10T04:28:29Z", "message": "update case statement to skip some conditions won't happen"}, "afterCommit": {"oid": "9fbd5899fd40f101b8400f045669fc90ee86913d", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/9fbd5899fd40f101b8400f045669fc90ee86913d", "committedDate": "2020-06-10T04:28:57Z", "message": "update case statement to skip some conditions won't happen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42bf64f27631011da7d748f62463a654848ea709", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/42bf64f27631011da7d748f62463a654848ea709", "committedDate": "2020-06-10T05:43:03Z", "message": "Adding case-when-else sql parsing statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35bbeb4c4776367beabb00de951bdb5c32d27233", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/35bbeb4c4776367beabb00de951bdb5c32d27233", "committedDate": "2020-06-10T05:43:03Z", "message": "Adding transform function support for case-when-else"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f64bec216ade1d56fbb5e45173f8967d3edfe28", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/8f64bec216ade1d56fbb5e45173f8967d3edfe28", "committedDate": "2020-06-10T05:43:03Z", "message": "Checks on then statements result type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5315ce75f81fc7fdecd93b1f8494834e9967199", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/d5315ce75f81fc7fdecd93b1f8494834e9967199", "committedDate": "2020-06-10T05:43:03Z", "message": "Not allowing aggregation functions in case statements for now"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a8ee5e7699455e108841e74a23a4ce3a8cfdaad", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/0a8ee5e7699455e108841e74a23a4ce3a8cfdaad", "committedDate": "2020-06-10T05:43:03Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9ec7fc02e900a960ebe4dc863a986ae1ef99f8", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/1f9ec7fc02e900a960ebe4dc863a986ae1ef99f8", "committedDate": "2020-06-10T05:43:03Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76e91030fe442b01360af3fd5cf07b4b0c166358", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/76e91030fe442b01360af3fd5cf07b4b0c166358", "committedDate": "2020-06-10T05:43:03Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2efaa03b25843b5db0b1fd19292d62da4cd8f2be", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/2efaa03b25843b5db0b1fd19292d62da4cd8f2be", "committedDate": "2020-06-10T05:43:03Z", "message": "update case statement to skip some conditions won't happen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eeccadb5b4b65e6ec528594fbf6302ad6c7da117", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/eeccadb5b4b65e6ec528594fbf6302ad6c7da117", "committedDate": "2020-06-10T05:43:03Z", "message": "Infer literal type in case-when statements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fbd5899fd40f101b8400f045669fc90ee86913d", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/9fbd5899fd40f101b8400f045669fc90ee86913d", "committedDate": "2020-06-10T04:28:57Z", "message": "update case statement to skip some conditions won't happen"}, "afterCommit": {"oid": "eeccadb5b4b65e6ec528594fbf6302ad6c7da117", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/eeccadb5b4b65e6ec528594fbf6302ad6c7da117", "committedDate": "2020-06-10T05:43:03Z", "message": "Infer literal type in case-when statements"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 862, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}