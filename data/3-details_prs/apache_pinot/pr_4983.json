{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyODQ5MjMy", "number": 4983, "title": "Make PQL case insensitive", "bodyText": "This PR will handle remove the restriction that table names and column names in the query must match what is defined in TableConfig and Schema.\nThe idea is to fix the broker request object in the beginning so that the rest of the code does not require any change.\nAdding option to enable this via cluster config enable.case.insensitive.pql\n#4902", "createdAt": "2020-01-14T21:32:50Z", "url": "https://github.com/apache/pinot/pull/4983", "merged": true, "mergeCommit": {"oid": "e46eec3553c33de7ad5b01edbb3c75c62dee12d2"}, "closed": true, "closedAt": "2020-01-21T00:07:56Z", "author": {"login": "kishoreg"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6X1axAH2gAyMzYyODQ5MjMyOjUyYjE0YmZmZGM4NjM2MWQyMDNiOWJkYjNjMmU3NTY0NzUwY2QxODU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8Vr-9AFqTM0NTU3NzkwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "52b14bffdc86361d203b9bdb3c2e7564750cd185", "author": {"user": {"login": "kishoreg", "name": "Kishore Gopalakrishna"}}, "url": "https://github.com/apache/pinot/commit/52b14bffdc86361d203b9bdb3c2e7564750cd185", "committedDate": "2020-01-14T21:28:42Z", "message": "Make PQL case insensitive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0", "author": {"user": {"login": "kishoreg", "name": "Kishore Gopalakrishna"}}, "url": "https://github.com/apache/pinot/commit/99992a2b52f1cfd01b74ddc7f4dfde623def62d0", "committedDate": "2020-01-14T23:28:37Z", "message": "Handling expression in filter clause"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU4ODA3", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342958807", "createdAt": "2020-01-15T02:32:49Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMjo0OVrOFdr0Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMjo0OVrOFdr0Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MDg1MQ==", "bodyText": "I don't understand this if check. FilterQueryMap is flattened and contained all the FilterQuery. We just need to iterate on all these FilterQuery which are stored in \"values\" and that will take care of fixing the column name for the entire tree", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366670851", "createdAt": "2020-01-15T02:32:49Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -335,6 +349,74 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     return brokerResponse;\n   }\n \n+  private void handleCaseSensitivity(BrokerRequest brokerRequest) {\n+    String inputTableName = brokerRequest.getQuerySource().getTableName();\n+    String actualTableName = _tableCache.getActualTableName(inputTableName);\n+    brokerRequest.getQuerySource().setTableName(actualTableName);\n+    //fix columns\n+    if (brokerRequest.getFilterSubQueryMap() != null) {\n+      Collection<FilterQuery> values = brokerRequest.getFilterSubQueryMap().getFilterQueryMap().values();\n+      for (FilterQuery filterQuery : values) {\n+        if (filterQuery.getNestedFilterQueryIdsSize() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU4ODUz", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342958853", "createdAt": "2020-01-15T02:33:00Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzowMFrOFdr0Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzowMFrOFdr0Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MDg4Mg==", "bodyText": "We should recurse for FUNCTION expression to identify the inner column names (IDENTIFIERS) at the leaf level and fix case for them", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366670882", "createdAt": "2020-01-15T02:33:00Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -335,6 +349,74 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     return brokerResponse;\n   }\n \n+  private void handleCaseSensitivity(BrokerRequest brokerRequest) {\n+    String inputTableName = brokerRequest.getQuerySource().getTableName();\n+    String actualTableName = _tableCache.getActualTableName(inputTableName);\n+    brokerRequest.getQuerySource().setTableName(actualTableName);\n+    //fix columns\n+    if (brokerRequest.getFilterSubQueryMap() != null) {\n+      Collection<FilterQuery> values = brokerRequest.getFilterSubQueryMap().getFilterQueryMap().values();\n+      for (FilterQuery filterQuery : values) {\n+        if (filterQuery.getNestedFilterQueryIdsSize() == 0) {\n+          String expression = filterQuery.getColumn();\n+          filterQuery.setColumn(fixColumnNameCase(actualTableName, expression));\n+        }\n+      }\n+    }\n+    if (brokerRequest.isSetAggregationsInfo()) {\n+      for (AggregationInfo info : brokerRequest.getAggregationsInfo()) {\n+        if (info.getAggregationParams() != null && !info.getAggregationType()\n+            .equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n+          String column = info.getAggregationParams().get(FunctionCallAstNode.COLUMN_KEY_IN_AGGREGATION_INFO);\n+          String[] expressions = column.split(FunctionCallAstNode.DISTINCT_MULTI_COLUMN_SEPARATOR);\n+          String[] newExpressions = new String[expressions.length];\n+          for (int i = 0; i < expressions.length; i++) {\n+            String expression = expressions[i];\n+            newExpressions[i] = fixColumnNameCase(actualTableName, expression);\n+          }\n+          String newColumns = StringUtil.join(FunctionCallAstNode.DISTINCT_MULTI_COLUMN_SEPARATOR, newExpressions);\n+          info.getAggregationParams().put(FunctionCallAstNode.COLUMN_KEY_IN_AGGREGATION_INFO, newColumns);\n+        }\n+      }\n+      if (brokerRequest.isSetGroupBy()) {\n+        List<String> expressions = brokerRequest.getGroupBy().getExpressions();\n+        for (int i = 0; i < expressions.size(); i++) {\n+          expressions.set(i, fixColumnNameCase(actualTableName, expressions.get(i)));\n+        }\n+      }\n+    } else {\n+      Selection selection = brokerRequest.getSelections();\n+      List<String> selectionColumns = selection.getSelectionColumns();\n+      for (int i = 0; i < selectionColumns.size(); i++) {\n+        String expression = selectionColumns.get(i);\n+        if (!expression.trim().equalsIgnoreCase(\"*\")) {\n+          selectionColumns.set(i, fixColumnNameCase(actualTableName, expression));\n+        }\n+      }\n+    }\n+  }\n+\n+  private String fixColumnNameCase(String actualTableName, String expression) {\n+    TransformExpressionTree rootExpression = TransformExpressionTree.compileToExpressionTree(expression);\n+    LinkedList<TransformExpressionTree> q = new LinkedList<>();\n+    q.add(rootExpression);\n+    while (!q.isEmpty()) {\n+      TransformExpressionTree expressionTree = q.pop();\n+      switch (expressionTree.getExpressionType()) {\n+        case FUNCTION:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU4ODcx", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342958871", "createdAt": "2020-01-15T02:33:05Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzowNlrOFdr0Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzowNlrOFdr0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MDkwMw==", "bodyText": "Good javadoc describing purpose and usage would be helpful for future readers\nJust to confirm --  There is one instance of TableCache per broker (via BaseBrokerRequestHandler created during broker start) and one instance per controller (created during controller start). Right?", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366670903", "createdAt": "2020-01-15T02:33:06Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/TableCache.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.helix;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.utils.SchemaUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU4OTYw", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342958960", "createdAt": "2020-01-15T02:33:22Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzoyMlrOFdr0eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzoyMlrOFdr0eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MDk2OQ==", "bodyText": "Since we can get the schema name here itself, looks like we don't need the other map in SchemaChangeListener as noted further below in the comment", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366670969", "createdAt": "2020-01-15T02:33:22Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/TableCache.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.helix;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.utils.SchemaUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+\n+\n+public class TableCache {\n+  private static final String PROPERTYSTORE_SCHEMAS_PREFIX = \"/SCHEMAS\";\n+  private static final String PROPERTYSTORE_TABLE_CONFIGS_PREFIX = \"/CONFIGS/TABLE\";\n+\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+  TableConfigChangeListener _tableConfigChangeListener;\n+  SchemaChangeListener _schemaChangeListener;\n+\n+  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore) {\n+    _propertyStore = propertyStore;\n+    _schemaChangeListener = new SchemaChangeListener();\n+    _schemaChangeListener.refresh();\n+    _tableConfigChangeListener = new TableConfigChangeListener();\n+    _tableConfigChangeListener.refresh();\n+  }\n+\n+  public String getActualTableName(String tableName) {\n+    return _tableConfigChangeListener._tableNameMap.getOrDefault(tableName.toLowerCase(), tableName);\n+  }\n+\n+  public String getActualColumnName(String tableName, String columnName) {\n+    String schemaName = _tableConfigChangeListener._table2SchemaConfigMap.get(tableName.toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU4OTcw", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342958970", "createdAt": "2020-01-15T02:33:25Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzoyNVrOFdr0hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzoyNVrOFdr0hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MDk4MA==", "bodyText": "Why do we need tableConfigMap? I don't see it being used", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366670980", "createdAt": "2020-01-15T02:33:25Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/TableCache.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.helix;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.utils.SchemaUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+\n+\n+public class TableCache {\n+  private static final String PROPERTYSTORE_SCHEMAS_PREFIX = \"/SCHEMAS\";\n+  private static final String PROPERTYSTORE_TABLE_CONFIGS_PREFIX = \"/CONFIGS/TABLE\";\n+\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+  TableConfigChangeListener _tableConfigChangeListener;\n+  SchemaChangeListener _schemaChangeListener;\n+\n+  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore) {\n+    _propertyStore = propertyStore;\n+    _schemaChangeListener = new SchemaChangeListener();\n+    _schemaChangeListener.refresh();\n+    _tableConfigChangeListener = new TableConfigChangeListener();\n+    _tableConfigChangeListener.refresh();\n+  }\n+\n+  public String getActualTableName(String tableName) {\n+    return _tableConfigChangeListener._tableNameMap.getOrDefault(tableName.toLowerCase(), tableName);\n+  }\n+\n+  public String getActualColumnName(String tableName, String columnName) {\n+    String schemaName = _tableConfigChangeListener._table2SchemaConfigMap.get(tableName.toLowerCase());\n+    if (schemaName != null) {\n+      return _schemaChangeListener.getColumnName(schemaName, columnName);\n+    }\n+    return columnName;\n+  }\n+\n+  class TableConfigChangeListener implements IZkChildListener, IZkDataListener {\n+\n+    Map<String, TableConfig> _tableConfigMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU4OTg2", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342958986", "createdAt": "2020-01-15T02:33:29Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzoyOVrOFdr0lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzoyOVrOFdr0lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MDk5Nw==", "bodyText": "I don't think this is needed. _schemaColumnMap should be enough.", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366670997", "createdAt": "2020-01-15T02:33:29Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/TableCache.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.helix;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.utils.SchemaUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+\n+\n+public class TableCache {\n+  private static final String PROPERTYSTORE_SCHEMAS_PREFIX = \"/SCHEMAS\";\n+  private static final String PROPERTYSTORE_TABLE_CONFIGS_PREFIX = \"/CONFIGS/TABLE\";\n+\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+  TableConfigChangeListener _tableConfigChangeListener;\n+  SchemaChangeListener _schemaChangeListener;\n+\n+  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore) {\n+    _propertyStore = propertyStore;\n+    _schemaChangeListener = new SchemaChangeListener();\n+    _schemaChangeListener.refresh();\n+    _tableConfigChangeListener = new TableConfigChangeListener();\n+    _tableConfigChangeListener.refresh();\n+  }\n+\n+  public String getActualTableName(String tableName) {\n+    return _tableConfigChangeListener._tableNameMap.getOrDefault(tableName.toLowerCase(), tableName);\n+  }\n+\n+  public String getActualColumnName(String tableName, String columnName) {\n+    String schemaName = _tableConfigChangeListener._table2SchemaConfigMap.get(tableName.toLowerCase());\n+    if (schemaName != null) {\n+      return _schemaChangeListener.getColumnName(schemaName, columnName);\n+    }\n+    return columnName;\n+  }\n+\n+  class TableConfigChangeListener implements IZkChildListener, IZkDataListener {\n+\n+    Map<String, TableConfig> _tableConfigMap = new ConcurrentHashMap<>();\n+    Map<String, String> _tableNameMap = new ConcurrentHashMap<>();\n+    Map<String, String> _table2SchemaConfigMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void refresh() {\n+      try {\n+        //always subscribe first before reading, so that we dont miss any changes\n+        _propertyStore.subscribeChildChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n+        _propertyStore.subscribeDataChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n+        List<ZNRecord> children =\n+            _propertyStore.getChildren(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, null, AccessOption.PERSISTENT);\n+        if (children != null) {\n+          for (ZNRecord znRecord : children) {\n+            try {\n+              TableConfig tableConfig = TableConfig.fromZnRecord(znRecord);\n+              String tableNameWithType = tableConfig.getTableName();\n+              _tableConfigMap.put(tableNameWithType, tableConfig);\n+              String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+              //create case insensitive mapping\n+              _tableNameMap.put(tableNameWithType.toLowerCase(), tableNameWithType);\n+              _tableNameMap.put(rawTableName.toLowerCase(), rawTableName);\n+              //create case insensitive mapping between table name and schemaName\n+              _table2SchemaConfigMap.put(tableNameWithType.toLowerCase(), rawTableName);\n+              _table2SchemaConfigMap.put(rawTableName.toLowerCase(), rawTableName);\n+            } catch (IOException e) {\n+              e.printStackTrace();\n+              //ignore\n+            }\n+          }\n+        }\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        //ignore\n+      }\n+    }\n+\n+    @Override\n+    public void handleChildChange(String s, List<String> list)\n+        throws Exception {\n+      refresh();\n+    }\n+\n+    @Override\n+    public void handleDataChange(String s, Object o)\n+        throws Exception {\n+      refresh();\n+    }\n+\n+    @Override\n+    public void handleDataDeleted(String s)\n+        throws Exception {\n+      refresh();\n+    }\n+  }\n+\n+  class SchemaChangeListener implements IZkChildListener, IZkDataListener {\n+    Map<String, Schema> _schemaMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU5MDA4", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342959008", "createdAt": "2020-01-15T02:33:33Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzozM1rOFdr0pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzozM1rOFdr0pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MTAxMg==", "bodyText": "So if the listener is invoked for a change to a particular table, we are going to go over schema of all the tables to update the map? If so, I think we should handle the callback at a table level.", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366671012", "createdAt": "2020-01-15T02:33:33Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/TableCache.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.helix;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.utils.SchemaUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+\n+\n+public class TableCache {\n+  private static final String PROPERTYSTORE_SCHEMAS_PREFIX = \"/SCHEMAS\";\n+  private static final String PROPERTYSTORE_TABLE_CONFIGS_PREFIX = \"/CONFIGS/TABLE\";\n+\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+  TableConfigChangeListener _tableConfigChangeListener;\n+  SchemaChangeListener _schemaChangeListener;\n+\n+  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore) {\n+    _propertyStore = propertyStore;\n+    _schemaChangeListener = new SchemaChangeListener();\n+    _schemaChangeListener.refresh();\n+    _tableConfigChangeListener = new TableConfigChangeListener();\n+    _tableConfigChangeListener.refresh();\n+  }\n+\n+  public String getActualTableName(String tableName) {\n+    return _tableConfigChangeListener._tableNameMap.getOrDefault(tableName.toLowerCase(), tableName);\n+  }\n+\n+  public String getActualColumnName(String tableName, String columnName) {\n+    String schemaName = _tableConfigChangeListener._table2SchemaConfigMap.get(tableName.toLowerCase());\n+    if (schemaName != null) {\n+      return _schemaChangeListener.getColumnName(schemaName, columnName);\n+    }\n+    return columnName;\n+  }\n+\n+  class TableConfigChangeListener implements IZkChildListener, IZkDataListener {\n+\n+    Map<String, TableConfig> _tableConfigMap = new ConcurrentHashMap<>();\n+    Map<String, String> _tableNameMap = new ConcurrentHashMap<>();\n+    Map<String, String> _table2SchemaConfigMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void refresh() {\n+      try {\n+        //always subscribe first before reading, so that we dont miss any changes\n+        _propertyStore.subscribeChildChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n+        _propertyStore.subscribeDataChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n+        List<ZNRecord> children =\n+            _propertyStore.getChildren(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, null, AccessOption.PERSISTENT);\n+        if (children != null) {\n+          for (ZNRecord znRecord : children) {\n+            try {\n+              TableConfig tableConfig = TableConfig.fromZnRecord(znRecord);\n+              String tableNameWithType = tableConfig.getTableName();\n+              _tableConfigMap.put(tableNameWithType, tableConfig);\n+              String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+              //create case insensitive mapping\n+              _tableNameMap.put(tableNameWithType.toLowerCase(), tableNameWithType);\n+              _tableNameMap.put(rawTableName.toLowerCase(), rawTableName);\n+              //create case insensitive mapping between table name and schemaName\n+              _table2SchemaConfigMap.put(tableNameWithType.toLowerCase(), rawTableName);\n+              _table2SchemaConfigMap.put(rawTableName.toLowerCase(), rawTableName);\n+            } catch (IOException e) {\n+              e.printStackTrace();\n+              //ignore\n+            }\n+          }\n+        }\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        //ignore\n+      }\n+    }\n+\n+    @Override\n+    public void handleChildChange(String s, List<String> list)\n+        throws Exception {\n+      refresh();\n+    }\n+\n+    @Override\n+    public void handleDataChange(String s, Object o)\n+        throws Exception {\n+      refresh();\n+    }\n+\n+    @Override\n+    public void handleDataDeleted(String s)\n+        throws Exception {\n+      refresh();\n+    }\n+  }\n+\n+  class SchemaChangeListener implements IZkChildListener, IZkDataListener {\n+    Map<String, Schema> _schemaMap = new ConcurrentHashMap<>();\n+    Map<String, Map<String, String>> _schemaColumnMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void refresh() {\n+      try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU5MDE4", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342959018", "createdAt": "2020-01-15T02:33:37Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzozN1rOFdr0sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzozN1rOFdr0sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MTAyNg==", "bodyText": "Since the other listener's map is sufficient to first get the schema name, this method and _schemaMap is probably not needed.", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366671026", "createdAt": "2020-01-15T02:33:37Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/TableCache.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.helix;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.utils.SchemaUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+\n+\n+public class TableCache {\n+  private static final String PROPERTYSTORE_SCHEMAS_PREFIX = \"/SCHEMAS\";\n+  private static final String PROPERTYSTORE_TABLE_CONFIGS_PREFIX = \"/CONFIGS/TABLE\";\n+\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+  TableConfigChangeListener _tableConfigChangeListener;\n+  SchemaChangeListener _schemaChangeListener;\n+\n+  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore) {\n+    _propertyStore = propertyStore;\n+    _schemaChangeListener = new SchemaChangeListener();\n+    _schemaChangeListener.refresh();\n+    _tableConfigChangeListener = new TableConfigChangeListener();\n+    _tableConfigChangeListener.refresh();\n+  }\n+\n+  public String getActualTableName(String tableName) {\n+    return _tableConfigChangeListener._tableNameMap.getOrDefault(tableName.toLowerCase(), tableName);\n+  }\n+\n+  public String getActualColumnName(String tableName, String columnName) {\n+    String schemaName = _tableConfigChangeListener._table2SchemaConfigMap.get(tableName.toLowerCase());\n+    if (schemaName != null) {\n+      return _schemaChangeListener.getColumnName(schemaName, columnName);\n+    }\n+    return columnName;\n+  }\n+\n+  class TableConfigChangeListener implements IZkChildListener, IZkDataListener {\n+\n+    Map<String, TableConfig> _tableConfigMap = new ConcurrentHashMap<>();\n+    Map<String, String> _tableNameMap = new ConcurrentHashMap<>();\n+    Map<String, String> _table2SchemaConfigMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void refresh() {\n+      try {\n+        //always subscribe first before reading, so that we dont miss any changes\n+        _propertyStore.subscribeChildChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n+        _propertyStore.subscribeDataChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n+        List<ZNRecord> children =\n+            _propertyStore.getChildren(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, null, AccessOption.PERSISTENT);\n+        if (children != null) {\n+          for (ZNRecord znRecord : children) {\n+            try {\n+              TableConfig tableConfig = TableConfig.fromZnRecord(znRecord);\n+              String tableNameWithType = tableConfig.getTableName();\n+              _tableConfigMap.put(tableNameWithType, tableConfig);\n+              String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+              //create case insensitive mapping\n+              _tableNameMap.put(tableNameWithType.toLowerCase(), tableNameWithType);\n+              _tableNameMap.put(rawTableName.toLowerCase(), rawTableName);\n+              //create case insensitive mapping between table name and schemaName\n+              _table2SchemaConfigMap.put(tableNameWithType.toLowerCase(), rawTableName);\n+              _table2SchemaConfigMap.put(rawTableName.toLowerCase(), rawTableName);\n+            } catch (IOException e) {\n+              e.printStackTrace();\n+              //ignore\n+            }\n+          }\n+        }\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        //ignore\n+      }\n+    }\n+\n+    @Override\n+    public void handleChildChange(String s, List<String> list)\n+        throws Exception {\n+      refresh();\n+    }\n+\n+    @Override\n+    public void handleDataChange(String s, Object o)\n+        throws Exception {\n+      refresh();\n+    }\n+\n+    @Override\n+    public void handleDataDeleted(String s)\n+        throws Exception {\n+      refresh();\n+    }\n+  }\n+\n+  class SchemaChangeListener implements IZkChildListener, IZkDataListener {\n+    Map<String, Schema> _schemaMap = new ConcurrentHashMap<>();\n+    Map<String, Map<String, String>> _schemaColumnMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void refresh() {\n+      try {\n+        //always subscribe first before reading, so that we dont miss any changes\n+        _propertyStore.subscribeChildChanges(PROPERTYSTORE_SCHEMAS_PREFIX, _schemaChangeListener);\n+        _propertyStore.subscribeDataChanges(PROPERTYSTORE_SCHEMAS_PREFIX, _schemaChangeListener);\n+        List<ZNRecord> children =\n+            _propertyStore.getChildren(PROPERTYSTORE_SCHEMAS_PREFIX, null, AccessOption.PERSISTENT);\n+        if (children != null) {\n+          for (ZNRecord znRecord : children) {\n+            try {\n+              Schema schema = SchemaUtils.fromZNRecord(znRecord);\n+              String schemaNameLowerCase = schema.getSchemaName().toLowerCase();\n+              _schemaMap.put(schemaNameLowerCase, schema);\n+              Collection<FieldSpec> allFieldSpecs = schema.getAllFieldSpecs();\n+              ConcurrentHashMap<String, String> columnNameMap = new ConcurrentHashMap<>();\n+              _schemaColumnMap.put(schemaNameLowerCase, columnNameMap);\n+              for (FieldSpec fieldSpec : allFieldSpecs) {\n+                columnNameMap.put(fieldSpec.getName().toLowerCase(), fieldSpec.getName());\n+              }\n+            } catch (IOException e) {\n+              //ignore\n+            }\n+          }\n+        }\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        //ignore\n+      }\n+    }\n+\n+    Schema getSchema(String schemaName) {\n+      return _schemaMap.get(schemaName.toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTU5MDM1", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-342959035", "createdAt": "2020-01-15T02:33:42Z", "commit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzo0M1rOFdr0ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjozMzo0M1rOFdr0ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MTA0Mw==", "bodyText": "Unrelated to this PR but may be at some point we need to fix this?\nJust to extract the table name, a query received on the controller via rest API will be compiled to BrokerRequest twice -- once at the controller and then at the broker.", "url": "https://github.com/apache/pinot/pull/4983#discussion_r366671043", "createdAt": "2020-01-15T02:33:43Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PqlQueryResource.java", "diffHunk": "@@ -108,6 +108,8 @@ public String getQueryResponse(String pqlQuery, String traceEnabled, String quer\n     BrokerRequest brokerRequest;\n     try {\n       brokerRequest = REQUEST_COMPILER.compileToBrokerRequest(pqlQuery);\n+      String inputTableName = brokerRequest.getQuerySource().getTableName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99992a2b52f1cfd01b74ddc7f4dfde623def62d0"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e09e1f0db11fcdf1ec812b9b06e0b5c0043426f", "author": {"user": {"login": "kishoreg", "name": "Kishore Gopalakrishna"}}, "url": "https://github.com/apache/pinot/commit/2e09e1f0db11fcdf1ec812b9b06e0b5c0043426f", "committedDate": "2020-01-16T08:12:57Z", "message": "Adding test case and making it configurable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8ef989ae656dd095ed516457ee8f22b4d03fe9d", "author": {"user": {"login": "kishoreg", "name": "Kishore Gopalakrishna"}}, "url": "https://github.com/apache/pinot/commit/c8ef989ae656dd095ed516457ee8f22b4d03fe9d", "committedDate": "2020-01-17T01:17:28Z", "message": "Addressing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "256efe6e014d322ab3795cd8d9aca65fe2435402", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/256efe6e014d322ab3795cd8d9aca65fe2435402", "committedDate": "2020-01-18T09:37:35Z", "message": "Fixing the bug of get actual column name"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51608983be98fd42ebe01c48ff58e025e512527c", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/51608983be98fd42ebe01c48ff58e025e512527c", "committedDate": "2020-01-18T09:34:47Z", "message": "Fixing the bug of get actual column name"}, "afterCommit": {"oid": "256efe6e014d322ab3795cd8d9aca65fe2435402", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/256efe6e014d322ab3795cd8d9aca65fe2435402", "committedDate": "2020-01-18T09:37:35Z", "message": "Fixing the bug of get actual column name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTc3OTAw", "url": "https://github.com/apache/pinot/pull/4983#pullrequestreview-345577900", "createdAt": "2020-01-21T00:06:26Z", "commit": {"oid": "256efe6e014d322ab3795cd8d9aca65fe2435402"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1463, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}