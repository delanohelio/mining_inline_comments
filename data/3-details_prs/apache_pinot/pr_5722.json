{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0MTQ2NzI4", "number": 5722, "title": "Introduce IndexContainer in MutableSegmentImpl to reduce map lookups", "bodyText": "Description\nMotivation:\nCurrently within MutableSegmentImpl we maintain 10 maps from column to different type of index or column stats, which is very inefficient and requires a lot of redundant map lookups to access or update indexes. Also, it is quite hard to manage 10 maps, and the number of maps will keep growing as we add more types of indexes.\nChanges:\n\nIntroduce IndexContainer class inside MutableSegmentImpl to wrap all the index and stats for a column\nAdd helper method in IndexContainer to directly get DataSource and close all indexes for a column\nSimplify the min/max value handling, add min/max value support for BYTES column\nStore dictId for the latest ingested records in IndexContainer to avoid the per-record map from column to dictId\n\nBug fixes:\n\nDo not store min/max value for aggregated metrics\nAdd document into text index properly", "createdAt": "2020-07-21T05:30:50Z", "url": "https://github.com/apache/pinot/pull/5722", "merged": true, "mergeCommit": {"oid": "152a8351c5e8df4e3fb54dc8b7578d0e07a7470b"}, "closed": true, "closedAt": "2020-07-22T22:16:18Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3I5B9gFqTQ1MjYzMjU4Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3gvH4gFqTQ1MzY1NDQ5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNjMyNTgy", "url": "https://github.com/apache/pinot/pull/5722#pullrequestreview-452632582", "createdAt": "2020-07-21T16:31:44Z", "commit": {"oid": "00696e33e82c3c8682b36a3ef380cbf488f946a1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjozMTo0NFrOG1AQsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjozMTo0NFrOG1AQsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzMTk4NA==", "bodyText": "Is the check for aggregateMetrics redundant here?", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458231984", "createdAt": "2020-07-21T16:31:44Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -432,202 +409,193 @@ public void addExtraColumns(Schema newSchema) {\n     _logger.info(\"Newly added columns: \" + _newlyAddedColumnsFieldMap.toString());\n   }\n \n+  // NOTE: Okay for single-writer\n+  @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n   @Override\n   public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n-    boolean canTakeMore;\n     // Update dictionary first\n-    Map<String, Object> dictIdMap = updateDictionary(row);\n-\n-    int numDocs = _numDocsIndexed;\n+    updateDictionary(row);\n \n     // If metrics aggregation is enabled and if the dimension values were already seen, this will return existing docId,\n     // else this will return a new docId.\n-    int docId = getOrCreateDocId(dictIdMap);\n-\n-    // docId == numDocs implies new docId.\n-    if (docId == numDocs) {\n-      // Add forward and inverted indices for new document.\n-      addForwardIndex(row, docId, dictIdMap);\n-      addInvertedIndex(row, docId, dictIdMap);\n-      if (_nullHandlingEnabled) {\n-        handleNullValues(row, docId);\n-      }\n+    int docId = getOrCreateDocId();\n \n+    boolean canTakeMore;\n+    if (docId == _numDocsIndexed) {\n+      // New document\n+      addNewDocument(row, docId);\n       // Update number of document indexed at last to make the latest record queryable\n       canTakeMore = _numDocsIndexed++ < _capacity;\n     } else {\n-      Preconditions\n-          .checkState(_aggregateMetrics, \"Invalid document-id during indexing: \" + docId + \" expected: \" + numDocs);\n-      // Update metrics for existing document.\n-      canTakeMore = aggregateMetrics(row, docId);\n+      // Aggregate metrics for existing document\n+      assert _aggregateMetrics;\n+      aggregateMetrics(row, docId);\n+      canTakeMore = true;\n     }\n \n+    // Update last indexed time and latest ingestion time\n     _lastIndexedTimeMs = System.currentTimeMillis();\n-\n-    if (rowMetadata != null && rowMetadata.getIngestionTimeMs() != Long.MIN_VALUE) {\n+    if (rowMetadata != null) {\n       _latestIngestionTimeMs = Math.max(_latestIngestionTimeMs, rowMetadata.getIngestionTimeMs());\n     }\n+\n     return canTakeMore;\n   }\n \n-  private Map<String, Object> updateDictionary(GenericRow row) {\n-    Map<String, Object> dictIdMap = new HashMap<>();\n-    for (FieldSpec fieldSpec : _physicalFieldSpecs) {\n-      String column = fieldSpec.getName();\n+  private void updateDictionary(GenericRow row) {\n+    for (Map.Entry<String, IndexContainer> entry : _indexContainerMap.entrySet()) {\n+      String column = entry.getKey();\n+      IndexContainer indexContainer = entry.getValue();\n       Object value = row.getValue(column);\n-\n-      BaseMutableDictionary dictionary = _dictionaryMap.get(column);\n+      BaseMutableDictionary dictionary = indexContainer._dictionary;\n       if (dictionary != null) {\n-        if (fieldSpec.isSingleValueField()) {\n-          dictIdMap.put(column, dictionary.index(value));\n+        if (indexContainer._fieldSpec.isSingleValueField()) {\n+          indexContainer._dictId = dictionary.index(value);\n         } else {\n-          int[] dictIds = dictionary.index((Object[]) value);\n-          dictIdMap.put(column, dictIds);\n-\n-          // No need to update min/max time value as time column cannot be multi-valued\n-          continue;\n+          indexContainer._dictIds = dictionary.index((Object[]) value);\n         }\n+\n+        // Update min/max value from dictionary\n+        indexContainer._minValue = dictionary.getMinVal();\n+        indexContainer._maxValue = dictionary.getMaxVal();\n       }\n     }\n-    return dictIdMap;\n   }\n \n-  private void addForwardIndex(GenericRow row, int docId, Map<String, Object> dictIdMap) {\n-    // Store dictionary Id(s) for columns with dictionary\n-    for (FieldSpec fieldSpec : _physicalFieldSpecs) {\n-      String column = fieldSpec.getName();\n+  private void addNewDocument(GenericRow row, int docId) {\n+    for (Map.Entry<String, IndexContainer> entry : _indexContainerMap.entrySet()) {\n+      String column = entry.getKey();\n+      IndexContainer indexContainer = entry.getValue();\n       Object value = row.getValue(column);\n-      NumValuesInfo numValuesInfo = _numValuesInfoMap.get(column);\n+      FieldSpec fieldSpec = indexContainer._fieldSpec;\n       if (fieldSpec.isSingleValueField()) {\n-        // SV column\n-        MutableForwardIndex mutableForwardIndex = _forwardIndexMap.get(column);\n-        Integer dictId = (Integer) dictIdMap.get(column);\n-        if (dictId != null) {\n-          // SV Column with dictionary\n-          mutableForwardIndex.setDictId(docId, dictId);\n+        // Single-value column\n+\n+        // Update numValues info\n+        indexContainer._numValuesInfo.updateSVEntry();\n+\n+        // Update indexes\n+        MutableForwardIndex forwardIndex = indexContainer._forwardIndex;\n+        int dictId = indexContainer._dictId;\n+        if (dictId >= 0) {\n+          // Dictionary-encoded single-value column\n+\n+          // Update forward index\n+          forwardIndex.setDictId(docId, dictId);\n+\n+          // Update inverted index\n+          RealtimeInvertedIndexReader invertedIndex = indexContainer._invertedIndex;\n+          if (invertedIndex != null) {\n+            invertedIndex.add(dictId, docId);\n+          }\n         } else {\n-          // No-dictionary SV column\n+          // Single-value column with raw index\n+\n+          // Update forward index\n           DataType dataType = fieldSpec.getDataType();\n           switch (dataType) {\n             case INT:\n-              mutableForwardIndex.setInt(docId, (Integer) value);\n+              forwardIndex.setInt(docId, (Integer) value);\n               break;\n             case LONG:\n-              mutableForwardIndex.setLong(docId, (Long) value);\n+              forwardIndex.setLong(docId, (Long) value);\n               break;\n             case FLOAT:\n-              mutableForwardIndex.setFloat(docId, (Float) value);\n+              forwardIndex.setFloat(docId, (Float) value);\n               break;\n             case DOUBLE:\n-              mutableForwardIndex.setDouble(docId, (Double) value);\n+              forwardIndex.setDouble(docId, (Double) value);\n               break;\n             case STRING:\n-              mutableForwardIndex.setString(docId, (String) value);\n+              forwardIndex.setString(docId, (String) value);\n               break;\n             case BYTES:\n-              mutableForwardIndex.setBytes(docId, (byte[]) value);\n+              forwardIndex.setBytes(docId, (byte[]) value);\n               break;\n             default:\n               throw new UnsupportedOperationException(\n                   \"Unsupported data type: \" + dataType + \" for no-dictionary column: \" + column);\n           }\n+\n+          // Update min/max value from raw value\n+          // NOTE: Skip updating min/max value for aggregated metrics because the value will change over time.\n+          if (!_aggregateMetrics || fieldSpec.getFieldType() != FieldSpec.FieldType.METRIC) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00696e33e82c3c8682b36a3ef380cbf488f946a1"}, "originalPosition": 401}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00696e33e82c3c8682b36a3ef380cbf488f946a1", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/00696e33e82c3c8682b36a3ef380cbf488f946a1", "committedDate": "2020-07-21T05:30:17Z", "message": "Introduce IndexContianer in MutableSegmentImpl to reduce map lookups"}, "afterCommit": {"oid": "e0359b839b8f04eb63acda113079ba1b22b98212", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/e0359b839b8f04eb63acda113079ba1b22b98212", "committedDate": "2020-07-21T17:38:33Z", "message": "Introduce IndexContianer in MutableSegmentImpl to reduce map lookups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzY1Mjk3", "url": "https://github.com/apache/pinot/pull/5722#pullrequestreview-452765297", "createdAt": "2020-07-21T19:29:27Z", "commit": {"oid": "e0359b839b8f04eb63acda113079ba1b22b98212"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyOToyOFrOG1Griw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyOToyOFrOG1Griw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzE2Mw==", "bodyText": "should this be IndexKey instead of String?", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458337163", "createdAt": "2020-07-21T19:29:28Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -108,19 +110,8 @@\n   private final int _partitionId;\n   private final boolean _nullHandlingEnabled;\n \n-  // TODO: Keep one map to store all these info\n-  private final Map<String, NumValuesInfo> _numValuesInfoMap = new HashMap<>();\n-  private final Map<String, BaseMutableDictionary> _dictionaryMap = new HashMap<>();\n-  private final Map<String, MutableForwardIndex> _forwardIndexMap = new HashMap<>();\n-  private final Map<String, InvertedIndexReader> _invertedIndexMap = new HashMap<>();\n-  private final Map<String, InvertedIndexReader> _rangeIndexMap = new HashMap<>();\n-  private final Map<String, InvertedIndexReader> _textIndexMap = new HashMap<>();\n-  private final Map<String, BloomFilterReader> _bloomFilterMap = new HashMap<>();\n-  // Only store min/max for non-dictionary fields\n-  private final Map<String, Comparable> _minValueMap = new HashMap<>();\n-  private final Map<String, Comparable> _maxValueMap = new HashMap<>();\n-\n-  private final Map<String, RealtimeNullValueVectorReaderWriter> _nullValueVectorMap = new HashMap<>();\n+  private final Map<String, IndexContainer> _indexContainerMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0359b839b8f04eb63acda113079ba1b22b98212"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzMzM1MTUw", "url": "https://github.com/apache/pinot/pull/5722#pullrequestreview-453335150", "createdAt": "2020-07-22T13:48:30Z", "commit": {"oid": "e0359b839b8f04eb63acda113079ba1b22b98212"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo0ODozMFrOG1jQNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo1MDoyNVrOG1jVvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTMwMA==", "bodyText": "Use Optional to avoid null check?", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458805300", "createdAt": "2020-07-22T13:48:30Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -1033,13 +960,89 @@ void updateMVEntry(int numValuesInMVEntry) {\n       _numValues += numValuesInMVEntry;\n       _maxNumValuesPerMVEntry = Math.max(_maxNumValuesPerMVEntry, numValuesInMVEntry);\n     }\n+  }\n+\n+  private class IndexContainer implements Closeable {\n+    final FieldSpec _fieldSpec;\n+    final PartitionFunction _partitionFunction;\n+    final int _partitionId;\n+    final NumValuesInfo _numValuesInfo;\n+    final MutableForwardIndex _forwardIndex;\n+    final BaseMutableDictionary _dictionary;\n+    final RealtimeInvertedIndexReader _invertedIndex;\n+    final InvertedIndexReader _rangeIndex;\n+    final RealtimeLuceneTextIndexReader _textIndex;\n+    final BloomFilterReader _bloomFilter;\n+    final MutableNullValueVector _nullValueVector;\n+\n+    volatile Comparable _minValue;\n+    volatile Comparable _maxValue;\n+\n+    // Hold the dictionary id for the latest record\n+    int _dictId = Integer.MIN_VALUE;\n+    int[] _dictIds;\n+\n+    IndexContainer(FieldSpec fieldSpec, PartitionFunction partitionFunction, int partitionId,\n+        NumValuesInfo numValuesInfo, MutableForwardIndex forwardIndex, BaseMutableDictionary dictionary,\n+        RealtimeInvertedIndexReader invertedIndex, InvertedIndexReader rangeIndex,\n+        RealtimeLuceneTextIndexReader textIndex, BloomFilterReader bloomFilter,\n+        MutableNullValueVector nullValueVector) {\n+      _fieldSpec = fieldSpec;\n+      _partitionFunction = partitionFunction;\n+      _partitionId = partitionId;\n+      _numValuesInfo = numValuesInfo;\n+      _forwardIndex = forwardIndex;\n+      _dictionary = dictionary;\n+      _invertedIndex = invertedIndex;\n+      _rangeIndex = rangeIndex;\n+      _textIndex = textIndex;\n+      _bloomFilter = bloomFilter;\n+      _nullValueVector = nullValueVector;\n+    }\n \n-    int getNumValues() {\n-      return _numValues;\n+    DataSource toDataSource() {\n+      return new MutableDataSource(_fieldSpec, _numDocsIndexed, _numValuesInfo._numValues,\n+          _numValuesInfo._maxNumValuesPerMVEntry, _partitionFunction, _partitionId, _minValue, _maxValue, _forwardIndex,\n+          _dictionary, _invertedIndex, _rangeIndex, _textIndex, _bloomFilter, _nullValueVector);\n     }\n \n-    int getMaxNumValuesPerMVEntry() {\n-      return _maxNumValuesPerMVEntry;\n+    @Override\n+    public void close() {\n+      String column = _fieldSpec.getName();\n+      try {\n+        _forwardIndex.close();\n+      } catch (Exception e) {\n+        _logger.error(\"Caught exception while closing forward index for column: {}, continuing with error\", column, e);\n+      }\n+      if (_dictionary != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0359b839b8f04eb63acda113079ba1b22b98212"}, "originalPosition": 787}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNjcxNg==", "bodyText": "Nit: addNewRow?", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458806716", "createdAt": "2020-07-22T13:50:25Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -432,202 +409,193 @@ public void addExtraColumns(Schema newSchema) {\n     _logger.info(\"Newly added columns: \" + _newlyAddedColumnsFieldMap.toString());\n   }\n \n+  // NOTE: Okay for single-writer\n+  @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n   @Override\n   public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n-    boolean canTakeMore;\n     // Update dictionary first\n-    Map<String, Object> dictIdMap = updateDictionary(row);\n-\n-    int numDocs = _numDocsIndexed;\n+    updateDictionary(row);\n \n     // If metrics aggregation is enabled and if the dimension values were already seen, this will return existing docId,\n     // else this will return a new docId.\n-    int docId = getOrCreateDocId(dictIdMap);\n-\n-    // docId == numDocs implies new docId.\n-    if (docId == numDocs) {\n-      // Add forward and inverted indices for new document.\n-      addForwardIndex(row, docId, dictIdMap);\n-      addInvertedIndex(row, docId, dictIdMap);\n-      if (_nullHandlingEnabled) {\n-        handleNullValues(row, docId);\n-      }\n+    int docId = getOrCreateDocId();\n \n+    boolean canTakeMore;\n+    if (docId == _numDocsIndexed) {\n+      // New document\n+      addNewDocument(row, docId);\n       // Update number of document indexed at last to make the latest record queryable\n       canTakeMore = _numDocsIndexed++ < _capacity;\n     } else {\n-      Preconditions\n-          .checkState(_aggregateMetrics, \"Invalid document-id during indexing: \" + docId + \" expected: \" + numDocs);\n-      // Update metrics for existing document.\n-      canTakeMore = aggregateMetrics(row, docId);\n+      // Aggregate metrics for existing document\n+      assert _aggregateMetrics;\n+      aggregateMetrics(row, docId);\n+      canTakeMore = true;\n     }\n \n+    // Update last indexed time and latest ingestion time\n     _lastIndexedTimeMs = System.currentTimeMillis();\n-\n-    if (rowMetadata != null && rowMetadata.getIngestionTimeMs() != Long.MIN_VALUE) {\n+    if (rowMetadata != null) {\n       _latestIngestionTimeMs = Math.max(_latestIngestionTimeMs, rowMetadata.getIngestionTimeMs());\n     }\n+\n     return canTakeMore;\n   }\n \n-  private Map<String, Object> updateDictionary(GenericRow row) {\n-    Map<String, Object> dictIdMap = new HashMap<>();\n-    for (FieldSpec fieldSpec : _physicalFieldSpecs) {\n-      String column = fieldSpec.getName();\n+  private void updateDictionary(GenericRow row) {\n+    for (Map.Entry<String, IndexContainer> entry : _indexContainerMap.entrySet()) {\n+      String column = entry.getKey();\n+      IndexContainer indexContainer = entry.getValue();\n       Object value = row.getValue(column);\n-\n-      BaseMutableDictionary dictionary = _dictionaryMap.get(column);\n+      BaseMutableDictionary dictionary = indexContainer._dictionary;\n       if (dictionary != null) {\n-        if (fieldSpec.isSingleValueField()) {\n-          dictIdMap.put(column, dictionary.index(value));\n+        if (indexContainer._fieldSpec.isSingleValueField()) {\n+          indexContainer._dictId = dictionary.index(value);\n         } else {\n-          int[] dictIds = dictionary.index((Object[]) value);\n-          dictIdMap.put(column, dictIds);\n-\n-          // No need to update min/max time value as time column cannot be multi-valued\n-          continue;\n+          indexContainer._dictIds = dictionary.index((Object[]) value);\n         }\n+\n+        // Update min/max value from dictionary\n+        indexContainer._minValue = dictionary.getMinVal();\n+        indexContainer._maxValue = dictionary.getMaxVal();\n       }\n     }\n-    return dictIdMap;\n   }\n \n-  private void addForwardIndex(GenericRow row, int docId, Map<String, Object> dictIdMap) {\n-    // Store dictionary Id(s) for columns with dictionary\n-    for (FieldSpec fieldSpec : _physicalFieldSpecs) {\n-      String column = fieldSpec.getName();\n+  private void addNewDocument(GenericRow row, int docId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0359b839b8f04eb63acda113079ba1b22b98212"}, "originalPosition": 330}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "413f6e55df9e10b83700ac0b366d1466dc6cc980", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/413f6e55df9e10b83700ac0b366d1466dc6cc980", "committedDate": "2020-07-22T17:52:29Z", "message": "Introduce IndexContianer in MutableSegmentImpl to reduce map lookups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0359b839b8f04eb63acda113079ba1b22b98212", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/e0359b839b8f04eb63acda113079ba1b22b98212", "committedDate": "2020-07-21T17:38:33Z", "message": "Introduce IndexContianer in MutableSegmentImpl to reduce map lookups"}, "afterCommit": {"oid": "413f6e55df9e10b83700ac0b366d1466dc6cc980", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/413f6e55df9e10b83700ac0b366d1466dc6cc980", "committedDate": "2020-07-22T17:52:29Z", "message": "Introduce IndexContianer in MutableSegmentImpl to reduce map lookups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNjU0NDk1", "url": "https://github.com/apache/pinot/pull/5722#pullrequestreview-453654495", "createdAt": "2020-07-22T20:20:21Z", "commit": {"oid": "413f6e55df9e10b83700ac0b366d1466dc6cc980"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 403, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}