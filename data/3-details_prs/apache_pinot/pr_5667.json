{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MDY0Nzc2", "number": 5667, "title": "Support text index on dictionary encoded columns", "bodyText": "Support text index on dictionary encoded columns. With these changes, we can essentially have both text and native\nPinot inverted index on the same column. Add several tests.\nNote: there has been a pending cleanup for both range index and text index (which followed the InvertedIndexReader) interface. I'd like to cleanup the same for text index in this PR.", "createdAt": "2020-07-08T07:56:38Z", "url": "https://github.com/apache/pinot/pull/5667", "merged": true, "mergeCommit": {"oid": "f740456dc74480456e8039db440afafce472e748"}, "closed": true, "closedAt": "2020-07-17T09:22:20Z", "author": {"login": "siddharthteotia"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcy96nsAFqTQ0NDk4Mzc4Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1rVDfgBqjM1NTYxMjkyMTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTgzNzg3", "url": "https://github.com/apache/pinot/pull/5667#pullrequestreview-444983787", "createdAt": "2020-07-08T17:30:32Z", "commit": {"oid": "9df8a5a7d7c6554ab7d845897708e66ec108e9f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNzozMDozMlrOGuySMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNzozMDozMlrOGuySMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxMTUzNw==", "bodyText": "Will this cause multiple text document map to the same pinot document? How do you maintain the map? We need to figure out the semantic of text index on MV columns", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451711537", "createdAt": "2020-07-08T17:30:32Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneTextIndexCreator.java", "diffHunk": "@@ -115,14 +115,31 @@ public IndexWriter getIndexWriter() {\n \n   @Override\n   public void addDoc(Object document, int docIdCounter) {\n-    Document docToIndex = new Document();\n-    docToIndex.add(new TextField(_textColumn, document.toString(), Field.Store.NO));\n-    docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n-    try {\n-      _indexWriter.addDocument(docToIndex);\n-    } catch (Exception e) {\n-      LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n-      throw new RuntimeException(e);\n+    if (!(document instanceof Object[])) {\n+      // text index on SV column\n+      Document docToIndex = new Document();\n+      docToIndex.add(new TextField(_textColumn, document.toString(), Field.Store.NO));\n+      docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n+      try {\n+        _indexWriter.addDocument(docToIndex);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n+        throw new RuntimeException(e);\n+      }\n+    } else {\n+      // text index on MV column\n+      Object[] values = (Object[])document;\n+      for (Object value : values) {\n+        Document docToIndex = new Document();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df8a5a7d7c6554ab7d845897708e66ec108e9f3"}, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9df8a5a7d7c6554ab7d845897708e66ec108e9f3", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/9df8a5a7d7c6554ab7d845897708e66ec108e9f3", "committedDate": "2020-07-08T07:53:02Z", "message": "Support co-existence of text index with other indexes\nand structures\n\n-- Remove the constraint that text index should be on raw columns\n-- Remove the constraint that text index should be on SV columns\n\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}, "afterCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/8e1e9af32c5f5c32afea20000048690471737c90", "committedDate": "2020-07-08T23:40:46Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MjIyMTI3", "url": "https://github.com/apache/pinot/pull/5667#pullrequestreview-445222127", "createdAt": "2020-07-09T00:57:48Z", "commit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMDo1Nzo0OFrOGu-DnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMToyMDoyOFrOGu-aXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDQxMg==", "bodyText": "Move this into the branch of single value column", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451904412", "createdAt": "2020-07-09T00:57:48Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -379,6 +370,13 @@ public void indexRow(GenericRow row) {\n           _nullValueVectorCreatorMap.get(columnName).setNull(docIdCounter);\n         }\n       }\n+\n+      // text-search enabled column", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNzM0NQ==", "bodyText": "Also check that column is STRING type?", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451907345", "createdAt": "2020-07-09T01:09:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -199,16 +200,17 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n         _forwardIndexCreatorMap.put(columnName,\n             getRawIndexCreatorForColumn(_indexDir, compressionType, columnName, fieldSpec.getDataType(), totalDocs,\n                 indexCreationInfo.getLengthOfLongestEntry(), deriveNumDocsPerChunk, writerVersion));\n+      }\n \n+      if (_textIndexColumns.contains(columnName)) {\n         // Initialize text index creator\n-        if (_textIndexColumns.contains(columnName)) {\n-          _invertedIndexCreatorMap\n-              .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n-        }\n+        Preconditions.checkState(fieldSpec.isSingleValueField(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ==", "bodyText": "I think you can just remove this method and always use the default one. We should always create dictionary-encoded index for default column because it is much more efficient.", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451909729", "createdAt": "2020-07-09T01:18:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -325,77 +323,92 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded\n    * single-value STRING columns. Eventually we will relax the constraints\n    * step by step.\n    * For example, later on user should be able to create text index on\n-   * a dictionary encoded STRING column that also has native Pinot's inverted\n-   * index. We can also support it on BYTE columns later.\n+   * a MV column\n    * @param column column name\n    * @param indexLoadingConfig index loading config\n    * @param fieldSpec field spec\n    */\n   private void checkUnsupportedOperationsForTextIndex(String column, IndexLoadingConfig indexLoadingConfig,\n       FieldSpec fieldSpec) {\n-    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n-      throw new UnsupportedOperationException(\n-          \"Text index is currently not supported on dictionary encoded column: \" + column);\n-    }\n-\n-    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n-    if (sortedColumns.contains(column)) {\n-      // since Pinot's current implementation doesn't support raw sorted columns,\n-      // we need to check for this too\n-      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted column: \" + column);\n-    }\n-\n     if (!fieldSpec.isSingleValueField()) {\n       throw new UnsupportedOperationException(\"Text index is currently not supported on multi-value column: \" + column);\n     }\n-\n     if (fieldSpec.getDataType() != DataType.STRING) {\n       throw new UnsupportedOperationException(\"Text index is currently only supported on STRING column:\" + column);\n     }\n   }\n \n   void createV1ForwardIndexForTextIndex(String column, IndexLoadingConfig indexLoadingConfig)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxMDIzNg==", "bodyText": "Since text column supports both raw & dictionary-encoded index, remove the branch for text column", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451910236", "createdAt": "2020-07-09T01:20:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "diffHunk": "@@ -67,10 +67,19 @@ protected void updateDefaultColumn(String column, DefaultColumnAction action, In\n     Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDY2MTky", "url": "https://github.com/apache/pinot/pull/5667#pullrequestreview-447466192", "createdAt": "2020-07-13T17:44:31Z", "commit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzo0NDozMVrOGwzDyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzo1MDoyM1rOGwzRvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMTM4NA==", "bodyText": "Are there any more constraints to relax? If not, we can modify this comment?", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453821384", "createdAt": "2020-07-13T17:44:31Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -325,77 +323,92 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMzAyNw==", "bodyText": "same here. capture the constraints correctly in comments", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453823027", "createdAt": "2020-07-13T17:47:13Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -111,35 +117,22 @@ public void createTextIndexesOnSegmentLoad()\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyNDk1OQ==", "bodyText": "Should it be ColumnIndexType.DICTIONARY?", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453824959", "createdAt": "2020-07-13T17:50:23Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -151,30 +144,68 @@ private void createTextIndexForColumn(ColumnMetadata columnMetadata)\n       return;\n     }\n     int numDocs = columnMetadata.getTotalDocs();\n-    LOGGER.info(\"Creating new text index for column: {} in segment: {}\", column, _segmentName);\n+    boolean hasDictionary = columnMetadata.hasDictionary();\n+    LOGGER.info(\"Creating new text index for column: {} in segment: {}, hasDictionary: {}\", column, _segmentName, hasDictionary);\n     File segmentDirectory = SegmentDirectoryPaths.segmentDirectoryFor(_indexDir, _segmentVersion);\n     // The handlers are always invoked by the preprocessor. Before this ImmutableSegmentLoader would have already\n     // up-converted the segment from v1/v2 -> v3 (if needed). So based on the segmentVersion, whatever segment\n     // segmentDirectory is indicated to us by SegmentDirectoryPaths, we create lucene index there. There is no\n     // further need to move around the lucene index directory since it is created with correct directory structure\n     // based on segmentVersion.\n-    try (LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true);\n-        VarByteChunkSVForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n-        ChunkReaderContext readerContext = forwardIndexReader.createContext()) {\n-      for (int docId = 0; docId < numDocs; docId++) {\n-        textIndexCreator.addDoc(forwardIndexReader.getString(docId, readerContext), docId);\n+    try (ForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n+        ForwardIndexReaderContext readerContext = forwardIndexReader.createContext();\n+        LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true)) {\n+      if (!hasDictionary) {\n+        // text index on raw column, just read the raw forward index\n+        VarByteChunkSVForwardIndexReader rawIndexReader = (VarByteChunkSVForwardIndexReader)forwardIndexReader;\n+        ChunkReaderContext chunkReaderContext = (ChunkReaderContext)readerContext;\n+        for (int docId = 0; docId < numDocs; docId++) {\n+          textIndexCreator.addDoc(rawIndexReader.getString(docId, chunkReaderContext), docId);\n+        }\n+      } else {\n+        // text index on dictionary encoded SV column\n+        // read forward index to get dictId\n+        // read the raw value from dictionary using dictId\n+        try (BaseImmutableDictionary dictionary = getDictionaryReader(columnMetadata)) {\n+          if (columnMetadata.isSingleValue()) {\n+            for (int docId = 0; docId < numDocs; docId++) {\n+              int dictId = forwardIndexReader.getDictId(docId, readerContext);\n+              String value = dictionary.getStringValue(dictId);\n+              textIndexCreator.addDoc(value, docId);\n+            }\n+          }\n+        }\n       }\n       textIndexCreator.seal();\n     }\n+\n     LOGGER.info(\"Created text index for column: {} in segment: {}\", column, _segmentName);\n     PropertiesConfiguration properties = SegmentMetadataImpl.getPropertiesConfiguration(_indexDir);\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), TextIndexType.LUCENE.name());\n     properties.save();\n   }\n \n-  private VarByteChunkSVForwardIndexReader getForwardIndexReader(ColumnMetadata columnMetadata)\n+  private ForwardIndexReader<?> getForwardIndexReader(ColumnMetadata columnMetadata)\n+      throws IOException {\n+    if (!columnMetadata.hasDictionary()) {\n+      // raw index\n+      PinotDataBuffer buffer = _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);\n+      return new VarByteChunkSVForwardIndexReader(buffer, DataType.STRING);\n+    } else {\n+      PinotDataBuffer buffer = _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90"}, "originalPosition": 113}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e1e9af32c5f5c32afea20000048690471737c90", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/8e1e9af32c5f5c32afea20000048690471737c90", "committedDate": "2020-07-08T23:40:46Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}, "afterCommit": {"oid": "ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "committedDate": "2020-07-15T20:15:02Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d30866f2da09047a343b73f39aa16b21313ccb7b", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/d30866f2da09047a343b73f39aa16b21313ccb7b", "committedDate": "2020-07-15T20:26:34Z", "message": "fix conflicts"}, "afterCommit": {"oid": "216b6cf99d0119e1514c396389d62a3deb8f348b", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/216b6cf99d0119e1514c396389d62a3deb8f348b", "committedDate": "2020-07-15T20:57:36Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "216b6cf99d0119e1514c396389d62a3deb8f348b", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/216b6cf99d0119e1514c396389d62a3deb8f348b", "committedDate": "2020-07-15T20:57:36Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}, "afterCommit": {"oid": "cdd757223f33faac42815feaaa3bed4814ab118b", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/cdd757223f33faac42815feaaa3bed4814ab118b", "committedDate": "2020-07-16T17:20:05Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTIzNTE3", "url": "https://github.com/apache/pinot/pull/5667#pullrequestreview-450123517", "createdAt": "2020-07-16T18:52:18Z", "commit": {"oid": "cdd757223f33faac42815feaaa3bed4814ab118b"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo1MjoxOFrOGy4IBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo1NDozNFrOGy4NVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMTU0MQ==", "bodyText": "Let's remove this check as it will be checked in TextIndexHandler. Try not to couple different modules together.", "url": "https://github.com/apache/pinot/pull/5667#discussion_r456001541", "createdAt": "2020-07-16T18:52:18Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -321,88 +321,33 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n-   * single-value STRING columns. Eventually we will relax the constraints\n-   * step by step.\n-   * For example, later on user should be able to create text index on\n-   * a dictionary encoded STRING column that also has native Pinot's inverted\n-   * index. We can also support it on BYTE columns later.\n+   * Right now the text index is supported on RAW and dictionary encoded\n+   * single-value STRING columns. Later we can add support for text index\n+   * on multi-value columns and BYTE type columns\n    * @param column column name\n-   * @param indexLoadingConfig index loading config\n    * @param fieldSpec field spec\n    */\n-  private void checkUnsupportedOperationsForTextIndex(String column, IndexLoadingConfig indexLoadingConfig,\n-      FieldSpec fieldSpec) {\n-    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n-      throw new UnsupportedOperationException(\n-          \"Text index is currently not supported on dictionary encoded column: \" + column);\n-    }\n-\n-    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n-    if (sortedColumns.contains(column)) {\n-      // since Pinot's current implementation doesn't support raw sorted columns,\n-      // we need to check for this too\n-      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted column: \" + column);\n-    }\n-\n+  private void checkUnsupportedOperationsForTextIndex(String column, FieldSpec fieldSpec) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd757223f33faac42815feaaa3bed4814ab118b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMjkwMA==", "bodyText": "Remove this check (or replace with checkState)", "url": "https://github.com/apache/pinot/pull/5667#discussion_r456002900", "createdAt": "2020-07-16T18:54:34Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -151,30 +143,76 @@ private void createTextIndexForColumn(ColumnMetadata columnMetadata)\n       return;\n     }\n     int numDocs = columnMetadata.getTotalDocs();\n-    LOGGER.info(\"Creating new text index for column: {} in segment: {}\", column, _segmentName);\n+    boolean hasDictionary = columnMetadata.hasDictionary();\n+    LOGGER.info(\"Creating new text index for column: {} in segment: {}, hasDictionary: {}\", column, _segmentName, hasDictionary);\n     File segmentDirectory = SegmentDirectoryPaths.segmentDirectoryFor(_indexDir, _segmentVersion);\n     // The handlers are always invoked by the preprocessor. Before this ImmutableSegmentLoader would have already\n     // up-converted the segment from v1/v2 -> v3 (if needed). So based on the segmentVersion, whatever segment\n     // segmentDirectory is indicated to us by SegmentDirectoryPaths, we create lucene index there. There is no\n     // further need to move around the lucene index directory since it is created with correct directory structure\n     // based on segmentVersion.\n-    try (LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true);\n-        VarByteChunkSVForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n-        ChunkReaderContext readerContext = forwardIndexReader.createContext()) {\n-      for (int docId = 0; docId < numDocs; docId++) {\n-        textIndexCreator.addDoc(forwardIndexReader.getString(docId, readerContext), docId);\n+    try (ForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n+        ForwardIndexReaderContext readerContext = forwardIndexReader.createContext();\n+        LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true)) {\n+      if (!hasDictionary) {\n+        // text index on raw column, just read the raw forward index\n+        VarByteChunkSVForwardIndexReader rawIndexReader = (VarByteChunkSVForwardIndexReader)forwardIndexReader;\n+        ChunkReaderContext chunkReaderContext = (ChunkReaderContext)readerContext;\n+        for (int docId = 0; docId < numDocs; docId++) {\n+          textIndexCreator.addDoc(rawIndexReader.getString(docId, chunkReaderContext), docId);\n+        }\n+      } else {\n+        // text index on dictionary encoded SV column\n+        // read forward index to get dictId\n+        // read the raw value from dictionary using dictId\n+        try (BaseImmutableDictionary dictionary = getDictionaryReader(columnMetadata)) {\n+          if (columnMetadata.isSingleValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd757223f33faac42815feaaa3bed4814ab118b"}, "originalPosition": 90}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cdd757223f33faac42815feaaa3bed4814ab118b", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/cdd757223f33faac42815feaaa3bed4814ab118b", "committedDate": "2020-07-16T17:20:05Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}, "afterCommit": {"oid": "7afda3f00cfaabcf966098ec3847993ee8063344", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/7afda3f00cfaabcf966098ec3847993ee8063344", "committedDate": "2020-07-17T01:33:22Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fb7f358d5fb0a4b6510a900fadd95a08def674c", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/7fb7f358d5fb0a4b6510a900fadd95a08def674c", "committedDate": "2020-07-17T03:32:29Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e422d6cfee230126fe2335d4ffcafccd71cbe4f", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/2e422d6cfee230126fe2335d4ffcafccd71cbe4f", "committedDate": "2020-07-17T01:34:52Z", "message": "format"}, "afterCommit": {"oid": "7fb7f358d5fb0a4b6510a900fadd95a08def674c", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/7fb7f358d5fb0a4b6510a900fadd95a08def674c", "committedDate": "2020-07-17T03:32:29Z", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 297, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}