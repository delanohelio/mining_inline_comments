{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5MzEzOTcx", "number": 5406, "title": "Adding support to execute functions during query compilation", "bodyText": "Adding support to execute functions during query compilation\n\nMoved FunctionRegistry from pinot-core to pinot-common\nAdding support for compilation time function invoker.\n\nNow that below queries are supported.\nSELECT * FROM T where ts < now()\nSELECT * FROM T where date < toDateTime(now(), 'yyyy-MM-dd z')\nnow() should be evaluated at the time of the query compilation. The logic introduced detects any function that has\n\nno arguments\nall arguments are literals or functions with all literal arguments (i.e. no column identifiers)\n\nThis PR introduces now() and datetimeFormat(String, String) as sample functions. There will be another PR that will add support for many other DateTime functions such as https://prestodb.io/docs/current/functions/datetime.html", "createdAt": "2020-05-18T07:35:17Z", "url": "https://github.com/apache/pinot/pull/5406", "merged": true, "mergeCommit": {"oid": "3f8ba7104869be4fcda5080631d546a5d7b30791"}, "closed": true, "closedAt": "2020-05-23T05:18:42Z", "author": {"login": "kishoreg"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcibABVAFqTQxMzM0MDQxOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcj-uRMgBqjMzNjY2NjI4NTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMzQwNDE5", "url": "https://github.com/apache/pinot/pull/5406#pullrequestreview-413340419", "createdAt": "2020-05-18T07:39:07Z", "commit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzozOTowN1rOGWq61Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo0NjozMFrOGWrJ4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyNTA0NQ==", "bodyText": "this should be recursively evaluated, technically a function of function of literal should still be true here.\nE.g. format_time(now(), 'yyyy-MM-dd')", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426425045", "createdAt": "2020-05-18T07:39:07Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);\n+              break;\n+            default:\n+              //no change, let the expression be handled during execution phase\n+          }\n+        }\n+\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {\n+\n+    boolean compileTimeEvaluationPossible = true;\n+    Function functionCall = funcExpr.getFunctionCall();\n+    if(functionCall.getOperandsSize() > 0) {\n+      for (Expression expression : functionCall.getOperands()) {\n+        if (expression.getType() != ExpressionType.LITERAL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ==", "bodyText": "better to implement method eval for each function which take operands list as argument which could be either literal or functions.\nThen this logic will just be\nfuncExpr = getScalarFunction(scalarFunctionType).eval(funcExpr.getFunctionCall().getOperands())", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426428899", "createdAt": "2020-05-18T07:46:30Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MDI0NzYy", "url": "https://github.com/apache/pinot/pull/5406#pullrequestreview-414024762", "createdAt": "2020-05-19T00:35:45Z", "commit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMDozNTo0NVrOGXL3RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMDo0MDoxNVrOGXL7sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NDgwNQ==", "bodyText": "What's the purpose of this? Flexibility to support variations of function names?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426964805", "createdAt": "2020-05-19T00:35:45Z", "author": {"login": "mayankshriv"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {\n+      String upperCaseFunctionName = value.getName().toUpperCase();\n+      _scalarFunctions.put(upperCaseFunctionName, value);\n+      _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA==", "bodyText": "Would it be easy to identify this based on function args, as opposed to pre-register?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426965020", "createdAt": "2020-05-19T00:36:41Z", "author": {"login": "mayankshriv"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA==", "bodyText": "Will this approach scale, as number of scalar functions increase? For example, each one would need to be added here. What do you think about modelling this as a query rewrite phase that goes over all scalars and evaluates them?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426965938", "createdAt": "2020-05-19T00:40:15Z", "author": {"login": "mayankshriv"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531", "author": {"user": {"login": "kishoreg", "name": "Kishore Gopalakrishna"}}, "url": "https://github.com/apache/pinot/commit/b91b4f33292c594307fe5e7087beae7f13dc0531", "committedDate": "2020-05-18T07:25:02Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "committedDate": "2020-05-19T10:40:39Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "committedDate": "2020-05-19T10:40:39Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "53acdfa8231d430232cefaa7cf09b75673abb90d", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/53acdfa8231d430232cefaa7cf09b75673abb90d", "committedDate": "2020-05-19T16:57:09Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "53acdfa8231d430232cefaa7cf09b75673abb90d", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/53acdfa8231d430232cefaa7cf09b75673abb90d", "committedDate": "2020-05-19T16:57:09Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "0e21590e08d954d73c0d28dd3ffa4b40727bdc25", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/0e21590e08d954d73c0d28dd3ffa4b40727bdc25", "committedDate": "2020-05-19T18:19:38Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e21590e08d954d73c0d28dd3ffa4b40727bdc25", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/0e21590e08d954d73c0d28dd3ffa4b40727bdc25", "committedDate": "2020-05-19T18:19:38Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "5ef20ce5a37b5c7a9fbe98de46fc75f5ca906a8e", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/5ef20ce5a37b5c7a9fbe98de46fc75f5ca906a8e", "committedDate": "2020-05-19T18:51:57Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ef20ce5a37b5c7a9fbe98de46fc75f5ca906a8e", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/5ef20ce5a37b5c7a9fbe98de46fc75f5ca906a8e", "committedDate": "2020-05-19T18:51:57Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "cbb6ad6dcc29ecbe7481717f6e2ff834800e44dd", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/cbb6ad6dcc29ecbe7481717f6e2ff834800e44dd", "committedDate": "2020-05-19T19:22:03Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbb6ad6dcc29ecbe7481717f6e2ff834800e44dd", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/cbb6ad6dcc29ecbe7481717f6e2ff834800e44dd", "committedDate": "2020-05-19T19:22:03Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "55c9814681067386671b37db749235eca0cded56", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/55c9814681067386671b37db749235eca0cded56", "committedDate": "2020-05-19T19:25:56Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "55c9814681067386671b37db749235eca0cded56", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/55c9814681067386671b37db749235eca0cded56", "committedDate": "2020-05-19T19:25:56Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/1368749a6375b6c94202b59a610a75b11dcabed0", "committedDate": "2020-05-19T19:31:32Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0Nzk5MjUz", "url": "https://github.com/apache/pinot/pull/5406#pullrequestreview-414799253", "createdAt": "2020-05-19T20:30:12Z", "commit": {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDozMDoxMlrOGXxdQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDozMDoxMlrOGXxdQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ==", "bodyText": "Instead of this, why don't we just have a constant value function registry  where all compile time evaluated functions are registered. So this check then becomes if the function is part of the constant value function registry.", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427580739", "createdAt": "2020-05-19T20:30:12Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +620,44 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n+          }\n+        }\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0"}, "originalPosition": 66}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/1368749a6375b6c94202b59a610a75b11dcabed0", "committedDate": "2020-05-19T19:31:32Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/9a4e8ca5e5343246c7f2c312c9826819426f5c42", "committedDate": "2020-05-19T23:09:23Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjY5ODI0", "url": "https://github.com/apache/pinot/pull/5406#pullrequestreview-416669824", "createdAt": "2020-05-22T06:11:02Z", "commit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjM3MzM3", "url": "https://github.com/apache/pinot/pull/5406#pullrequestreview-417237337", "createdAt": "2020-05-23T01:09:12Z", "commit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowOToxM1rOGZmoPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowOToxM1rOGZmoPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDQ3Nw==", "bodyText": "this function is the same as fromDateTime on line 217. Do we need both?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429500477", "createdAt": "2020-05-23T01:09:13Z", "author": {"login": "npawar"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java", "diffHunk": "@@ -216,4 +217,18 @@ static String toDateTime(Long millis, String pattern) {\n   static Long fromDateTime(String dateTimeString, String pattern) {\n     return DateTimePatternHandler.parseDateTimeStringToEpochMillis(dateTimeString, pattern);\n   }\n+\n+  /**\n+   * Return current time as epoch millis\n+   */\n+  static Long now() {\n+    return System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Return epoch millis value based on a given date time string and it's corresponding format.\n+   */\n+  public static Long formatDatetime(String input, String format) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjM4Nzk0", "url": "https://github.com/apache/pinot/pull/5406#pullrequestreview-417238794", "createdAt": "2020-05-23T01:26:44Z", "commit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNjo0NFrOGZmt0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNjo0NFrOGZmt0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTkwNg==", "bodyText": "i didn't quite follow why there is special casing for  DISTINCTCOUNT ?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429501906", "createdAt": "2020-05-23T01:26:44Z", "author": {"login": "npawar"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -593,29 +596,77 @@ private static Expression toExpression(SqlNode node) {\n           // Move on to process default logic.\n         }\n       default:\n-        SqlBasicCall funcSqlNode = (SqlBasicCall) node;\n-        String funcName = funcSqlNode.getOperator().getKind().name();\n-        if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n-          funcName = funcSqlNode.getOperator().getName();\n+        return evaluateFunctionExpression((SqlBasicCall) node);\n+    }\n+  }\n+\n+  private static String extractFunctionName(SqlBasicCall funcSqlNode) {\n+    String funcName = funcSqlNode.getOperator().getKind().name();\n+    if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n+      funcName = funcSqlNode.getOperator().getName();\n+    }\n+    if (funcName.equalsIgnoreCase(SqlKind.COUNT.toString()) && (funcSqlNode.getFunctionQuantifier() != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d84161496a68ff55916d2b4bb8fed401a65418b", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/8d84161496a68ff55916d2b4bb8fed401a65418b", "committedDate": "2020-05-23T03:57:53Z", "message": "Adding support to execute functions during query compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc89fe3aba61f035864cd1bda86e2c62642c4131", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/cc89fe3aba61f035864cd1bda86e2c62642c4131", "committedDate": "2020-05-23T03:57:53Z", "message": "Remove function formatDatetime"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/9a4e8ca5e5343246c7f2c312c9826819426f5c42", "committedDate": "2020-05-19T23:09:23Z", "message": "Adding support to execute functions during query compilation"}, "afterCommit": {"oid": "cc89fe3aba61f035864cd1bda86e2c62642c4131", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/cc89fe3aba61f035864cd1bda86e2c62642c4131", "committedDate": "2020-05-23T03:57:53Z", "message": "Remove function formatDatetime"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 800, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}