{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1ODE1MDA0", "number": 5074, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzowMTozN1rODgPYwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToyMzoxN1rODhOgtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTMzMTIxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzowMTozN1rOFqVx8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzowMTozN1rOFqVx8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk0MTM2MA==", "bodyText": "better name, also why do we need this constraint", "url": "https://github.com/apache/pinot/pull/5074#discussion_r379941360", "createdAt": "2020-02-16T23:01:37Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -285,6 +291,89 @@ protected void removeColumnV1Indices(String column)\n     SegmentColumnarIndexCreator.removeColumnMetadataInfo(_segmentProperties, column);\n   }\n \n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param column column name\n+   * @param indexLoadingConfig index loading config\n+   * @param fieldSpec field spec\n+   */\n+  private void checkUnsupForEnablingTextIndexOnNewColumn(String column, IndexLoadingConfig indexLoadingConfig,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9479293c10387dadd8216cf736c8b9fdc670a18a"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTMzMTc4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzowMjo0MlrOFqVyOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzowMjo0MlrOFqVyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk0MTQzMw==", "bodyText": "where is this invoked from?", "url": "https://github.com/apache/pinot/pull/5074#discussion_r379941433", "createdAt": "2020-02-16T23:02:42Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -285,6 +291,89 @@ protected void removeColumnV1Indices(String column)\n     SegmentColumnarIndexCreator.removeColumnMetadataInfo(_segmentProperties, column);\n   }\n \n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param column column name\n+   * @param indexLoadingConfig index loading config\n+   * @param fieldSpec field spec\n+   */\n+  private void checkUnsupForEnablingTextIndexOnNewColumn(String column, IndexLoadingConfig indexLoadingConfig,\n+      FieldSpec fieldSpec) {\n+    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");\n+    }\n+\n+    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n+    if (sortedColumns.contains(column)) {\n+      // since Pinot's current implementation doesn't support raw sorted columns,\n+      // we need to check for this too\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted columns\");\n+    }\n+\n+    if (!fieldSpec.isSingleValueField()) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on multi-value columns\");\n+    }\n+\n+    if (fieldSpec.getDataType() != FieldSpec.DataType.STRING) {\n+      throw new UnsupportedOperationException(\"Text index is currently only supported on STRING columns\");\n+    }\n+  }\n+\n+  void createRawForwardIndexForTextIndexEnabledColumn(String column, File segmentIndexDir,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9479293c10387dadd8216cf736c8b9fdc670a18a"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTMzMjU5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzowMzo1NlrOFqVyng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxMTo1MlrOFr3xmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk0MTUzNA==", "bodyText": "why do you need to create a raw forward index. This code can be removed", "url": "https://github.com/apache/pinot/pull/5074#discussion_r379941534", "createdAt": "2020-02-16T23:03:56Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "diffHunk": "@@ -61,21 +63,27 @@ protected void updateDefaultColumn(String column, DefaultColumnAction action)\n           \"Default value indices for column: \" + column + \" cannot be removed for V3 format segment.\");\n     }\n \n-    // Create new dictionary and forward index, and update column metadata\n-    createColumnV1Indices(column);\n-\n-    // Write index to V3 format.\n     FieldSpec fieldSpec = _schema.getFieldSpecFor(column);\n     Preconditions.checkNotNull(fieldSpec);\n     boolean isSingleValue = fieldSpec.isSingleValueField();\n-    File dictionaryFile = new File(_indexDir, column + V1Constants.Dict.FILE_EXTENSION);\n-    File forwardIndexFile;\n-    if (isSingleValue) {\n-      forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.SORTED_SV_FORWARD_INDEX_FILE_EXTENSION);\n+\n+    Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9479293c10387dadd8216cf736c8b9fdc670a18a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NjkwNA==", "bodyText": "Provided there are no assumptions anywhere that (text index == raw forward index).\nTo start with, it is ok to keep things consistent, and relax the constraints as we move forward.", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381546904", "createdAt": "2020-02-19T21:11:52Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "diffHunk": "@@ -61,21 +63,27 @@ protected void updateDefaultColumn(String column, DefaultColumnAction action)\n           \"Default value indices for column: \" + column + \" cannot be removed for V3 format segment.\");\n     }\n \n-    // Create new dictionary and forward index, and update column metadata\n-    createColumnV1Indices(column);\n-\n-    // Write index to V3 format.\n     FieldSpec fieldSpec = _schema.getFieldSpecFor(column);\n     Preconditions.checkNotNull(fieldSpec);\n     boolean isSingleValue = fieldSpec.isSingleValueField();\n-    File dictionaryFile = new File(_indexDir, column + V1Constants.Dict.FILE_EXTENSION);\n-    File forwardIndexFile;\n-    if (isSingleValue) {\n-      forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.SORTED_SV_FORWARD_INDEX_FILE_EXTENSION);\n+\n+    Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk0MTUzNA=="}, "originalCommit": {"oid": "9479293c10387dadd8216cf736c8b9fdc670a18a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTMzMjczOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzowNDoyMVrOFqVytg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzowNDoyMVrOFqVytg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk0MTU1OA==", "bodyText": "not sure why we need all these checks", "url": "https://github.com/apache/pinot/pull/5074#discussion_r379941558", "createdAt": "2020-02-16T23:04:21Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import org.apache.commons.configuration.PropertiesConfiguration;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.io.reader.DataFileReader;\n+import org.apache.pinot.core.io.reader.impl.v1.VarByteChunkSingleValueReader;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneTextIndexCreator;\n+import org.apache.pinot.core.segment.index.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.HAS_TEXT_INDEX;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.getKeyFor;\n+\n+\n+public class TextIndexHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(InvertedIndexHandler.class);\n+\n+  private final File _indexDir;\n+  private final SegmentDirectory.Writer _segmentWriter;\n+  private final String _segmentName;\n+  private final SegmentVersion _segmentVersion;\n+  private final Set<ColumnMetadata> _textIndexColumns = new HashSet<>();\n+\n+  public TextIndexHandler(@Nonnull File indexDir, @Nonnull SegmentMetadataImpl segmentMetadata,\n+      @Nonnull IndexLoadingConfig indexLoadingConfig, @Nonnull SegmentDirectory.Writer segmentWriter) {\n+    _indexDir = indexDir;\n+    _segmentWriter = segmentWriter;\n+    _segmentName = segmentMetadata.getName();\n+    _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+    for (String column : indexLoadingConfig.getTextIndexColumns()) {\n+      ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+      if (columnMetadata != null) {\n+        _textIndexColumns.add(columnMetadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Create text index for column during segment load time. Currently text index is always\n+   * created (if enabled on a column) during segment generation (true for both offline\n+   * and realtime segments). So this function is a NO-OP for case when a new segment is loaded\n+   * after creation. However, when segment reload is issued in the following scenarios, we generate\n+   * text index.\n+   *\n+   * SCENARIO 1: user enables text index on an existing column (table config change)\n+   * SCENARIO 2: user adds a new column and enables text index (both schema and table config change)\n+   *\n+   * This function is a NO-OP for the above two cases. Later we can also add a segment generator\n+   * config option to not necessarily generate text index during segment generation. When we do\n+   * so, this function should be able to take care of that scenario too.\n+   *\n+   * For scenario 2, {@link org.apache.pinot.core.segment.index.loader.defaultcolumn.V3DefaultColumnHandler}\n+   * would have already added the forward index for the column with default value. We use the forward\n+   * index here to get the raw data and build text index.\n+   *\n+   * @throws IOException\n+   */\n+  public void createTextIndexesOnSegmentLoad()\n+      throws Exception {\n+    for (ColumnMetadata columnMetadata : _textIndexColumns) {\n+      checkUnsupForEnablingTextIndexOnExistingColumn(columnMetadata);\n+      createTextIndexForColumn(columnMetadata);\n+    }\n+  }\n+\n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param columnMetadata metadata for column\n+   */\n+  private void checkUnsupForEnablingTextIndexOnExistingColumn(ColumnMetadata columnMetadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9479293c10387dadd8216cf736c8b9fdc670a18a"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODAwMDgwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/IndexLoadingConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjoyOTozN1rOFrU0Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMToyMTo0MFrOFtIpxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk3NDE2Mg==", "bodyText": "include column name in this exception", "url": "https://github.com/apache/pinot/pull/5074#discussion_r380974162", "createdAt": "2020-02-18T22:29:37Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/IndexLoadingConfig.java", "diffHunk": "@@ -135,7 +135,11 @@ private void extractTextIndexColumnsFromTableConfig(TableConfig tableConfig) {\n     if (fieldConfigList != null) {\n       for (FieldConfig fieldConfig : fieldConfigList) {\n         if (fieldConfig.getIndexType() == FieldConfig.IndexType.TEXT) {\n+          if (fieldConfig.getEncodingType() != FieldConfig.EncodingType.RAW) {\n+            throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MjAwNQ==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382872005", "createdAt": "2020-02-22T01:21:40Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/IndexLoadingConfig.java", "diffHunk": "@@ -135,7 +135,11 @@ private void extractTextIndexColumnsFromTableConfig(TableConfig tableConfig) {\n     if (fieldConfigList != null) {\n       for (FieldConfig fieldConfig : fieldConfigList) {\n         if (fieldConfig.getIndexType() == FieldConfig.IndexType.TEXT) {\n+          if (fieldConfig.getEncodingType() != FieldConfig.EncodingType.RAW) {\n+            throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk3NDE2Mg=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTU3NTI0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/V1Constants.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo1MToxMVrOFr3Jfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzo0ODoxMVrOFtJVRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjYzOQ==", "bodyText": "Since this is persistent metadata you should call it hasLuceneIndex . This will make sure that when we evolve to using native text index (or some other), we can still load old segments that have Lucene indexes and convert them correctly.\nOf course, this also means that you need to pass in the right text index type into methods as needed, instead of just a boolean.\nAnother alternative may be to change it to textIndexType and put Lucene in there.", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381536639", "createdAt": "2020-02-19T20:51:11Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/V1Constants.java", "diffHunk": "@@ -103,6 +103,7 @@\n       public static final String PARTITION_VALUES = \"partitionValues\";\n       public static final String DATETIME_FORMAT = \"datetimeFormat\";\n       public static final String DATETIME_GRANULARITY = \"datetimeGranularity\";\n+      public static final String HAS_TEXT_INDEX = \"hasTextIndex\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTk5Nw==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871997", "createdAt": "2020-02-22T01:21:37Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/V1Constants.java", "diffHunk": "@@ -103,6 +103,7 @@\n       public static final String PARTITION_VALUES = \"partitionValues\";\n       public static final String DATETIME_FORMAT = \"datetimeFormat\";\n       public static final String DATETIME_GRANULARITY = \"datetimeGranularity\";\n+      public static final String HAS_TEXT_INDEX = \"hasTextIndex\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjYzOQ=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MjI4MQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382872281", "createdAt": "2020-02-22T01:24:19Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/V1Constants.java", "diffHunk": "@@ -103,6 +103,7 @@\n       public static final String PARTITION_VALUES = \"partitionValues\";\n       public static final String DATETIME_FORMAT = \"datetimeFormat\";\n       public static final String DATETIME_GRANULARITY = \"datetimeGranularity\";\n+      public static final String HAS_TEXT_INDEX = \"hasTextIndex\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjYzOQ=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3OTQ2Mw==", "bodyText": "Why not just have text index type instead of a boolean and the type?  we can have an enum NONE to represent no text index, right?", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382879463", "createdAt": "2020-02-22T02:47:08Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/V1Constants.java", "diffHunk": "@@ -103,6 +103,7 @@\n       public static final String PARTITION_VALUES = \"partitionValues\";\n       public static final String DATETIME_FORMAT = \"datetimeFormat\";\n       public static final String DATETIME_GRANULARITY = \"datetimeGranularity\";\n+      public static final String HAS_TEXT_INDEX = \"hasTextIndex\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjYzOQ=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MzE0Mg==", "bodyText": "Yes, NONE is good.", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382883142", "createdAt": "2020-02-22T03:48:11Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/V1Constants.java", "diffHunk": "@@ -103,6 +103,7 @@\n       public static final String PARTITION_VALUES = \"partitionValues\";\n       public static final String DATETIME_FORMAT = \"datetimeFormat\";\n       public static final String DATETIME_GRANULARITY = \"datetimeGranularity\";\n+      public static final String HAS_TEXT_INDEX = \"hasTextIndex\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjYzOQ=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTYxNjcyOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTowMzo1OVrOFr3ijQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMToyMTozNVrOFtIptA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzA1Mw==", "bodyText": "You should include the column name in each of these exceptions.\nAlternatrively, it may be better to return a boolean, and use PreConditions in the caller and include the column name in the exception thrown.", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381543053", "createdAt": "2020-02-19T21:03:59Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -285,6 +291,89 @@ protected void removeColumnV1Indices(String column)\n     SegmentColumnarIndexCreator.removeColumnMetadataInfo(_segmentProperties, column);\n   }\n \n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param column column name\n+   * @param indexLoadingConfig index loading config\n+   * @param fieldSpec field spec\n+   */\n+  private void checkUnsupForEnablingTextIndexOnNewColumn(String column, IndexLoadingConfig indexLoadingConfig,\n+      FieldSpec fieldSpec) {\n+    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTk4OA==", "bodyText": "Included the column name", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871988", "createdAt": "2020-02-22T01:21:35Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -285,6 +291,89 @@ protected void removeColumnV1Indices(String column)\n     SegmentColumnarIndexCreator.removeColumnMetadataInfo(_segmentProperties, column);\n   }\n \n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param column column name\n+   * @param indexLoadingConfig index loading config\n+   * @param fieldSpec field spec\n+   */\n+  private void checkUnsupForEnablingTextIndexOnNewColumn(String column, IndexLoadingConfig indexLoadingConfig,\n+      FieldSpec fieldSpec) {\n+    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzA1Mw=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTYyMDI4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTowNTowMlrOFr3ksQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMToyMTozMVrOFtIpmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzYwMQ==", "bodyText": "I think make this a Preconditions statement with a booleanm return, and include column namne in the exception is easier.", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381543601", "createdAt": "2020-02-19T21:05:02Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -285,6 +291,89 @@ protected void removeColumnV1Indices(String column)\n     SegmentColumnarIndexCreator.removeColumnMetadataInfo(_segmentProperties, column);\n   }\n \n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param column column name\n+   * @param indexLoadingConfig index loading config\n+   * @param fieldSpec field spec\n+   */\n+  private void checkUnsupForEnablingTextIndexOnNewColumn(String column, IndexLoadingConfig indexLoadingConfig,\n+      FieldSpec fieldSpec) {\n+    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");\n+    }\n+\n+    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n+    if (sortedColumns.contains(column)) {\n+      // since Pinot's current implementation doesn't support raw sorted columns,\n+      // we need to check for this too\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted columns\");\n+    }\n+\n+    if (!fieldSpec.isSingleValueField()) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on multi-value columns\");\n+    }\n+\n+    if (fieldSpec.getDataType() != FieldSpec.DataType.STRING) {\n+      throw new UnsupportedOperationException(\"Text index is currently only supported on STRING columns\");\n+    }\n+  }\n+\n+  void createRawForwardIndexForTextIndexEnabledColumn(String column, File segmentIndexDir,\n+      SegmentDirectory.Writer segmentWriter, IndexLoadingConfig indexLoadingConfig)\n+      throws IOException {\n+    FieldSpec fieldSpec = _schema.getFieldSpecFor(column);\n+    Preconditions.checkNotNull(fieldSpec);\n+    checkUnsupForEnablingTextIndexOnNewColumn(column, indexLoadingConfig, fieldSpec);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTk2Mw==", "bodyText": "Yes but that way we won't capture the reason (which unsupported operation it it). I included the column name in exception", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871963", "createdAt": "2020-02-22T01:21:31Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -285,6 +291,89 @@ protected void removeColumnV1Indices(String column)\n     SegmentColumnarIndexCreator.removeColumnMetadataInfo(_segmentProperties, column);\n   }\n \n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param column column name\n+   * @param indexLoadingConfig index loading config\n+   * @param fieldSpec field spec\n+   */\n+  private void checkUnsupForEnablingTextIndexOnNewColumn(String column, IndexLoadingConfig indexLoadingConfig,\n+      FieldSpec fieldSpec) {\n+    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");\n+    }\n+\n+    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n+    if (sortedColumns.contains(column)) {\n+      // since Pinot's current implementation doesn't support raw sorted columns,\n+      // we need to check for this too\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted columns\");\n+    }\n+\n+    if (!fieldSpec.isSingleValueField()) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on multi-value columns\");\n+    }\n+\n+    if (fieldSpec.getDataType() != FieldSpec.DataType.STRING) {\n+      throw new UnsupportedOperationException(\"Text index is currently only supported on STRING columns\");\n+    }\n+  }\n+\n+  void createRawForwardIndexForTextIndexEnabledColumn(String column, File segmentIndexDir,\n+      SegmentDirectory.Writer segmentWriter, IndexLoadingConfig indexLoadingConfig)\n+      throws IOException {\n+    FieldSpec fieldSpec = _schema.getFieldSpecFor(column);\n+    Preconditions.checkNotNull(fieldSpec);\n+    checkUnsupForEnablingTextIndexOnNewColumn(column, indexLoadingConfig, fieldSpec);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzYwMQ=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTYzMDM0OnYy", "diffSide": "LEFT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTowODozMlrOFr3rDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMToyMToyOFrOFtIpmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NTIzMA==", "bodyText": "Hmm.. Does this mean that we always created dictionary even if the column had raw index? Of course, it should not matter, since the column has only one default value, and having the dictonary is better (storage-wise). As long as segment metadata is treated as the source of truth, we are good.", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381545230", "createdAt": "2020-02-19T21:08:32Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "diffHunk": "@@ -61,21 +63,27 @@ protected void updateDefaultColumn(String column, DefaultColumnAction action)\n           \"Default value indices for column: \" + column + \" cannot be removed for V3 format segment.\");\n     }\n \n-    // Create new dictionary and forward index, and update column metadata\n-    createColumnV1Indices(column);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTk2MA==", "bodyText": "This is existing behavior (I mean not changed as part of this PR. Github doesn't do a good job of recognizing even little bit of code movement ).\nI noticed this as well. I am not sure why we do this. Can look into it separately", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871960", "createdAt": "2020-02-22T01:21:28Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "diffHunk": "@@ -61,21 +63,27 @@ protected void updateDefaultColumn(String column, DefaultColumnAction action)\n           \"Default value indices for column: \" + column + \" cannot be removed for V3 format segment.\");\n     }\n \n-    // Create new dictionary and forward index, and update column metadata\n-    createColumnV1Indices(column);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NTIzMA=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTY0NTY3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxMzozNFrOFr30yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMToyMToyNFrOFtIpjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NzcyMQ==", "bodyText": "TextIndexPreprocessor? Is this code always invoked during segment pre-process?", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381547721", "createdAt": "2020-02-19T21:13:34Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import org.apache.commons.configuration.PropertiesConfiguration;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.io.reader.DataFileReader;\n+import org.apache.pinot.core.io.reader.impl.v1.VarByteChunkSingleValueReader;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneTextIndexCreator;\n+import org.apache.pinot.core.segment.index.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.HAS_TEXT_INDEX;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.getKeyFor;\n+\n+\n+public class TextIndexHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(InvertedIndexHandler.class);\n+\n+  private final File _indexDir;\n+  private final SegmentDirectory.Writer _segmentWriter;\n+  private final String _segmentName;\n+  private final SegmentVersion _segmentVersion;\n+  private final Set<ColumnMetadata> _textIndexColumns = new HashSet<>();\n+\n+  public TextIndexHandler(@Nonnull File indexDir, @Nonnull SegmentMetadataImpl segmentMetadata,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTk0OQ==", "bodyText": "SegmentPreprocessor invokes this if there are one or more text columns in IndexLoadingConfig. Used the \"handler\" suffix to be consistent with existing InvertedIndexHandler class", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871949", "createdAt": "2020-02-22T01:21:24Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import org.apache.commons.configuration.PropertiesConfiguration;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.io.reader.DataFileReader;\n+import org.apache.pinot.core.io.reader.impl.v1.VarByteChunkSingleValueReader;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneTextIndexCreator;\n+import org.apache.pinot.core.segment.index.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.HAS_TEXT_INDEX;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.getKeyFor;\n+\n+\n+public class TextIndexHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(InvertedIndexHandler.class);\n+\n+  private final File _indexDir;\n+  private final SegmentDirectory.Writer _segmentWriter;\n+  private final String _segmentName;\n+  private final SegmentVersion _segmentVersion;\n+  private final Set<ColumnMetadata> _textIndexColumns = new HashSet<>();\n+\n+  public TextIndexHandler(@Nonnull File indexDir, @Nonnull SegmentMetadataImpl segmentMetadata,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NzcyMQ=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTY1MDE2OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxNToxM1rOFr33rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMToyMToyMFrOFtIpgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODQ2MQ==", "bodyText": "Same comment as before, about column names and use of Precondition with a boolean return", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381548461", "createdAt": "2020-02-19T21:15:13Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import org.apache.commons.configuration.PropertiesConfiguration;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.io.reader.DataFileReader;\n+import org.apache.pinot.core.io.reader.impl.v1.VarByteChunkSingleValueReader;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneTextIndexCreator;\n+import org.apache.pinot.core.segment.index.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.HAS_TEXT_INDEX;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.getKeyFor;\n+\n+\n+public class TextIndexHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(InvertedIndexHandler.class);\n+\n+  private final File _indexDir;\n+  private final SegmentDirectory.Writer _segmentWriter;\n+  private final String _segmentName;\n+  private final SegmentVersion _segmentVersion;\n+  private final Set<ColumnMetadata> _textIndexColumns = new HashSet<>();\n+\n+  public TextIndexHandler(@Nonnull File indexDir, @Nonnull SegmentMetadataImpl segmentMetadata,\n+      @Nonnull IndexLoadingConfig indexLoadingConfig, @Nonnull SegmentDirectory.Writer segmentWriter) {\n+    _indexDir = indexDir;\n+    _segmentWriter = segmentWriter;\n+    _segmentName = segmentMetadata.getName();\n+    _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+    for (String column : indexLoadingConfig.getTextIndexColumns()) {\n+      ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+      if (columnMetadata != null) {\n+        _textIndexColumns.add(columnMetadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Create text index for column during segment load time. Currently text index is always\n+   * created (if enabled on a column) during segment generation (true for both offline\n+   * and realtime segments). So this function is a NO-OP for case when a new segment is loaded\n+   * after creation. However, when segment reload is issued in the following scenarios, we generate\n+   * text index.\n+   *\n+   * SCENARIO 1: user enables text index on an existing column (table config change)\n+   * SCENARIO 2: user adds a new column and enables text index (both schema and table config change)\n+   *\n+   * This function is a NO-OP for the above two cases. Later we can also add a segment generator\n+   * config option to not necessarily generate text index during segment generation. When we do\n+   * so, this function should be able to take care of that scenario too.\n+   *\n+   * For scenario 2, {@link org.apache.pinot.core.segment.index.loader.defaultcolumn.V3DefaultColumnHandler}\n+   * would have already added the forward index for the column with default value. We use the forward\n+   * index here to get the raw data and build text index.\n+   *\n+   * @throws IOException\n+   */\n+  public void createTextIndexesOnSegmentLoad()\n+      throws Exception {\n+    for (ColumnMetadata columnMetadata : _textIndexColumns) {\n+      checkUnsupForEnablingTextIndexOnExistingColumn(columnMetadata);\n+      createTextIndexForColumn(columnMetadata);\n+    }\n+  }\n+\n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param columnMetadata metadata for column\n+   */\n+  private void checkUnsupForEnablingTextIndexOnExistingColumn(ColumnMetadata columnMetadata) {\n+    if (columnMetadata.hasDictionary()) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTkzOQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871939", "createdAt": "2020-02-22T01:21:20Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import org.apache.commons.configuration.PropertiesConfiguration;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.io.reader.DataFileReader;\n+import org.apache.pinot.core.io.reader.impl.v1.VarByteChunkSingleValueReader;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneTextIndexCreator;\n+import org.apache.pinot.core.segment.index.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.HAS_TEXT_INDEX;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.getKeyFor;\n+\n+\n+public class TextIndexHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(InvertedIndexHandler.class);\n+\n+  private final File _indexDir;\n+  private final SegmentDirectory.Writer _segmentWriter;\n+  private final String _segmentName;\n+  private final SegmentVersion _segmentVersion;\n+  private final Set<ColumnMetadata> _textIndexColumns = new HashSet<>();\n+\n+  public TextIndexHandler(@Nonnull File indexDir, @Nonnull SegmentMetadataImpl segmentMetadata,\n+      @Nonnull IndexLoadingConfig indexLoadingConfig, @Nonnull SegmentDirectory.Writer segmentWriter) {\n+    _indexDir = indexDir;\n+    _segmentWriter = segmentWriter;\n+    _segmentName = segmentMetadata.getName();\n+    _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+    for (String column : indexLoadingConfig.getTextIndexColumns()) {\n+      ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+      if (columnMetadata != null) {\n+        _textIndexColumns.add(columnMetadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Create text index for column during segment load time. Currently text index is always\n+   * created (if enabled on a column) during segment generation (true for both offline\n+   * and realtime segments). So this function is a NO-OP for case when a new segment is loaded\n+   * after creation. However, when segment reload is issued in the following scenarios, we generate\n+   * text index.\n+   *\n+   * SCENARIO 1: user enables text index on an existing column (table config change)\n+   * SCENARIO 2: user adds a new column and enables text index (both schema and table config change)\n+   *\n+   * This function is a NO-OP for the above two cases. Later we can also add a segment generator\n+   * config option to not necessarily generate text index during segment generation. When we do\n+   * so, this function should be able to take care of that scenario too.\n+   *\n+   * For scenario 2, {@link org.apache.pinot.core.segment.index.loader.defaultcolumn.V3DefaultColumnHandler}\n+   * would have already added the forward index for the column with default value. We use the forward\n+   * index here to get the raw data and build text index.\n+   *\n+   * @throws IOException\n+   */\n+  public void createTextIndexesOnSegmentLoad()\n+      throws Exception {\n+    for (ColumnMetadata columnMetadata : _textIndexColumns) {\n+      checkUnsupForEnablingTextIndexOnExistingColumn(columnMetadata);\n+      createTextIndexForColumn(columnMetadata);\n+    }\n+  }\n+\n+  /**\n+   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * single-value STRING columns. Eventually we will relax the constraints\n+   * step by step.\n+   * For example, later on user should be able to create text index on\n+   * a dictionary encoded STRING column that also has native Pinot's inverted\n+   * index. We can also support it on BYTE columns later.\n+   * @param columnMetadata metadata for column\n+   */\n+  private void checkUnsupForEnablingTextIndexOnExistingColumn(ColumnMetadata columnMetadata) {\n+    if (columnMetadata.hasDictionary()) {\n+      throw new UnsupportedOperationException(\"Text index is currently not supported on dictionary encoded columns\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODQ2MQ=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTY2Mzc3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/store/ColumnIndexType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxOTo1NFrOFr4AWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMToyMToxN1rOFtIpfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MDY4MA==", "bodyText": "I am not sure whether this is persisted or not. If it is, then we may need to rename this also to include lucene", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381550680", "createdAt": "2020-02-19T21:19:54Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/store/ColumnIndexType.java", "diffHunk": "@@ -23,7 +23,8 @@\n   FORWARD_INDEX(\"forward_index\"),\n   INVERTED_INDEX(\"inverted_index\"),\n   BLOOM_FILTER(\"bloom_filter\"),\n-  NULLVALUE_VECTOR(\"nullvalue_vector\");\n+  NULLVALUE_VECTOR(\"nullvalue_vector\"),\n+  TEXT_INDEX(\"text_index\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTkzNA==", "bodyText": "This is non-persistent", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871934", "createdAt": "2020-02-22T01:21:17Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/store/ColumnIndexType.java", "diffHunk": "@@ -23,7 +23,8 @@\n   FORWARD_INDEX(\"forward_index\"),\n   INVERTED_INDEX(\"inverted_index\"),\n   BLOOM_FILTER(\"bloom_filter\"),\n-  NULLVALUE_VECTOR(\"nullvalue_vector\");\n+  NULLVALUE_VECTOR(\"nullvalue_vector\"),\n+  TEXT_INDEX(\"text_index\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MDY4MA=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTY3MzUwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToyMzoxN1rOFr4GkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMToyMToxM1rOFtIpdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MjI3Mw==", "bodyText": "It is best to check for as close to the exception thrown as possible. Otherwise, if we throw some exception from some other part of the code, we will catch that here and assume that the test passed.\nI would not be opposed to checking the exact exception message here, with the column name, for example. It will also help us refine our messages to be consistent when the exceptions are thrown", "url": "https://github.com/apache/pinot/pull/5074#discussion_r381552273", "createdAt": "2020-02-19T21:23:17Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -140,6 +154,124 @@ private void constructV3Segment()\n     new SegmentV1V2ToV3FormatConverter().convert(_indexDir);\n   }\n \n+  /**\n+   * Test to check for default column handling and text index creation during\n+   * segment load after a new column is added to the schema with text index\n+   * creation enabled\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnNewlyAddedStringColumn() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(NEWLY_ADDED_STRING_COL);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(NEWLY_ADDED_STRING_COL);\n+    Assert.assertNull(columnMetadata);\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+\n+      segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+      columnMetadata = segmentMetadata.getColumnMetadataFor(NEWLY_ADDED_STRING_COL);\n+      Assert.assertNotNull(columnMetadata);\n+      Assert.assertEquals(columnMetadata.getCardinality(), 1);\n+      Assert.assertEquals(columnMetadata.getTotalDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalRawDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalAggDocs(), 0);\n+      Assert.assertEquals(columnMetadata.getDataType(), FieldSpec.DataType.STRING);\n+      Assert.assertEquals(columnMetadata.getBitsPerElement(), 1);\n+      Assert.assertEquals(columnMetadata.getColumnMaxLength(), 0);\n+      Assert.assertEquals(columnMetadata.getFieldType(), FieldSpec.FieldType.DIMENSION);\n+      Assert.assertFalse(columnMetadata.isSorted());\n+      Assert.assertFalse(columnMetadata.hasNulls());\n+      Assert.assertFalse(columnMetadata.hasDictionary());\n+      Assert.assertFalse(columnMetadata.hasInvertedIndex());\n+      Assert.assertTrue(columnMetadata.hasTextIndex());\n+      Assert.assertTrue(columnMetadata.isSingleValue());\n+      Assert.assertEquals(columnMetadata.getMaxNumberOfMultiValues(), 0);\n+      Assert.assertEquals(columnMetadata.getTotalNumberOfEntries(), 100000);\n+      Assert.assertTrue(columnMetadata.isAutoGenerated());\n+      Assert.assertEquals(columnMetadata.getDefaultNullValueString(), \"null\");\n+\n+      try (SegmentDirectory segmentDirectory = SegmentDirectory.createFromLocalFS(_indexDir, ReadMode.mmap);\n+          SegmentDirectory.Reader reader = segmentDirectory.createReader()) {\n+        Assert.assertTrue(reader.hasIndexFor(NEWLY_ADDED_STRING_COL, ColumnIndexType.TEXT_INDEX));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Test to check text index creation during segment load after text index\n+   * creation is enabled on an existing column\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnExistingColumn() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(EXISTING_STRING_COL_RAW);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_RAW);\n+    Assert.assertNotNull(columnMetadata);\n+    Assert.assertFalse(columnMetadata.hasTextIndex());\n+\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+      segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+      columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_RAW);\n+\n+      Assert.assertEquals(columnMetadata.getCardinality(), 5);\n+      Assert.assertEquals(columnMetadata.getTotalDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalRawDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalAggDocs(), 0);\n+      Assert.assertEquals(columnMetadata.getDataType(), FieldSpec.DataType.STRING);\n+      Assert.assertEquals(columnMetadata.getBitsPerElement(), 3);\n+      Assert.assertEquals(columnMetadata.getColumnMaxLength(), 0);\n+      Assert.assertEquals(columnMetadata.getFieldType(), FieldSpec.FieldType.DIMENSION);\n+      Assert.assertFalse(columnMetadata.isSorted());\n+      Assert.assertFalse(columnMetadata.hasNulls());\n+      Assert.assertFalse(columnMetadata.hasDictionary());\n+      Assert.assertTrue(columnMetadata.hasTextIndex());\n+      Assert.assertTrue(columnMetadata.isSingleValue());\n+      Assert.assertEquals(columnMetadata.getMaxNumberOfMultiValues(), 0);\n+      Assert.assertEquals(columnMetadata.getTotalNumberOfEntries(), 100000);\n+      Assert.assertFalse(columnMetadata.isAutoGenerated());\n+      Assert.assertEquals(columnMetadata.getDefaultNullValueString(), \"null\");\n+\n+      try (SegmentDirectory segmentDirectory = SegmentDirectory.createFromLocalFS(_indexDir, ReadMode.mmap);\n+          SegmentDirectory.Reader reader = segmentDirectory.createReader()) {\n+        Assert.assertTrue(reader.hasIndexFor(EXISTING_STRING_COL_RAW, ColumnIndexType.TEXT_INDEX));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Test to check for failure case where text index is enabled on an existing\n+   * column that is dictionary encoded. This is currently not supported.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnExistingColumnDictEncoded() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(EXISTING_STRING_COL_DICT);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_DICT);\n+    Assert.assertNotNull(columnMetadata);\n+    Assert.assertFalse(columnMetadata.hasTextIndex());\n+\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+      Assert.fail(\"operation should have failed\");\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTkyMg==", "bodyText": "Assert.fail ensures that if exception is not thrown by line above, the test will fail. I am now checking for the full error message including column name", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871922", "createdAt": "2020-02-22T01:21:09Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -140,6 +154,124 @@ private void constructV3Segment()\n     new SegmentV1V2ToV3FormatConverter().convert(_indexDir);\n   }\n \n+  /**\n+   * Test to check for default column handling and text index creation during\n+   * segment load after a new column is added to the schema with text index\n+   * creation enabled\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnNewlyAddedStringColumn() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(NEWLY_ADDED_STRING_COL);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(NEWLY_ADDED_STRING_COL);\n+    Assert.assertNull(columnMetadata);\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+\n+      segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+      columnMetadata = segmentMetadata.getColumnMetadataFor(NEWLY_ADDED_STRING_COL);\n+      Assert.assertNotNull(columnMetadata);\n+      Assert.assertEquals(columnMetadata.getCardinality(), 1);\n+      Assert.assertEquals(columnMetadata.getTotalDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalRawDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalAggDocs(), 0);\n+      Assert.assertEquals(columnMetadata.getDataType(), FieldSpec.DataType.STRING);\n+      Assert.assertEquals(columnMetadata.getBitsPerElement(), 1);\n+      Assert.assertEquals(columnMetadata.getColumnMaxLength(), 0);\n+      Assert.assertEquals(columnMetadata.getFieldType(), FieldSpec.FieldType.DIMENSION);\n+      Assert.assertFalse(columnMetadata.isSorted());\n+      Assert.assertFalse(columnMetadata.hasNulls());\n+      Assert.assertFalse(columnMetadata.hasDictionary());\n+      Assert.assertFalse(columnMetadata.hasInvertedIndex());\n+      Assert.assertTrue(columnMetadata.hasTextIndex());\n+      Assert.assertTrue(columnMetadata.isSingleValue());\n+      Assert.assertEquals(columnMetadata.getMaxNumberOfMultiValues(), 0);\n+      Assert.assertEquals(columnMetadata.getTotalNumberOfEntries(), 100000);\n+      Assert.assertTrue(columnMetadata.isAutoGenerated());\n+      Assert.assertEquals(columnMetadata.getDefaultNullValueString(), \"null\");\n+\n+      try (SegmentDirectory segmentDirectory = SegmentDirectory.createFromLocalFS(_indexDir, ReadMode.mmap);\n+          SegmentDirectory.Reader reader = segmentDirectory.createReader()) {\n+        Assert.assertTrue(reader.hasIndexFor(NEWLY_ADDED_STRING_COL, ColumnIndexType.TEXT_INDEX));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Test to check text index creation during segment load after text index\n+   * creation is enabled on an existing column\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnExistingColumn() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(EXISTING_STRING_COL_RAW);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_RAW);\n+    Assert.assertNotNull(columnMetadata);\n+    Assert.assertFalse(columnMetadata.hasTextIndex());\n+\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+      segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+      columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_RAW);\n+\n+      Assert.assertEquals(columnMetadata.getCardinality(), 5);\n+      Assert.assertEquals(columnMetadata.getTotalDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalRawDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalAggDocs(), 0);\n+      Assert.assertEquals(columnMetadata.getDataType(), FieldSpec.DataType.STRING);\n+      Assert.assertEquals(columnMetadata.getBitsPerElement(), 3);\n+      Assert.assertEquals(columnMetadata.getColumnMaxLength(), 0);\n+      Assert.assertEquals(columnMetadata.getFieldType(), FieldSpec.FieldType.DIMENSION);\n+      Assert.assertFalse(columnMetadata.isSorted());\n+      Assert.assertFalse(columnMetadata.hasNulls());\n+      Assert.assertFalse(columnMetadata.hasDictionary());\n+      Assert.assertTrue(columnMetadata.hasTextIndex());\n+      Assert.assertTrue(columnMetadata.isSingleValue());\n+      Assert.assertEquals(columnMetadata.getMaxNumberOfMultiValues(), 0);\n+      Assert.assertEquals(columnMetadata.getTotalNumberOfEntries(), 100000);\n+      Assert.assertFalse(columnMetadata.isAutoGenerated());\n+      Assert.assertEquals(columnMetadata.getDefaultNullValueString(), \"null\");\n+\n+      try (SegmentDirectory segmentDirectory = SegmentDirectory.createFromLocalFS(_indexDir, ReadMode.mmap);\n+          SegmentDirectory.Reader reader = segmentDirectory.createReader()) {\n+        Assert.assertTrue(reader.hasIndexFor(EXISTING_STRING_COL_RAW, ColumnIndexType.TEXT_INDEX));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Test to check for failure case where text index is enabled on an existing\n+   * column that is dictionary encoded. This is currently not supported.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnExistingColumnDictEncoded() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(EXISTING_STRING_COL_DICT);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_DICT);\n+    Assert.assertNotNull(columnMetadata);\n+    Assert.assertFalse(columnMetadata.hasTextIndex());\n+\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+      Assert.fail(\"operation should have failed\");\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MjI3Mw=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTkyNA==", "bodyText": "Assert.fail ensures that if exception is not thrown by line above, the test will fail. I am now checking for the full error message including column name", "url": "https://github.com/apache/pinot/pull/5074#discussion_r382871924", "createdAt": "2020-02-22T01:21:13Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -140,6 +154,124 @@ private void constructV3Segment()\n     new SegmentV1V2ToV3FormatConverter().convert(_indexDir);\n   }\n \n+  /**\n+   * Test to check for default column handling and text index creation during\n+   * segment load after a new column is added to the schema with text index\n+   * creation enabled\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnNewlyAddedStringColumn() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(NEWLY_ADDED_STRING_COL);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(NEWLY_ADDED_STRING_COL);\n+    Assert.assertNull(columnMetadata);\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+\n+      segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+      columnMetadata = segmentMetadata.getColumnMetadataFor(NEWLY_ADDED_STRING_COL);\n+      Assert.assertNotNull(columnMetadata);\n+      Assert.assertEquals(columnMetadata.getCardinality(), 1);\n+      Assert.assertEquals(columnMetadata.getTotalDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalRawDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalAggDocs(), 0);\n+      Assert.assertEquals(columnMetadata.getDataType(), FieldSpec.DataType.STRING);\n+      Assert.assertEquals(columnMetadata.getBitsPerElement(), 1);\n+      Assert.assertEquals(columnMetadata.getColumnMaxLength(), 0);\n+      Assert.assertEquals(columnMetadata.getFieldType(), FieldSpec.FieldType.DIMENSION);\n+      Assert.assertFalse(columnMetadata.isSorted());\n+      Assert.assertFalse(columnMetadata.hasNulls());\n+      Assert.assertFalse(columnMetadata.hasDictionary());\n+      Assert.assertFalse(columnMetadata.hasInvertedIndex());\n+      Assert.assertTrue(columnMetadata.hasTextIndex());\n+      Assert.assertTrue(columnMetadata.isSingleValue());\n+      Assert.assertEquals(columnMetadata.getMaxNumberOfMultiValues(), 0);\n+      Assert.assertEquals(columnMetadata.getTotalNumberOfEntries(), 100000);\n+      Assert.assertTrue(columnMetadata.isAutoGenerated());\n+      Assert.assertEquals(columnMetadata.getDefaultNullValueString(), \"null\");\n+\n+      try (SegmentDirectory segmentDirectory = SegmentDirectory.createFromLocalFS(_indexDir, ReadMode.mmap);\n+          SegmentDirectory.Reader reader = segmentDirectory.createReader()) {\n+        Assert.assertTrue(reader.hasIndexFor(NEWLY_ADDED_STRING_COL, ColumnIndexType.TEXT_INDEX));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Test to check text index creation during segment load after text index\n+   * creation is enabled on an existing column\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnExistingColumn() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(EXISTING_STRING_COL_RAW);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_RAW);\n+    Assert.assertNotNull(columnMetadata);\n+    Assert.assertFalse(columnMetadata.hasTextIndex());\n+\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+      segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+      columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_RAW);\n+\n+      Assert.assertEquals(columnMetadata.getCardinality(), 5);\n+      Assert.assertEquals(columnMetadata.getTotalDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalRawDocs(), 100000);\n+      Assert.assertEquals(columnMetadata.getTotalAggDocs(), 0);\n+      Assert.assertEquals(columnMetadata.getDataType(), FieldSpec.DataType.STRING);\n+      Assert.assertEquals(columnMetadata.getBitsPerElement(), 3);\n+      Assert.assertEquals(columnMetadata.getColumnMaxLength(), 0);\n+      Assert.assertEquals(columnMetadata.getFieldType(), FieldSpec.FieldType.DIMENSION);\n+      Assert.assertFalse(columnMetadata.isSorted());\n+      Assert.assertFalse(columnMetadata.hasNulls());\n+      Assert.assertFalse(columnMetadata.hasDictionary());\n+      Assert.assertTrue(columnMetadata.hasTextIndex());\n+      Assert.assertTrue(columnMetadata.isSingleValue());\n+      Assert.assertEquals(columnMetadata.getMaxNumberOfMultiValues(), 0);\n+      Assert.assertEquals(columnMetadata.getTotalNumberOfEntries(), 100000);\n+      Assert.assertFalse(columnMetadata.isAutoGenerated());\n+      Assert.assertEquals(columnMetadata.getDefaultNullValueString(), \"null\");\n+\n+      try (SegmentDirectory segmentDirectory = SegmentDirectory.createFromLocalFS(_indexDir, ReadMode.mmap);\n+          SegmentDirectory.Reader reader = segmentDirectory.createReader()) {\n+        Assert.assertTrue(reader.hasIndexFor(EXISTING_STRING_COL_RAW, ColumnIndexType.TEXT_INDEX));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Test to check for failure case where text index is enabled on an existing\n+   * column that is dictionary encoded. This is currently not supported.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testEnableTextIndexOnExistingColumnDictEncoded() throws Exception {\n+    constructV3Segment();\n+    Set<String> textIndexColumns = new HashSet<>();\n+    textIndexColumns.add(EXISTING_STRING_COL_DICT);\n+    _indexLoadingConfig.setTextIndexColumns(textIndexColumns);\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(EXISTING_STRING_COL_DICT);\n+    Assert.assertNotNull(columnMetadata);\n+    Assert.assertFalse(columnMetadata.hasTextIndex());\n+\n+    try (SegmentPreProcessor processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchemaWithText)) {\n+      processor.process();\n+      Assert.fail(\"operation should have failed\");\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MjI3Mw=="}, "originalCommit": {"oid": "de4833d00072a43e1f14a229ebbda0a922c9c140"}, "originalPosition": 177}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3459, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}