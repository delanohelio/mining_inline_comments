{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM2NTI4MTkw", "number": 6346, "title": "Introduce DimensionTableDataManager", "bodyText": "Description\nAdding DimensionTableDataManager for managing data access for 'Dimension Tables'. It will be used by the upcoming LookupTransformFunction as outlined in Lookup UDF Join In Pinot document.\nThis is a followup to the PR: Adding offline dimension table creation and segment assignment and will be followed by a third PR to create the LookupTransformFunction soon. If you'd like to see a full end-to-end proof of concept implementation please take a look at here.\nDimensionTableDataManager is implemented as an extension of OfflineTableDataManager since Dimension tables are modeled as Offline tables with a couple additional features. DimensionTableDataManager has a private constructor and its Instances are 'per-table' singletons which are created/accessed via static methods: createInstanceByTableName and getInstanceByTableName. This is to make it possible for the transform functions to be able to access Dimension tables, without having to change the TransformFunction interface, which would have been very intrusive.\nIn this implementation, DimensionTableDataManager simply loads the contents of a Dimension table into a HashMap on addSegment hook. Entries are keyed by table's PrimaryKey, and are available for querying via method lookupRowByPrimaryKey.\nA couple of known shortcomings:\n\nSize of the table is not bounded: This will be addressed in a separate work as quota config enforcement at table creation flow.\nSchema changes require server restart: This can be addressed in the next iteration of the feature, once basic feature is finalized.\n\nTesting\n\nUnit tests are added\nA JoinQuickStart is added for local manual testing.\nA manual end-to-end test is done in the POC implementation by loading >1MM items on a trivial dim table.\n\nPlease take a look\nDocumentation\n\nWill be added with the next PR, 'LookupTransformFunction'.", "createdAt": "2020-12-11T05:42:22Z", "url": "https://github.com/apache/pinot/pull/6346", "merged": true, "mergeCommit": {"oid": "33de6dc6374db26a801124543bc633ba859220df"}, "closed": true, "closedAt": "2020-12-22T22:36:42Z", "author": {"login": "cbalci"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmP9MBAFqTU1MjAyNDEyMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdoyYyYAFqTU1NzQwNjEyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMDI0MTIx", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-552024121", "createdAt": "2020-12-15T00:56:23Z", "commit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo1NjoyM1rOIFzz-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMToyMDo0MlrOIF0YsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2MjY4Mg==", "bodyText": "(nit)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private DimensionTableDataManager() {}\n          \n          \n            \n              private DimensionTableDataManager() {\n          \n          \n            \n              }", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542962682", "createdAt": "2020-12-15T00:56:23Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Mjg2MA==", "bodyText": "For clarity\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n          \n          \n            \n              public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542962860", "createdAt": "2020-12-15T00:56:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Mjk4Mw==", "bodyText": "For clarity\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n          \n          \n            \n              public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542962983", "createdAt": "2020-12-15T00:57:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NDE4OQ==", "bodyText": "Always create a new one instead of reusing the existing one (there should be no existing one normally)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n          \n          \n            \n                return _instances.get(tableName);\n          \n          \n            \n                DimensionTableDataManager instance = new DimensionTableDataManager();\n          \n          \n            \n                _instances.put(tableNameWithType, instance);\n          \n          \n            \n                return instance;", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542964189", "createdAt": "2020-12-15T01:00:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NTc4Nw==", "bodyText": "(nit)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n          \n          \n            \n                  _logger.info(\"Successfully loaded lookup table: {}\", getTableName());", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542965787", "createdAt": "2020-12-15T01:04:20Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NjUxNg==", "bodyText": "(nit) reformat", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542966516", "createdAt": "2020-12-15T01:06:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NjY1OA==", "bodyText": "(nit)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n          \n          \n            \n                  _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542966658", "createdAt": "2020-12-15T01:06:26Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2Njg4Mg==", "bodyText": "Wrap it into a RuntimeException and throw it", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542966882", "createdAt": "2020-12-15T01:07:01Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTIyNg==", "bodyText": "To simplify the logic, clear the lookup table first, then load it", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542971226", "createdAt": "2020-12-15T01:18:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTI5Nw==", "bodyText": "Remove", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542971297", "createdAt": "2020-12-15T01:18:39Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        _lookupTable.clear();\n+        return;\n+      }\n+\n+      List<File> indexDirs = new ArrayList<>();\n+      for (SegmentDataManager segmentManager: segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        System.out.println(indexSegment.getSegmentName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MTY5Nw==", "bodyText": "No need to use MultiplePinotSegmentRecordReader here, use PinotSegmentRecordReader instead on each segment. Use try-with-resource to close the reader after the reading", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542971697", "createdAt": "2020-12-15T01:19:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.MultiplePinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {}\n+\n+  public static DimensionTableDataManager createInstanceByTableName(String tableName) {\n+    _instances.putIfAbsent(tableName, new DimensionTableDataManager());\n+    return _instances.get(tableName);\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableName) {\n+    return _instances.get(tableName);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error loading lookup table: %s\", getTableName()),e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table for {}\", getTableName());\n+    } catch (Exception e) {\n+      _logger.error(\"Error reloading lookup table after segment remove for table {}\", getTableName());\n+    }\n+  }\n+\n+  /*\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable() throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        _lookupTable.clear();\n+        return;\n+      }\n+\n+      List<File> indexDirs = new ArrayList<>();\n+      for (SegmentDataManager segmentManager: segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        System.out.println(indexSegment.getSegmentName());\n+        indexDirs.add(indexSegment.getSegmentMetadata().getIndexDir());\n+      }\n+      MultiplePinotSegmentRecordReader reader = new MultiplePinotSegmentRecordReader(indexDirs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MjAzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @BeforeSuite\n          \n          \n            \n              @BeforeClass", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542972036", "createdAt": "2020-12-15T01:20:33Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManagerTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.yammer.metrics.core.MetricsRegistry;\n+import java.io.File;\n+import java.net.URL;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.metrics.ServerMetrics;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.config.TableDataManagerConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.SegmentIndexCreationDriver;\n+import org.apache.pinot.core.segment.creator.impl.SegmentCreationDriverFactory;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.index.loader.LoaderTest;\n+import org.apache.pinot.segments.v1.creator.SegmentTestUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.*;\n+\n+\n+public class DimensionTableDataManagerTest {\n+  private static final String TABLE_NAME = \"dimBaseballTeams\";\n+  private static final File INDEX_DIR = new File(LoaderTest.class.getName());\n+  private static final String AVRO_DATA_PATH = \"data/dimBaseballTeams.avro\";\n+\n+  private File _indexDir;\n+  private IndexLoadingConfig _indexLoadingConfig;\n+\n+  @BeforeSuite", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MjA4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @AfterSuite\n          \n          \n            \n              @AfterClass", "url": "https://github.com/apache/pinot/pull/6346#discussion_r542972081", "createdAt": "2020-12-15T01:20:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManagerTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.yammer.metrics.core.MetricsRegistry;\n+import java.io.File;\n+import java.net.URL;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.metrics.ServerMetrics;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.config.TableDataManagerConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.SegmentIndexCreationDriver;\n+import org.apache.pinot.core.segment.creator.impl.SegmentCreationDriverFactory;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.index.loader.LoaderTest;\n+import org.apache.pinot.segments.v1.creator.SegmentTestUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.*;\n+\n+\n+public class DimensionTableDataManagerTest {\n+  private static final String TABLE_NAME = \"dimBaseballTeams\";\n+  private static final File INDEX_DIR = new File(LoaderTest.class.getName());\n+  private static final String AVRO_DATA_PATH = \"data/dimBaseballTeams.avro\";\n+\n+  private File _indexDir;\n+  private IndexLoadingConfig _indexLoadingConfig;\n+\n+  @BeforeSuite\n+  public void setUp()\n+      throws Exception {\n+    // prepare segment data\n+    URL resourceUrl = getClass().getClassLoader().getResource(AVRO_DATA_PATH);\n+    Assert.assertNotNull(resourceUrl);\n+    File avroFile = new File(resourceUrl.getFile());\n+\n+    // create segment\n+    SegmentGeneratorConfig segmentGeneratorConfig =\n+        SegmentTestUtils.getSegmentGeneratorConfigWithoutTimeColumn(avroFile, INDEX_DIR, TABLE_NAME);\n+    segmentGeneratorConfig.setSegmentVersion(SegmentVersion.v3);\n+    SegmentIndexCreationDriver driver = SegmentCreationDriverFactory.get(null);\n+    driver.init(segmentGeneratorConfig);\n+    driver.build();\n+    _indexDir = new File(INDEX_DIR, driver.getSegmentName());\n+\n+    _indexLoadingConfig = new IndexLoadingConfig();\n+    _indexLoadingConfig.setReadMode(ReadMode.mmap);\n+    _indexLoadingConfig.setSegmentVersion(SegmentVersion.v3);\n+  }\n+\n+  @AfterSuite", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bab13425162cdf0ae15230c6c2b11f627ce6374c"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzMTQ0MTAw", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-553144100", "createdAt": "2020-12-16T00:07:55Z", "commit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDowNzo1NlrOIGloDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDoyMTo1MlrOIGl9Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3ODgzMA==", "bodyText": "Use @link to reference classes and methods. The nice thing is that IDE can help you track it and refactor it.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543778830", "createdAt": "2020-12-16T00:07:56Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /*\n+   * `createInstanceByTableName` should only be used by the `TableDataManagerProvider` and the returned instance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3ODk2MA==", "bodyText": "extra line", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543778960", "createdAt": "2020-12-16T00:08:20Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via `getInstanceByTableName` static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /*\n+   * `createInstanceByTableName` should only be used by the `TableDataManagerProvider` and the returned instance\n+   * should be properly initialized via `TableDataManager::init` method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    DimensionTableDataManager instance = new DimensionTableDataManager();\n+    _instances.put(tableNameWithType, instance);\n+    return instance;\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /*\n+   * DimensionTableDataManager Instance Properties/Methods\n+   */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4NDIyMw==", "bodyText": "nit: use else to be clearer", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543784223", "createdAt": "2020-12-16T00:21:52Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/TableDataManagerProvider.java", "diffHunk": "@@ -53,6 +53,11 @@ public static TableDataManager getTableDataManager(@Nonnull TableDataManagerConf\n     TableDataManager tableDataManager;\n     switch (TableType.valueOf(tableDataManagerConfig.getTableDataManagerType())) {\n       case OFFLINE:\n+        if (tableDataManagerConfig.isDimTable()) {\n+          tableDataManager =\n+              DimensionTableDataManager.createInstanceByTableName(tableDataManagerConfig.getTableName());\n+          break;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a94ab18b974e810d50c4ff9ab20c2be9cde30f5e"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzMjE1NDcz", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-553215473", "createdAt": "2020-12-16T00:59:35Z", "commit": {"oid": "c8fd8bfa22ee0e9c17b5870c97292cfa96c03d46"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDo1OTozNVrOIGm1mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDo1OTozNVrOIGm1mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5ODY4Mg==", "bodyText": "(Critical) release these segment data managers after reading them", "url": "https://github.com/apache/pinot/pull/6346#discussion_r543798682", "createdAt": "2020-12-16T00:59:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    DimensionTableDataManager instance = new DimensionTableDataManager();\n+    _instances.put(tableNameWithType, instance);\n+    return instance;\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8fd8bfa22ee0e9c17b5870c97292cfa96c03d46"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MDc3MTE0", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-554077114", "createdAt": "2020-12-16T20:56:26Z", "commit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMDo1NjoyNlrOIHYykw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMDo1NjoyNlrOIHYykw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxNzEwNw==", "bodyText": "We might want to put release in the finally block so that it is always released even with exceptions:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    releaseSegment(segmentManager);\n          \n          \n            \n              try {\n          \n          \n            \n                for (SegmentDataManager segmentManager : segmentManagers) {\n          \n          \n            \n                  ...\n          \n          \n            \n                }\n          \n          \n            \n              } finally {\n          \n          \n            \n                for (SegmentDataManager segmentManager : segmentManagers) {\n          \n          \n            \n                  releaseSegment(segmentManager);\n          \n          \n            \n                }\n          \n          \n            \n              }", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544617107", "createdAt": "2020-12-16T20:56:26Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTg0MjUx", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-554184251", "createdAt": "2020-12-17T00:08:06Z", "commit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowODowNlrOIHeqLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxNTozOFrOIHe1Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzI2Mg==", "bodyText": "Please annotate as visiblefortesting.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544713262", "createdAt": "2020-12-17T00:08:06Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+          String.format(\"Error reloading lookup table after segment remove for table: {}\", getTableName()), e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      for (SegmentDataManager segmentManager : segmentManagers) {\n+        IndexSegment indexSegment = segmentManager.getSegment();\n+        try (PinotSegmentRecordReader reader =\n+            new PinotSegmentRecordReader(indexSegment.getSegmentMetadata().getIndexDir())) {\n+          while (reader.hasNext()) {\n+            GenericRow row = reader.next();\n+            _lookupTable.put(row.getPrimaryKey(_primaryKeyColumns), row);\n+          }\n+        }\n+        releaseSegment(segmentManager);\n+      }\n+    } finally {\n+      _lookupTableWriteLock.unlock();\n+    }\n+  }\n+\n+  public GenericRow lookupRowByPrimaryKey(PrimaryKey pk) {\n+    _lookupTableReadLock.lock();\n+    try {\n+      return _lookupTable.get(pk);\n+    } finally {\n+      _lookupTableReadLock.unlock();\n+    }\n+  }\n+\n+  public FieldSpec getColumnFieldSpec(String columnName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzUwNg==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n          \n          \n            \n                  _logger.info(\"Successfully added segment {} and loaded lookup table: {}\", getTableName());", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544713506", "createdAt": "2020-12-17T00:08:45Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzU1Nw==", "bodyText": "Good to add segment name in the log", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544713557", "createdAt": "2020-12-17T00:08:56Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully loaded lookup table: {}\", getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment and reloaded lookup table: {}\", getTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjEwNg==", "bodyText": "Please move this check to the table creation code in the controller.\nAlso ensure that the other checks are there as well:\n(1) table type must be OFFLINE\n(2) table ingestion should be REFRESH", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544716106", "createdAt": "2020-12-17T00:15:38Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTk4MTcz", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-554198173", "createdAt": "2020-12-17T00:44:43Z", "commit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDo0NDo0M1rOIHfgEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDo0NDo0M1rOIHfgEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyNzA1OA==", "bodyText": "is this table going to use heap or non-heap memory?", "url": "https://github.com/apache/pinot/pull/6346#discussion_r544727058", "createdAt": "2020-12-17T00:44:43Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f671a4094b9093a7f57114bad84e12a1c4ccd9e"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjY3ODc2", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-555667876", "createdAt": "2020-12-18T17:13:58Z", "commit": {"oid": "3ae2beda4f452345f9d30603cd8401f7ac7728aa"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzoxNToxNlrOIIrhPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzoxNjo1MlrOIIrkig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MjU0MA==", "bodyText": "If we already check at the time of adding the table config, then it should never be null here, right?", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545972540", "createdAt": "2020-12-18T17:15:16Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjEwNg=="}, "originalCommit": {"oid": "353d70d64d225b9bab08c51b08766532bdebae96"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MzM4Ng==", "bodyText": "Since we want that a lookup table should be small, it may be worth asserting that the table has to be in one segment?", "url": "https://github.com/apache/pinot/pull/6346#discussion_r545973386", "createdAt": "2020-12-18T17:16:52Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.data.manager.offline;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * Dimension Table is a special type of OFFLINE table which is assigned to all servers\n+ * in a tenant and is used to execute a LOOKUP Transform Function. DimensionTableDataManager\n+ * loads the contents into a HashMap for faster access thus the size should be small\n+ * enough to easily fit in memory.\n+ *\n+ * DimensionTableDataManager uses Registry of Singletons pattern to store one instance per table\n+ * which can be accessed via {@link #getInstanceByTableName} static method.\n+ */\n+@ThreadSafe\n+public class DimensionTableDataManager extends OfflineTableDataManager {\n+  // Storing singletons per table in a HashMap\n+  private static final Map<String, DimensionTableDataManager> _instances = new ConcurrentHashMap<>();\n+\n+  private DimensionTableDataManager() {\n+  }\n+\n+  /**\n+   * `createInstanceByTableName` should only be used by the {@link TableDataManagerProvider} and the returned\n+   * instance should be properly initialized via {@link #init} method before using.\n+   */\n+  public static DimensionTableDataManager createInstanceByTableName(String tableNameWithType) {\n+    return _instances.computeIfAbsent(tableNameWithType, k -> new DimensionTableDataManager());\n+  }\n+\n+  public static DimensionTableDataManager getInstanceByTableName(String tableNameWithType) {\n+    return _instances.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Instance properties/methods\n+   */\n+  private final ReadWriteLock _rwl = new ReentrantReadWriteLock();\n+  private final Lock _lookupTableReadLock = _rwl.readLock();\n+  private final Lock _lookupTableWriteLock = _rwl.writeLock();\n+\n+  // _lookupTable is a HashMap used for storing/serving records for a table keyed by table PK\n+  @GuardedBy(\"_rwl\")\n+  private final Map<PrimaryKey, GenericRow> _lookupTable = new HashMap<>();\n+  private Schema _tableSchema;\n+  private List<String> _primaryKeyColumns;\n+\n+  @Override\n+  protected void doInit() {\n+    super.doInit();\n+\n+    _tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n+    Preconditions.checkState(_tableSchema != null, \"Failed to find schema for table: %s\", _tableNameWithType);\n+    _primaryKeyColumns = _tableSchema.getPrimaryKeyColumns();\n+    Preconditions.checkState(!CollectionUtils.isEmpty(_primaryKeyColumns),\n+        \"Primary key columns must be configured for dimension table: %s\", _tableNameWithType);\n+  }\n+\n+  @Override\n+  public void addSegment(File indexDir, IndexLoadingConfig indexLoadingConfig)\n+      throws Exception {\n+    super.addSegment(indexDir, indexLoadingConfig);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully added segment {} and loaded lookup table: {}\", indexDir.getName(), getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String.format(\"Error loading lookup table: %s\", getTableName()), e);\n+    }\n+  }\n+\n+  @Override\n+  public void removeSegment(String segmentName) {\n+    super.removeSegment(segmentName);\n+    try {\n+      loadLookupTable();\n+      _logger.info(\"Successfully removed segment {} and reloaded lookup table: {}\", segmentName, getTableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(String\n+          .format(\"Error reloading lookup table after segment remove ({}) for table: {}\", segmentName, getTableName()),\n+          e);\n+    }\n+  }\n+\n+  /**\n+   * `loadLookupTable()` reads contents of the DimensionTable into _lookupTable HashMap for fast lookup.\n+   */\n+  private void loadLookupTable()\n+      throws Exception {\n+    _lookupTableWriteLock.lock();\n+    try {\n+      _lookupTable.clear();\n+      List<SegmentDataManager> segmentManagers = acquireAllSegments();\n+      if (segmentManagers.size() == 0) {\n+        return;\n+      }\n+\n+      try {\n+        for (SegmentDataManager segmentManager : segmentManagers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ae2beda4f452345f9d30603cd8401f7ac7728aa"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be6656561f2d0682167ccd71a38c9c66522a7939", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/be6656561f2d0682167ccd71a38c9c66522a7939", "committedDate": "2020-12-18T21:16:56Z", "message": "Add DimensionTableData manager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "620d311ec62a15ab26bf8a3833482a99b29a8263", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/620d311ec62a15ab26bf8a3833482a99b29a8263", "committedDate": "2020-12-18T21:16:56Z", "message": "Address review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "296171cf7dbd7cf0292625a4f807ea4e0857804e", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/296171cf7dbd7cf0292625a4f807ea4e0857804e", "committedDate": "2020-12-18T21:16:56Z", "message": "CLose reader after using."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3606ae7e17dad3931112ca4f7d10d49cae25aa6", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/e3606ae7e17dad3931112ca4f7d10d49cae25aa6", "committedDate": "2020-12-18T21:16:56Z", "message": "Revisit javadocs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5663a6170f4afb185e30946c493c3d9c807d76f7", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/5663a6170f4afb185e30946c493c3d9c807d76f7", "committedDate": "2020-12-18T21:16:56Z", "message": "Release segment after use."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23cdc917f0f5739192a65f197c7029fd94e06752", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/23cdc917f0f5739192a65f197c7029fd94e06752", "committedDate": "2020-12-18T21:16:56Z", "message": "Touch up instance instantiation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88905e815e0914b8b6f3eead4ef116ba1fb4b9c5", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/88905e815e0914b8b6f3eead4ef116ba1fb4b9c5", "committedDate": "2020-12-18T21:16:56Z", "message": "Cleanup segment in test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e428485e5deb0ff931bce8c61d7da6265e4ad0f0", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/e428485e5deb0ff931bce8c61d7da6265e4ad0f0", "committedDate": "2020-12-18T21:16:56Z", "message": "Release segments in \"finally\" block."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f458a8cdd378dca9e1bdad2c01612d8e3b49cdf", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/1f458a8cdd378dca9e1bdad2c01612d8e3b49cdf", "committedDate": "2020-12-18T21:16:56Z", "message": "Update logs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0726be0cfbab32e7c17f94eeeb2210bf3cf2f61", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/d0726be0cfbab32e7c17f94eeeb2210bf3cf2f61", "committedDate": "2020-12-18T21:16:56Z", "message": "Add TableConfig validations for Dim Tables."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36b07a8d1112a731eb29672bcf22fe2c8d066c2f", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/36b07a8d1112a731eb29672bcf22fe2c8d066c2f", "committedDate": "2020-12-18T21:16:56Z", "message": "Seperate IngestionConfigTests for dim tables."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3881b95d2a2ed4b67c4ae51f390dae7569f2ac17", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/3881b95d2a2ed4b67c4ae51f390dae7569f2ac17", "committedDate": "2020-12-18T21:16:56Z", "message": "Remove defensive null checks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8281dc121ba8ab3a97dc133e1e4f48a111487b6b", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/8281dc121ba8ab3a97dc133e1e4f48a111487b6b", "committedDate": "2020-12-18T21:16:56Z", "message": "Fix github action profile name."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "699b035febd71cad2621460295e0dc2847a27d22", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/699b035febd71cad2621460295e0dc2847a27d22", "committedDate": "2020-12-18T20:41:56Z", "message": "Fix github action profile name."}, "afterCommit": {"oid": "8281dc121ba8ab3a97dc133e1e4f48a111487b6b", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/8281dc121ba8ab3a97dc133e1e4f48a111487b6b", "committedDate": "2020-12-18T21:16:56Z", "message": "Fix github action profile name."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b47465c9e193a83feaa22fcee35568c9f42bc14b", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/b47465c9e193a83feaa22fcee35568c9f42bc14b", "committedDate": "2020-12-18T21:22:43Z", "message": "Fix ingestionTest dependencies."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f719a847c811ee35d6af68e1724c69004d36c7e8", "author": {"user": {"login": "cbalci", "name": "Caner Balci"}}, "url": "https://github.com/apache/pinot/commit/f719a847c811ee35d6af68e1724c69004d36c7e8", "committedDate": "2020-12-18T21:45:39Z", "message": "Undo the gihub-actions mvn profile name fix."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1OTA3MTI1", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-555907125", "createdAt": "2020-12-19T02:13:58Z", "commit": {"oid": "f719a847c811ee35d6af68e1724c69004d36c7e8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoxMzo1OFrOII39Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoxMzo1OFrOII39Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NjI4Mg==", "bodyText": "I hope this API is still only for testing. The API does not make sense in production since the ref count could change any time after you get it. Please confirm.", "url": "https://github.com/apache/pinot/pull/6346#discussion_r546176282", "createdAt": "2020-12-19T02:13:58Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/SegmentDataManager.java", "diffHunk": "@@ -29,7 +29,7 @@\n   private int _referenceCount = 1;\n \n   @VisibleForTesting\n-  synchronized int getReferenceCount() {\n+  public synchronized int getReferenceCount() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f719a847c811ee35d6af68e1724c69004d36c7e8"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1OTEyNTMy", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-555912532", "createdAt": "2020-12-19T03:33:54Z", "commit": {"oid": "f719a847c811ee35d6af68e1724c69004d36c7e8"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDA2MTIw", "url": "https://github.com/apache/pinot/pull/6346#pullrequestreview-557406120", "createdAt": "2020-12-22T22:36:32Z", "commit": {"oid": "f719a847c811ee35d6af68e1724c69004d36c7e8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1652, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}