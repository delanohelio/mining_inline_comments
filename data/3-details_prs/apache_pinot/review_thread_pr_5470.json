{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NTM0OTU5", "number": 5470, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMzoyNjozNlrOEBJOlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMDowMDowOFrOEBJTbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjM1MjIxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMzoyNjozNlrOGc11VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMzo1MToxM1rOGc15pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTMxNw==", "bodyText": "deriveNumDocsPerChunk sounds more accurate? (applicable to all related config & variable names)", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432895317", "createdAt": "2020-05-30T23:26:36Z", "author": {"login": "snleee"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -193,9 +194,10 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n             getColumnCompressionType(segmentCreationSpec, fieldSpec);\n \n         // Initialize forward index creator\n+        boolean deriveNumChunksForVarByteRawIndex = shouldDeriveNumChunksForRawIndex(columnName, segmentCreationSpec.getColumnProperties());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjQyMg==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896422", "createdAt": "2020-05-30T23:51:13Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -193,9 +194,10 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n             getColumnCompressionType(segmentCreationSpec, fieldSpec);\n \n         // Initialize forward index creator\n+        boolean deriveNumChunksForVarByteRawIndex = shouldDeriveNumChunksForRawIndex(columnName, segmentCreationSpec.getColumnProperties());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTMxNw=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjM1MzI0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMzoyODowOFrOGc11zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMDoxMDo1MVrOGc19Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg==", "bodyText": "What was the original behavior before your recent change? Did we explicitly check STRING and BYTES types also?", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432895436", "createdAt": "2020-05-30T23:28:08Z", "author": {"login": "snleee"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {\n+      // text column is no dictionary currently\n+      return true;\n+    }\n+    FieldSpec.DataType dataType = fieldSpec.getDataType();\n+    if (noDictionaryColumns.contains(column)) {\n+      // Earlier we didn't support noDict in consuming segments for STRING and BYTES columns.\n+      // So even if the user had the column in noDictionaryColumns set in table config, we still\n+      // created dictionary in consuming segments.\n+      // Later on we added this support. There is a particular impact of this change on the use cases\n+      // that have set noDict on their STRING dimension columns for other performance\n+      // reasons and also want metricsAggregation. These use cases don't get to\n+      // aggregateMetrics because the new implementation is able to honor their table config setting\n+      // of noDict on STRING/BYTES. Without metrics aggregation, memory pressure increases.\n+      // So to continue aggregating metrics for such cases, we will create dictionary even\n+      // if the column is part of noDictionary set from table config\n+      if (fieldSpec instanceof DimensionFieldSpec && _aggregateMetrics && (dataType == FieldSpec.DataType.STRING ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjQxNg==", "bodyText": "Yes we checked for STRING. See here #4791\nNote that there is a method  enableMetricsAggregationIfPossible that decides whether metrics can be aggregated or not and that checks whether all dimensions have dictionary, all metrics should not have dictionary and should be SV etc. That method is still intact.\nJust that during initialization of MutableSegmentImpl, we used to check for STRING and remove it from noDictionaryColumns set since raw index wasn't supported. This was actually the reason why the use cases were able to specify it as noDict in config and still able to aggregate metrics.", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896416", "createdAt": "2020-05-30T23:51:02Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {\n+      // text column is no dictionary currently\n+      return true;\n+    }\n+    FieldSpec.DataType dataType = fieldSpec.getDataType();\n+    if (noDictionaryColumns.contains(column)) {\n+      // Earlier we didn't support noDict in consuming segments for STRING and BYTES columns.\n+      // So even if the user had the column in noDictionaryColumns set in table config, we still\n+      // created dictionary in consuming segments.\n+      // Later on we added this support. There is a particular impact of this change on the use cases\n+      // that have set noDict on their STRING dimension columns for other performance\n+      // reasons and also want metricsAggregation. These use cases don't get to\n+      // aggregateMetrics because the new implementation is able to honor their table config setting\n+      // of noDict on STRING/BYTES. Without metrics aggregation, memory pressure increases.\n+      // So to continue aggregating metrics for such cases, we will create dictionary even\n+      // if the column is part of noDictionary set from table config\n+      if (fieldSpec instanceof DimensionFieldSpec && _aggregateMetrics && (dataType == FieldSpec.DataType.STRING ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjU3NQ==", "bodyText": "Sounds good to me \ud83d\udc4d", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896575", "createdAt": "2020-05-30T23:54:23Z", "author": {"login": "snleee"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {\n+      // text column is no dictionary currently\n+      return true;\n+    }\n+    FieldSpec.DataType dataType = fieldSpec.getDataType();\n+    if (noDictionaryColumns.contains(column)) {\n+      // Earlier we didn't support noDict in consuming segments for STRING and BYTES columns.\n+      // So even if the user had the column in noDictionaryColumns set in table config, we still\n+      // created dictionary in consuming segments.\n+      // Later on we added this support. There is a particular impact of this change on the use cases\n+      // that have set noDict on their STRING dimension columns for other performance\n+      // reasons and also want metricsAggregation. These use cases don't get to\n+      // aggregateMetrics because the new implementation is able to honor their table config setting\n+      // of noDict on STRING/BYTES. Without metrics aggregation, memory pressure increases.\n+      // So to continue aggregating metrics for such cases, we will create dictionary even\n+      // if the column is part of noDictionary set from table config\n+      if (fieldSpec instanceof DimensionFieldSpec && _aggregateMetrics && (dataType == FieldSpec.DataType.STRING ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjY2MA==", "bodyText": "Log message for this?", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896660", "createdAt": "2020-05-30T23:55:58Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {\n+      // text column is no dictionary currently\n+      return true;\n+    }\n+    FieldSpec.DataType dataType = fieldSpec.getDataType();\n+    if (noDictionaryColumns.contains(column)) {\n+      // Earlier we didn't support noDict in consuming segments for STRING and BYTES columns.\n+      // So even if the user had the column in noDictionaryColumns set in table config, we still\n+      // created dictionary in consuming segments.\n+      // Later on we added this support. There is a particular impact of this change on the use cases\n+      // that have set noDict on their STRING dimension columns for other performance\n+      // reasons and also want metricsAggregation. These use cases don't get to\n+      // aggregateMetrics because the new implementation is able to honor their table config setting\n+      // of noDict on STRING/BYTES. Without metrics aggregation, memory pressure increases.\n+      // So to continue aggregating metrics for such cases, we will create dictionary even\n+      // if the column is part of noDictionary set from table config\n+      if (fieldSpec instanceof DimensionFieldSpec && _aggregateMetrics && (dataType == FieldSpec.DataType.STRING ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NzM2Mg==", "bodyText": "should the name of the method be changed to shouldCreateDictionaryForColumn()?", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432897362", "createdAt": "2020-05-31T00:10:51Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {\n+      // text column is no dictionary currently\n+      return true;\n+    }\n+    FieldSpec.DataType dataType = fieldSpec.getDataType();\n+    if (noDictionaryColumns.contains(column)) {\n+      // Earlier we didn't support noDict in consuming segments for STRING and BYTES columns.\n+      // So even if the user had the column in noDictionaryColumns set in table config, we still\n+      // created dictionary in consuming segments.\n+      // Later on we added this support. There is a particular impact of this change on the use cases\n+      // that have set noDict on their STRING dimension columns for other performance\n+      // reasons and also want metricsAggregation. These use cases don't get to\n+      // aggregateMetrics because the new implementation is able to honor their table config setting\n+      // of noDict on STRING/BYTES. Without metrics aggregation, memory pressure increases.\n+      // So to continue aggregating metrics for such cases, we will create dictionary even\n+      // if the column is part of noDictionary set from table config\n+      if (fieldSpec instanceof DimensionFieldSpec && _aggregateMetrics && (dataType == FieldSpec.DataType.STRING ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjM1Nzk4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMzo0MToyM1rOGc14Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMzoyNzozOVrOGc2enQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ==", "bodyText": "The description of textIndexColumns is missing in this method.", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896019", "createdAt": "2020-05-30T23:41:23Z", "author": {"login": "jackjlli"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjQxOQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896419", "createdAt": "2020-05-30T23:51:08Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NzE5NQ==", "bodyText": "This check here seems a little dangerous to me. We do have column level settings, it is better to throw an exception if a column has both text index as well as dictionary. If we somehow add a dictionary for text column later, we will have to remember to come back to change this place.", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432897195", "createdAt": "2020-05-31T00:07:41Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5ODIzMQ==", "bodyText": "Actually it is not needed anymore. I already do the validation upfront in TableConfig (already in master). So we can remove it. Per column config is enough", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432898231", "createdAt": "2020-05-31T00:29:37Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNTg4NQ==", "bodyText": "Excellent. I think we still rename the method as something along the lines if shouldCreateDictionaryForColumn(), since it has some logic and is not just checking the table config for noDictionary setting,", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432905885", "createdAt": "2020-05-31T03:27:39Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ=="}, "originalCommit": {"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjM2NDYzOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMDowMDowOFrOGc17Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMzoyNjowMlrOGc2ebQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Njg0Ng==", "bodyText": "Defaults to false, right?", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896846", "createdAt": "2020-05-31T00:00:08Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -213,6 +215,14 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n     }\n   }\n \n+  public static boolean shouldDeriveNumDocsPerChunk(String columnName, Map<String, Map<String, String>> columnProperties) {\n+    if (columnProperties != null) {\n+      Map<String, String> properties = columnProperties.get(columnName);\n+      return properties != null && Boolean.parseBoolean(properties.get(FieldConfig.DERIVE_NUM_DOCS_PER_CHUNK_RAW_INDEX_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b7c94560dad927561df2161edd085f6f8066dfc"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NzQyMg==", "bodyText": "Can we derive it automatically? (e.g. if column is text index then we derive it from metadata) Or, do you see this being usefiul in other cases as well?", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432897422", "createdAt": "2020-05-31T00:12:24Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -213,6 +215,14 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n     }\n   }\n \n+  public static boolean shouldDeriveNumDocsPerChunk(String columnName, Map<String, Map<String, String>> columnProperties) {\n+    if (columnProperties != null) {\n+      Map<String, String> properties = columnProperties.get(columnName);\n+      return properties != null && Boolean.parseBoolean(properties.get(FieldConfig.DERIVE_NUM_DOCS_PER_CHUNK_RAW_INDEX_KEY));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Njg0Ng=="}, "originalCommit": {"oid": "1b7c94560dad927561df2161edd085f6f8066dfc"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5ODQ1Mw==", "bodyText": "Defaults to false, right?\n\nYes\n\nCan we derive it automatically? (e.g. if column is text index then we derive it from metadata) Or, do you see this being usefiul in other cases as well?\n\nWe could. Even for columns with text indexes, I don't think we should use it by default (since now that we have seen the potential -ve impact related to access pattern). Yes, most likely this will be used for columns with text index but only if the average column value size is very large (around 1-2MB) since that is the case which takes the chunk size and compressed chunk size (2 * raw) > 2GB and deriving the numDocsPerChunk becomes useful.", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432898453", "createdAt": "2020-05-31T00:34:27Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -213,6 +215,14 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n     }\n   }\n \n+  public static boolean shouldDeriveNumDocsPerChunk(String columnName, Map<String, Map<String, String>> columnProperties) {\n+    if (columnProperties != null) {\n+      Map<String, String> properties = columnProperties.get(columnName);\n+      return properties != null && Boolean.parseBoolean(properties.get(FieldConfig.DERIVE_NUM_DOCS_PER_CHUNK_RAW_INDEX_KEY));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Njg0Ng=="}, "originalCommit": {"oid": "1b7c94560dad927561df2161edd085f6f8066dfc"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNTgzNw==", "bodyText": "The reason I ask is that if we introduce a config it is hard to remove/deprecate, etc. if we make it a default for text column, we can always introduce a config later to adjust. In both offline and realtime cases, we know the average column size (or, can compute easily) at the segment generation time, so it seems to me that this can be done automatically without introducing a configuration. I would propose to NOT introduce a config at this time", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432905837", "createdAt": "2020-05-31T03:26:02Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -213,6 +215,14 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n     }\n   }\n \n+  public static boolean shouldDeriveNumDocsPerChunk(String columnName, Map<String, Map<String, String>> columnProperties) {\n+    if (columnProperties != null) {\n+      Map<String, String> properties = columnProperties.get(columnName);\n+      return properties != null && Boolean.parseBoolean(properties.get(FieldConfig.DERIVE_NUM_DOCS_PER_CHUNK_RAW_INDEX_KEY));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Njg0Ng=="}, "originalCommit": {"oid": "1b7c94560dad927561df2161edd085f6f8066dfc"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4504, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}