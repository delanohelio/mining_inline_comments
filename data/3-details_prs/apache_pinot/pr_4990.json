{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMzI4Njgy", "number": 4990, "title": "Enhance TableRebalancer to be able to rebalance table under any condition", "bodyText": "Best effort rebalance in the following scenario (min available replicas won't be guaranteed)\n\nTable with segments in ERROR state\nExternalView not converged within the timeout\n\nAlso add support for rebalancing Helix disabled table", "createdAt": "2020-01-15T20:42:28Z", "url": "https://github.com/apache/pinot/pull/4990", "merged": true, "mergeCommit": {"oid": "696a04ac9748edb38dce9ea22d60b9e9ac6a0b2a"}, "closed": true, "closedAt": "2020-01-22T08:51:37Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6snd0AFqTM0MzU0MDU4MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8viKJABqjI5Njg4MDkwNDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTQwNTgx", "url": "https://github.com/apache/pinot/pull/4990#pullrequestreview-343540581", "createdAt": "2020-01-15T21:41:27Z", "commit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMTo0MToyN1rOFeHVvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMTo0MToyN1rOFeHVvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMTg1NQ==", "bodyText": "I think this should be error level.", "url": "https://github.com/apache/pinot/pull/4990#discussion_r367121855", "createdAt": "2020-01-15T21:41:27Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -420,10 +463,19 @@ static boolean isExternalViewConverged(Map<String, Map<String, String>> external\n       Map<String, String> idealStateInstanceStateMap = entry.getValue();\n       for (Map.Entry<String, String> instanceStateEntry : idealStateInstanceStateMap.entrySet()) {\n         // Ignore OFFLINE state in IdealState\n-        String state = instanceStateEntry.getValue();\n-        if (!state.equals(SegmentOnlineOfflineStateModel.OFFLINE) && !state\n-            .equals(externalViewInstanceStateMap.get(instanceStateEntry.getKey()))) {\n-          return false;\n+        String idealStateInstanceState = instanceStateEntry.getValue();\n+        if (!idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {\n+          continue;\n+        }\n+        String instanceName = instanceStateEntry.getKey();\n+        String externalViewInstanceState = externalViewInstanceStateMap.get(instanceName);\n+        if (!idealStateInstanceState.equals(externalViewInstanceState)) {\n+          if (RealtimeSegmentOnlineOfflineStateModel.ERROR.equals(externalViewInstanceState)) {\n+            LOGGER.warn(\"Found ERROR instance: {} for segment: {}, table: {}\", instanceName, segmentName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 401}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MDM0NDMz", "url": "https://github.com/apache/pinot/pull/4990#pullrequestreview-345034433", "createdAt": "2020-01-19T23:17:55Z", "commit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQyMzoxNzo1NVrOFfRLlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQyMzo0ODoxMFrOFfRT6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMTY3MA==", "bodyText": "Can you elaborate on what instance re-assignment means? Maybe best to add it in the comments on RebalanceConfigConstants. We need to also doc it in along with the rebalance command. Let me know if there is a doc already, and I can read it.", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368331670", "createdAt": "2020-01-19T23:17:55Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMTc3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n          \n          \n            \n                  LOGGER.info(\"Rebalancing table {} in dry-run mode, returning the target assignment\", tableNameWithType);", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368331774", "createdAt": "2020-01-19T23:19:24Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,\n+              targetAssignment);\n+        } else {\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n+              instancePartitionsMap, targetAssignment);\n+        }\n       } else {\n         return new RebalanceResult(RebalanceResult.Status.NO_OP, \"Table is already balanced\", instancePartitionsMap,\n             targetAssignment);\n       }\n     }\n \n     if (dryRun) {\n-      LOGGER.info(\"Rebalance table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n+      LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjAwNw==", "bodyText": "(1) If the table is disabled, it is already down, so maybe just say that we are moving segment assignment?\n(2) Why is this a warning? it can be an info.\n(3) We should return this information in the status as well.", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368332007", "createdAt": "2020-01-19T23:22:50Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,\n+              targetAssignment);\n+        } else {\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n+              instancePartitionsMap, targetAssignment);\n+        }\n       } else {\n         return new RebalanceResult(RebalanceResult.Status.NO_OP, \"Table is already balanced\", instancePartitionsMap,\n             targetAssignment);\n       }\n     }\n \n     if (dryRun) {\n-      LOGGER.info(\"Rebalance table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n+      LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n       return new RebalanceResult(RebalanceResult.Status.DONE, \"Dry-run mode\", instancePartitionsMap, targetAssignment);\n     }\n \n-    int minAvailableReplicas;\n-    if (rebalanceConfig.getBoolean(RebalanceConfigConstants.DOWNTIME, RebalanceConfigConstants.DEFAULT_DOWNTIME)) {\n-      minAvailableReplicas = 0;\n+    if (!downtime && !currentIdealState.isEnabled()) {\n+      LOGGER.warn(\"Table: {} is disabled, rebalancing it with downtime\", tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjEzMw==", "bodyText": "Is is useful to extract this part into a method (provided it has reasonable number of arguments. Similarly the else part.", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368332133", "createdAt": "2020-01-19T23:24:27Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,\n+              targetAssignment);\n+        } else {\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n+              instancePartitionsMap, targetAssignment);\n+        }\n       } else {\n         return new RebalanceResult(RebalanceResult.Status.NO_OP, \"Table is already balanced\", instancePartitionsMap,\n             targetAssignment);\n       }\n     }\n \n     if (dryRun) {\n-      LOGGER.info(\"Rebalance table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n+      LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n       return new RebalanceResult(RebalanceResult.Status.DONE, \"Dry-run mode\", instancePartitionsMap, targetAssignment);\n     }\n \n-    int minAvailableReplicas;\n-    if (rebalanceConfig.getBoolean(RebalanceConfigConstants.DOWNTIME, RebalanceConfigConstants.DEFAULT_DOWNTIME)) {\n-      minAvailableReplicas = 0;\n+    if (!downtime && !currentIdealState.isEnabled()) {\n+      LOGGER.warn(\"Table: {} is disabled, rebalancing it with downtime\", tableNameWithType);\n+      downtime = true;\n+    }\n+\n+    if (downtime) {\n       LOGGER.info(\"Rebalancing table: {} with downtime\", tableNameWithType);\n-    } else {\n-      minAvailableReplicas = rebalanceConfig.getInt(RebalanceConfigConstants.MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME,\n-          RebalanceConfigConstants.DEFAULT_MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME);\n-      int numCurrentReplicas = currentAssignment.values().iterator().next().size();\n-      int numTargetReplicas = targetAssignment.values().iterator().next().size();\n-      // Use the smaller one to determine the min available replicas\n-      int numReplicas = Math.min(numCurrentReplicas, numTargetReplicas);\n-      if (minAvailableReplicas > 0) {\n-        if (minAvailableReplicas >= numReplicas) {\n-          LOGGER.warn(\n-              \"Illegal config for min available replicas: {} for table: {}, must be less than number of replicas (current: {}, target: {})\",\n-              minAvailableReplicas, tableNameWithType, numCurrentReplicas, numTargetReplicas);\n-          return new RebalanceResult(RebalanceResult.Status.FAILED, \"Illegal min available replicas config\",\n+\n+      while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjcyOQ==", "bodyText": "Should we be passing the expected version into waitForExternalViewToConverge so that if the idealstate changes due to some other factor, we don't wait for convergence. Instead, we should execute the logic below.", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368332729", "createdAt": "2020-01-19T23:33:11Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,\n+              targetAssignment);\n+        } else {\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n+              instancePartitionsMap, targetAssignment);\n+        }\n       } else {\n         return new RebalanceResult(RebalanceResult.Status.NO_OP, \"Table is already balanced\", instancePartitionsMap,\n             targetAssignment);\n       }\n     }\n \n     if (dryRun) {\n-      LOGGER.info(\"Rebalance table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n+      LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n       return new RebalanceResult(RebalanceResult.Status.DONE, \"Dry-run mode\", instancePartitionsMap, targetAssignment);\n     }\n \n-    int minAvailableReplicas;\n-    if (rebalanceConfig.getBoolean(RebalanceConfigConstants.DOWNTIME, RebalanceConfigConstants.DEFAULT_DOWNTIME)) {\n-      minAvailableReplicas = 0;\n+    if (!downtime && !currentIdealState.isEnabled()) {\n+      LOGGER.warn(\"Table: {} is disabled, rebalancing it with downtime\", tableNameWithType);\n+      downtime = true;\n+    }\n+\n+    if (downtime) {\n       LOGGER.info(\"Rebalancing table: {} with downtime\", tableNameWithType);\n-    } else {\n-      minAvailableReplicas = rebalanceConfig.getInt(RebalanceConfigConstants.MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME,\n-          RebalanceConfigConstants.DEFAULT_MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME);\n-      int numCurrentReplicas = currentAssignment.values().iterator().next().size();\n-      int numTargetReplicas = targetAssignment.values().iterator().next().size();\n-      // Use the smaller one to determine the min available replicas\n-      int numReplicas = Math.min(numCurrentReplicas, numTargetReplicas);\n-      if (minAvailableReplicas > 0) {\n-        if (minAvailableReplicas >= numReplicas) {\n-          LOGGER.warn(\n-              \"Illegal config for min available replicas: {} for table: {}, must be less than number of replicas (current: {}, target: {})\",\n-              minAvailableReplicas, tableNameWithType, numCurrentReplicas, numTargetReplicas);\n-          return new RebalanceResult(RebalanceResult.Status.FAILED, \"Illegal min available replicas config\",\n+\n+      while (true) {\n+        // Reuse current IdealState to update the IdealState in cluster\n+        ZNRecord idealStateRecord = currentIdealState.getRecord();\n+        idealStateRecord.setMapFields(targetAssignment);\n+        currentIdealState.setNumPartitions(targetAssignment.size());\n+        currentIdealState.setReplicas(Integer.toString(targetAssignment.values().iterator().next().size()));\n+\n+        // Check version and update IdealState\n+        try {\n+          Preconditions.checkState(_helixDataAccessor.getBaseDataAccessor()\n+              .set(idealStatePropertyKey.getPath(), idealStateRecord, idealStateRecord.getVersion(),\n+                  AccessOption.PERSISTENT), \"Failed to update IdealState\");\n+          LOGGER.info(\"Finished rebalancing table: {} in {}ms.\", tableNameWithType,\n+              System.currentTimeMillis() - startTimeMs);\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Success\", instancePartitionsMap, targetAssignment);\n+        } catch (ZkBadVersionException e) {\n+          LOGGER.info(\"IdealState version changed for table: {}, re-calculating the target assignment\",\n+              tableNameWithType);\n+          try {\n+            IdealState idealState = _helixDataAccessor.getProperty(idealStatePropertyKey);\n+            // IdealState might be null if table got deleted, throwing exception to abort the rebalance\n+            Preconditions.checkState(idealState != null, \"Failed to find the IdealState\");\n+            currentIdealState = idealState;\n+            currentAssignment = currentIdealState.getRecord().getMapFields();\n+            targetAssignment =\n+                segmentAssignment.rebalanceTable(currentAssignment, instancePartitionsMap, rebalanceConfig);\n+          } catch (Exception e1) {\n+            LOGGER.error(\"Caught exception while re-calculating the target assignment for table: {}\", tableNameWithType,\n+                e1);\n+            return new RebalanceResult(RebalanceResult.Status.FAILED,\n+                \"Caught exception while re-calculating the target assignment: \" + e1, instancePartitionsMap,\n+                targetAssignment);\n+          }\n+        } catch (Exception e) {\n+          LOGGER.error(\"Caught exception while updating IdealState for table: {}\", tableNameWithType, e);\n+          return new RebalanceResult(RebalanceResult.Status.FAILED, \"Caught exception while updating IdealState: \" + e,\n               instancePartitionsMap, targetAssignment);\n         }\n       }\n-      // If min available replicas is negative, treat it as max unavailable replicas\n-      if (minAvailableReplicas < 0) {\n-        minAvailableReplicas = Math.max(numReplicas + minAvailableReplicas, 0);\n+    }\n+\n+    // Calculate the min available replicas for no-downtime rebalance\n+    int minAvailableReplicas = rebalanceConfig.getInt(RebalanceConfigConstants.MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME,\n+        RebalanceConfigConstants.DEFAULT_MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME);\n+    int numCurrentReplicas = currentAssignment.values().iterator().next().size();\n+    int numTargetReplicas = targetAssignment.values().iterator().next().size();\n+    // Use the smaller one to determine the min available replicas\n+    int numReplicas = Math.min(numCurrentReplicas, numTargetReplicas);\n+    if (minAvailableReplicas > 0) {\n+      if (minAvailableReplicas >= numReplicas) {\n+        LOGGER.warn(\n+            \"Illegal config for min available replicas: {} for table: {}, must be less than number of replicas (current: {}, target: {})\",\n+            minAvailableReplicas, tableNameWithType, numCurrentReplicas, numTargetReplicas);\n+        return new RebalanceResult(RebalanceResult.Status.FAILED, \"Illegal min available replicas config\",\n+            instancePartitionsMap, targetAssignment);\n       }\n-      LOGGER.info(\"Rebalancing table: {} with min available replicas: {}\", tableNameWithType, minAvailableReplicas);\n     }\n+    // If min available replicas is negative, treat it as max unavailable replicas\n+    if (minAvailableReplicas < 0) {\n+      minAvailableReplicas = Math.max(numReplicas + minAvailableReplicas, 0);\n+    }\n+    LOGGER.info(\"Rebalancing table: {} with min available replicas: {}\", tableNameWithType, minAvailableReplicas);\n \n     int expectedVersion = currentIdealState.getRecord().getVersion();\n     while (true) {\n       // Wait for ExternalView to converge before updating the next IdealState\n+      IdealState idealState;\n       try {\n-        IdealState idealState = waitForExternalViewToConverge(tableNameWithType);\n-        LOGGER.info(\"ExternalView converged for table: {}\", tableNameWithType);\n-        if (idealState.getRecord().getVersion() != expectedVersion) {\n-          LOGGER.info(\n-              \"IdealState version changed while waiting for ExternalView to converge for table: {}, re-calculating the target assignment\",\n-              tableNameWithType);\n+        idealState = waitForExternalViewToConverge(tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMzIzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                LOGGER.warn(\"ExternalView haven't converged within: {}ms for table: {}, continuing the rebalance\",\n          \n          \n            \n                LOGGER.warn(\"ExternalView has not converged within: {}ms for table: {}, continuing the rebalance\",", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368333237", "createdAt": "2020-01-19T23:40:33Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -307,32 +358,32 @@ private InstancePartitions getInstancePartitions(TableConfig tableConfig,\n   }\n \n   private IdealState waitForExternalViewToConverge(String tableNameWithType)\n-      throws InterruptedException, TimeoutException {\n+      throws InterruptedException {\n     long endTimeMs = System.currentTimeMillis() + EXTERNAL_VIEW_STABILIZATION_MAX_WAIT_MS;\n \n-    while (System.currentTimeMillis() < endTimeMs) {\n-      IdealState idealState =\n-          _helixDataAccessor.getProperty(_helixDataAccessor.keyBuilder().idealStates(tableNameWithType));\n+    IdealState idealState;\n+    do {\n+      idealState = _helixDataAccessor.getProperty(_helixDataAccessor.keyBuilder().idealStates(tableNameWithType));\n       // IdealState might be null if table got deleted, throwing exception to abort the rebalance\n       Preconditions.checkState(idealState != null, \"Failed to find the IdealState\");\n \n       ExternalView externalView =\n           _helixDataAccessor.getProperty(_helixDataAccessor.keyBuilder().externalView(tableNameWithType));\n       // ExternalView might be null when table is just created, skipping check for this iteration\n       if (externalView != null) {\n-        Map<String, Map<String, String>> externalViewSegmentStates = externalView.getRecord().getMapFields();\n-        if (isExternalViewConverged(externalViewSegmentStates, idealState.getRecord().getMapFields())) {\n+        if (isExternalViewConverged(tableNameWithType, externalView.getRecord().getMapFields(),\n+            idealState.getRecord().getMapFields())) {\n+          LOGGER.info(\"ExternalView converged for table: {}\", tableNameWithType);\n           return idealState;\n         }\n-        if (hasSegmentInErrorState(externalViewSegmentStates)) {\n-          throw new IllegalStateException(\"Found segments in ERROR state\");\n-        }\n       }\n \n       Thread.sleep(EXTERNAL_VIEW_CHECK_INTERVAL_MS);\n-    }\n+    } while (System.currentTimeMillis() < endTimeMs);\n \n-    throw new TimeoutException(\"Timeout while waiting for ExternalView to converge\");\n+    LOGGER.warn(\"ExternalView haven't converged within: {}ms for table: {}, continuing the rebalance\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMzQxNA==", "bodyText": "Is the condition inverted?", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368333414", "createdAt": "2020-01-19T23:42:54Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -420,10 +463,19 @@ static boolean isExternalViewConverged(Map<String, Map<String, String>> external\n       Map<String, String> idealStateInstanceStateMap = entry.getValue();\n       for (Map.Entry<String, String> instanceStateEntry : idealStateInstanceStateMap.entrySet()) {\n         // Ignore OFFLINE state in IdealState\n-        String state = instanceStateEntry.getValue();\n-        if (!state.equals(SegmentOnlineOfflineStateModel.OFFLINE) && !state\n-            .equals(externalViewInstanceStateMap.get(instanceStateEntry.getKey()))) {\n-          return false;\n+        String idealStateInstanceState = instanceStateEntry.getValue();\n+        if (!idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMzgwMA==", "bodyText": "I think  a warning is better. The server instance, when it transitioned into ERROR state, would have logged an error anyway. It is not an error in the controller if it discovers that a server was malfunctioning.\nOn another (but related) note, I would avoid logging strings that have \"ERROR\". It is quite irritating to see these come up when we see some problem, and want to get all the error logs (as in, logs that have been logged with LOGGER.error() statement). I am not sure we can do much here, but something to note.", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368333800", "createdAt": "2020-01-19T23:48:10Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -420,10 +463,19 @@ static boolean isExternalViewConverged(Map<String, Map<String, String>> external\n       Map<String, String> idealStateInstanceStateMap = entry.getValue();\n       for (Map.Entry<String, String> instanceStateEntry : idealStateInstanceStateMap.entrySet()) {\n         // Ignore OFFLINE state in IdealState\n-        String state = instanceStateEntry.getValue();\n-        if (!state.equals(SegmentOnlineOfflineStateModel.OFFLINE) && !state\n-            .equals(externalViewInstanceStateMap.get(instanceStateEntry.getKey()))) {\n-          return false;\n+        String idealStateInstanceState = instanceStateEntry.getValue();\n+        if (!idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {\n+          continue;\n+        }\n+        String instanceName = instanceStateEntry.getKey();\n+        String externalViewInstanceState = externalViewInstanceStateMap.get(instanceName);\n+        if (!idealStateInstanceState.equals(externalViewInstanceState)) {\n+          if (RealtimeSegmentOnlineOfflineStateModel.ERROR.equals(externalViewInstanceState)) {\n+            LOGGER.warn(\"Found ERROR instance: {} for segment: {}, table: {}\", instanceName, segmentName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMTg1NQ=="}, "originalCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367"}, "originalPosition": 401}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "83a32918c257be3d400e32aefcaa037871c8c367", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/83a32918c257be3d400e32aefcaa037871c8c367", "committedDate": "2020-01-15T20:42:03Z", "message": "Enhance TableRebalancer to be able to rebalance table under any condition\n\nBest effore rebalance in the following scenario (min available replicas won't be guaranteed)\n- Table with segments in ERROR state\n- ExternalView not converged within the timeout\n\nAlso add support for rebalancing Helix disabled table"}, "afterCommit": {"oid": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "committedDate": "2020-01-22T00:50:02Z", "message": "Address comments, add more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2Mjk3NzI3", "url": "https://github.com/apache/pinot/pull/4990#pullrequestreview-346297727", "createdAt": "2020-01-22T01:22:57Z", "commit": {"oid": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "committedDate": "2020-01-22T00:50:02Z", "message": "Address comments, add more tests"}, "afterCommit": {"oid": "0ad78b7887bf1a9059742f00eb5b03c9174a9f10", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/0ad78b7887bf1a9059742f00eb5b03c9174a9f10", "committedDate": "2020-01-22T05:38:36Z", "message": "Enhance TableRebalancer to be able to rebalance table under any condition\n\nAdd a new option: \"bestEfforts\" to allow rebalance in the following scenario (min available replicas won't be guaranteed)\n- Table with segments in ERROR state\n- ExternalView not converged within the max wait time\n\nAlso add support for rebalancing Helix disabled table with downtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f84d46a9856e55aa2854adea8e94dfc0440fad8d", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/f84d46a9856e55aa2854adea8e94dfc0440fad8d", "committedDate": "2020-01-22T06:13:00Z", "message": "Enhance TableRebalancer to be able to rebalance table under any condition\n\nAdd a new option: \"bestEfforts\" to allow rebalance in the following scenario (min available replicas won't be guaranteed)\n- Table with segments in ERROR state\n- ExternalView not converged within the max wait time\n\nAlso add support for rebalancing Helix disabled table with downtime"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ad78b7887bf1a9059742f00eb5b03c9174a9f10", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/0ad78b7887bf1a9059742f00eb5b03c9174a9f10", "committedDate": "2020-01-22T05:38:36Z", "message": "Enhance TableRebalancer to be able to rebalance table under any condition\n\nAdd a new option: \"bestEfforts\" to allow rebalance in the following scenario (min available replicas won't be guaranteed)\n- Table with segments in ERROR state\n- ExternalView not converged within the max wait time\n\nAlso add support for rebalancing Helix disabled table with downtime"}, "afterCommit": {"oid": "f84d46a9856e55aa2854adea8e94dfc0440fad8d", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/f84d46a9856e55aa2854adea8e94dfc0440fad8d", "committedDate": "2020-01-22T06:13:00Z", "message": "Enhance TableRebalancer to be able to rebalance table under any condition\n\nAdd a new option: \"bestEfforts\" to allow rebalance in the following scenario (min available replicas won't be guaranteed)\n- Table with segments in ERROR state\n- ExternalView not converged within the max wait time\n\nAlso add support for rebalancing Helix disabled table with downtime"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1486, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}