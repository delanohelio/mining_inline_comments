{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5NDkxNDU2", "number": 5774, "reviewThreads": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMjozNlrOEVdAEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTozMzoyMlrOEVjHEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMwNzA0OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotTableRestletResource.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMjozNlrOG8Nydw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTo1NjoxN1rOG9pvpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MzY1NQ==", "bodyText": "We should also use @consumes annotation right?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465793655", "createdAt": "2020-08-05T15:02:36Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotTableRestletResource.java", "diffHunk": "@@ -141,6 +142,18 @@ public SuccessResponse addTable(String tableConfigStr) {\n     }\n   }\n \n+  @PUT\n+  @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MDAwNg==", "bodyText": "got it", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465940006", "createdAt": "2020-08-05T19:02:30Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotTableRestletResource.java", "diffHunk": "@@ -141,6 +142,18 @@ public SuccessResponse addTable(String tableConfigStr) {\n     }\n   }\n \n+  @PUT\n+  @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MzY1NQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDI2Mg==", "bodyText": "I stayed with only @Produces(MediaType.APPLICATION_JSON) to follow the pattern of other APIs", "url": "https://github.com/apache/pinot/pull/5774#discussion_r467300262", "createdAt": "2020-08-07T21:56:17Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotTableRestletResource.java", "diffHunk": "@@ -141,6 +142,18 @@ public SuccessResponse addTable(String tableConfigStr) {\n     }\n   }\n \n+  @PUT\n+  @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MzY1NQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMwNzU3OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/RecommenderDriver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMjo0MlrOG8Nyyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTo1NjoyNVrOG9pv-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MzczOA==", "bodyText": "A concise javadoc would be helpful explaining the purpose of each class. No need to explain the algorithm, but bullet-list items explaining the responsibility of the class", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465793738", "createdAt": "2020-08-05T15:02:42Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/RecommenderDriver.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class RecommenderDriver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDM0Nw==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r467300347", "createdAt": "2020-08-07T21:56:25Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/RecommenderDriver.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class RecommenderDriver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MzczOA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMwODAxOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/ConfigManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMjo0OVrOG8NzGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoyODozNVrOG8VlpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MzgxNw==", "bodyText": "IIUC, this is the output side right?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465793817", "createdAt": "2020-08-05T15:02:49Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/ConfigManager.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import org.apache.pinot.controller.recommender.rules.io.FlaggedQueries;\n+import org.apache.pinot.controller.recommender.rules.io.configs.IndexConfig;\n+import org.apache.pinot.controller.recommender.rules.io.configs.PartitionConfig;\n+\n+\n+public class ConfigManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMTQ0NA==", "bodyText": "Yes I will add java docs...", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465921444", "createdAt": "2020-08-05T18:28:35Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/ConfigManager.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import org.apache.pinot.controller.recommender.rules.io.FlaggedQueries;\n+import org.apache.pinot.controller.recommender.rules.io.configs.IndexConfig;\n+import org.apache.pinot.controller.recommender.rules.io.configs.PartitionConfig;\n+\n+\n+public class ConfigManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MzgxNw=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMwODM1OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMjo1M1rOG8NzVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTozMDozOFrOG9BXFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5Mzg3Ng==", "bodyText": "javadoc please", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465793876", "createdAt": "2020-08-05T15:02:53Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzODYxMg==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466638612", "createdAt": "2020-08-06T19:30:38Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5Mzg3Ng=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMwOTAxOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMjo1OVrOG8NzsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTowMzowN1rOG8WvYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5Mzk2OQ==", "bodyText": "consider naming it numMessagesPerSecInKafKaTopic and add a comment stating this is applicable to realtime/hybrid table", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465793969", "createdAt": "2020-08-05T15:02:59Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MDMyMw==", "bodyText": "got it", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465940323", "createdAt": "2020-08-05T19:03:07Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5Mzk2OQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMwOTI2OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzowNFrOG8Nz3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTozMDozMVrOG9BWzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDAxNQ==", "bodyText": "I think we need to make the purpose of overwrittenConfigs more clear. IIUC, this works as follows:\nI as a user/dev wants to use the rule engine to recommend configs. However, based on my experience or due to a special optimization for a use case, I know that it will help to have inverted index on a particular column. But I still want to run the engine to recommend inverted indexes on other columns (if applicable) and recommend other configs (sorted, bloom etc). The engine will do it's job of recommending by taking into account the overwritten config and honoring it. In other words, the recommended config is going to be a super-set of the overwritten config. Is this understanding correct?\nWe should highlight the purpose clearly in comments", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794015", "createdAt": "2020-08-05T15:03:04Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5NjQyNA==", "bodyText": "added comments", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466096424", "createdAt": "2020-08-06T01:42:31Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDAxNQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzODU0MA==", "bodyText": "Added code comments", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466638540", "createdAt": "2020-08-06T19:30:31Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDAxNQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMwOTUyOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzowN1rOG8N0Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTowNToxOFrOG8Wz3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDA1OA==", "bodyText": "I don't think I fully understand why this should be ignored by the deserializer", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794058", "createdAt": "2020-08-05T15:03:07Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyNjc2Ng==", "bodyText": "The fields following this line are pre-processed from the input and used as algorithm input only, so no need to serialize/deserialize them using jackson.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465926766", "createdAt": "2020-08-05T18:38:25Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDA1OA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MTQ2OA==", "bodyText": "Got it. Thanks.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465941468", "createdAt": "2020-08-05T19:05:18Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDA1OA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMwOTgyOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzoxMFrOG8N0OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzoxMFrOG8N0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDEwNQ==", "bodyText": "Please see my comment above w.r.t explaining the purpose and usage of overwritten configs.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794105", "createdAt": "2020-08-05T15:03:10Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/\n+  public Map<String, ColumnMetaData> _metaDataMap = new HashMap<>(); // meta data per column, complement to schema\n+  long _sizePerRecord = 0;\n+  Map<String, FieldSpec.DataType> _colnameFieldTypeMap = new HashMap<>();\n+  Set<String> _dimNames = null;\n+  Set<String> _metricNames = null;\n+  Set<String> _dateTimeNames = null;\n+  Set<String> _dimNamesInveredSortedIndexApplicable = null;\n+  Map<String, Integer> _colNameToIntMap = null;\n+  String[] _intToColNameMap = null;\n+  Map<FieldSpec.DataType, Integer> _dataTypeSizeMap = new HashMap<FieldSpec.DataType, Integer>() {{\n+    put(FieldSpec.DataType.INT, DEFAULT_INT_SIZE);\n+    put(FieldSpec.DataType.LONG, DEFAULT_LONG_SIZE);\n+    put(FieldSpec.DataType.FLOAT, DEFAULT_FLOAT_SIZE);\n+    put(FieldSpec.DataType.DOUBLE, DEFAULT_DOUBLE_SIZE);\n+    put(FieldSpec.DataType.BYTES, DEFAULT_BYTE_SIZE);\n+    put(FieldSpec.DataType.STRING, DEFAULT_CHAR_SIZE);\n+    put(null, DEFAULT_NULL_SIZE);\n+  }};\n+\n+  /**\n+   * Process the dependencies incurred by overwritten configs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxMDQyOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/exceptions/InvalidInputException.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzoxOFrOG8N0jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTowNTozM1rOG8W0XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDE4OA==", "bodyText": "Why did we move this class to the recommender? Is it not being used elsewhere?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794188", "createdAt": "2020-08-05T15:03:18Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/exceptions/InvalidInputException.java", "diffHunk": "@@ -16,14 +16,12 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.pinot.tools.tuner.query.src.stats.wrapper;\n+package org.apache.pinot.controller.recommender.io.exceptions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMDAzMw==", "bodyText": "The tuner package was the old code for index recommender. I did reuse some of the old code, so github shows I'm moving some files from the old package. But I'm not sure why this happens in InvalidInputException class as it is completely new. The old  index recommender is not used anywhere right now so I removed  the sources completely.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465930033", "createdAt": "2020-08-05T18:44:27Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/exceptions/InvalidInputException.java", "diffHunk": "@@ -16,14 +16,12 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.pinot.tools.tuner.query.src.stats.wrapper;\n+package org.apache.pinot.controller.recommender.io.exceptions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDE4OA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MTU5Ng==", "bodyText": "Got it. Thanks", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465941596", "createdAt": "2020-08-05T19:05:33Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/exceptions/InvalidInputException.java", "diffHunk": "@@ -16,14 +16,12 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.pinot.tools.tuner.query.src.stats.wrapper;\n+package org.apache.pinot.controller.recommender.io.exceptions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDE4OA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxMDc4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/metadata/ColumnMetaData.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzoyM1rOG8N0wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTowNjowOFrOG8W1bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDI0MA==", "bodyText": "We have an existing class ColumnMetadata in pinot-core. Although, this is in a different package so there shouldn't be any conflict. But, just to avoid any confusion (intellij will display both files as the user starts typing the name in file search), please consider renaming it.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794240", "createdAt": "2020-08-05T15:03:23Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/metadata/ColumnMetaData.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io.metadata;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.DEFAULT_CARDINALITY;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.DEFAULT_DATA_LENGTH;\n+\n+\n+/**\n+ * The metadata of a column\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ColumnMetaData extends FieldSpec {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MTg2OQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465941869", "createdAt": "2020-08-05T19:06:08Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/metadata/ColumnMetaData.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io.metadata;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.DEFAULT_CARDINALITY;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.DEFAULT_DATA_LENGTH;\n+\n+\n+/**\n+ * The metadata of a column\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ColumnMetaData extends FieldSpec {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDI0MA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxMTE4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/AbstractRule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzoyOFrOG8N1AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTowNjoxN1rOG8W1zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDMwNQ==", "bodyText": "This should be a new class/interface for the recommender right? Why are we moving an existing class? or is this a github issue?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794305", "createdAt": "2020-08-05T15:03:28Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/AbstractRule.java", "diffHunk": "@@ -16,22 +16,19 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.pinot.tools.tuner.query.src.parser;\n+package org.apache.pinot.controller.recommender.rules;\n \n-import javax.annotation.Nullable;\n-import org.apache.pinot.tools.tuner.query.src.stats.wrapper.AbstractQueryStats;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n \n \n-/**\n- * Parser interface for a query line\n- */\n-public interface QueryParser {\n-  /**\n-   * parse the the complete log line to a parsed obj\n-   * @param line the complete log line to be parsed, InputIterator should put broken lines together\n-   * @return the parsed log line obj\n-   */\n-  @Nullable\n-  AbstractQueryStats parse(String line);\n-}\n+public abstract class AbstractRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjAzMQ==", "bodyText": "Please see the above conversation.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465932031", "createdAt": "2020-08-05T18:48:06Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/AbstractRule.java", "diffHunk": "@@ -16,22 +16,19 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.pinot.tools.tuner.query.src.parser;\n+package org.apache.pinot.controller.recommender.rules;\n \n-import javax.annotation.Nullable;\n-import org.apache.pinot.tools.tuner.query.src.stats.wrapper.AbstractQueryStats;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n \n \n-/**\n- * Parser interface for a query line\n- */\n-public interface QueryParser {\n-  /**\n-   * parse the the complete log line to a parsed obj\n-   * @param line the complete log line to be parsed, InputIterator should put broken lines together\n-   * @return the parsed log line obj\n-   */\n-  @Nullable\n-  AbstractQueryStats parse(String line);\n-}\n+public abstract class AbstractRule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDMwNQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MTk2Nw==", "bodyText": "Got it. They came from tuner", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465941967", "createdAt": "2020-08-05T19:06:17Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/AbstractRule.java", "diffHunk": "@@ -16,22 +16,19 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.pinot.tools.tuner.query.src.parser;\n+package org.apache.pinot.controller.recommender.rules;\n \n-import javax.annotation.Nullable;\n-import org.apache.pinot.tools.tuner.query.src.stats.wrapper.AbstractQueryStats;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n \n \n-/**\n- * Parser interface for a query line\n- */\n-public interface QueryParser {\n-  /**\n-   * parse the the complete log line to a parsed obj\n-   * @param line the complete log line to be parsed, InputIterator should put broken lines together\n-   * @return the parsed log line obj\n-   */\n-  @Nullable\n-  AbstractQueryStats parse(String line);\n-}\n+public abstract class AbstractRule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDMwNQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxMTY5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/RulesToExecute.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzozM1rOG8N1Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTo1MTozM1rOG8b53g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDM3OQ==", "bodyText": "Javadoc would be nice", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794379", "createdAt": "2020-08-05T15:03:33Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/RulesToExecute.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.impl.BloomFilterRule;\n+import org.apache.pinot.controller.recommender.rules.impl.FlagQueryRule;\n+import org.apache.pinot.controller.recommender.rules.impl.InvertedSortedIndexJointRule;\n+import org.apache.pinot.controller.recommender.rules.impl.KafkaPartitionRule;\n+import org.apache.pinot.controller.recommender.rules.impl.NoDictionaryOnHeapDictionaryJointRule;\n+import org.apache.pinot.controller.recommender.rules.impl.PinotTablePartitionRule;\n+import org.apache.pinot.controller.recommender.rules.impl.VariedLengthDictionaryRule;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.RulesToExecute.*;\n+\n+\n+public class RulesToExecute {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyNDkyNg==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466024926", "createdAt": "2020-08-05T21:51:33Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/RulesToExecute.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.impl.BloomFilterRule;\n+import org.apache.pinot.controller.recommender.rules.impl.FlagQueryRule;\n+import org.apache.pinot.controller.recommender.rules.impl.InvertedSortedIndexJointRule;\n+import org.apache.pinot.controller.recommender.rules.impl.KafkaPartitionRule;\n+import org.apache.pinot.controller.recommender.rules.impl.NoDictionaryOnHeapDictionaryJointRule;\n+import org.apache.pinot.controller.recommender.rules.impl.PinotTablePartitionRule;\n+import org.apache.pinot.controller.recommender.rules.impl.VariedLengthDictionaryRule;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.RulesToExecute.*;\n+\n+\n+public class RulesToExecute {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDM3OQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxMjM1OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/RulesToExecute.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzo0M1rOG8N1vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTo1MToyOFrOG8b5tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDQ5NA==", "bodyText": "The enum name shouldn't really have \"plural\". The enum although defines multiple constants, it represents only 1 of them at a give time. So, we should simply call it Rule?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794494", "createdAt": "2020-08-05T15:03:43Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/RulesToExecute.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.impl.BloomFilterRule;\n+import org.apache.pinot.controller.recommender.rules.impl.FlagQueryRule;\n+import org.apache.pinot.controller.recommender.rules.impl.InvertedSortedIndexJointRule;\n+import org.apache.pinot.controller.recommender.rules.impl.KafkaPartitionRule;\n+import org.apache.pinot.controller.recommender.rules.impl.NoDictionaryOnHeapDictionaryJointRule;\n+import org.apache.pinot.controller.recommender.rules.impl.PinotTablePartitionRule;\n+import org.apache.pinot.controller.recommender.rules.impl.VariedLengthDictionaryRule;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.RulesToExecute.*;\n+\n+\n+public class RulesToExecute {\n+  public static class RuleFactory {\n+    public static AbstractRule getRule(Rules rule, InputManager inputManager, ConfigManager outputManager) {\n+      switch (rule) {\n+        case FlagQueryRule:\n+          return new FlagQueryRule(inputManager, outputManager);\n+        case InvertedSortedIndexJointRule:\n+          return new InvertedSortedIndexJointRule(inputManager, outputManager);\n+        case KafkaPartitionRule:\n+          return new KafkaPartitionRule(inputManager, outputManager);\n+        case PinotTablePartitionRule:\n+          return new PinotTablePartitionRule(inputManager, outputManager);\n+        case BloomFilterRule:\n+          return new BloomFilterRule(inputManager, outputManager);\n+        case NoDictionaryOnHeapDictionaryJointRule:\n+          return new NoDictionaryOnHeapDictionaryJointRule(inputManager, outputManager);\n+        case VariedLengthDictionaryRule:\n+          return new VariedLengthDictionaryRule(inputManager, outputManager);\n+        default:\n+          return null;\n+      }\n+    }\n+  }\n+  // All rules will execute by default unless explicitly specifying \"recommendInvertedSortedIndexJoint\" = \"false\"\n+  boolean _recommendKafkaPartition = DEFAULT_RECOMMEND_KAFKA_PARTITION;\n+  boolean _recommendPinotTablePartition = DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION;\n+  boolean _recommendInvertedSortedIndexJoint = DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT;\n+  boolean _recommendBloomFilter = DEFAULT_RECOMMEND_BLOOM_FILTER;\n+  boolean _recommendNoDictionaryOnHeapDictionaryJoint = DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT;\n+  boolean _recommendVariedLengthDictionary = DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY;\n+  boolean _recommendFlagQuery = DEFAULT_RECOMMEND_FLAG_QUERY;\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendVariedLengthDictionary(boolean recommendVariedLengthDictionary) {\n+    _recommendVariedLengthDictionary = recommendVariedLengthDictionary;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendFlagQuery(boolean recommendFlagQuery) {\n+    _recommendFlagQuery = recommendFlagQuery;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendNoDictionaryOnHeapDictionaryJoint(boolean recommendNoDictionaryOnHeapDictionaryJoint) {\n+    _recommendNoDictionaryOnHeapDictionaryJoint = recommendNoDictionaryOnHeapDictionaryJoint;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendKafkaPartition(boolean recommendKafkaPartition) {\n+    _recommendKafkaPartition = recommendKafkaPartition;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendInvertedSortedIndexJoint(boolean recommendInvertedSortedIndexJoint) {\n+    _recommendInvertedSortedIndexJoint = recommendInvertedSortedIndexJoint;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendPinotTablePartition(boolean recommendPinotTablePartition) {\n+    _recommendPinotTablePartition = recommendPinotTablePartition;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendBloomFilter(boolean recommendBloomFilter) {\n+    _recommendBloomFilter = recommendBloomFilter;\n+  }\n+\n+  public boolean isRecommendVariedLengthDictionary() {\n+    return _recommendVariedLengthDictionary;\n+  }\n+\n+  public boolean isRecommendFlagQuery() {\n+    return _recommendFlagQuery;\n+  }\n+\n+  public boolean isRecommendNoDictionaryOnHeapDictionaryJoint() {\n+    return _recommendNoDictionaryOnHeapDictionaryJoint;\n+  }\n+\n+  public boolean isRecommendKafkaPartition() {\n+    return _recommendKafkaPartition;\n+  }\n+\n+  public boolean isRecommendInvertedSortedIndexJoint() {\n+    return _recommendInvertedSortedIndexJoint;\n+  }\n+\n+  public boolean isRecommendPinotTablePartition() {\n+    return _recommendPinotTablePartition;\n+  }\n+\n+  public boolean isRecommendBloomFilter() {\n+    return _recommendBloomFilter;\n+  }\n+\n+  public enum Rules {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyNDg4NQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466024885", "createdAt": "2020-08-05T21:51:28Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/RulesToExecute.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.impl.BloomFilterRule;\n+import org.apache.pinot.controller.recommender.rules.impl.FlagQueryRule;\n+import org.apache.pinot.controller.recommender.rules.impl.InvertedSortedIndexJointRule;\n+import org.apache.pinot.controller.recommender.rules.impl.KafkaPartitionRule;\n+import org.apache.pinot.controller.recommender.rules.impl.NoDictionaryOnHeapDictionaryJointRule;\n+import org.apache.pinot.controller.recommender.rules.impl.PinotTablePartitionRule;\n+import org.apache.pinot.controller.recommender.rules.impl.VariedLengthDictionaryRule;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.RulesToExecute.*;\n+\n+\n+public class RulesToExecute {\n+  public static class RuleFactory {\n+    public static AbstractRule getRule(Rules rule, InputManager inputManager, ConfigManager outputManager) {\n+      switch (rule) {\n+        case FlagQueryRule:\n+          return new FlagQueryRule(inputManager, outputManager);\n+        case InvertedSortedIndexJointRule:\n+          return new InvertedSortedIndexJointRule(inputManager, outputManager);\n+        case KafkaPartitionRule:\n+          return new KafkaPartitionRule(inputManager, outputManager);\n+        case PinotTablePartitionRule:\n+          return new PinotTablePartitionRule(inputManager, outputManager);\n+        case BloomFilterRule:\n+          return new BloomFilterRule(inputManager, outputManager);\n+        case NoDictionaryOnHeapDictionaryJointRule:\n+          return new NoDictionaryOnHeapDictionaryJointRule(inputManager, outputManager);\n+        case VariedLengthDictionaryRule:\n+          return new VariedLengthDictionaryRule(inputManager, outputManager);\n+        default:\n+          return null;\n+      }\n+    }\n+  }\n+  // All rules will execute by default unless explicitly specifying \"recommendInvertedSortedIndexJoint\" = \"false\"\n+  boolean _recommendKafkaPartition = DEFAULT_RECOMMEND_KAFKA_PARTITION;\n+  boolean _recommendPinotTablePartition = DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION;\n+  boolean _recommendInvertedSortedIndexJoint = DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT;\n+  boolean _recommendBloomFilter = DEFAULT_RECOMMEND_BLOOM_FILTER;\n+  boolean _recommendNoDictionaryOnHeapDictionaryJoint = DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT;\n+  boolean _recommendVariedLengthDictionary = DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY;\n+  boolean _recommendFlagQuery = DEFAULT_RECOMMEND_FLAG_QUERY;\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendVariedLengthDictionary(boolean recommendVariedLengthDictionary) {\n+    _recommendVariedLengthDictionary = recommendVariedLengthDictionary;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendFlagQuery(boolean recommendFlagQuery) {\n+    _recommendFlagQuery = recommendFlagQuery;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendNoDictionaryOnHeapDictionaryJoint(boolean recommendNoDictionaryOnHeapDictionaryJoint) {\n+    _recommendNoDictionaryOnHeapDictionaryJoint = recommendNoDictionaryOnHeapDictionaryJoint;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendKafkaPartition(boolean recommendKafkaPartition) {\n+    _recommendKafkaPartition = recommendKafkaPartition;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendInvertedSortedIndexJoint(boolean recommendInvertedSortedIndexJoint) {\n+    _recommendInvertedSortedIndexJoint = recommendInvertedSortedIndexJoint;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendPinotTablePartition(boolean recommendPinotTablePartition) {\n+    _recommendPinotTablePartition = recommendPinotTablePartition;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRecommendBloomFilter(boolean recommendBloomFilter) {\n+    _recommendBloomFilter = recommendBloomFilter;\n+  }\n+\n+  public boolean isRecommendVariedLengthDictionary() {\n+    return _recommendVariedLengthDictionary;\n+  }\n+\n+  public boolean isRecommendFlagQuery() {\n+    return _recommendFlagQuery;\n+  }\n+\n+  public boolean isRecommendNoDictionaryOnHeapDictionaryJoint() {\n+    return _recommendNoDictionaryOnHeapDictionaryJoint;\n+  }\n+\n+  public boolean isRecommendKafkaPartition() {\n+    return _recommendKafkaPartition;\n+  }\n+\n+  public boolean isRecommendInvertedSortedIndexJoint() {\n+    return _recommendInvertedSortedIndexJoint;\n+  }\n+\n+  public boolean isRecommendPinotTablePartition() {\n+    return _recommendPinotTablePartition;\n+  }\n+\n+  public boolean isRecommendBloomFilter() {\n+    return _recommendBloomFilter;\n+  }\n+\n+  public enum Rules {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDQ5NA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxMjYzOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/BloomFilterRule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzo0N1rOG8N16g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOToyOTo1N1rOG9BVrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDUzOA==", "bodyText": "Please add javadoc and brief explanation of the rule's algorithm. We already have that in the design, so just englishize it here :)", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794538", "createdAt": "2020-08-05T15:03:47Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/BloomFilterRule.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class  BloomFilterRule extends AbstractRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5OTcwNA==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466099704", "createdAt": "2020-08-06T01:54:55Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/BloomFilterRule.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class  BloomFilterRule extends AbstractRule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDUzOA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzODI1NA==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466638254", "createdAt": "2020-08-06T19:29:57Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/BloomFilterRule.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class  BloomFilterRule extends AbstractRule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDUzOA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxMjkzOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/BloomFilterRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzo1M1rOG8N2KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMDozNzoyN1rOG8fNYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDYwMA==", "bodyText": "Mark this is as a TODO since it can be easily spotted in the code if someone stumbles upon it in the future.\nTODO: once Pinot starts supporting bloom filter based pruning for IN, !=, NOT IN, we should enhance the algorithm of this rule.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794600", "createdAt": "2020-08-05T15:03:53Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/BloomFilterRule.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class  BloomFilterRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(BloomFilterRule.class);\n+  private final BloomFilterRuleParams _params;\n+  protected final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+\n+  public BloomFilterRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getBloomFilterRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    int numDims = _inputManager.getNumDims();\n+    double[] weights = new double[numDims];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    // For each query, find out the dimensions used in 'EQ'\n+    // and accumulate the (weighted) frequencies\n+    _inputManager.getQueryWeightMap().forEach((query,weight) -> {\n+      totalWeight.addAndGet(weight);\n+      FixedLenBitset fixedLenBitset = parseQuery(query);\n+      LOGGER.debug(\"fixedLenBitset {}\", fixedLenBitset);\n+      for (Integer i : fixedLenBitset.getOffsets()) {\n+        weights[i] += weight;\n+      }\n+    });\n+    LOGGER.debug(\"Weight: {}, Total {}\", weights, totalWeight);\n+\n+    for (int i = 0; i < numDims; i++) {\n+      String dimName = _inputManager.intToColName(i);\n+      if (((weights[i] / totalWeight.get()) > _params.THRESHOLD_MIN_PERCENT_EQ_BLOOMFILTER)\n+          //The partitioned dimension should be frequently > P used\n+          && (_inputManager.getCardinality(dimName)\n+          < _params.THRESHOLD_MAX_CARDINALITY_BLOOMFILTER)) { //The Cardinality < C (1 million for 1MB size)\n+        _outputManager.getIndexConfig().getBloomFilterColumns().add(dimName);\n+      }\n+    }\n+  }\n+\n+  public FixedLenBitset parseQuery(String queryString) {\n+    LOGGER.debug(\"Parsing query: {}\", queryString);\n+    if (queryString == null) {\n+      return FixedLenBitset.IMMUTABLE_EMPTY_SET;\n+    }\n+\n+    BrokerRequest brokerRequest;\n+    AbstractCompiler parser = PinotQueryParserFactory.get(_inputManager.getQueryType());\n+    try {\n+      brokerRequest = parser.compileToBrokerRequest(queryString);\n+    } catch (SqlCompilationException e) {\n+      LOGGER.error(\"Error parsing query: {}, {}\", queryString, e.getMessage());\n+      return FixedLenBitset.IMMUTABLE_EMPTY_SET;\n+    }\n+    BrokerRequest optimizedRequest = _brokerRequestOptimizer.optimize(brokerRequest, _inputManager.getTimeCol());\n+    QueryContext queryContext = BrokerRequestToQueryContextConverter.convert(optimizedRequest);\n+\n+    if (queryContext.getFilter() == null) {\n+      return FixedLenBitset.IMMUTABLE_EMPTY_SET;\n+    }\n+\n+    LOGGER.trace(\"Parsing Where Clause: {}\", queryContext.getFilter().toString());\n+    return parsePredicateList(queryContext.getFilter());\n+  }\n+\n+  /**\n+   * The partitioned dimension should used in the \u201c=\u201d \uff08IN, NOT IN, != are not using bloom filter in Pinot for now) filter.\n+   * @param filterContext filterContext", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3OTA3Mg==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466079072", "createdAt": "2020-08-06T00:37:27Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/BloomFilterRule.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class  BloomFilterRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(BloomFilterRule.class);\n+  private final BloomFilterRuleParams _params;\n+  protected final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+\n+  public BloomFilterRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getBloomFilterRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    int numDims = _inputManager.getNumDims();\n+    double[] weights = new double[numDims];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    // For each query, find out the dimensions used in 'EQ'\n+    // and accumulate the (weighted) frequencies\n+    _inputManager.getQueryWeightMap().forEach((query,weight) -> {\n+      totalWeight.addAndGet(weight);\n+      FixedLenBitset fixedLenBitset = parseQuery(query);\n+      LOGGER.debug(\"fixedLenBitset {}\", fixedLenBitset);\n+      for (Integer i : fixedLenBitset.getOffsets()) {\n+        weights[i] += weight;\n+      }\n+    });\n+    LOGGER.debug(\"Weight: {}, Total {}\", weights, totalWeight);\n+\n+    for (int i = 0; i < numDims; i++) {\n+      String dimName = _inputManager.intToColName(i);\n+      if (((weights[i] / totalWeight.get()) > _params.THRESHOLD_MIN_PERCENT_EQ_BLOOMFILTER)\n+          //The partitioned dimension should be frequently > P used\n+          && (_inputManager.getCardinality(dimName)\n+          < _params.THRESHOLD_MAX_CARDINALITY_BLOOMFILTER)) { //The Cardinality < C (1 million for 1MB size)\n+        _outputManager.getIndexConfig().getBloomFilterColumns().add(dimName);\n+      }\n+    }\n+  }\n+\n+  public FixedLenBitset parseQuery(String queryString) {\n+    LOGGER.debug(\"Parsing query: {}\", queryString);\n+    if (queryString == null) {\n+      return FixedLenBitset.IMMUTABLE_EMPTY_SET;\n+    }\n+\n+    BrokerRequest brokerRequest;\n+    AbstractCompiler parser = PinotQueryParserFactory.get(_inputManager.getQueryType());\n+    try {\n+      brokerRequest = parser.compileToBrokerRequest(queryString);\n+    } catch (SqlCompilationException e) {\n+      LOGGER.error(\"Error parsing query: {}, {}\", queryString, e.getMessage());\n+      return FixedLenBitset.IMMUTABLE_EMPTY_SET;\n+    }\n+    BrokerRequest optimizedRequest = _brokerRequestOptimizer.optimize(brokerRequest, _inputManager.getTimeCol());\n+    QueryContext queryContext = BrokerRequestToQueryContextConverter.convert(optimizedRequest);\n+\n+    if (queryContext.getFilter() == null) {\n+      return FixedLenBitset.IMMUTABLE_EMPTY_SET;\n+    }\n+\n+    LOGGER.trace(\"Parsing Where Clause: {}\", queryContext.getFilter().toString());\n+    return parsePredicateList(queryContext.getFilter());\n+  }\n+\n+  /**\n+   * The partitioned dimension should used in the \u201c=\u201d \uff08IN, NOT IN, != are not using bloom filter in Pinot for now) filter.\n+   * @param filterContext filterContext", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDYwMA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxNDY0OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNDoxOVrOG8N3VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTozMDowNVrOG9BV9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDkwMQ==", "bodyText": "Please add javadoc and brief explanation of the algorithm (please do this for all rules)", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794901", "createdAt": "2020-08-05T15:04:19Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzODMyNw==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466638327", "createdAt": "2020-08-06T19:30:05Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDkwMQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxNTAyOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNDoyM1rOG8N3hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMDozNDo1MlrOG8fKtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDk1MQ==", "bodyText": "Not sure if I follow this. If the column is in filter and group by, why do we have to consider the frequency?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465794951", "createdAt": "2020-08-05T15:04:23Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MzYxNg==", "bodyText": "Add a comment explaining the rationale", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465943616", "createdAt": "2020-08-05T19:09:31Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDk1MQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODM5MA==", "bodyText": "resolved", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466078390", "createdAt": "2020-08-06T00:34:52Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDk1MQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMyNTI2OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNjo0OVrOG8N-Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMDozNDozNlrOG8fKcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NjYzMQ==", "bodyText": "Might want to add comment about the experiment done during the design phase -- for a column heavily used in selection only (not part of filter or group by), making it no dictionary reduces the latency by 20% (I guess) since we avoid the 2 lookups.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465796631", "createdAt": "2020-08-05T15:06:49Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0NzYyNA==", "bodyText": "It looks like we can improve the performance of this loop starting at line 94 by going over the remaining columns", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465947624", "createdAt": "2020-08-05T19:17:00Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NjYzMQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODMyMg==", "bodyText": "added", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466078322", "createdAt": "2020-08-06T00:34:36Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NjYzMQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMzNTM5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowOToxMlrOG8OEfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOToyOTo0MlrOG9BVJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5ODI3MQ==", "bodyText": "General question - Would it be possible to parse the query exactly once before the execution of first rule begins? Right now, it seems like as the rules are fired in order, each rule will parse the input query set? Even though the algorithm of each rule is different, is it possible to parse once and extract all the common info needed by all the rules?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465798271", "createdAt": "2020-08-05T15:09:12Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection\n+      double selectionFreq = selectionWeights[i] / totalWeight.get();\n+      if (selectionFreq > _params.THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY) {\n+        continue;\n+      }\n+\n+      // Add dictionary on columns NOT frequently used in selection\n+      // AND can save storage > threshold\n+      String colName = _inputManager.intToColName(i);\n+      double noDictSize;\n+      double withDictSize;\n+      long colDataSizeWithoutDictionary = _inputManager.getColDataSizeWithoutDictionary(colName);\n+      double numValuesPerEntry = _inputManager.getNumValuesPerEntry(colName);\n+      int bitCompressedDataSize = _inputManager.getBitCompressedDataSize(colName);\n+      long dictionarySize = _inputManager.getDictionarySize(colName);\n+      double cardinality = _inputManager.getCardinality(colName);\n+      long numRecordsPerPush = _inputManager.getNumRecordsPerPush();\n+      LOGGER.debug(\"colDataSizeWithoutDictionary {}\", colDataSizeWithoutDictionary);\n+      LOGGER.debug(\"bitCompressedDataSize {}\", bitCompressedDataSize);\n+      LOGGER.debug(\"dictionarySize {}\", dictionarySize);\n+      LOGGER.debug(\"numValuesPerEntry {}\", numValuesPerEntry);\n+\n+      if (_inputManager.getTableType().equalsIgnoreCase(REALTIME)) {\n+        //TODO: improve this estimation\n+        noDictSize = // size of one segment flushed ith no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;\n+        withDictSize = // size of one flushed segment with dictionary\n+            dictionarySize + bitCompressedDataSize * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;\n+      } else { // For hybrid or offline table, nodictionary follows the offline side\n+        noDictSize = // size of all segments in one push  with no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * numRecordsPerPush;\n+        withDictSize = // size of all segments in one push with dictionary\n+            dictionarySize * dictionaryCoefficient(cardinality, numRecordsPerPush) * DEFAUlT_NUM_PARTITIONS\n+                + bitCompressedDataSize * numValuesPerEntry * numRecordsPerPush;\n+      }\n+\n+      double storageSaved = (double) (noDictSize - withDictSize) / noDictSize;\n+      LOGGER.debug(\"colName {}, noDictSize {}, withDictSize{}, storageSaved{}\", colName, noDictSize, withDictSize,\n+          storageSaved);\n+\n+      if (storageSaved > _params.THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE) {\n+        noDictCols.remove(colName);\n+      }\n+    }\n+\n+    // Add the no dictionary cols to config\n+    _outputManager.getIndexConfig().getNoDictionaryColumns().addAll(noDictCols);\n+\n+    //**********On heap dictionary recommendation*******/\n+    if (_inputManager.getQps() > _params.THRESHOLD_MIN_QPS_ON_HEAP) { // QPS > THRESHOLD_MIN_QPS_ON_HEAP\n+      for (String colName : _inputManager.getColNameToIntMap().keySet()) {\n+        if (!_outputManager.getIndexConfig().getNoDictionaryColumns().contains(colName)) //exclude no dictionary column\n+        {\n+          long dictionarySize = _inputManager.getDictionarySize(colName);\n+          int colId = _inputManager.colNameToInt(colName);\n+          double filterGroupByFreq = filterGroupByWeights[colId] / totalWeight.get();\n+          if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_ON_HEAP  //frequently used in filter/group by\n+              && dictionarySize < _params.THRESHOLD_MAX_DICTIONARY_SIZE_ON_HEAP) { // memory foot print < threshold\n+            _outputManager.getIndexConfig().getOnHeapDictionaryColumns().add(colName);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private double dictionaryCoefficient(double cardinality, long numRecordsPerPush) {\n+    return 1 - min(max(DEFAULT_DICT_COEFF_A * Math.log(DEFAULT_DICT_COEFF_B * cardinality / numRecordsPerPush),\n+        DEFAULT_DICT_LOWER), DEFAULT_DICT_UPPER);\n+  }\n+\n+  public void parseQuery(String queryString, double weight, double[] filterGroupByWeights, double[] selectionWeights) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzODExNg==", "bodyText": "resolved - the code will parse only once", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466638116", "createdAt": "2020-08-06T19:29:42Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection\n+      double selectionFreq = selectionWeights[i] / totalWeight.get();\n+      if (selectionFreq > _params.THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY) {\n+        continue;\n+      }\n+\n+      // Add dictionary on columns NOT frequently used in selection\n+      // AND can save storage > threshold\n+      String colName = _inputManager.intToColName(i);\n+      double noDictSize;\n+      double withDictSize;\n+      long colDataSizeWithoutDictionary = _inputManager.getColDataSizeWithoutDictionary(colName);\n+      double numValuesPerEntry = _inputManager.getNumValuesPerEntry(colName);\n+      int bitCompressedDataSize = _inputManager.getBitCompressedDataSize(colName);\n+      long dictionarySize = _inputManager.getDictionarySize(colName);\n+      double cardinality = _inputManager.getCardinality(colName);\n+      long numRecordsPerPush = _inputManager.getNumRecordsPerPush();\n+      LOGGER.debug(\"colDataSizeWithoutDictionary {}\", colDataSizeWithoutDictionary);\n+      LOGGER.debug(\"bitCompressedDataSize {}\", bitCompressedDataSize);\n+      LOGGER.debug(\"dictionarySize {}\", dictionarySize);\n+      LOGGER.debug(\"numValuesPerEntry {}\", numValuesPerEntry);\n+\n+      if (_inputManager.getTableType().equalsIgnoreCase(REALTIME)) {\n+        //TODO: improve this estimation\n+        noDictSize = // size of one segment flushed ith no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;\n+        withDictSize = // size of one flushed segment with dictionary\n+            dictionarySize + bitCompressedDataSize * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;\n+      } else { // For hybrid or offline table, nodictionary follows the offline side\n+        noDictSize = // size of all segments in one push  with no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * numRecordsPerPush;\n+        withDictSize = // size of all segments in one push with dictionary\n+            dictionarySize * dictionaryCoefficient(cardinality, numRecordsPerPush) * DEFAUlT_NUM_PARTITIONS\n+                + bitCompressedDataSize * numValuesPerEntry * numRecordsPerPush;\n+      }\n+\n+      double storageSaved = (double) (noDictSize - withDictSize) / noDictSize;\n+      LOGGER.debug(\"colName {}, noDictSize {}, withDictSize{}, storageSaved{}\", colName, noDictSize, withDictSize,\n+          storageSaved);\n+\n+      if (storageSaved > _params.THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE) {\n+        noDictCols.remove(colName);\n+      }\n+    }\n+\n+    // Add the no dictionary cols to config\n+    _outputManager.getIndexConfig().getNoDictionaryColumns().addAll(noDictCols);\n+\n+    //**********On heap dictionary recommendation*******/\n+    if (_inputManager.getQps() > _params.THRESHOLD_MIN_QPS_ON_HEAP) { // QPS > THRESHOLD_MIN_QPS_ON_HEAP\n+      for (String colName : _inputManager.getColNameToIntMap().keySet()) {\n+        if (!_outputManager.getIndexConfig().getNoDictionaryColumns().contains(colName)) //exclude no dictionary column\n+        {\n+          long dictionarySize = _inputManager.getDictionarySize(colName);\n+          int colId = _inputManager.colNameToInt(colName);\n+          double filterGroupByFreq = filterGroupByWeights[colId] / totalWeight.get();\n+          if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_ON_HEAP  //frequently used in filter/group by\n+              && dictionarySize < _params.THRESHOLD_MAX_DICTIONARY_SIZE_ON_HEAP) { // memory foot print < threshold\n+            _outputManager.getIndexConfig().getOnHeapDictionaryColumns().add(colName);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private double dictionaryCoefficient(double cardinality, long numRecordsPerPush) {\n+    return 1 - min(max(DEFAULT_DICT_COEFF_A * Math.log(DEFAULT_DICT_COEFF_B * cardinality / numRecordsPerPush),\n+        DEFAULT_DICT_LOWER), DEFAULT_DICT_UPPER);\n+  }\n+\n+  public void parseQuery(String queryString, double weight, double[] filterGroupByWeights, double[] selectionWeights) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5ODI3MQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTM0NzYyOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToxMTo1OFrOG8OMVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzoyNToyN1rOG8d8Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMDI3OA==", "bodyText": "We can simplify this by not bringing numValuesPerEntry into the equation. numValuesPerEntry is applicable to MV columns right? Pinot currently doesn't support raw MV columns so they are always dictionary encoded", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465800278", "createdAt": "2020-08-05T15:11:58Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection\n+      double selectionFreq = selectionWeights[i] / totalWeight.get();\n+      if (selectionFreq > _params.THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY) {\n+        continue;\n+      }\n+\n+      // Add dictionary on columns NOT frequently used in selection\n+      // AND can save storage > threshold\n+      String colName = _inputManager.intToColName(i);\n+      double noDictSize;\n+      double withDictSize;\n+      long colDataSizeWithoutDictionary = _inputManager.getColDataSizeWithoutDictionary(colName);\n+      double numValuesPerEntry = _inputManager.getNumValuesPerEntry(colName);\n+      int bitCompressedDataSize = _inputManager.getBitCompressedDataSize(colName);\n+      long dictionarySize = _inputManager.getDictionarySize(colName);\n+      double cardinality = _inputManager.getCardinality(colName);\n+      long numRecordsPerPush = _inputManager.getNumRecordsPerPush();\n+      LOGGER.debug(\"colDataSizeWithoutDictionary {}\", colDataSizeWithoutDictionary);\n+      LOGGER.debug(\"bitCompressedDataSize {}\", bitCompressedDataSize);\n+      LOGGER.debug(\"dictionarySize {}\", dictionarySize);\n+      LOGGER.debug(\"numValuesPerEntry {}\", numValuesPerEntry);\n+\n+      if (_inputManager.getTableType().equalsIgnoreCase(REALTIME)) {\n+        //TODO: improve this estimation\n+        noDictSize = // size of one segment flushed ith no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMDkxNQ==", "bodyText": "We should add a TODO though -- stating to enhance this to consider MV columns as noDictionary in the future when Pinot supports that", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465800915", "createdAt": "2020-08-05T15:12:45Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection\n+      double selectionFreq = selectionWeights[i] / totalWeight.get();\n+      if (selectionFreq > _params.THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY) {\n+        continue;\n+      }\n+\n+      // Add dictionary on columns NOT frequently used in selection\n+      // AND can save storage > threshold\n+      String colName = _inputManager.intToColName(i);\n+      double noDictSize;\n+      double withDictSize;\n+      long colDataSizeWithoutDictionary = _inputManager.getColDataSizeWithoutDictionary(colName);\n+      double numValuesPerEntry = _inputManager.getNumValuesPerEntry(colName);\n+      int bitCompressedDataSize = _inputManager.getBitCompressedDataSize(colName);\n+      long dictionarySize = _inputManager.getDictionarySize(colName);\n+      double cardinality = _inputManager.getCardinality(colName);\n+      long numRecordsPerPush = _inputManager.getNumRecordsPerPush();\n+      LOGGER.debug(\"colDataSizeWithoutDictionary {}\", colDataSizeWithoutDictionary);\n+      LOGGER.debug(\"bitCompressedDataSize {}\", bitCompressedDataSize);\n+      LOGGER.debug(\"dictionarySize {}\", dictionarySize);\n+      LOGGER.debug(\"numValuesPerEntry {}\", numValuesPerEntry);\n+\n+      if (_inputManager.getTableType().equalsIgnoreCase(REALTIME)) {\n+        //TODO: improve this estimation\n+        noDictSize = // size of one segment flushed ith no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMDI3OA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1ODI3MQ==", "bodyText": "Done. Thanks for bring out this!", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466058271", "createdAt": "2020-08-05T23:25:27Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection\n+      double selectionFreq = selectionWeights[i] / totalWeight.get();\n+      if (selectionFreq > _params.THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY) {\n+        continue;\n+      }\n+\n+      // Add dictionary on columns NOT frequently used in selection\n+      // AND can save storage > threshold\n+      String colName = _inputManager.intToColName(i);\n+      double noDictSize;\n+      double withDictSize;\n+      long colDataSizeWithoutDictionary = _inputManager.getColDataSizeWithoutDictionary(colName);\n+      double numValuesPerEntry = _inputManager.getNumValuesPerEntry(colName);\n+      int bitCompressedDataSize = _inputManager.getBitCompressedDataSize(colName);\n+      long dictionarySize = _inputManager.getDictionarySize(colName);\n+      double cardinality = _inputManager.getCardinality(colName);\n+      long numRecordsPerPush = _inputManager.getNumRecordsPerPush();\n+      LOGGER.debug(\"colDataSizeWithoutDictionary {}\", colDataSizeWithoutDictionary);\n+      LOGGER.debug(\"bitCompressedDataSize {}\", bitCompressedDataSize);\n+      LOGGER.debug(\"dictionarySize {}\", dictionarySize);\n+      LOGGER.debug(\"numValuesPerEntry {}\", numValuesPerEntry);\n+\n+      if (_inputManager.getTableType().equalsIgnoreCase(REALTIME)) {\n+        //TODO: improve this estimation\n+        noDictSize = // size of one segment flushed ith no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMDI3OA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTM4NDYyOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyMDowMlrOG8Ojow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyMDowMlrOG8Ojow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNjI0Mw==", "bodyText": "Why is DEFAULT_NUM_PARTITIONS used here?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465806243", "createdAt": "2020-08-05T15:20:02Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/NoDictionaryOnHeapDictionaryJointRule.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import com.google.common.util.concurrent.AtomicDouble;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.REALTIME;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(NoDictionaryOnHeapDictionaryJointRule.class);\n+  private final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+  private final NoDictionaryOnHeapDictionaryJointRuleParams _params;\n+\n+  public NoDictionaryOnHeapDictionaryJointRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    _params = inputManager.getNoDictionaryOnHeapDictionaryJointRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    LOGGER.info(\"Recommending no dictionary and on-heap dictionaries\");\n+\n+    int numCols = _inputManager.getNumCols();\n+    double[] filterGroupByWeights = new double[numCols];\n+    double[] selectionWeights = new double[numCols];\n+    AtomicDouble totalWeight = new AtomicDouble(0);\n+\n+    //**********No dictionary recommendation*******/\n+    Set<String> noDictCols = new HashSet<>(_inputManager.getColNameToIntMap().keySet());\n+\n+    //Exclude cols with index\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getInvertedIndexColumns());\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getSortedColumn());\n+    // TODO: Remove this after range index is implemented for no-dictionary\n+    noDictCols.removeAll(_outputManager.getIndexConfig().getRangeIndexColumns());\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+    //Find out columns used in filter&groupby and selection and corresponding frequencies\n+    _inputManager.getQueryWeightMap().forEach((query, weight) -> {\n+      parseQuery(query, weight, filterGroupByWeights, selectionWeights);\n+      totalWeight.addAndGet(weight);\n+    });\n+\n+    //Add dictionary on columns used in filter&groupby , with frequency > threshold\n+    for (int i = 0; i < numCols; i++) {\n+      double filterGroupByFreq = filterGroupByWeights[i] / totalWeight.get();\n+      if (filterGroupByFreq > _params.THRESHOLD_MIN_FILTER_FREQ_DICTIONARY) {\n+        noDictCols.remove(_inputManager.intToColName(i));\n+      }\n+    }\n+\n+    LOGGER.debug(\"filterGroupByWeights {}, selectionWeights{}, totalWeight{} \", filterGroupByWeights, selectionWeights,\n+        totalWeight);\n+    LOGGER.debug(\"noDictCols {}\", noDictCols);\n+\n+    for (int i = 0; i < numCols; i++) {\n+      // No dictionary on columns frequently used in selection\n+      double selectionFreq = selectionWeights[i] / totalWeight.get();\n+      if (selectionFreq > _params.THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY) {\n+        continue;\n+      }\n+\n+      // Add dictionary on columns NOT frequently used in selection\n+      // AND can save storage > threshold\n+      String colName = _inputManager.intToColName(i);\n+      double noDictSize;\n+      double withDictSize;\n+      long colDataSizeWithoutDictionary = _inputManager.getColDataSizeWithoutDictionary(colName);\n+      double numValuesPerEntry = _inputManager.getNumValuesPerEntry(colName);\n+      int bitCompressedDataSize = _inputManager.getBitCompressedDataSize(colName);\n+      long dictionarySize = _inputManager.getDictionarySize(colName);\n+      double cardinality = _inputManager.getCardinality(colName);\n+      long numRecordsPerPush = _inputManager.getNumRecordsPerPush();\n+      LOGGER.debug(\"colDataSizeWithoutDictionary {}\", colDataSizeWithoutDictionary);\n+      LOGGER.debug(\"bitCompressedDataSize {}\", bitCompressedDataSize);\n+      LOGGER.debug(\"dictionarySize {}\", dictionarySize);\n+      LOGGER.debug(\"numValuesPerEntry {}\", numValuesPerEntry);\n+\n+      if (_inputManager.getTableType().equalsIgnoreCase(REALTIME)) {\n+        //TODO: improve this estimation\n+        noDictSize = // size of one segment flushed ith no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;\n+        withDictSize = // size of one flushed segment with dictionary\n+            dictionarySize + bitCompressedDataSize * numValuesPerEntry * _params.SEGMENT_FLUSH_TIME;\n+      } else { // For hybrid or offline table, nodictionary follows the offline side\n+        noDictSize = // size of all segments in one push  with no dictionary\n+            colDataSizeWithoutDictionary * numValuesPerEntry * numRecordsPerPush;\n+        withDictSize = // size of all segments in one push with dictionary\n+            dictionarySize * dictionaryCoefficient(cardinality, numRecordsPerPush) * DEFAUlT_NUM_PARTITIONS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTM5MTk3OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyMTozOVrOG8OoNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyNToxNlrOG8OyJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNzQxMw==", "bodyText": "you can probably remove the \"*\". It just adds minor overhead to the logger", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465807413", "createdAt": "2020-08-05T15:21:39Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.InPredicate;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+public class PinotTablePartitionRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(PinotTablePartitionRule.class);\n+  PartitionRuleParams _params;\n+\n+  protected final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+\n+  public PinotTablePartitionRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    this._params = inputManager.getPartitionRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    //**********Calculate size per record***************/\n+    _inputManager.estimateSizePerRecord();\n+    //**************************************************/\n+\n+    LOGGER.info(\"Recommending partition configurations\");\n+\n+    if (_inputManager.getQps()\n+        < _params.THRESHOLD_MIN_QPS_PARTITION) { //For a table whose QPS < Q (say 200 or 300) NO partitioning is needed.\n+      LOGGER.info(\"*Input QPS {} < threshold {}, no partition needed\", _inputManager.getQps(),\n+          _params.THRESHOLD_MIN_QPS_PARTITION);\n+      return;\n+    }\n+    if (_inputManager.getLatencySLA()\n+        > _params.THRESHOLD_MAX_SLA_PARTITION) { //For a table whose latency SLA > L (say 1000ms) NO partitioning is needed.\n+      LOGGER.info(\"*Input SLA {} > threshold {}, no partition needed\", _inputManager.getLatencySLA(),\n+          _params.THRESHOLD_MAX_SLA_PARTITION);\n+      return;\n+    }\n+\n+    LOGGER.info(\"*Recommending partition number\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwOTk1Ng==", "bodyText": "(nit): suggest changing it to \"Recommending number of partitions\"", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465809956", "createdAt": "2020-08-05T15:25:16Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.InPredicate;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+public class PinotTablePartitionRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(PinotTablePartitionRule.class);\n+  PartitionRuleParams _params;\n+\n+  protected final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+\n+  public PinotTablePartitionRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    this._params = inputManager.getPartitionRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    //**********Calculate size per record***************/\n+    _inputManager.estimateSizePerRecord();\n+    //**************************************************/\n+\n+    LOGGER.info(\"Recommending partition configurations\");\n+\n+    if (_inputManager.getQps()\n+        < _params.THRESHOLD_MIN_QPS_PARTITION) { //For a table whose QPS < Q (say 200 or 300) NO partitioning is needed.\n+      LOGGER.info(\"*Input QPS {} < threshold {}, no partition needed\", _inputManager.getQps(),\n+          _params.THRESHOLD_MIN_QPS_PARTITION);\n+      return;\n+    }\n+    if (_inputManager.getLatencySLA()\n+        > _params.THRESHOLD_MAX_SLA_PARTITION) { //For a table whose latency SLA > L (say 1000ms) NO partitioning is needed.\n+      LOGGER.info(\"*Input SLA {} > threshold {}, no partition needed\", _inputManager.getLatencySLA(),\n+          _params.THRESHOLD_MAX_SLA_PARTITION);\n+      return;\n+    }\n+\n+    LOGGER.info(\"*Recommending partition number\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNzQxMw=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQwMjYxOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyNDoxMVrOG8OvKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMDoyNjozMFrOG8fBpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwOTE5NQ==", "bodyText": "We can actually simplify the code here. Currently we are writing the code for offline and realtime.\nWe can compute once for offline (if type is OFFLINE or HYBRID)\nWe can compute once for realtime (if type if REALTIME or HYBRID)\nThis will clenup the if-else block here", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465809195", "createdAt": "2020-08-05T15:24:11Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.InPredicate;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+public class PinotTablePartitionRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(PinotTablePartitionRule.class);\n+  PartitionRuleParams _params;\n+\n+  protected final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+\n+  public PinotTablePartitionRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    this._params = inputManager.getPartitionRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    //**********Calculate size per record***************/\n+    _inputManager.estimateSizePerRecord();\n+    //**************************************************/\n+\n+    LOGGER.info(\"Recommending partition configurations\");\n+\n+    if (_inputManager.getQps()\n+        < _params.THRESHOLD_MIN_QPS_PARTITION) { //For a table whose QPS < Q (say 200 or 300) NO partitioning is needed.\n+      LOGGER.info(\"*Input QPS {} < threshold {}, no partition needed\", _inputManager.getQps(),\n+          _params.THRESHOLD_MIN_QPS_PARTITION);\n+      return;\n+    }\n+    if (_inputManager.getLatencySLA()\n+        > _params.THRESHOLD_MAX_SLA_PARTITION) { //For a table whose latency SLA > L (say 1000ms) NO partitioning is needed.\n+      LOGGER.info(\"*Input SLA {} > threshold {}, no partition needed\", _inputManager.getLatencySLA(),\n+          _params.THRESHOLD_MAX_SLA_PARTITION);\n+      return;\n+    }\n+\n+    LOGGER.info(\"*Recommending partition number\");\n+    if (_inputManager.getTableType().equalsIgnoreCase(\n+        REALTIME)) { //real time partition num should be the same value as the number of kafka partitions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3NjA3MQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466076071", "createdAt": "2020-08-06T00:26:30Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.InPredicate;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+public class PinotTablePartitionRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(PinotTablePartitionRule.class);\n+  PartitionRuleParams _params;\n+\n+  protected final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+\n+  public PinotTablePartitionRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    this._params = inputManager.getPartitionRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    //**********Calculate size per record***************/\n+    _inputManager.estimateSizePerRecord();\n+    //**************************************************/\n+\n+    LOGGER.info(\"Recommending partition configurations\");\n+\n+    if (_inputManager.getQps()\n+        < _params.THRESHOLD_MIN_QPS_PARTITION) { //For a table whose QPS < Q (say 200 or 300) NO partitioning is needed.\n+      LOGGER.info(\"*Input QPS {} < threshold {}, no partition needed\", _inputManager.getQps(),\n+          _params.THRESHOLD_MIN_QPS_PARTITION);\n+      return;\n+    }\n+    if (_inputManager.getLatencySLA()\n+        > _params.THRESHOLD_MAX_SLA_PARTITION) { //For a table whose latency SLA > L (say 1000ms) NO partitioning is needed.\n+      LOGGER.info(\"*Input SLA {} > threshold {}, no partition needed\", _inputManager.getLatencySLA(),\n+          _params.THRESHOLD_MAX_SLA_PARTITION);\n+      return;\n+    }\n+\n+    LOGGER.info(\"*Recommending partition number\");\n+    if (_inputManager.getTableType().equalsIgnoreCase(\n+        REALTIME)) { //real time partition num should be the same value as the number of kafka partitions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwOTE5NQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQxNDM5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/PartitionRuleParams.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyNjo1NFrOG8O2pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMzowMzoxMlrOG9G_sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTEwOQ==", "bodyText": "I think our check-style will complain for using * import. We should import specifically", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465811109", "createdAt": "2020-08-05T15:26:54Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/PartitionRuleParams.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.PartitionRule.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczMDkzMQ==", "bodyText": "mvn checkstyle:check success so we should be fine", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466730931", "createdAt": "2020-08-06T23:03:12Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/PartitionRuleParams.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.PartitionRule.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTEwOQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQxODYzOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/PartitionRuleParams.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyNzo1OFrOG8O5dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOToyOToxMVrOG9BT_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTgyOQ==", "bodyText": "Please add javadoc and a short one-line comment explaining the purpose of each configuration. Please try to do this for all param classes.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465811829", "createdAt": "2020-08-05T15:27:58Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/PartitionRuleParams.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.PartitionRule.*;\n+\n+\n+public class PartitionRuleParams {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzNzgyMA==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466637820", "createdAt": "2020-08-06T19:29:11Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/PartitionRuleParams.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.PartitionRule.*;\n+\n+\n+public class PartitionRuleParams {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTgyOQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQxOTEwOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyODowNlrOG8O5xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOToyOTowM1rOG9BTvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTkwOQ==", "bodyText": "Please add javadoc", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465811909", "createdAt": "2020-08-05T15:28:06Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzNzc1OQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466637759", "createdAt": "2020-08-06T19:29:03Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTkwOQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQxOTM4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyODowOVrOG8O56Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTozNzowMlrOG8bg8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTk0NQ==", "bodyText": "a very short one line comment above each configuration (at least for the ones that are not self explanatory and intuitive from the name)", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465811945", "createdAt": "2020-08-05T15:28:09Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxODU0Nw==", "bodyText": "Will add the comments in the *Params class for parameters", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466018547", "createdAt": "2020-08-05T21:37:02Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTk0NQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQ1NDYxOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/NoDictionaryOnHeapDictionaryJointRuleParams.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTozNjozMVrOG8PQBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTozNDo0NFrOG8bcww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNzYwNA==", "bodyText": "typo in name?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465817604", "createdAt": "2020-08-05T15:36:31Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/NoDictionaryOnHeapDictionaryJointRuleParams.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRuleParams {\n+  public Double THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE = DEFAULT_THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxNzQ3NQ==", "bodyText": "fixed", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466017475", "createdAt": "2020-08-05T21:34:44Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/NoDictionaryOnHeapDictionaryJointRuleParams.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.NoDictionaryOnHeapDictionaryJointRule.*;\n+\n+\n+public class NoDictionaryOnHeapDictionaryJointRuleParams {\n+  public Double THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE = DEFAULT_THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNzYwNA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQ2MTE5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTozNzo1OVrOG8PUCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTozNDowNFrOG8bbmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxODYzMw==", "bodyText": "include latency in the name", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465818633", "createdAt": "2020-08-05T15:37:59Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxNzE3OQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466017179", "createdAt": "2020-08-05T21:34:04Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxODYzMw=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQ3MzMzOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0MDo0NVrOG8PbiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjowMzo0OVrOG8cOEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMDU1Mg==", "bodyText": "I don't think we should accept input if QPS, latency, num messages per second in kafka topic and number of records pushed per day are not specified. It is something user (or whoever is getting the recommendation) needs to know. So, we should not have any defaults for these 4.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465820552", "createdAt": "2020-08-05T15:40:45Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_PARTITION = 200;\n+    public static final long DEFAULT_OPTIMAL_SIZE_PER_SEGMENT = 2000_000_000; //2GB\n+    public static final long DEFAULT_KAFKA_NUM_MESSAGES_PER_SEC_PER_PARTITION = 250;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_DIMENSION_PARTITION_TOP_CANDIDATES = 0.8d;\n+    public static final int DEFAULT_THRESHOLD_MAX_IN_LENGTH = 4;\n+  }\n+\n+  public static class BloomFilterRule {\n+    public static final long DEFAULT_THRESHOLD_MAX_CARDINALITY_BLOOMFILTER = 1000_000;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_EQ_BLOOMFILTER = 0.5d;\n+  }\n+\n+  public static class NoDictionaryOnHeapDictionaryJointRule {\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_DICTIONARY = 0d;\n+    public static final double DEFAULT_THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY = 0.3d;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_ON_HEAP = 10_000;\n+    public static final long DEFAULT_THRESHOLD_MAX_DICTIONARY_SIZE_ON_HEAP = 1000_000L;\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_ON_HEAP = 0.3d;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE = 0.95;\n+\n+    public static final double DEFAULT_DICT_COEFF_A = 0.217769;\n+    public static final double DEFAULT_DICT_COEFF_B = 89.0975;\n+    public static final double DEFAULT_DICT_LOWER = 0;\n+    public static final double DEFAULT_DICT_UPPER = 0;\n+    public static final int DEFAUlT_NUM_PARTITIONS = 16;\n+\n+    public static final int DEFAULT_SEGMENT_FLUSH_TIME = 86400;\n+  }\n+\n+  public static class FlagQueryRuleParams{\n+    public static final long DEFAULT_THRESHOLD_MAX_LIMIT_SIZE = 100000;\n+    public static final String WARNING_NO_FILTERING = \"Warning: No filtering in ths query\";\n+    public static final String WARNING_NO_TIME_COL = \"Warning: No time column used in ths query\";\n+    public static final String WARNING_TOO_LONG_LIMIT = \"Warning: The size of LIMIT is longer than \" + DEFAULT_THRESHOLD_MAX_LIMIT_SIZE;\n+    public static final String ERROR_INVALID_QUERY = \"Error: query not able to parse, skipped\";\n+  }\n+\n+  public static final String PQL = \"pql\";\n+  public static final String SQL = \"sql\";\n+  public static final String OFFLINE = \"offline\";\n+  public static final String REALTIME = \"realtime\";\n+  public static final String HYBRID = \"hybrid\";\n+  public static final int NO_SUCH_COL = -1;\n+  public static final double DEFAULT_CARDINALITY = 1;\n+  public static final double MIN_CARDINALITY = 1;\n+  public static final double DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY = 1d;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzMDA5OA==", "bodyText": "done, I think on Dino side he can probably make these fields \"required\"", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466030098", "createdAt": "2020-08-05T22:03:49Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_PARTITION = 200;\n+    public static final long DEFAULT_OPTIMAL_SIZE_PER_SEGMENT = 2000_000_000; //2GB\n+    public static final long DEFAULT_KAFKA_NUM_MESSAGES_PER_SEC_PER_PARTITION = 250;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_DIMENSION_PARTITION_TOP_CANDIDATES = 0.8d;\n+    public static final int DEFAULT_THRESHOLD_MAX_IN_LENGTH = 4;\n+  }\n+\n+  public static class BloomFilterRule {\n+    public static final long DEFAULT_THRESHOLD_MAX_CARDINALITY_BLOOMFILTER = 1000_000;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_EQ_BLOOMFILTER = 0.5d;\n+  }\n+\n+  public static class NoDictionaryOnHeapDictionaryJointRule {\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_DICTIONARY = 0d;\n+    public static final double DEFAULT_THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY = 0.3d;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_ON_HEAP = 10_000;\n+    public static final long DEFAULT_THRESHOLD_MAX_DICTIONARY_SIZE_ON_HEAP = 1000_000L;\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_ON_HEAP = 0.3d;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE = 0.95;\n+\n+    public static final double DEFAULT_DICT_COEFF_A = 0.217769;\n+    public static final double DEFAULT_DICT_COEFF_B = 89.0975;\n+    public static final double DEFAULT_DICT_LOWER = 0;\n+    public static final double DEFAULT_DICT_UPPER = 0;\n+    public static final int DEFAUlT_NUM_PARTITIONS = 16;\n+\n+    public static final int DEFAULT_SEGMENT_FLUSH_TIME = 86400;\n+  }\n+\n+  public static class FlagQueryRuleParams{\n+    public static final long DEFAULT_THRESHOLD_MAX_LIMIT_SIZE = 100000;\n+    public static final String WARNING_NO_FILTERING = \"Warning: No filtering in ths query\";\n+    public static final String WARNING_NO_TIME_COL = \"Warning: No time column used in ths query\";\n+    public static final String WARNING_TOO_LONG_LIMIT = \"Warning: The size of LIMIT is longer than \" + DEFAULT_THRESHOLD_MAX_LIMIT_SIZE;\n+    public static final String ERROR_INVALID_QUERY = \"Error: query not able to parse, skipped\";\n+  }\n+\n+  public static final String PQL = \"pql\";\n+  public static final String SQL = \"sql\";\n+  public static final String OFFLINE = \"offline\";\n+  public static final String REALTIME = \"realtime\";\n+  public static final String HYBRID = \"hybrid\";\n+  public static final int NO_SUCH_COL = -1;\n+  public static final double DEFAULT_CARDINALITY = 1;\n+  public static final double MIN_CARDINALITY = 1;\n+  public static final double DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY = 1d;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMDU1Mg=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQ4Mjc1OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0Mjo1NVrOG8PhjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTozMDo1MVrOG8bWKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMjA5Mw==", "bodyText": "I don't think you need to have DEFAULT_FLOAT/INT/LONG etc size. These are fixed width columns and will always be same as specified in their respective classes. -- Float.BYTES, Long.BYTES etc", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465822093", "createdAt": "2020-08-05T15:42:55Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_PARTITION = 200;\n+    public static final long DEFAULT_OPTIMAL_SIZE_PER_SEGMENT = 2000_000_000; //2GB\n+    public static final long DEFAULT_KAFKA_NUM_MESSAGES_PER_SEC_PER_PARTITION = 250;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_DIMENSION_PARTITION_TOP_CANDIDATES = 0.8d;\n+    public static final int DEFAULT_THRESHOLD_MAX_IN_LENGTH = 4;\n+  }\n+\n+  public static class BloomFilterRule {\n+    public static final long DEFAULT_THRESHOLD_MAX_CARDINALITY_BLOOMFILTER = 1000_000;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_EQ_BLOOMFILTER = 0.5d;\n+  }\n+\n+  public static class NoDictionaryOnHeapDictionaryJointRule {\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_DICTIONARY = 0d;\n+    public static final double DEFAULT_THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY = 0.3d;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_ON_HEAP = 10_000;\n+    public static final long DEFAULT_THRESHOLD_MAX_DICTIONARY_SIZE_ON_HEAP = 1000_000L;\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_ON_HEAP = 0.3d;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE = 0.95;\n+\n+    public static final double DEFAULT_DICT_COEFF_A = 0.217769;\n+    public static final double DEFAULT_DICT_COEFF_B = 89.0975;\n+    public static final double DEFAULT_DICT_LOWER = 0;\n+    public static final double DEFAULT_DICT_UPPER = 0;\n+    public static final int DEFAUlT_NUM_PARTITIONS = 16;\n+\n+    public static final int DEFAULT_SEGMENT_FLUSH_TIME = 86400;\n+  }\n+\n+  public static class FlagQueryRuleParams{\n+    public static final long DEFAULT_THRESHOLD_MAX_LIMIT_SIZE = 100000;\n+    public static final String WARNING_NO_FILTERING = \"Warning: No filtering in ths query\";\n+    public static final String WARNING_NO_TIME_COL = \"Warning: No time column used in ths query\";\n+    public static final String WARNING_TOO_LONG_LIMIT = \"Warning: The size of LIMIT is longer than \" + DEFAULT_THRESHOLD_MAX_LIMIT_SIZE;\n+    public static final String ERROR_INVALID_QUERY = \"Error: query not able to parse, skipped\";\n+  }\n+\n+  public static final String PQL = \"pql\";\n+  public static final String SQL = \"sql\";\n+  public static final String OFFLINE = \"offline\";\n+  public static final String REALTIME = \"realtime\";\n+  public static final String HYBRID = \"hybrid\";\n+  public static final int NO_SUCH_COL = -1;\n+  public static final double DEFAULT_CARDINALITY = 1;\n+  public static final double MIN_CARDINALITY = 1;\n+  public static final double DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY = 1d;\n+  public static final int DEFAULT_QPS = 100;\n+  public static final int DEFAULT_LATENCY_SLA = 1000;\n+  public static final int DEFAULT_NUM_MSG_PER_SEC = 250;\n+  public static final int DEFAULT_NUM_RECORDS_PER_PUSH = 10000;\n+  public static final int DEFAULT_INT_SIZE = Integer.BYTES;\n+  public static final int DEFAULT_NULL_SIZE = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxNTc4NQ==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466015785", "createdAt": "2020-08-05T21:30:51Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_PARTITION = 200;\n+    public static final long DEFAULT_OPTIMAL_SIZE_PER_SEGMENT = 2000_000_000; //2GB\n+    public static final long DEFAULT_KAFKA_NUM_MESSAGES_PER_SEC_PER_PARTITION = 250;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_DIMENSION_PARTITION_TOP_CANDIDATES = 0.8d;\n+    public static final int DEFAULT_THRESHOLD_MAX_IN_LENGTH = 4;\n+  }\n+\n+  public static class BloomFilterRule {\n+    public static final long DEFAULT_THRESHOLD_MAX_CARDINALITY_BLOOMFILTER = 1000_000;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_EQ_BLOOMFILTER = 0.5d;\n+  }\n+\n+  public static class NoDictionaryOnHeapDictionaryJointRule {\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_DICTIONARY = 0d;\n+    public static final double DEFAULT_THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY = 0.3d;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_ON_HEAP = 10_000;\n+    public static final long DEFAULT_THRESHOLD_MAX_DICTIONARY_SIZE_ON_HEAP = 1000_000L;\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_ON_HEAP = 0.3d;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE = 0.95;\n+\n+    public static final double DEFAULT_DICT_COEFF_A = 0.217769;\n+    public static final double DEFAULT_DICT_COEFF_B = 89.0975;\n+    public static final double DEFAULT_DICT_LOWER = 0;\n+    public static final double DEFAULT_DICT_UPPER = 0;\n+    public static final int DEFAUlT_NUM_PARTITIONS = 16;\n+\n+    public static final int DEFAULT_SEGMENT_FLUSH_TIME = 86400;\n+  }\n+\n+  public static class FlagQueryRuleParams{\n+    public static final long DEFAULT_THRESHOLD_MAX_LIMIT_SIZE = 100000;\n+    public static final String WARNING_NO_FILTERING = \"Warning: No filtering in ths query\";\n+    public static final String WARNING_NO_TIME_COL = \"Warning: No time column used in ths query\";\n+    public static final String WARNING_TOO_LONG_LIMIT = \"Warning: The size of LIMIT is longer than \" + DEFAULT_THRESHOLD_MAX_LIMIT_SIZE;\n+    public static final String ERROR_INVALID_QUERY = \"Error: query not able to parse, skipped\";\n+  }\n+\n+  public static final String PQL = \"pql\";\n+  public static final String SQL = \"sql\";\n+  public static final String OFFLINE = \"offline\";\n+  public static final String REALTIME = \"realtime\";\n+  public static final String HYBRID = \"hybrid\";\n+  public static final int NO_SUCH_COL = -1;\n+  public static final double DEFAULT_CARDINALITY = 1;\n+  public static final double MIN_CARDINALITY = 1;\n+  public static final double DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY = 1d;\n+  public static final int DEFAULT_QPS = 100;\n+  public static final int DEFAULT_LATENCY_SLA = 1000;\n+  public static final int DEFAULT_NUM_MSG_PER_SEC = 250;\n+  public static final int DEFAULT_NUM_RECORDS_PER_PUSH = 10000;\n+  public static final int DEFAULT_INT_SIZE = Integer.BYTES;\n+  public static final int DEFAULT_NULL_SIZE = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMjA5Mw=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQ4OTU2OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0NDozNlrOG8Plww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMToyNDozMVrOG8bKbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMzE3MQ==", "bodyText": "How are these coefficients used?", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465823171", "createdAt": "2020-08-05T15:44:36Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_PARTITION = 200;\n+    public static final long DEFAULT_OPTIMAL_SIZE_PER_SEGMENT = 2000_000_000; //2GB\n+    public static final long DEFAULT_KAFKA_NUM_MESSAGES_PER_SEC_PER_PARTITION = 250;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_DIMENSION_PARTITION_TOP_CANDIDATES = 0.8d;\n+    public static final int DEFAULT_THRESHOLD_MAX_IN_LENGTH = 4;\n+  }\n+\n+  public static class BloomFilterRule {\n+    public static final long DEFAULT_THRESHOLD_MAX_CARDINALITY_BLOOMFILTER = 1000_000;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_EQ_BLOOMFILTER = 0.5d;\n+  }\n+\n+  public static class NoDictionaryOnHeapDictionaryJointRule {\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_DICTIONARY = 0d;\n+    public static final double DEFAULT_THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY = 0.3d;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_ON_HEAP = 10_000;\n+    public static final long DEFAULT_THRESHOLD_MAX_DICTIONARY_SIZE_ON_HEAP = 1000_000L;\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_ON_HEAP = 0.3d;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE = 0.95;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxMjc4Mw==", "bodyText": "Will revisit this later today", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466012783", "createdAt": "2020-08-05T21:24:31Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_PARTITION = 200;\n+    public static final long DEFAULT_OPTIMAL_SIZE_PER_SEGMENT = 2000_000_000; //2GB\n+    public static final long DEFAULT_KAFKA_NUM_MESSAGES_PER_SEC_PER_PARTITION = 250;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_DIMENSION_PARTITION_TOP_CANDIDATES = 0.8d;\n+    public static final int DEFAULT_THRESHOLD_MAX_IN_LENGTH = 4;\n+  }\n+\n+  public static class BloomFilterRule {\n+    public static final long DEFAULT_THRESHOLD_MAX_CARDINALITY_BLOOMFILTER = 1000_000;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_EQ_BLOOMFILTER = 0.5d;\n+  }\n+\n+  public static class NoDictionaryOnHeapDictionaryJointRule {\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_DICTIONARY = 0d;\n+    public static final double DEFAULT_THRESHOLD_MAX_SELECTION_FREQ_DICTIONARY = 0.3d;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_ON_HEAP = 10_000;\n+    public static final long DEFAULT_THRESHOLD_MAX_DICTIONARY_SIZE_ON_HEAP = 1000_000L;\n+    public static final double DEFAULT_THRESHOLD_MIN_FILTER_FREQ_ON_HEAP = 0.3d;\n+    public static final double DEFAULT_THRESHOLD_MIN_PERCENT_DICTIONARY_STORAGE_SVAE = 0.95;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMzE3MQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTU2MTY4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjowMTo1MlrOG8QTxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMToyMzoyN1rOG8bIlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzNDk1MQ==", "bodyText": "It will also be very useful for reference to quote the study and analysis we had done for use case at Li. Please don't quote the table names. However, we should include the following general comments:\n\nFor realtime/hybrid, the number of partitions on realtime Pinot table side is same as number of kafka partitions. This is generally the case unless there is a reason for them to be different. We saw one outlier\nFor offline, the number of partitions on offline Pinot table side is dependent on the amount of data. For hybrid table, we have seen cases where this value = number of kafka partitions  = number of realtime table partitions. For hybrid table, we have also seen cases, where the value for offline is lower than realtime since the data generated on a given day is low volume and using a high count of number of partitions would lead to too many small sized segments since we typically have data from one partition in a segment.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465834951", "createdAt": "2020-08-05T16:01:52Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.InPredicate;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+public class PinotTablePartitionRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(PinotTablePartitionRule.class);\n+  PartitionRuleParams _params;\n+\n+  protected final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+\n+  public PinotTablePartitionRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    this._params = inputManager.getPartitionRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    //**********Calculate size per record***************/\n+    _inputManager.estimateSizePerRecord();\n+    //**************************************************/\n+\n+    LOGGER.info(\"Recommending partition configurations\");\n+\n+    if (_inputManager.getQps()\n+        < _params.THRESHOLD_MIN_QPS_PARTITION) { //For a table whose QPS < Q (say 200 or 300) NO partitioning is needed.\n+      LOGGER.info(\"*Input QPS {} < threshold {}, no partition needed\", _inputManager.getQps(),\n+          _params.THRESHOLD_MIN_QPS_PARTITION);\n+      return;\n+    }\n+    if (_inputManager.getLatencySLA()\n+        > _params.THRESHOLD_MAX_SLA_PARTITION) { //For a table whose latency SLA > L (say 1000ms) NO partitioning is needed.\n+      LOGGER.info(\"*Input SLA {} > threshold {}, no partition needed\", _inputManager.getLatencySLA(),\n+          _params.THRESHOLD_MAX_SLA_PARTITION);\n+      return;\n+    }\n+\n+    LOGGER.info(\"*Recommending partition number\");\n+    if (_inputManager.getTableType().equalsIgnoreCase(\n+        REALTIME)) { //real time partition num should be the same value as the number of kafka partitions\n+      _outputManager.getPartitionConfig()\n+          .setNumPartitionsRealtime(_outputManager.getPartitionConfig().getNumKafkaPartitions());\n+    } else if (_inputManager.getTableType().equalsIgnoreCase(OFFLINE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxMjMxMQ==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466012311", "createdAt": "2020-08-05T21:23:27Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/impl/PinotTablePartitionRule.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.core.query.request.context.predicate.InPredicate;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.query.request.context.utils.BrokerRequestToQueryContextConverter;\n+import org.apache.pinot.core.requesthandler.BrokerRequestOptimizer;\n+import org.apache.pinot.core.requesthandler.PinotQueryParserFactory;\n+import org.apache.pinot.parsers.AbstractCompiler;\n+import org.apache.pinot.sql.parsers.SqlCompilationException;\n+import org.apache.pinot.controller.recommender.io.ConfigManager;\n+import org.apache.pinot.controller.recommender.io.InputManager;\n+import org.apache.pinot.controller.recommender.rules.AbstractRule;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+public class PinotTablePartitionRule extends AbstractRule {\n+  private final Logger LOGGER = LoggerFactory.getLogger(PinotTablePartitionRule.class);\n+  PartitionRuleParams _params;\n+\n+  protected final BrokerRequestOptimizer _brokerRequestOptimizer = new BrokerRequestOptimizer();\n+\n+  public PinotTablePartitionRule(InputManager inputManager, ConfigManager outputManager) {\n+    super(inputManager, outputManager);\n+    this._params = inputManager.getPartitionRuleParams();\n+  }\n+\n+  @Override\n+  public void run() {\n+    //**********Calculate size per record***************/\n+    _inputManager.estimateSizePerRecord();\n+    //**************************************************/\n+\n+    LOGGER.info(\"Recommending partition configurations\");\n+\n+    if (_inputManager.getQps()\n+        < _params.THRESHOLD_MIN_QPS_PARTITION) { //For a table whose QPS < Q (say 200 or 300) NO partitioning is needed.\n+      LOGGER.info(\"*Input QPS {} < threshold {}, no partition needed\", _inputManager.getQps(),\n+          _params.THRESHOLD_MIN_QPS_PARTITION);\n+      return;\n+    }\n+    if (_inputManager.getLatencySLA()\n+        > _params.THRESHOLD_MAX_SLA_PARTITION) { //For a table whose latency SLA > L (say 1000ms) NO partitioning is needed.\n+      LOGGER.info(\"*Input SLA {} > threshold {}, no partition needed\", _inputManager.getLatencySLA(),\n+          _params.THRESHOLD_MAX_SLA_PARTITION);\n+      return;\n+    }\n+\n+    LOGGER.info(\"*Recommending partition number\");\n+    if (_inputManager.getTableType().equalsIgnoreCase(\n+        REALTIME)) { //real time partition num should be the same value as the number of kafka partitions\n+      _outputManager.getPartitionConfig()\n+          .setNumPartitionsRealtime(_outputManager.getPartitionConfig().getNumKafkaPartitions());\n+    } else if (_inputManager.getTableType().equalsIgnoreCase(OFFLINE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzNDk1MQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTU2NzIwOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjowMzoyMFrOG8QXSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMToxMzo1MFrOG8a2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzNTg0OA==", "bodyText": "I think 2GB is on the high end. Let's just start with 1GB probably", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465835848", "createdAt": "2020-08-05T16:03:20Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_PARTITION = 200;\n+    public static final long DEFAULT_OPTIMAL_SIZE_PER_SEGMENT = 2000_000_000; //2GB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwNzYwMQ==", "bodyText": "changed to 1 GB", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466007601", "createdAt": "2020-08-05T21:13:50Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/rules/io/params/RecommenderConstants.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.rules.io.params;\n+\n+public class RecommenderConstants {\n+  public static class InvertedSortedIndexJointRule {\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_FUNCTION = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_TEXT_MATCH = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_RANGE = 0.5d;\n+    public static final double DEAFULT_PERCENT_SELECT_FOR_REGEX = 0.5d;\n+    public static final double DEFAULT_PERCENT_SELECT_FOR_ISNULL = 0.5d;\n+    public static final double DEFAULT_THRESHOLD_MIN_AND_PREDICATE_INCREMENTAL_VOTE = 0.6d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_AND_PREDICATE_TOP_CANDIDATES = 0.8d;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_GAIN_DIFF_BETWEEN_ITERATION = 0.05d;\n+    public static final int DEFAULT_MAX_NUM_ITERATION_WITHOUT_GAIN = 3;\n+    public static final double DEFAULT_THRESHOLD_RATIO_MIN_NESI_FOR_TOP_CANDIDATES = 0.7d;\n+  }\n+\n+  public static class RulesToExecute {\n+    public static final boolean DEFAULT_RECOMMEND_FLAG_QUERY = true;\n+    public static final boolean DEFAULT_RECOMMEND_VARIED_LENGTH_DICTIONARY = true;\n+    public static final boolean DEFAULT_RECOMMEND_KAFKA_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_PINOT_TABLE_PARTITION = true;\n+    public static final boolean DEFAULT_RECOMMEND_INVERTED_SORTED_INDEX_JOINT = true;\n+    public static final boolean DEFAULT_RECOMMEND_BLOOM_FILTER = true;\n+    public static final boolean DEFAULT_RECOMMEND_NO_DICTIONARY_ONHEAP_DICTIONARY_JOINT = true;\n+  }\n+\n+  public static class PartitionRule {\n+    public static final int DEFAULT_NUM_PARTITIONS = 0;\n+\n+    public static final long DEFAULT_THRESHOLD_MAX_SLA_PARTITION = 1000;\n+    public static final long DEFAULT_THRESHOLD_MIN_QPS_PARTITION = 200;\n+    public static final long DEFAULT_OPTIMAL_SIZE_PER_SEGMENT = 2000_000_000; //2GB", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzNTg0OA=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDI5OTE1OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTozMDoxN1rOG8XmfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMToxMjo1OVrOG8a0pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NDQyOQ==", "bodyText": "This function is only computing the size of dictionary right? We should not include the size of bit compressed forward index", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465954429", "createdAt": "2020-08-05T19:30:17Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/\n+  public Map<String, ColumnMetaData> _metaDataMap = new HashMap<>(); // meta data per column, complement to schema\n+  long _sizePerRecord = 0;\n+  Map<String, FieldSpec.DataType> _colnameFieldTypeMap = new HashMap<>();\n+  Set<String> _dimNames = null;\n+  Set<String> _metricNames = null;\n+  Set<String> _dateTimeNames = null;\n+  Set<String> _dimNamesInveredSortedIndexApplicable = null;\n+  Map<String, Integer> _colNameToIntMap = null;\n+  String[] _intToColNameMap = null;\n+  Map<FieldSpec.DataType, Integer> _dataTypeSizeMap = new HashMap<FieldSpec.DataType, Integer>() {{\n+    put(FieldSpec.DataType.INT, DEFAULT_INT_SIZE);\n+    put(FieldSpec.DataType.LONG, DEFAULT_LONG_SIZE);\n+    put(FieldSpec.DataType.FLOAT, DEFAULT_FLOAT_SIZE);\n+    put(FieldSpec.DataType.DOUBLE, DEFAULT_DOUBLE_SIZE);\n+    put(FieldSpec.DataType.BYTES, DEFAULT_BYTE_SIZE);\n+    put(FieldSpec.DataType.STRING, DEFAULT_CHAR_SIZE);\n+    put(null, DEFAULT_NULL_SIZE);\n+  }};\n+\n+  /**\n+   * Process the dependencies incurred by overwritten configs.\n+   * E.g. we will subtract the dimensions with overwritten indices from _dimNames to get _dimNamesIndexApplicable\n+   * This ensures we do not recommend indices on those dimensions\n+   */\n+  public void init()\n+      throws InvalidInputException {\n+    LOGGER.info(\"Preprocessing Input:\");\n+    reorderDimsAndBuildMap();\n+    registerColnameFieldType();\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setFlagQueryRuleParams(FlagQueryRuleParams flagQueryRuleParams) {\n+    _flagQueryRuleParams = flagQueryRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumKafkaPartitions(int numKafkaPartitions) {\n+    _numKafkaPartitions = numKafkaPartitions;\n+  }\n+\n+  @JsonSetter(value = \"queriesWithWeights\", nulls = Nulls.SKIP)\n+  public void setQueryWeightMap(Map<String, Double> queryWeightMap) {\n+    _queryWeightMap = queryWeightMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNoDictionaryOnHeapDictionaryJointRuleParams(\n+      NoDictionaryOnHeapDictionaryJointRuleParams noDictionaryOnHeapDictionaryJointRuleParams) {\n+    _noDictionaryOnHeapDictionaryJointRuleParams = noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setLatencySLA(int latencySLA) {\n+    _latencySLA = latencySLA;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQps(long qps) {\n+    _qps = qps;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setBloomFilterRuleParams(BloomFilterRuleParams bloomFilterRuleParams) {\n+    _bloomFilterRuleParams = bloomFilterRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setPartitionRuleParams(PartitionRuleParams partitionRuleParams) {\n+    _partitionRuleParams = partitionRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setTableType(String tableType) {\n+    _tableType = tableType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumMessagesPerSec(long numMessagesPerSec) {\n+    _numMessagesPerSec = numMessagesPerSec;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumRecordsPerPush(long numRecordsPerPush) {\n+    _numRecordsPerPush = numRecordsPerPush;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRulesToExecute(RulesToExecute rulesToExecute) {\n+    _rulesToExecute = rulesToExecute;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setSchema(JsonNode jsonNode)\n+      throws IOException {\n+    ObjectReader reader = new ObjectMapper().readerFor(Schema.class);\n+    this._schema=reader.readValue(jsonNode);\n+    reader = new ObjectMapper().readerFor(SchemaWithMetaData.class);\n+    this._schemaWithMetaData=reader.readValue(jsonNode);\n+    _schemaWithMetaData.getDimensionFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getMetricFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getDateTimeFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _metaDataMap.put(_schemaWithMetaData.getTimeFieldSpec().getName(), _schemaWithMetaData.getTimeFieldSpec());\n+  }\n+\n+  @JsonIgnore\n+  public void setMetaDataMap(Map<String, ColumnMetaData> metaDataMap) {\n+    _metaDataMap = metaDataMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQueryType(String queryType) {\n+    _queryType = queryType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setInvertedSortedIndexJointRuleParams(\n+      InvertedSortedIndexJointRuleParams invertedSortedIndexJointRuleParams) {\n+    _invertedSortedIndexJointRuleParams = invertedSortedIndexJointRuleParams;\n+  }\n+\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setOverWrittenConfigs(ConfigManager overWrittenConfigs) {\n+    _overWrittenConfigs = overWrittenConfigs;\n+  }\n+\n+\n+  public FlagQueryRuleParams getFlagQueryRuleParams() {\n+    return _flagQueryRuleParams;\n+  }\n+\n+\n+  public FieldSpec.DataType getFieldType(String colName){\n+    return _colnameFieldTypeMap.getOrDefault(colName, null);\n+  }\n+\n+  public Map<String, Integer> getColNameToIntMap() {\n+    return _colNameToIntMap;\n+  }\n+\n+  /**\n+   * Get the number of dimensions we can apply indices on.\n+   * @return total number of dimensions minus number of dimensions with overwritten indices\n+   */\n+  public int getNumDimsInvertedSortedApplicable() {\n+    return _dimNamesInveredSortedIndexApplicable.size();\n+  }\n+\n+  public NoDictionaryOnHeapDictionaryJointRuleParams getNoDictionaryOnHeapDictionaryJointRuleParams() {\n+    return _noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  public int getNumDims() {\n+    return _dimNames.size();\n+  }\n+\n+  public int getNumCols() {\n+    return _colNameToIntMap.size();\n+  }\n+\n+  //TODO: Currently Pinot is using only ONE time column specified by TimeFieldSpec\n+  //TODO: Change the implementation after the new schema with multiple _dateTimeNames is in use\n+  public String getTimeCol() {\n+    return _schema.getTimeFieldSpec().getName();\n+  }\n+\n+  public Set<String> getColNamesNoDictionary() {\n+    return _overWrittenConfigs.getIndexConfig().getNoDictionaryColumns();\n+  }\n+\n+  public long getLatencySLA() {\n+    return _latencySLA;\n+  }\n+\n+  public long getQps() {\n+    return _qps;\n+  }\n+\n+  public BloomFilterRuleParams getBloomFilterRuleParams() {\n+    return _bloomFilterRuleParams;\n+  }\n+\n+  public PartitionRuleParams getPartitionRuleParams() {\n+    return _partitionRuleParams;\n+  }\n+\n+  public String getTableType() {\n+    return _tableType;\n+  }\n+\n+  public Map<String, Double> getQueryWeightMap() {\n+    return _queryWeightMap;\n+  }\n+\n+  public long getNumMessagesPerSec() {\n+    return _numMessagesPerSec;\n+  }\n+\n+  public long getNumRecordsPerPush() {\n+    return _numRecordsPerPush;\n+  }\n+\n+  public RulesToExecute getRulesToExecute() {\n+    return _rulesToExecute;\n+  }\n+\n+  public Schema getSchema() {\n+    return _schema;\n+  }\n+\n+  @JsonIgnore\n+  public Map<String, ColumnMetaData> getMetaDataMap() {\n+    return _metaDataMap;\n+  }\n+\n+  public String getQueryType() {\n+    return _queryType;\n+  }\n+\n+  public InvertedSortedIndexJointRuleParams getInvertedSortedIndexJointRuleParams() {\n+    return _invertedSortedIndexJointRuleParams;\n+  }\n+\n+  public ConfigManager getOverWrittenConfigs() {\n+    return _overWrittenConfigs;\n+  }\n+\n+  public long getSizePerRecord() {\n+    return _sizePerRecord;\n+  }\n+\n+  public double getCardinality(String columnName) {\n+    return max(_metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getCardinality(), MIN_CARDINALITY);\n+  }\n+\n+  public double getNumValuesPerEntry(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getNumValuesPerEntry();\n+  }\n+\n+  public int getAverageDataLen(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getAverageLength();\n+  }\n+\n+  public int getNumKafkaPartitions() {\n+    return _numKafkaPartitions;\n+  }\n+\n+  public boolean isIndexableDim(String colName) {\n+    return _dimNamesInveredSortedIndexApplicable.contains(colName);\n+  }\n+\n+  public boolean isSingleValueColumn(String colName){\n+    ColumnMetaData columnMetaData = _metaDataMap.getOrDefault(colName, new ColumnMetaData());\n+    return columnMetaData.isSingleValueField() && (columnMetaData.getNumValuesPerEntry() < DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY + EPSILON);\n+  }\n+\n+  /**\n+   * Map a index-applicable dimension name to an 0<=integer<getNumDimsInvertedSortedApplicable,\n+   * to be used with {@link FixedLenBitset}\n+   * @param colName a dimension with no overwritten index\n+   * @return a unique integer id\n+   */\n+  public int colNameToInt(String colName) {\n+    return _colNameToIntMap.getOrDefault(colName, NO_SUCH_COL);\n+  }\n+\n+  /**\n+   * A reverse process of colNameToInt\n+   * @param colID a unique integer id\n+   * @return column name\n+   */\n+  public String intToColName(int colID) {\n+    return _intToColNameMap[colID];\n+  }\n+\n+  /**\n+   * Test if colName is a valid dimension name\n+   */\n+  public boolean isDim(String colName) {\n+    return _dimNames.contains(colName);\n+  }\n+\n+  public boolean isDateTime(String colName) {\n+    return _schema.getTimeFieldSpec().getName().equals(colName);\n+  }\n+\n+  public void registerColnameFieldType() { // create a map from colname to data type\n+    for (DimensionFieldSpec dimensionFieldSpec : _schema.getDimensionFieldSpecs()) {\n+      _colnameFieldTypeMap.put(dimensionFieldSpec.getName(), dimensionFieldSpec.getDataType());\n+    }\n+    for (MetricFieldSpec metricFieldSpec : _schema.getMetricFieldSpecs()) {\n+      _colnameFieldTypeMap.put(metricFieldSpec.getName(), metricFieldSpec.getDataType());\n+    }\n+    //TODO: add support for multiple getDateTimeFieldSpecs\n+    _colnameFieldTypeMap.put(_schema.getTimeFieldSpec().getName(), _schema.getTimeFieldSpec().getDataType());\n+  }\n+\n+  public void estimateSizePerRecord() {\n+    for (String colName : _colnameFieldTypeMap.keySet()) {\n+      _sizePerRecord += getColDataSizeWithDictionary(colName);\n+      LOGGER.debug(\"{} {}\",colName, getColDataSizeWithDictionary(colName));\n+    }\n+    LOGGER.info(\"*Estimated size per record {} bytes\", _sizePerRecord);\n+  }\n+\n+  public long getColDataSizeWithoutDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else {\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType);\n+      }\n+    }\n+  }\n+\n+  public long getColDataSizeWithDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    int numValuesPerEntry = (int) Math.ceil(getNumValuesPerEntry(colName));\n+    LOGGER.trace(\"{} {}\", colName, numValuesPerEntry);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else if (!_overWrittenConfigs.getIndexConfig().getNoDictionaryColumns().contains(colName)) { // has dictionary\n+      return getBitCompressedDataSize(colName) * numValuesPerEntry;\n+    } else { // no dictionary\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry;\n+      }\n+    }\n+  }\n+\n+  public int getBitCompressedDataSize(String colName) {\n+    return max((int) Math.ceil(Math.log(getCardinality(colName)) / (8 * Math.log(2))), 1);\n+  }\n+\n+  //\n+  public long getDictionarySize(String colName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwNzIwNQ==", "bodyText": "Done! Thanks for pointing out this bug.", "url": "https://github.com/apache/pinot/pull/5774#discussion_r466007205", "createdAt": "2020-08-05T21:12:59Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/\n+  public Map<String, ColumnMetaData> _metaDataMap = new HashMap<>(); // meta data per column, complement to schema\n+  long _sizePerRecord = 0;\n+  Map<String, FieldSpec.DataType> _colnameFieldTypeMap = new HashMap<>();\n+  Set<String> _dimNames = null;\n+  Set<String> _metricNames = null;\n+  Set<String> _dateTimeNames = null;\n+  Set<String> _dimNamesInveredSortedIndexApplicable = null;\n+  Map<String, Integer> _colNameToIntMap = null;\n+  String[] _intToColNameMap = null;\n+  Map<FieldSpec.DataType, Integer> _dataTypeSizeMap = new HashMap<FieldSpec.DataType, Integer>() {{\n+    put(FieldSpec.DataType.INT, DEFAULT_INT_SIZE);\n+    put(FieldSpec.DataType.LONG, DEFAULT_LONG_SIZE);\n+    put(FieldSpec.DataType.FLOAT, DEFAULT_FLOAT_SIZE);\n+    put(FieldSpec.DataType.DOUBLE, DEFAULT_DOUBLE_SIZE);\n+    put(FieldSpec.DataType.BYTES, DEFAULT_BYTE_SIZE);\n+    put(FieldSpec.DataType.STRING, DEFAULT_CHAR_SIZE);\n+    put(null, DEFAULT_NULL_SIZE);\n+  }};\n+\n+  /**\n+   * Process the dependencies incurred by overwritten configs.\n+   * E.g. we will subtract the dimensions with overwritten indices from _dimNames to get _dimNamesIndexApplicable\n+   * This ensures we do not recommend indices on those dimensions\n+   */\n+  public void init()\n+      throws InvalidInputException {\n+    LOGGER.info(\"Preprocessing Input:\");\n+    reorderDimsAndBuildMap();\n+    registerColnameFieldType();\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setFlagQueryRuleParams(FlagQueryRuleParams flagQueryRuleParams) {\n+    _flagQueryRuleParams = flagQueryRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumKafkaPartitions(int numKafkaPartitions) {\n+    _numKafkaPartitions = numKafkaPartitions;\n+  }\n+\n+  @JsonSetter(value = \"queriesWithWeights\", nulls = Nulls.SKIP)\n+  public void setQueryWeightMap(Map<String, Double> queryWeightMap) {\n+    _queryWeightMap = queryWeightMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNoDictionaryOnHeapDictionaryJointRuleParams(\n+      NoDictionaryOnHeapDictionaryJointRuleParams noDictionaryOnHeapDictionaryJointRuleParams) {\n+    _noDictionaryOnHeapDictionaryJointRuleParams = noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setLatencySLA(int latencySLA) {\n+    _latencySLA = latencySLA;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQps(long qps) {\n+    _qps = qps;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setBloomFilterRuleParams(BloomFilterRuleParams bloomFilterRuleParams) {\n+    _bloomFilterRuleParams = bloomFilterRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setPartitionRuleParams(PartitionRuleParams partitionRuleParams) {\n+    _partitionRuleParams = partitionRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setTableType(String tableType) {\n+    _tableType = tableType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumMessagesPerSec(long numMessagesPerSec) {\n+    _numMessagesPerSec = numMessagesPerSec;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumRecordsPerPush(long numRecordsPerPush) {\n+    _numRecordsPerPush = numRecordsPerPush;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRulesToExecute(RulesToExecute rulesToExecute) {\n+    _rulesToExecute = rulesToExecute;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setSchema(JsonNode jsonNode)\n+      throws IOException {\n+    ObjectReader reader = new ObjectMapper().readerFor(Schema.class);\n+    this._schema=reader.readValue(jsonNode);\n+    reader = new ObjectMapper().readerFor(SchemaWithMetaData.class);\n+    this._schemaWithMetaData=reader.readValue(jsonNode);\n+    _schemaWithMetaData.getDimensionFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getMetricFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getDateTimeFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _metaDataMap.put(_schemaWithMetaData.getTimeFieldSpec().getName(), _schemaWithMetaData.getTimeFieldSpec());\n+  }\n+\n+  @JsonIgnore\n+  public void setMetaDataMap(Map<String, ColumnMetaData> metaDataMap) {\n+    _metaDataMap = metaDataMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQueryType(String queryType) {\n+    _queryType = queryType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setInvertedSortedIndexJointRuleParams(\n+      InvertedSortedIndexJointRuleParams invertedSortedIndexJointRuleParams) {\n+    _invertedSortedIndexJointRuleParams = invertedSortedIndexJointRuleParams;\n+  }\n+\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setOverWrittenConfigs(ConfigManager overWrittenConfigs) {\n+    _overWrittenConfigs = overWrittenConfigs;\n+  }\n+\n+\n+  public FlagQueryRuleParams getFlagQueryRuleParams() {\n+    return _flagQueryRuleParams;\n+  }\n+\n+\n+  public FieldSpec.DataType getFieldType(String colName){\n+    return _colnameFieldTypeMap.getOrDefault(colName, null);\n+  }\n+\n+  public Map<String, Integer> getColNameToIntMap() {\n+    return _colNameToIntMap;\n+  }\n+\n+  /**\n+   * Get the number of dimensions we can apply indices on.\n+   * @return total number of dimensions minus number of dimensions with overwritten indices\n+   */\n+  public int getNumDimsInvertedSortedApplicable() {\n+    return _dimNamesInveredSortedIndexApplicable.size();\n+  }\n+\n+  public NoDictionaryOnHeapDictionaryJointRuleParams getNoDictionaryOnHeapDictionaryJointRuleParams() {\n+    return _noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  public int getNumDims() {\n+    return _dimNames.size();\n+  }\n+\n+  public int getNumCols() {\n+    return _colNameToIntMap.size();\n+  }\n+\n+  //TODO: Currently Pinot is using only ONE time column specified by TimeFieldSpec\n+  //TODO: Change the implementation after the new schema with multiple _dateTimeNames is in use\n+  public String getTimeCol() {\n+    return _schema.getTimeFieldSpec().getName();\n+  }\n+\n+  public Set<String> getColNamesNoDictionary() {\n+    return _overWrittenConfigs.getIndexConfig().getNoDictionaryColumns();\n+  }\n+\n+  public long getLatencySLA() {\n+    return _latencySLA;\n+  }\n+\n+  public long getQps() {\n+    return _qps;\n+  }\n+\n+  public BloomFilterRuleParams getBloomFilterRuleParams() {\n+    return _bloomFilterRuleParams;\n+  }\n+\n+  public PartitionRuleParams getPartitionRuleParams() {\n+    return _partitionRuleParams;\n+  }\n+\n+  public String getTableType() {\n+    return _tableType;\n+  }\n+\n+  public Map<String, Double> getQueryWeightMap() {\n+    return _queryWeightMap;\n+  }\n+\n+  public long getNumMessagesPerSec() {\n+    return _numMessagesPerSec;\n+  }\n+\n+  public long getNumRecordsPerPush() {\n+    return _numRecordsPerPush;\n+  }\n+\n+  public RulesToExecute getRulesToExecute() {\n+    return _rulesToExecute;\n+  }\n+\n+  public Schema getSchema() {\n+    return _schema;\n+  }\n+\n+  @JsonIgnore\n+  public Map<String, ColumnMetaData> getMetaDataMap() {\n+    return _metaDataMap;\n+  }\n+\n+  public String getQueryType() {\n+    return _queryType;\n+  }\n+\n+  public InvertedSortedIndexJointRuleParams getInvertedSortedIndexJointRuleParams() {\n+    return _invertedSortedIndexJointRuleParams;\n+  }\n+\n+  public ConfigManager getOverWrittenConfigs() {\n+    return _overWrittenConfigs;\n+  }\n+\n+  public long getSizePerRecord() {\n+    return _sizePerRecord;\n+  }\n+\n+  public double getCardinality(String columnName) {\n+    return max(_metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getCardinality(), MIN_CARDINALITY);\n+  }\n+\n+  public double getNumValuesPerEntry(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getNumValuesPerEntry();\n+  }\n+\n+  public int getAverageDataLen(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getAverageLength();\n+  }\n+\n+  public int getNumKafkaPartitions() {\n+    return _numKafkaPartitions;\n+  }\n+\n+  public boolean isIndexableDim(String colName) {\n+    return _dimNamesInveredSortedIndexApplicable.contains(colName);\n+  }\n+\n+  public boolean isSingleValueColumn(String colName){\n+    ColumnMetaData columnMetaData = _metaDataMap.getOrDefault(colName, new ColumnMetaData());\n+    return columnMetaData.isSingleValueField() && (columnMetaData.getNumValuesPerEntry() < DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY + EPSILON);\n+  }\n+\n+  /**\n+   * Map a index-applicable dimension name to an 0<=integer<getNumDimsInvertedSortedApplicable,\n+   * to be used with {@link FixedLenBitset}\n+   * @param colName a dimension with no overwritten index\n+   * @return a unique integer id\n+   */\n+  public int colNameToInt(String colName) {\n+    return _colNameToIntMap.getOrDefault(colName, NO_SUCH_COL);\n+  }\n+\n+  /**\n+   * A reverse process of colNameToInt\n+   * @param colID a unique integer id\n+   * @return column name\n+   */\n+  public String intToColName(int colID) {\n+    return _intToColNameMap[colID];\n+  }\n+\n+  /**\n+   * Test if colName is a valid dimension name\n+   */\n+  public boolean isDim(String colName) {\n+    return _dimNames.contains(colName);\n+  }\n+\n+  public boolean isDateTime(String colName) {\n+    return _schema.getTimeFieldSpec().getName().equals(colName);\n+  }\n+\n+  public void registerColnameFieldType() { // create a map from colname to data type\n+    for (DimensionFieldSpec dimensionFieldSpec : _schema.getDimensionFieldSpecs()) {\n+      _colnameFieldTypeMap.put(dimensionFieldSpec.getName(), dimensionFieldSpec.getDataType());\n+    }\n+    for (MetricFieldSpec metricFieldSpec : _schema.getMetricFieldSpecs()) {\n+      _colnameFieldTypeMap.put(metricFieldSpec.getName(), metricFieldSpec.getDataType());\n+    }\n+    //TODO: add support for multiple getDateTimeFieldSpecs\n+    _colnameFieldTypeMap.put(_schema.getTimeFieldSpec().getName(), _schema.getTimeFieldSpec().getDataType());\n+  }\n+\n+  public void estimateSizePerRecord() {\n+    for (String colName : _colnameFieldTypeMap.keySet()) {\n+      _sizePerRecord += getColDataSizeWithDictionary(colName);\n+      LOGGER.debug(\"{} {}\",colName, getColDataSizeWithDictionary(colName));\n+    }\n+    LOGGER.info(\"*Estimated size per record {} bytes\", _sizePerRecord);\n+  }\n+\n+  public long getColDataSizeWithoutDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else {\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType);\n+      }\n+    }\n+  }\n+\n+  public long getColDataSizeWithDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    int numValuesPerEntry = (int) Math.ceil(getNumValuesPerEntry(colName));\n+    LOGGER.trace(\"{} {}\", colName, numValuesPerEntry);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else if (!_overWrittenConfigs.getIndexConfig().getNoDictionaryColumns().contains(colName)) { // has dictionary\n+      return getBitCompressedDataSize(colName) * numValuesPerEntry;\n+    } else { // no dictionary\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry;\n+      }\n+    }\n+  }\n+\n+  public int getBitCompressedDataSize(String colName) {\n+    return max((int) Math.ceil(Math.log(getCardinality(colName)) / (8 * Math.log(2))), 1);\n+  }\n+\n+  //\n+  public long getDictionarySize(String colName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NDQyOQ=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 435}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDMwODAwOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTozMzoyMlrOG8XsYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo1NTo1OVrOG8aSpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NTkzNw==", "bodyText": "You might want to rename it to getDictionaryEncodedForwardIndexSize", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465955937", "createdAt": "2020-08-05T19:33:22Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/\n+  public Map<String, ColumnMetaData> _metaDataMap = new HashMap<>(); // meta data per column, complement to schema\n+  long _sizePerRecord = 0;\n+  Map<String, FieldSpec.DataType> _colnameFieldTypeMap = new HashMap<>();\n+  Set<String> _dimNames = null;\n+  Set<String> _metricNames = null;\n+  Set<String> _dateTimeNames = null;\n+  Set<String> _dimNamesInveredSortedIndexApplicable = null;\n+  Map<String, Integer> _colNameToIntMap = null;\n+  String[] _intToColNameMap = null;\n+  Map<FieldSpec.DataType, Integer> _dataTypeSizeMap = new HashMap<FieldSpec.DataType, Integer>() {{\n+    put(FieldSpec.DataType.INT, DEFAULT_INT_SIZE);\n+    put(FieldSpec.DataType.LONG, DEFAULT_LONG_SIZE);\n+    put(FieldSpec.DataType.FLOAT, DEFAULT_FLOAT_SIZE);\n+    put(FieldSpec.DataType.DOUBLE, DEFAULT_DOUBLE_SIZE);\n+    put(FieldSpec.DataType.BYTES, DEFAULT_BYTE_SIZE);\n+    put(FieldSpec.DataType.STRING, DEFAULT_CHAR_SIZE);\n+    put(null, DEFAULT_NULL_SIZE);\n+  }};\n+\n+  /**\n+   * Process the dependencies incurred by overwritten configs.\n+   * E.g. we will subtract the dimensions with overwritten indices from _dimNames to get _dimNamesIndexApplicable\n+   * This ensures we do not recommend indices on those dimensions\n+   */\n+  public void init()\n+      throws InvalidInputException {\n+    LOGGER.info(\"Preprocessing Input:\");\n+    reorderDimsAndBuildMap();\n+    registerColnameFieldType();\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setFlagQueryRuleParams(FlagQueryRuleParams flagQueryRuleParams) {\n+    _flagQueryRuleParams = flagQueryRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumKafkaPartitions(int numKafkaPartitions) {\n+    _numKafkaPartitions = numKafkaPartitions;\n+  }\n+\n+  @JsonSetter(value = \"queriesWithWeights\", nulls = Nulls.SKIP)\n+  public void setQueryWeightMap(Map<String, Double> queryWeightMap) {\n+    _queryWeightMap = queryWeightMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNoDictionaryOnHeapDictionaryJointRuleParams(\n+      NoDictionaryOnHeapDictionaryJointRuleParams noDictionaryOnHeapDictionaryJointRuleParams) {\n+    _noDictionaryOnHeapDictionaryJointRuleParams = noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setLatencySLA(int latencySLA) {\n+    _latencySLA = latencySLA;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQps(long qps) {\n+    _qps = qps;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setBloomFilterRuleParams(BloomFilterRuleParams bloomFilterRuleParams) {\n+    _bloomFilterRuleParams = bloomFilterRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setPartitionRuleParams(PartitionRuleParams partitionRuleParams) {\n+    _partitionRuleParams = partitionRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setTableType(String tableType) {\n+    _tableType = tableType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumMessagesPerSec(long numMessagesPerSec) {\n+    _numMessagesPerSec = numMessagesPerSec;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumRecordsPerPush(long numRecordsPerPush) {\n+    _numRecordsPerPush = numRecordsPerPush;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRulesToExecute(RulesToExecute rulesToExecute) {\n+    _rulesToExecute = rulesToExecute;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setSchema(JsonNode jsonNode)\n+      throws IOException {\n+    ObjectReader reader = new ObjectMapper().readerFor(Schema.class);\n+    this._schema=reader.readValue(jsonNode);\n+    reader = new ObjectMapper().readerFor(SchemaWithMetaData.class);\n+    this._schemaWithMetaData=reader.readValue(jsonNode);\n+    _schemaWithMetaData.getDimensionFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getMetricFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getDateTimeFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _metaDataMap.put(_schemaWithMetaData.getTimeFieldSpec().getName(), _schemaWithMetaData.getTimeFieldSpec());\n+  }\n+\n+  @JsonIgnore\n+  public void setMetaDataMap(Map<String, ColumnMetaData> metaDataMap) {\n+    _metaDataMap = metaDataMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQueryType(String queryType) {\n+    _queryType = queryType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setInvertedSortedIndexJointRuleParams(\n+      InvertedSortedIndexJointRuleParams invertedSortedIndexJointRuleParams) {\n+    _invertedSortedIndexJointRuleParams = invertedSortedIndexJointRuleParams;\n+  }\n+\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setOverWrittenConfigs(ConfigManager overWrittenConfigs) {\n+    _overWrittenConfigs = overWrittenConfigs;\n+  }\n+\n+\n+  public FlagQueryRuleParams getFlagQueryRuleParams() {\n+    return _flagQueryRuleParams;\n+  }\n+\n+\n+  public FieldSpec.DataType getFieldType(String colName){\n+    return _colnameFieldTypeMap.getOrDefault(colName, null);\n+  }\n+\n+  public Map<String, Integer> getColNameToIntMap() {\n+    return _colNameToIntMap;\n+  }\n+\n+  /**\n+   * Get the number of dimensions we can apply indices on.\n+   * @return total number of dimensions minus number of dimensions with overwritten indices\n+   */\n+  public int getNumDimsInvertedSortedApplicable() {\n+    return _dimNamesInveredSortedIndexApplicable.size();\n+  }\n+\n+  public NoDictionaryOnHeapDictionaryJointRuleParams getNoDictionaryOnHeapDictionaryJointRuleParams() {\n+    return _noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  public int getNumDims() {\n+    return _dimNames.size();\n+  }\n+\n+  public int getNumCols() {\n+    return _colNameToIntMap.size();\n+  }\n+\n+  //TODO: Currently Pinot is using only ONE time column specified by TimeFieldSpec\n+  //TODO: Change the implementation after the new schema with multiple _dateTimeNames is in use\n+  public String getTimeCol() {\n+    return _schema.getTimeFieldSpec().getName();\n+  }\n+\n+  public Set<String> getColNamesNoDictionary() {\n+    return _overWrittenConfigs.getIndexConfig().getNoDictionaryColumns();\n+  }\n+\n+  public long getLatencySLA() {\n+    return _latencySLA;\n+  }\n+\n+  public long getQps() {\n+    return _qps;\n+  }\n+\n+  public BloomFilterRuleParams getBloomFilterRuleParams() {\n+    return _bloomFilterRuleParams;\n+  }\n+\n+  public PartitionRuleParams getPartitionRuleParams() {\n+    return _partitionRuleParams;\n+  }\n+\n+  public String getTableType() {\n+    return _tableType;\n+  }\n+\n+  public Map<String, Double> getQueryWeightMap() {\n+    return _queryWeightMap;\n+  }\n+\n+  public long getNumMessagesPerSec() {\n+    return _numMessagesPerSec;\n+  }\n+\n+  public long getNumRecordsPerPush() {\n+    return _numRecordsPerPush;\n+  }\n+\n+  public RulesToExecute getRulesToExecute() {\n+    return _rulesToExecute;\n+  }\n+\n+  public Schema getSchema() {\n+    return _schema;\n+  }\n+\n+  @JsonIgnore\n+  public Map<String, ColumnMetaData> getMetaDataMap() {\n+    return _metaDataMap;\n+  }\n+\n+  public String getQueryType() {\n+    return _queryType;\n+  }\n+\n+  public InvertedSortedIndexJointRuleParams getInvertedSortedIndexJointRuleParams() {\n+    return _invertedSortedIndexJointRuleParams;\n+  }\n+\n+  public ConfigManager getOverWrittenConfigs() {\n+    return _overWrittenConfigs;\n+  }\n+\n+  public long getSizePerRecord() {\n+    return _sizePerRecord;\n+  }\n+\n+  public double getCardinality(String columnName) {\n+    return max(_metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getCardinality(), MIN_CARDINALITY);\n+  }\n+\n+  public double getNumValuesPerEntry(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getNumValuesPerEntry();\n+  }\n+\n+  public int getAverageDataLen(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getAverageLength();\n+  }\n+\n+  public int getNumKafkaPartitions() {\n+    return _numKafkaPartitions;\n+  }\n+\n+  public boolean isIndexableDim(String colName) {\n+    return _dimNamesInveredSortedIndexApplicable.contains(colName);\n+  }\n+\n+  public boolean isSingleValueColumn(String colName){\n+    ColumnMetaData columnMetaData = _metaDataMap.getOrDefault(colName, new ColumnMetaData());\n+    return columnMetaData.isSingleValueField() && (columnMetaData.getNumValuesPerEntry() < DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY + EPSILON);\n+  }\n+\n+  /**\n+   * Map a index-applicable dimension name to an 0<=integer<getNumDimsInvertedSortedApplicable,\n+   * to be used with {@link FixedLenBitset}\n+   * @param colName a dimension with no overwritten index\n+   * @return a unique integer id\n+   */\n+  public int colNameToInt(String colName) {\n+    return _colNameToIntMap.getOrDefault(colName, NO_SUCH_COL);\n+  }\n+\n+  /**\n+   * A reverse process of colNameToInt\n+   * @param colID a unique integer id\n+   * @return column name\n+   */\n+  public String intToColName(int colID) {\n+    return _intToColNameMap[colID];\n+  }\n+\n+  /**\n+   * Test if colName is a valid dimension name\n+   */\n+  public boolean isDim(String colName) {\n+    return _dimNames.contains(colName);\n+  }\n+\n+  public boolean isDateTime(String colName) {\n+    return _schema.getTimeFieldSpec().getName().equals(colName);\n+  }\n+\n+  public void registerColnameFieldType() { // create a map from colname to data type\n+    for (DimensionFieldSpec dimensionFieldSpec : _schema.getDimensionFieldSpecs()) {\n+      _colnameFieldTypeMap.put(dimensionFieldSpec.getName(), dimensionFieldSpec.getDataType());\n+    }\n+    for (MetricFieldSpec metricFieldSpec : _schema.getMetricFieldSpecs()) {\n+      _colnameFieldTypeMap.put(metricFieldSpec.getName(), metricFieldSpec.getDataType());\n+    }\n+    //TODO: add support for multiple getDateTimeFieldSpecs\n+    _colnameFieldTypeMap.put(_schema.getTimeFieldSpec().getName(), _schema.getTimeFieldSpec().getDataType());\n+  }\n+\n+  public void estimateSizePerRecord() {\n+    for (String colName : _colnameFieldTypeMap.keySet()) {\n+      _sizePerRecord += getColDataSizeWithDictionary(colName);\n+      LOGGER.debug(\"{} {}\",colName, getColDataSizeWithDictionary(colName));\n+    }\n+    LOGGER.info(\"*Estimated size per record {} bytes\", _sizePerRecord);\n+  }\n+\n+  public long getColDataSizeWithoutDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else {\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType);\n+      }\n+    }\n+  }\n+\n+  public long getColDataSizeWithDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    int numValuesPerEntry = (int) Math.ceil(getNumValuesPerEntry(colName));\n+    LOGGER.trace(\"{} {}\", colName, numValuesPerEntry);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else if (!_overWrittenConfigs.getIndexConfig().getNoDictionaryColumns().contains(colName)) { // has dictionary\n+      return getBitCompressedDataSize(colName) * numValuesPerEntry;\n+    } else { // no dictionary\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry;\n+      }\n+    }\n+  }\n+\n+  public int getBitCompressedDataSize(String colName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 430}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2MDc4OQ==", "bodyText": "This function doesn't actually return the total bit compressed size.\nWhat we need is the following:\n\nget the number of bits per value\nnumber of records\n\nmultiply both\nnumber of bits per value  can be calculated by a function PinotDataBitSet", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465960789", "createdAt": "2020-08-05T19:42:46Z", "author": {"login": "siddharthteotia"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/\n+  public Map<String, ColumnMetaData> _metaDataMap = new HashMap<>(); // meta data per column, complement to schema\n+  long _sizePerRecord = 0;\n+  Map<String, FieldSpec.DataType> _colnameFieldTypeMap = new HashMap<>();\n+  Set<String> _dimNames = null;\n+  Set<String> _metricNames = null;\n+  Set<String> _dateTimeNames = null;\n+  Set<String> _dimNamesInveredSortedIndexApplicable = null;\n+  Map<String, Integer> _colNameToIntMap = null;\n+  String[] _intToColNameMap = null;\n+  Map<FieldSpec.DataType, Integer> _dataTypeSizeMap = new HashMap<FieldSpec.DataType, Integer>() {{\n+    put(FieldSpec.DataType.INT, DEFAULT_INT_SIZE);\n+    put(FieldSpec.DataType.LONG, DEFAULT_LONG_SIZE);\n+    put(FieldSpec.DataType.FLOAT, DEFAULT_FLOAT_SIZE);\n+    put(FieldSpec.DataType.DOUBLE, DEFAULT_DOUBLE_SIZE);\n+    put(FieldSpec.DataType.BYTES, DEFAULT_BYTE_SIZE);\n+    put(FieldSpec.DataType.STRING, DEFAULT_CHAR_SIZE);\n+    put(null, DEFAULT_NULL_SIZE);\n+  }};\n+\n+  /**\n+   * Process the dependencies incurred by overwritten configs.\n+   * E.g. we will subtract the dimensions with overwritten indices from _dimNames to get _dimNamesIndexApplicable\n+   * This ensures we do not recommend indices on those dimensions\n+   */\n+  public void init()\n+      throws InvalidInputException {\n+    LOGGER.info(\"Preprocessing Input:\");\n+    reorderDimsAndBuildMap();\n+    registerColnameFieldType();\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setFlagQueryRuleParams(FlagQueryRuleParams flagQueryRuleParams) {\n+    _flagQueryRuleParams = flagQueryRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumKafkaPartitions(int numKafkaPartitions) {\n+    _numKafkaPartitions = numKafkaPartitions;\n+  }\n+\n+  @JsonSetter(value = \"queriesWithWeights\", nulls = Nulls.SKIP)\n+  public void setQueryWeightMap(Map<String, Double> queryWeightMap) {\n+    _queryWeightMap = queryWeightMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNoDictionaryOnHeapDictionaryJointRuleParams(\n+      NoDictionaryOnHeapDictionaryJointRuleParams noDictionaryOnHeapDictionaryJointRuleParams) {\n+    _noDictionaryOnHeapDictionaryJointRuleParams = noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setLatencySLA(int latencySLA) {\n+    _latencySLA = latencySLA;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQps(long qps) {\n+    _qps = qps;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setBloomFilterRuleParams(BloomFilterRuleParams bloomFilterRuleParams) {\n+    _bloomFilterRuleParams = bloomFilterRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setPartitionRuleParams(PartitionRuleParams partitionRuleParams) {\n+    _partitionRuleParams = partitionRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setTableType(String tableType) {\n+    _tableType = tableType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumMessagesPerSec(long numMessagesPerSec) {\n+    _numMessagesPerSec = numMessagesPerSec;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumRecordsPerPush(long numRecordsPerPush) {\n+    _numRecordsPerPush = numRecordsPerPush;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRulesToExecute(RulesToExecute rulesToExecute) {\n+    _rulesToExecute = rulesToExecute;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setSchema(JsonNode jsonNode)\n+      throws IOException {\n+    ObjectReader reader = new ObjectMapper().readerFor(Schema.class);\n+    this._schema=reader.readValue(jsonNode);\n+    reader = new ObjectMapper().readerFor(SchemaWithMetaData.class);\n+    this._schemaWithMetaData=reader.readValue(jsonNode);\n+    _schemaWithMetaData.getDimensionFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getMetricFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getDateTimeFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _metaDataMap.put(_schemaWithMetaData.getTimeFieldSpec().getName(), _schemaWithMetaData.getTimeFieldSpec());\n+  }\n+\n+  @JsonIgnore\n+  public void setMetaDataMap(Map<String, ColumnMetaData> metaDataMap) {\n+    _metaDataMap = metaDataMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQueryType(String queryType) {\n+    _queryType = queryType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setInvertedSortedIndexJointRuleParams(\n+      InvertedSortedIndexJointRuleParams invertedSortedIndexJointRuleParams) {\n+    _invertedSortedIndexJointRuleParams = invertedSortedIndexJointRuleParams;\n+  }\n+\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setOverWrittenConfigs(ConfigManager overWrittenConfigs) {\n+    _overWrittenConfigs = overWrittenConfigs;\n+  }\n+\n+\n+  public FlagQueryRuleParams getFlagQueryRuleParams() {\n+    return _flagQueryRuleParams;\n+  }\n+\n+\n+  public FieldSpec.DataType getFieldType(String colName){\n+    return _colnameFieldTypeMap.getOrDefault(colName, null);\n+  }\n+\n+  public Map<String, Integer> getColNameToIntMap() {\n+    return _colNameToIntMap;\n+  }\n+\n+  /**\n+   * Get the number of dimensions we can apply indices on.\n+   * @return total number of dimensions minus number of dimensions with overwritten indices\n+   */\n+  public int getNumDimsInvertedSortedApplicable() {\n+    return _dimNamesInveredSortedIndexApplicable.size();\n+  }\n+\n+  public NoDictionaryOnHeapDictionaryJointRuleParams getNoDictionaryOnHeapDictionaryJointRuleParams() {\n+    return _noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  public int getNumDims() {\n+    return _dimNames.size();\n+  }\n+\n+  public int getNumCols() {\n+    return _colNameToIntMap.size();\n+  }\n+\n+  //TODO: Currently Pinot is using only ONE time column specified by TimeFieldSpec\n+  //TODO: Change the implementation after the new schema with multiple _dateTimeNames is in use\n+  public String getTimeCol() {\n+    return _schema.getTimeFieldSpec().getName();\n+  }\n+\n+  public Set<String> getColNamesNoDictionary() {\n+    return _overWrittenConfigs.getIndexConfig().getNoDictionaryColumns();\n+  }\n+\n+  public long getLatencySLA() {\n+    return _latencySLA;\n+  }\n+\n+  public long getQps() {\n+    return _qps;\n+  }\n+\n+  public BloomFilterRuleParams getBloomFilterRuleParams() {\n+    return _bloomFilterRuleParams;\n+  }\n+\n+  public PartitionRuleParams getPartitionRuleParams() {\n+    return _partitionRuleParams;\n+  }\n+\n+  public String getTableType() {\n+    return _tableType;\n+  }\n+\n+  public Map<String, Double> getQueryWeightMap() {\n+    return _queryWeightMap;\n+  }\n+\n+  public long getNumMessagesPerSec() {\n+    return _numMessagesPerSec;\n+  }\n+\n+  public long getNumRecordsPerPush() {\n+    return _numRecordsPerPush;\n+  }\n+\n+  public RulesToExecute getRulesToExecute() {\n+    return _rulesToExecute;\n+  }\n+\n+  public Schema getSchema() {\n+    return _schema;\n+  }\n+\n+  @JsonIgnore\n+  public Map<String, ColumnMetaData> getMetaDataMap() {\n+    return _metaDataMap;\n+  }\n+\n+  public String getQueryType() {\n+    return _queryType;\n+  }\n+\n+  public InvertedSortedIndexJointRuleParams getInvertedSortedIndexJointRuleParams() {\n+    return _invertedSortedIndexJointRuleParams;\n+  }\n+\n+  public ConfigManager getOverWrittenConfigs() {\n+    return _overWrittenConfigs;\n+  }\n+\n+  public long getSizePerRecord() {\n+    return _sizePerRecord;\n+  }\n+\n+  public double getCardinality(String columnName) {\n+    return max(_metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getCardinality(), MIN_CARDINALITY);\n+  }\n+\n+  public double getNumValuesPerEntry(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getNumValuesPerEntry();\n+  }\n+\n+  public int getAverageDataLen(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getAverageLength();\n+  }\n+\n+  public int getNumKafkaPartitions() {\n+    return _numKafkaPartitions;\n+  }\n+\n+  public boolean isIndexableDim(String colName) {\n+    return _dimNamesInveredSortedIndexApplicable.contains(colName);\n+  }\n+\n+  public boolean isSingleValueColumn(String colName){\n+    ColumnMetaData columnMetaData = _metaDataMap.getOrDefault(colName, new ColumnMetaData());\n+    return columnMetaData.isSingleValueField() && (columnMetaData.getNumValuesPerEntry() < DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY + EPSILON);\n+  }\n+\n+  /**\n+   * Map a index-applicable dimension name to an 0<=integer<getNumDimsInvertedSortedApplicable,\n+   * to be used with {@link FixedLenBitset}\n+   * @param colName a dimension with no overwritten index\n+   * @return a unique integer id\n+   */\n+  public int colNameToInt(String colName) {\n+    return _colNameToIntMap.getOrDefault(colName, NO_SUCH_COL);\n+  }\n+\n+  /**\n+   * A reverse process of colNameToInt\n+   * @param colID a unique integer id\n+   * @return column name\n+   */\n+  public String intToColName(int colID) {\n+    return _intToColNameMap[colID];\n+  }\n+\n+  /**\n+   * Test if colName is a valid dimension name\n+   */\n+  public boolean isDim(String colName) {\n+    return _dimNames.contains(colName);\n+  }\n+\n+  public boolean isDateTime(String colName) {\n+    return _schema.getTimeFieldSpec().getName().equals(colName);\n+  }\n+\n+  public void registerColnameFieldType() { // create a map from colname to data type\n+    for (DimensionFieldSpec dimensionFieldSpec : _schema.getDimensionFieldSpecs()) {\n+      _colnameFieldTypeMap.put(dimensionFieldSpec.getName(), dimensionFieldSpec.getDataType());\n+    }\n+    for (MetricFieldSpec metricFieldSpec : _schema.getMetricFieldSpecs()) {\n+      _colnameFieldTypeMap.put(metricFieldSpec.getName(), metricFieldSpec.getDataType());\n+    }\n+    //TODO: add support for multiple getDateTimeFieldSpecs\n+    _colnameFieldTypeMap.put(_schema.getTimeFieldSpec().getName(), _schema.getTimeFieldSpec().getDataType());\n+  }\n+\n+  public void estimateSizePerRecord() {\n+    for (String colName : _colnameFieldTypeMap.keySet()) {\n+      _sizePerRecord += getColDataSizeWithDictionary(colName);\n+      LOGGER.debug(\"{} {}\",colName, getColDataSizeWithDictionary(colName));\n+    }\n+    LOGGER.info(\"*Estimated size per record {} bytes\", _sizePerRecord);\n+  }\n+\n+  public long getColDataSizeWithoutDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else {\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType);\n+      }\n+    }\n+  }\n+\n+  public long getColDataSizeWithDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    int numValuesPerEntry = (int) Math.ceil(getNumValuesPerEntry(colName));\n+    LOGGER.trace(\"{} {}\", colName, numValuesPerEntry);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else if (!_overWrittenConfigs.getIndexConfig().getNoDictionaryColumns().contains(colName)) { // has dictionary\n+      return getBitCompressedDataSize(colName) * numValuesPerEntry;\n+    } else { // no dictionary\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry;\n+      }\n+    }\n+  }\n+\n+  public int getBitCompressedDataSize(String colName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NTkzNw=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 430}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5ODUwMw==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/5774#discussion_r465998503", "createdAt": "2020-08-05T20:55:59Z", "author": {"login": "jasperjiaguo"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/recommender/io/InputManager.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.recommender.io;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.pinot.controller.recommender.io.exceptions.InvalidInputException;\n+import org.apache.pinot.controller.recommender.io.metadata.ColumnMetaData;\n+import org.apache.pinot.controller.recommender.io.metadata.SchemaWithMetaData;\n+import org.apache.pinot.controller.recommender.rules.RulesToExecute;\n+import org.apache.pinot.controller.recommender.rules.io.params.BloomFilterRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.FlagQueryRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.InvertedSortedIndexJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.NoDictionaryOnHeapDictionaryJointRuleParams;\n+import org.apache.pinot.controller.recommender.rules.io.params.PartitionRuleParams;\n+import org.apache.pinot.controller.recommender.rules.utils.FixedLenBitset;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.lang.Math.max;\n+import static org.apache.pinot.controller.recommender.rules.io.params.RecommenderConstants.*;\n+\n+\n+@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)\n+public class InputManager {\n+  private final Logger LOGGER = LoggerFactory.getLogger(InputManager.class);\n+\n+  /******************************Deserialized from input json*********************************/\n+  // Basic input fields\n+  public RulesToExecute _rulesToExecute = new RulesToExecute(); // dictates which rules to execute\n+  public Schema _schema = new Schema();\n+  public SchemaWithMetaData _schemaWithMetaData = new SchemaWithMetaData();\n+\n+  public String _queryType = SQL; // SQL or PQL\n+  public long _qps = DEFAULT_QPS;\n+  public Map<String, Double> _queryWeightMap = new HashMap<>(); // {\"queryString\":\"queryWeight\"}\n+  public String _tableType = OFFLINE;\n+  public long _numMessagesPerSec = DEFAULT_NUM_MSG_PER_SEC; // messages per sec for kafka to consume\n+  public long _numRecordsPerPush = DEFAULT_NUM_RECORDS_PER_PUSH; // records per push for offline part of a table\n+  public long _latencySLA = DEFAULT_LATENCY_SLA; // latency sla in ms\n+  public int _numKafkaPartitions = DEFAULT_NUM_KAFKA_PARTITIONS;\n+\n+  // The parameters of rules\n+  public PartitionRuleParams _partitionRuleParams = new PartitionRuleParams();\n+  public InvertedSortedIndexJointRuleParams _invertedSortedIndexJointRuleParams =\n+      new InvertedSortedIndexJointRuleParams();\n+  public BloomFilterRuleParams _bloomFilterRuleParams = new BloomFilterRuleParams();\n+  public NoDictionaryOnHeapDictionaryJointRuleParams _noDictionaryOnHeapDictionaryJointRuleParams =\n+      new NoDictionaryOnHeapDictionaryJointRuleParams();\n+  public FlagQueryRuleParams _flagQueryRuleParams = new FlagQueryRuleParams();\n+\n+  // For forward compatibility: 1. dev/sre to overwrite field(s) 2. incremental recommendation on existing/staging tables\n+  public ConfigManager _overWrittenConfigs = new ConfigManager();\n+\n+  /******************************Ignored by deserializer****************************************/\n+  public Map<String, ColumnMetaData> _metaDataMap = new HashMap<>(); // meta data per column, complement to schema\n+  long _sizePerRecord = 0;\n+  Map<String, FieldSpec.DataType> _colnameFieldTypeMap = new HashMap<>();\n+  Set<String> _dimNames = null;\n+  Set<String> _metricNames = null;\n+  Set<String> _dateTimeNames = null;\n+  Set<String> _dimNamesInveredSortedIndexApplicable = null;\n+  Map<String, Integer> _colNameToIntMap = null;\n+  String[] _intToColNameMap = null;\n+  Map<FieldSpec.DataType, Integer> _dataTypeSizeMap = new HashMap<FieldSpec.DataType, Integer>() {{\n+    put(FieldSpec.DataType.INT, DEFAULT_INT_SIZE);\n+    put(FieldSpec.DataType.LONG, DEFAULT_LONG_SIZE);\n+    put(FieldSpec.DataType.FLOAT, DEFAULT_FLOAT_SIZE);\n+    put(FieldSpec.DataType.DOUBLE, DEFAULT_DOUBLE_SIZE);\n+    put(FieldSpec.DataType.BYTES, DEFAULT_BYTE_SIZE);\n+    put(FieldSpec.DataType.STRING, DEFAULT_CHAR_SIZE);\n+    put(null, DEFAULT_NULL_SIZE);\n+  }};\n+\n+  /**\n+   * Process the dependencies incurred by overwritten configs.\n+   * E.g. we will subtract the dimensions with overwritten indices from _dimNames to get _dimNamesIndexApplicable\n+   * This ensures we do not recommend indices on those dimensions\n+   */\n+  public void init()\n+      throws InvalidInputException {\n+    LOGGER.info(\"Preprocessing Input:\");\n+    reorderDimsAndBuildMap();\n+    registerColnameFieldType();\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setFlagQueryRuleParams(FlagQueryRuleParams flagQueryRuleParams) {\n+    _flagQueryRuleParams = flagQueryRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumKafkaPartitions(int numKafkaPartitions) {\n+    _numKafkaPartitions = numKafkaPartitions;\n+  }\n+\n+  @JsonSetter(value = \"queriesWithWeights\", nulls = Nulls.SKIP)\n+  public void setQueryWeightMap(Map<String, Double> queryWeightMap) {\n+    _queryWeightMap = queryWeightMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNoDictionaryOnHeapDictionaryJointRuleParams(\n+      NoDictionaryOnHeapDictionaryJointRuleParams noDictionaryOnHeapDictionaryJointRuleParams) {\n+    _noDictionaryOnHeapDictionaryJointRuleParams = noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setLatencySLA(int latencySLA) {\n+    _latencySLA = latencySLA;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQps(long qps) {\n+    _qps = qps;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setBloomFilterRuleParams(BloomFilterRuleParams bloomFilterRuleParams) {\n+    _bloomFilterRuleParams = bloomFilterRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setPartitionRuleParams(PartitionRuleParams partitionRuleParams) {\n+    _partitionRuleParams = partitionRuleParams;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setTableType(String tableType) {\n+    _tableType = tableType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumMessagesPerSec(long numMessagesPerSec) {\n+    _numMessagesPerSec = numMessagesPerSec;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setNumRecordsPerPush(long numRecordsPerPush) {\n+    _numRecordsPerPush = numRecordsPerPush;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setRulesToExecute(RulesToExecute rulesToExecute) {\n+    _rulesToExecute = rulesToExecute;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setSchema(JsonNode jsonNode)\n+      throws IOException {\n+    ObjectReader reader = new ObjectMapper().readerFor(Schema.class);\n+    this._schema=reader.readValue(jsonNode);\n+    reader = new ObjectMapper().readerFor(SchemaWithMetaData.class);\n+    this._schemaWithMetaData=reader.readValue(jsonNode);\n+    _schemaWithMetaData.getDimensionFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getMetricFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _schemaWithMetaData.getDateTimeFieldSpecs()\n+        .forEach(columnMetaData -> {_metaDataMap.put(columnMetaData.getName(),columnMetaData);});\n+    _metaDataMap.put(_schemaWithMetaData.getTimeFieldSpec().getName(), _schemaWithMetaData.getTimeFieldSpec());\n+  }\n+\n+  @JsonIgnore\n+  public void setMetaDataMap(Map<String, ColumnMetaData> metaDataMap) {\n+    _metaDataMap = metaDataMap;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setQueryType(String queryType) {\n+    _queryType = queryType;\n+  }\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setInvertedSortedIndexJointRuleParams(\n+      InvertedSortedIndexJointRuleParams invertedSortedIndexJointRuleParams) {\n+    _invertedSortedIndexJointRuleParams = invertedSortedIndexJointRuleParams;\n+  }\n+\n+\n+  @JsonSetter(nulls = Nulls.SKIP)\n+  public void setOverWrittenConfigs(ConfigManager overWrittenConfigs) {\n+    _overWrittenConfigs = overWrittenConfigs;\n+  }\n+\n+\n+  public FlagQueryRuleParams getFlagQueryRuleParams() {\n+    return _flagQueryRuleParams;\n+  }\n+\n+\n+  public FieldSpec.DataType getFieldType(String colName){\n+    return _colnameFieldTypeMap.getOrDefault(colName, null);\n+  }\n+\n+  public Map<String, Integer> getColNameToIntMap() {\n+    return _colNameToIntMap;\n+  }\n+\n+  /**\n+   * Get the number of dimensions we can apply indices on.\n+   * @return total number of dimensions minus number of dimensions with overwritten indices\n+   */\n+  public int getNumDimsInvertedSortedApplicable() {\n+    return _dimNamesInveredSortedIndexApplicable.size();\n+  }\n+\n+  public NoDictionaryOnHeapDictionaryJointRuleParams getNoDictionaryOnHeapDictionaryJointRuleParams() {\n+    return _noDictionaryOnHeapDictionaryJointRuleParams;\n+  }\n+\n+  public int getNumDims() {\n+    return _dimNames.size();\n+  }\n+\n+  public int getNumCols() {\n+    return _colNameToIntMap.size();\n+  }\n+\n+  //TODO: Currently Pinot is using only ONE time column specified by TimeFieldSpec\n+  //TODO: Change the implementation after the new schema with multiple _dateTimeNames is in use\n+  public String getTimeCol() {\n+    return _schema.getTimeFieldSpec().getName();\n+  }\n+\n+  public Set<String> getColNamesNoDictionary() {\n+    return _overWrittenConfigs.getIndexConfig().getNoDictionaryColumns();\n+  }\n+\n+  public long getLatencySLA() {\n+    return _latencySLA;\n+  }\n+\n+  public long getQps() {\n+    return _qps;\n+  }\n+\n+  public BloomFilterRuleParams getBloomFilterRuleParams() {\n+    return _bloomFilterRuleParams;\n+  }\n+\n+  public PartitionRuleParams getPartitionRuleParams() {\n+    return _partitionRuleParams;\n+  }\n+\n+  public String getTableType() {\n+    return _tableType;\n+  }\n+\n+  public Map<String, Double> getQueryWeightMap() {\n+    return _queryWeightMap;\n+  }\n+\n+  public long getNumMessagesPerSec() {\n+    return _numMessagesPerSec;\n+  }\n+\n+  public long getNumRecordsPerPush() {\n+    return _numRecordsPerPush;\n+  }\n+\n+  public RulesToExecute getRulesToExecute() {\n+    return _rulesToExecute;\n+  }\n+\n+  public Schema getSchema() {\n+    return _schema;\n+  }\n+\n+  @JsonIgnore\n+  public Map<String, ColumnMetaData> getMetaDataMap() {\n+    return _metaDataMap;\n+  }\n+\n+  public String getQueryType() {\n+    return _queryType;\n+  }\n+\n+  public InvertedSortedIndexJointRuleParams getInvertedSortedIndexJointRuleParams() {\n+    return _invertedSortedIndexJointRuleParams;\n+  }\n+\n+  public ConfigManager getOverWrittenConfigs() {\n+    return _overWrittenConfigs;\n+  }\n+\n+  public long getSizePerRecord() {\n+    return _sizePerRecord;\n+  }\n+\n+  public double getCardinality(String columnName) {\n+    return max(_metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getCardinality(), MIN_CARDINALITY);\n+  }\n+\n+  public double getNumValuesPerEntry(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getNumValuesPerEntry();\n+  }\n+\n+  public int getAverageDataLen(String columnName) {\n+    return _metaDataMap.getOrDefault(columnName, new ColumnMetaData()).getAverageLength();\n+  }\n+\n+  public int getNumKafkaPartitions() {\n+    return _numKafkaPartitions;\n+  }\n+\n+  public boolean isIndexableDim(String colName) {\n+    return _dimNamesInveredSortedIndexApplicable.contains(colName);\n+  }\n+\n+  public boolean isSingleValueColumn(String colName){\n+    ColumnMetaData columnMetaData = _metaDataMap.getOrDefault(colName, new ColumnMetaData());\n+    return columnMetaData.isSingleValueField() && (columnMetaData.getNumValuesPerEntry() < DEFAULT_AVERAGE_NUM_VALUES_PER_ENTRY + EPSILON);\n+  }\n+\n+  /**\n+   * Map a index-applicable dimension name to an 0<=integer<getNumDimsInvertedSortedApplicable,\n+   * to be used with {@link FixedLenBitset}\n+   * @param colName a dimension with no overwritten index\n+   * @return a unique integer id\n+   */\n+  public int colNameToInt(String colName) {\n+    return _colNameToIntMap.getOrDefault(colName, NO_SUCH_COL);\n+  }\n+\n+  /**\n+   * A reverse process of colNameToInt\n+   * @param colID a unique integer id\n+   * @return column name\n+   */\n+  public String intToColName(int colID) {\n+    return _intToColNameMap[colID];\n+  }\n+\n+  /**\n+   * Test if colName is a valid dimension name\n+   */\n+  public boolean isDim(String colName) {\n+    return _dimNames.contains(colName);\n+  }\n+\n+  public boolean isDateTime(String colName) {\n+    return _schema.getTimeFieldSpec().getName().equals(colName);\n+  }\n+\n+  public void registerColnameFieldType() { // create a map from colname to data type\n+    for (DimensionFieldSpec dimensionFieldSpec : _schema.getDimensionFieldSpecs()) {\n+      _colnameFieldTypeMap.put(dimensionFieldSpec.getName(), dimensionFieldSpec.getDataType());\n+    }\n+    for (MetricFieldSpec metricFieldSpec : _schema.getMetricFieldSpecs()) {\n+      _colnameFieldTypeMap.put(metricFieldSpec.getName(), metricFieldSpec.getDataType());\n+    }\n+    //TODO: add support for multiple getDateTimeFieldSpecs\n+    _colnameFieldTypeMap.put(_schema.getTimeFieldSpec().getName(), _schema.getTimeFieldSpec().getDataType());\n+  }\n+\n+  public void estimateSizePerRecord() {\n+    for (String colName : _colnameFieldTypeMap.keySet()) {\n+      _sizePerRecord += getColDataSizeWithDictionary(colName);\n+      LOGGER.debug(\"{} {}\",colName, getColDataSizeWithDictionary(colName));\n+    }\n+    LOGGER.info(\"*Estimated size per record {} bytes\", _sizePerRecord);\n+  }\n+\n+  public long getColDataSizeWithoutDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else {\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType);\n+      }\n+    }\n+  }\n+\n+  public long getColDataSizeWithDictionary(String colName) {\n+    //TODO: implement this after the complex is supported\n+    FieldSpec.DataType dataType = getFieldType(colName);\n+    int numValuesPerEntry = (int) Math.ceil(getNumValuesPerEntry(colName));\n+    LOGGER.trace(\"{} {}\", colName, numValuesPerEntry);\n+    if (dataType == FieldSpec.DataType.STRUCT || dataType == FieldSpec.DataType.MAP\n+        || dataType == FieldSpec.DataType.LIST) {\n+      return 0;\n+    } else if (!_overWrittenConfigs.getIndexConfig().getNoDictionaryColumns().contains(colName)) { // has dictionary\n+      return getBitCompressedDataSize(colName) * numValuesPerEntry;\n+    } else { // no dictionary\n+      if (dataType == FieldSpec.DataType.BYTES || dataType == FieldSpec.DataType.STRING) {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry * getAverageDataLen(colName);\n+      } else {\n+        return _dataTypeSizeMap.get(dataType) * numValuesPerEntry;\n+      }\n+    }\n+  }\n+\n+  public int getBitCompressedDataSize(String colName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NTkzNw=="}, "originalCommit": {"oid": "c3c722c824480ab95851c0df2cef36adb7f29e65"}, "originalPosition": 430}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4234, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}