{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNjEwNTI0", "number": 5440, "title": "Add GenericTransformFunction wrapper for simple ScalarFunctions", "bodyText": "Today, adding new TransformFunction is quite involved. Supporting simple static java functions requires one to write a lot of boiler plate code. This PR adds a generic Transform Function that can invoke any of the registered functions in FunctionRegistry.\nThis PR tests this new feature with StringFunctions.", "createdAt": "2020-05-25T08:12:52Z", "url": "https://github.com/apache/pinot/pull/5440", "merged": true, "mergeCommit": {"oid": "f7417ff088365fee7bf956dfa0a5229f7e07d07c"}, "closed": true, "closedAt": "2020-06-03T23:54:49Z", "author": {"login": "KKcorps"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABckrwwsAFqTQxNzU0MjQxMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnd5D1AFqTQyMzEzMzM2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NTQyNDEw", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-417542410", "createdAt": "2020-05-25T08:21:52Z", "commit": {"oid": "88f5e959de8eb0b227bd94df755489241c248c46"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyMTo1MlrOGZ47Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyMzoxNFrOGZ4-AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMDI2Mw==", "bodyText": "missing float", "url": "https://github.com/apache/pinot/pull/5440#discussion_r429800263", "createdAt": "2020-05-25T08:21:52Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _info = info;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f5e959de8eb0b227bd94df755489241c248c46"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMDk2MQ==", "bodyText": "you can add another switch statement in init to set this based on the return type of the scalarfunction, see functionInvoker.getReturnType", "url": "https://github.com/apache/pinot/pull/5440#discussion_r429800961", "createdAt": "2020-05-25T08:23:14Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _info = info;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _args[i] = Integer.parseInt(literal);\n+            break;\n+          case \"java.lang.String\":\n+            _args[i] = literal;\n+            break;\n+          case \"java.lang.Double\":\n+            _args[i] = Double.valueOf(literal);\n+            break;\n+          case \"java.lang.Long\":\n+            _args[i] = Long.valueOf(literal);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      } else {\n+        _nonLiteralArgIndices.add(i);\n+        _nonLiteralTransformFunction.add(function);\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.INT);\n+            break;\n+          case \"java.lang.String\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.STRING);\n+            break;\n+          case \"java.lang.Double\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.DOUBLE);\n+            break;\n+          case \"java.lang.Long\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.LONG);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return STRING_SV_NO_DICTIONARY_METADATA;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f5e959de8eb0b227bd94df755489241c248c46"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3ODc5MjM1", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-417879235", "createdAt": "2020-05-25T21:22:36Z", "commit": {"oid": "88f5e959de8eb0b227bd94df755489241c248c46"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMToyMjozNlrOGaJ2BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMToyMjozNlrOGaJ2BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NzQ0NA==", "bodyText": "I am not sure I follow the logic here. Is GenericTransformFunction going to be the wrapper or single point of entry for all transform functions in Pinot. The name seems to suggest so but this code implies that only the functions registered in the registry can be treated as GenericTransformFunction.\nThis also brings the point that we should add good javadocs to the new class.", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430077444", "createdAt": "2020-05-25T21:22:36Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/TransformFunctionFactory.java", "diffHunk": "@@ -112,13 +115,24 @@ public static TransformFunction get(TransformExpressionTree expression, Map<Stri\n     switch (expression.getExpressionType()) {\n       case FUNCTION:\n         String functionName = expression.getValue();\n-        Class<? extends TransformFunction> transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        Class<? extends TransformFunction> transformFunctionClass;\n+        FunctionInfo functionInfo = null;\n+        if (FunctionRegistry.containsFunctionByName(functionName)) {\n+          transformFunctionClass = GenericTransformFunction.class;\n+          functionInfo = FunctionRegistry.getFunctionByName(functionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f5e959de8eb0b227bd94df755489241c248c46"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3ODgwNTA0", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-417880504", "createdAt": "2020-05-25T21:25:39Z", "commit": {"oid": "88f5e959de8eb0b227bd94df755489241c248c46"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMToyNTozOVrOGaJ4iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMToyNTozOVrOGaJ4iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3ODA4OQ==", "bodyText": "I believe this exercises the compilation path. You should add tests in CalciteSqlCompiler test file as well.\nAlso, we should add tests for end to end query execution. See TransformQueriesTest class or consider adding execution tests to one of the existing query tests", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430078089", "createdAt": "2020-05-25T21:25:39Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunctionTest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class GenericTransformFunctionTest extends BaseTransformFunctionTest {\n+\n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f5e959de8eb0b227bd94df755489241c248c46"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTY4OTM0", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-418568934", "createdAt": "2020-05-26T18:31:51Z", "commit": {"oid": "c67f6d3a9b6c9bd80138fe9415505d897a8db977"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODozMTo1MVrOGarG1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODo0MDo1NlrOGarbfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyMjQyMA==", "bodyText": "should we move this to constructor @mayankshriv @Jackie-Jiang", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430622420", "createdAt": "2020-05-26T18:31:51Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c67f6d3a9b6c9bd80138fe9415505d897a8db977"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyMzAxOQ==", "bodyText": "better to do this in init and save the metadata, Pinot might call this function multiple times", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430623019", "createdAt": "2020-05-26T18:32:54Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _info = info;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _args[i] = Integer.parseInt(literal);\n+            break;\n+          case \"java.lang.String\":\n+            _args[i] = literal;\n+            break;\n+          case \"java.lang.Double\":\n+            _args[i] = Double.valueOf(literal);\n+            break;\n+          case \"java.lang.Float\":\n+            _args[i] = Float.valueOf(literal);\n+            break;\n+          case \"java.lang.Long\":\n+            _args[i] = Long.valueOf(literal);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      } else {\n+        _nonLiteralArgIndices.add(i);\n+        _nonLiteralTransformFunction.add(function);\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.INT);\n+            break;\n+          case \"java.lang.String\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.STRING);\n+            break;\n+          case \"java.lang.Double\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.DOUBLE);\n+            break;\n+          case \"java.lang.Float\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.FLOAT);\n+            break;\n+          case \"java.lang.Long\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.LONG);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    Class returnType = _functionInvoker.getReturnType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c67f6d3a9b6c9bd80138fe9415505d897a8db977"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyNjQyMg==", "bodyText": "it's better to duplicate this for every type event though this code looks better for readability.\nthe switch case on every invocation will hurt perf", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430626422", "createdAt": "2020-05-26T18:38:46Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _info = info;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _args[i] = Integer.parseInt(literal);\n+            break;\n+          case \"java.lang.String\":\n+            _args[i] = literal;\n+            break;\n+          case \"java.lang.Double\":\n+            _args[i] = Double.valueOf(literal);\n+            break;\n+          case \"java.lang.Float\":\n+            _args[i] = Float.valueOf(literal);\n+            break;\n+          case \"java.lang.Long\":\n+            _args[i] = Long.valueOf(literal);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      } else {\n+        _nonLiteralArgIndices.add(i);\n+        _nonLiteralTransformFunction.add(function);\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.INT);\n+            break;\n+          case \"java.lang.String\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.STRING);\n+            break;\n+          case \"java.lang.Double\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.DOUBLE);\n+            break;\n+          case \"java.lang.Float\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.FLOAT);\n+            break;\n+          case \"java.lang.Long\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.LONG);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    Class returnType = _functionInvoker.getReturnType();\n+    switch(returnType.getTypeName()) {\n+      case \"java.lang.Integer\": return INT_SV_NO_DICTIONARY_METADATA;\n+      case \"java.lang.Long\": return LONG_SV_NO_DICTIONARY_METADATA;\n+      case \"java.lang.Float\": return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+      case \"java.lang.Double\": return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+      case \"java.lang.String\": return STRING_SV_NO_DICTIONARY_METADATA;\n+      default:\n+        throw new RuntimeException(\"Unsupported data type \" + returnType.getTypeName() + \"for transform function \" + getName());\n+    }\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    if (_integerResult == null) {\n+      _integerResult = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _integerResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public long[] transformToLongValuesSV(ProjectionBlock projectionBlock) {\n+    if (_longResult == null) {\n+      _longResult = new long[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _longResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public float[] transformToFloatValuesSV(ProjectionBlock projectionBlock) {\n+    if (_floatResult == null) {\n+      _floatResult = new float[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _floatResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_doubleResult == null) {\n+      _doubleResult = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _doubleResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_stringResult == null) {\n+      _stringResult = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _stringResult;\n+  }\n+\n+  private void transformValues(ProjectionBlock projectionBlock) {\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+\n+      Class returnType = _functionInvoker.getReturnType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c67f6d3a9b6c9bd80138fe9415505d897a8db977"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyNzcwOQ==", "bodyText": "its a wrapper for all functions in FunctionRegistry. what name do you suggest - ScalarTransformFunctionWrapper", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430627709", "createdAt": "2020-05-26T18:40:56Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/TransformFunctionFactory.java", "diffHunk": "@@ -112,13 +115,24 @@ public static TransformFunction get(TransformExpressionTree expression, Map<Stri\n     switch (expression.getExpressionType()) {\n       case FUNCTION:\n         String functionName = expression.getValue();\n-        Class<? extends TransformFunction> transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        Class<? extends TransformFunction> transformFunctionClass;\n+        FunctionInfo functionInfo = null;\n+        if (FunctionRegistry.containsFunctionByName(functionName)) {\n+          transformFunctionClass = GenericTransformFunction.class;\n+          functionInfo = FunctionRegistry.getFunctionByName(functionName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NzQ0NA=="}, "originalCommit": {"oid": "88f5e959de8eb0b227bd94df755489241c248c46"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTIyNjE3", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-420522617", "createdAt": "2020-05-28T21:59:07Z", "commit": {"oid": "4fa6827b6f9b3a950596ef50c305a52f86139eee"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo1OTowN1rOGcINHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjowMDozOFrOGcIPyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0Nzc0MQ==", "bodyText": "move version to pom.properties in root pom.xml", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432147741", "createdAt": "2020-05-28T21:59:07Z", "author": {"login": "kishoreg"}, "path": "pinot-common/pom.xml", "diffHunk": "@@ -248,6 +248,11 @@\n       <groupId>org.glassfish.jersey.core</groupId>\n       <artifactId>jersey-server</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.reflections</groupId>\n+      <artifactId>reflections</artifactId>\n+      <version>0.9.11</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fa6827b6f9b3a950596ef50c305a52f86139eee"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODEyNQ==", "bodyText": "java doc", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432148125", "createdAt": "2020-05-28T21:59:57Z", "author": {"login": "kishoreg"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/StringFunctions.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.regex.Pattern;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+\n+\n+/**\n+ *\n+ */\n+public class StringFunctions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fa6827b6f9b3a950596ef50c305a52f86139eee"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODQyNw==", "bodyText": "add the ability to set name, add javadocs", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432148427", "createdAt": "2020-05-28T22:00:38Z", "author": {"login": "kishoreg"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/annotations/ScalarFunction.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface ScalarFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fa6827b6f9b3a950596ef50c305a52f86139eee"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1aee329f7f06bc84906a25c2bf6a6c1226e22fc4", "author": {"user": {"login": "kishoreg", "name": "Kishore Gopalakrishna"}}, "url": "https://github.com/apache/pinot/commit/1aee329f7f06bc84906a25c2bf6a6c1226e22fc4", "committedDate": "2020-05-29T22:33:51Z", "message": "Adding support to invoke any scalar function via GenericTransformFunction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05f5c69bcf3a7710850d01c3b9e25d26b3d53fe1", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/05f5c69bcf3a7710850d01c3b9e25d26b3d53fe1", "committedDate": "2020-05-29T22:33:51Z", "message": "string functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85d2753145efbaa5eecda4b181800e8ab016587f", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/85d2753145efbaa5eecda4b181800e8ab016587f", "committedDate": "2020-05-29T22:34:36Z", "message": "adding string functions along with tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58a16cadabdd59f6f7678e01fb9dd37a39ed75ae", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/58a16cadabdd59f6f7678e01fb9dd37a39ed75ae", "committedDate": "2020-05-29T22:34:36Z", "message": "adding support for multiple types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46006307aeb3a3bcd663d343d0db56d19d0310f5", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/46006307aeb3a3bcd663d343d0db56d19d0310f5", "committedDate": "2020-05-29T22:34:36Z", "message": "refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf2fa38e8684fbb185256a3394abf0d097e84ede", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/bf2fa38e8684fbb185256a3394abf0d097e84ede", "committedDate": "2020-05-29T22:35:23Z", "message": "adding scalar function annotation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20a099ced08be67ef64315d90e02a0d8c4278694", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/20a099ced08be67ef64315d90e02a0d8c4278694", "committedDate": "2020-05-29T22:36:10Z", "message": "refactoring and adding javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/90f3854192715ca58cb8eafd88e34ef538644731", "committedDate": "2020-05-29T22:36:10Z", "message": "adding pom property"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3eee657cdad8372d0cc0986089891d7cae3c1460", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/3eee657cdad8372d0cc0986089891d7cae3c1460", "committedDate": "2020-05-29T22:20:34Z", "message": "adding pom property"}, "afterCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/90f3854192715ca58cb8eafd88e34ef538644731", "committedDate": "2020-05-29T22:36:10Z", "message": "adding pom property"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzQ4ODkx", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-421348891", "createdAt": "2020-05-29T23:34:52Z", "commit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMzozNDo1MlrOGcu8MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMDoxNzozOFrOGcvYRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MjM4NA==", "bodyText": "Move the version info into the root pom file", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432782384", "createdAt": "2020-05-29T23:34:52Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/pom.xml", "diffHunk": "@@ -33,6 +33,7 @@\n   <url>https://pinot.apache.org/</url>\n   <properties>\n     <pinot.root>${basedir}/..</pinot.root>\n+    <reflections.version>0.9.11</reflections.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTA2OQ==", "bodyText": "(nit) Suggest putting name in front of method", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432785069", "createdAt": "2020-05-29T23:49:02Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/FunctionRegistry.java", "diffHunk": "@@ -53,8 +61,12 @@ public static FunctionInfo getFunctionByNameWithApplicableArgumentTypes(String f\n   }\n \n   public static void registerFunction(Method method) {\n+    registerFunction(method, method.getName().toLowerCase());\n+  }\n+\n+  public static void registerFunction(Method method, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4Nzg0MQ==", "bodyText": "For readability, can we always order them as INT, LONG, FLOAT, DOUBLE, STRING? Same for other places", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432787841", "createdAt": "2020-05-30T00:05:25Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODAxNg==", "bodyText": "Suggest directly comparing class instead of String comparison for both performance and readability:\nif (paramType == Integer.class) {\n  ...\n} else if (paramType == Long.class) {\n ...", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432788016", "createdAt": "2020-05-30T00:06:32Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODE4Ng==", "bodyText": "(nit) Use a local variable int numArguments = arguments.size()", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432788186", "createdAt": "2020-05-30T00:07:50Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODc4Mg==", "bodyText": "Why using different way to box the values?\nI would suggest changing all types to be the same as FLOAT. From the past experience, seems the streaming fashion has worse performance.", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432788782", "createdAt": "2020-05-30T00:12:00Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _args[i] = Integer.parseInt(literal);\n+            break;\n+          case \"java.lang.String\":\n+            _args[i] = literal;\n+            break;\n+          case \"java.lang.Double\":\n+            _args[i] = Double.valueOf(literal);\n+            break;\n+          case \"java.lang.Float\":\n+            _args[i] = Float.valueOf(literal);\n+            break;\n+          case \"java.lang.Long\":\n+            _args[i] = Long.valueOf(literal);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      } else {\n+        _nonLiteralArgIndices.add(i);\n+        _nonLiteralTransformFunction.add(function);\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.INT);\n+            break;\n+          case \"java.lang.String\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.STRING);\n+            break;\n+          case \"java.lang.Double\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.DOUBLE);\n+            break;\n+          case \"java.lang.Float\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.FLOAT);\n+            break;\n+          case \"java.lang.Long\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.LONG);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      }\n+    }\n+\n+    Class returnType = _functionInvoker.getReturnType();\n+    switch(returnType.getTypeName()) {\n+      case \"java.lang.Integer\":\n+        _transformResultMetadata =  INT_SV_NO_DICTIONARY_METADATA;\n+        break;\n+      case \"java.lang.Long\":\n+        _transformResultMetadata =  LONG_SV_NO_DICTIONARY_METADATA;\n+        break;\n+      case \"java.lang.Float\":\n+      case \"java.lang.Double\":\n+        _transformResultMetadata =  DOUBLE_SV_NO_DICTIONARY_METADATA;\n+        break;\n+      case \"java.lang.Boolean\":\n+      case \"java.lang.String\":\n+        _transformResultMetadata =  STRING_SV_NO_DICTIONARY_METADATA;\n+        break;\n+      default:\n+        throw new RuntimeException(\"Unsupported data type \" + returnType.getTypeName() + \"for transform function \" + getName());\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _transformResultMetadata;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    if (_integerResult == null) {\n+      _integerResult = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _integerResult[i] = (Integer) _functionInvoker.process(_args);\n+    }\n+    return _integerResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public long[] transformToLongValuesSV(ProjectionBlock projectionBlock) {\n+    if (_longResult == null) {\n+      _longResult = new long[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _longResult[i] = (Long) _functionInvoker.process(_args);\n+    }\n+    return _longResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public float[] transformToFloatValuesSV(ProjectionBlock projectionBlock) {\n+    if (_floatResult == null) {\n+      _floatResult = new float[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _floatResult[i] = (Float) _functionInvoker.process(_args);\n+    }\n+    return _floatResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_doubleResult == null) {\n+      _doubleResult = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _doubleResult[i] = (Double) _functionInvoker.process(_args);\n+    }\n+    return _doubleResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_stringResult == null) {\n+      _stringResult = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _stringResult[i] = (String) _functionInvoker.process(_args);\n+    }\n+\n+    return _stringResult;\n+  }\n+\n+  private void transformNonLiteralArgsToValues(ProjectionBlock projectionBlock, int numNonLiteralArgs,\n+      Object[][] nonLiteralBlockValues) {\n+    for (int i = 0; i < numNonLiteralArgs; i++) {\n+      TransformFunction transformFunc = _nonLiteralTransformFunction.get(i);\n+      FieldSpec.DataType returnType = _nonLiteralArgType.get(i);\n+      switch (returnType) {\n+        case STRING:\n+          nonLiteralBlockValues[i] = transformFunc.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          int[] values = transformFunc.transformToIntValuesSV(projectionBlock);\n+          nonLiteralBlockValues[i] = Arrays.stream(values).boxed().toArray(Integer[]::new);\n+          break;\n+        case DOUBLE:\n+          double[] doubleValues = transformFunc.transformToDoubleValuesSV(projectionBlock);\n+          nonLiteralBlockValues[i] = Arrays.stream(doubleValues).boxed().toArray(Double[]::new);\n+          break;\n+        case FLOAT:\n+          float[] floatValues = transformFunc.transformToFloatValuesSV(projectionBlock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTEyNA==", "bodyText": "Don't catch all Exceptions because it will also catch the BadQueryRequestException. We treat BadQueryRequestException differently on the caller side", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789124", "createdAt": "2020-05-30T00:14:22Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/TransformFunctionFactory.java", "diffHunk": "@@ -112,13 +115,24 @@ public static TransformFunction get(TransformExpressionTree expression, Map<Stri\n     switch (expression.getExpressionType()) {\n       case FUNCTION:\n         String functionName = expression.getValue();\n-        Class<? extends TransformFunction> transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        Class<? extends TransformFunction> transformFunctionClass;\n+        FunctionInfo functionInfo = null;\n+        if (FunctionRegistry.containsFunctionByName(functionName)) {\n+          transformFunctionClass = ScalarTransformFunctionWrapper.class;\n+          functionInfo = FunctionRegistry.getFunctionByName(functionName);\n+        } else {\n+          transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        }\n+\n         if (transformFunctionClass == null) {\n           throw new BadQueryRequestException(\"Unsupported transform function: \" + functionName);\n         }\n         try {\n           transformFunction = transformFunctionClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n+          if (functionInfo != null) {\n+            ((ScalarTransformFunctionWrapper) transformFunction).setFunction(functionName, functionInfo);\n+          }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTM2Mw==", "bodyText": "Suggest using a constructor with functionName and functionInfo instead of using newInstance()", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789363", "createdAt": "2020-05-30T00:15:55Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/TransformFunctionFactory.java", "diffHunk": "@@ -112,13 +115,24 @@ public static TransformFunction get(TransformExpressionTree expression, Map<Stri\n     switch (expression.getExpressionType()) {\n       case FUNCTION:\n         String functionName = expression.getValue();\n-        Class<? extends TransformFunction> transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        Class<? extends TransformFunction> transformFunctionClass;\n+        FunctionInfo functionInfo = null;\n+        if (FunctionRegistry.containsFunctionByName(functionName)) {\n+          transformFunctionClass = ScalarTransformFunctionWrapper.class;\n+          functionInfo = FunctionRegistry.getFunctionByName(functionName);\n+        } else {\n+          transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        }\n+\n         if (transformFunctionClass == null) {\n           throw new BadQueryRequestException(\"Unsupported transform function: \" + functionName);\n         }\n         try {\n           transformFunction = transformFunctionClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n+          if (functionInfo != null) {\n+            ((ScalarTransformFunctionWrapper) transformFunction).setFunction(functionName, functionInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTQzOQ==", "bodyText": "Add private or private final for these member variables", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789439", "createdAt": "2020-05-30T00:16:32Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTUxNg==", "bodyText": "Suggest merging this into the constructor", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789516", "createdAt": "2020-05-30T00:17:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTU3NQ==", "bodyText": "Rename it to ScalarTransformFunction?", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789575", "createdAt": "2020-05-30T00:17:38Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f3854192715ca58cb8eafd88e34ef538644731"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0404e96fc85664d1e5ccb11235a1a9de1d8919e3", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/0404e96fc85664d1e5ccb11235a1a9de1d8919e3", "committedDate": "2020-06-01T19:43:52Z", "message": "moving pom version to root and refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a21b5429e935a52b018235515326cbde6966c33", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/9a21b5429e935a52b018235515326cbde6966c33", "committedDate": "2020-06-01T20:08:58Z", "message": "fixing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1161253d3e14a4bd0090344f6216975e54d20c8", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/d1161253d3e14a4bd0090344f6216975e54d20c8", "committedDate": "2020-06-01T20:43:36Z", "message": "refactoring: adding constructor to wrapper class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4edaed45b539286d597eba86ca21e808c8e28a86", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/4edaed45b539286d597eba86ca21e808c8e28a86", "committedDate": "2020-06-02T08:43:37Z", "message": "moving dependency out of module"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDkxMTUz", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-423091153", "createdAt": "2020-06-02T22:07:54Z", "commit": {"oid": "4edaed45b539286d597eba86ca21e808c8e28a86"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDk0NTk2", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-423094596", "createdAt": "2020-06-02T22:15:26Z", "commit": {"oid": "4edaed45b539286d597eba86ca21e808c8e28a86"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTMzMzY0", "url": "https://github.com/apache/pinot/pull/5440#pullrequestreview-423133364", "createdAt": "2020-06-02T23:58:42Z", "commit": {"oid": "4edaed45b539286d597eba86ca21e808c8e28a86"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 825, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}