{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2ODQ0NTg1", "number": 5593, "title": "[TE] frontend - harleyjj/alerts - refactor Alerts route for backend p\u2026", "bodyText": "\u2026agination and filtering\nDescription\n\nConverts Alerts Route Frontend Pagination of Alerts to Backend Pagination\nUses Autocomplete Endpoints for Getting Values to Filter Alerts By", "createdAt": "2020-06-19T01:55:23Z", "url": "https://github.com/apache/pinot/pull/5593", "merged": true, "mergeCommit": {"oid": "5366bc2d15e245f121eb2e8d283ab761baeff200"}, "closed": true, "closedAt": "2020-06-25T17:40:35Z", "author": {"login": "harleyjj"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcs4YbdgFqTQzNDI5Nzc5OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuyNJsgFqTQzNzcxNDQyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0Mjk3Nzk4", "url": "https://github.com/apache/pinot/pull/5593#pullrequestreview-434297798", "createdAt": "2020-06-19T19:25:41Z", "commit": {"oid": "ec40bb1ebaa53283e0fe9466f81ed22fe8f0f6bb"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxOToyNTo0MVrOGmfJ3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxOTozNzo0M1rOGmfaQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAwOTUwMw==", "bodyText": "It seems the request URL for when there are multiple values is incorrect. it should be /alerts?limit=10&offset=0&application=app1&application=app2 not /alerts?limit=10&offset=0&application=app1%2Capp2. Otherwise, it won't get the right result. Could you double check?", "url": "https://github.com/apache/pinot/pull/5593#discussion_r443009503", "createdAt": "2020-06-19T19:25:41Z", "author": {"login": "jihaozh"}, "path": "thirdeye/thirdeye-frontend/app/utils/api/self-serve.js", "diffHunk": "@@ -142,20 +102,93 @@ const createNewDataset = '/onboard/create';\n  */\n const setAlertActivationUrl = (detectionId, active) => `/yaml/activation/${detectionId}?active=${active}`;\n \n+/**\n+ * GET autocomplete request for alert by name\n+ * @param {String} functionName: alert name\n+ * @see {@link https://tinyurl.com/ybelagey|class DataResource}\n+ */\n+const alertByName = functionName => `/data/autocomplete/detection?name=${encodeURIComponent(functionName)}`;\n+\n+/**\n+ * GET autocomplete request for application\n+ * @param {String} app: application name\n+ */\n+const application = app => `/data/autocomplete/application?name=${encodeURIComponent(app)}`;\n+\n+/**\n+ * GET autocomplete request for dataset\n+ * @param {String} type: dataset name\n+ */\n+const dataset = name => `/data/autocomplete/dataset?name=${encodeURIComponent(name)}`;\n+\n+/**\n+ * GET autocomplete request for detection type\n+ * @param {String} type: detection type\n+ */\n+const detectionType = type => `/data/autocomplete/ruleType?name=${encodeURIComponent(type)}`;\n+\n+/**\n+ * GET autocomplete request for metric data by name\n+ * @param {String} metricName: metric name\n+ * @see {@link https://tinyurl.com/y7hhzm33|class DataResource}\n+ */\n+const metric = metricName => `/data/autocomplete/metric?name=${encodeURIComponent(metricName)}`;\n+\n+/**\n+ * GET autocomplete request for alerty owner\n+ * @param {String} name: owner name\n+ */\n+const owner = name => `/data/autocomplete/detection-createdby?name=${encodeURIComponent(name)}`;\n+\n+/**\n+ * GET autocomplete request for subscription group by name\n+ * @param {String} name: group name\n+ */\n+const subscriptionGroup = name => `/data/autocomplete/subscription?name=${encodeURIComponent(name)}`;\n+\n+/**\n+ * GET alerts, filtered and paginated according to params\n+ * @param {Object} params: params to query alerts by\n+ */\n+const getPaginatedAlertsUrl = params => {\n+  const paramKeys = Object.keys(params || {});\n+  let url = '/alerts';\n+  if (paramKeys.length === 0) {\n+    return url;\n+  }\n+  url += '?';\n+  let index = 0;\n+  paramKeys.forEach(key => {\n+    const paramString = `${key}=${encodeURIComponent(params[key])}`;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec40bb1ebaa53283e0fe9466f81ed22fe8f0f6bb"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMDQ4Mw==", "bodyText": "seems we can remove this filter in the UI because the endpoint can't perform this search?", "url": "https://github.com/apache/pinot/pull/5593#discussion_r443010483", "createdAt": "2020-06-19T19:28:18Z", "author": {"login": "jihaozh"}, "path": "thirdeye/thirdeye-frontend/app/utils/yaml-tools.js", "diffHunk": "@@ -338,12 +339,159 @@ export function postYamlProps(postData) {\n   };\n }\n \n+export function enrichAlertResponseObject(alerts, subscriptionGroups) {\n+  for (let yamlAlert of alerts) {\n+    let dimensions = '';\n+    let dimensionsArray = yamlAlert.dimensionExploration ? yamlAlert.dimensionExploration.dimensions : null;\n+    if (Array.isArray(dimensionsArray)) {\n+      dimensionsArray.forEach(dim => {\n+        dimensions = dimensions + `${dim}, `;\n+      });\n+      dimensions = dimensions.substring(0, dimensions.length-2);\n+    }\n+    Object.assign(yamlAlert, {\n+      functionName: yamlAlert.name,\n+      collection: yamlAlert.datasetNames.toString(),\n+      granularity: yamlAlert.monitoringGranularity.toString(),\n+      type: _detectionType(yamlAlert),\n+      exploreDimensions: dimensions,\n+      filters: formatYamlFilter(yamlAlert.filters),\n+      isNewPipeline: true\n+    });\n+  }\n+\n+  // Iterate through detection alerter to enhance all yaml alert with extra properties (group name, application)\n+  for (let subscriptionGroup of subscriptionGroups){\n+    const detectionConfigIds = subscriptionGroup.detectionConfigIds;\n+    for (let id of detectionConfigIds) {\n+      let foundAlert = alerts.find(yamlAlert => yamlAlert.id === id);\n+      if (foundAlert) {\n+        Object.assign(foundAlert, {\n+          application: foundAlert.application ? foundAlert.application + \", \" + subscriptionGroup.application : subscriptionGroup.application,\n+          group: foundAlert.group ? foundAlert.group + \", \" + subscriptionGroup.name : subscriptionGroup.name\n+        });\n+      }\n+    }\n+  }\n+\n+  return alerts;\n+}\n+\n+/**\n+ * Grab detection type if available, else return yamlAlert.pipelineType\n+ */\n+function _detectionType(yamlAlert) {\n+  if (yamlAlert.rules && Array.isArray(yamlAlert.rules) && yamlAlert.rules.length > 0) {\n+    if (yamlAlert.rules[0].detection && Array.isArray(yamlAlert.rules[0].detection) && yamlAlert.rules[0].detection.length > 0) {\n+      return yamlAlert.rules[0].detection[0].type;\n+    }\n+  }\n+  return yamlAlert.pipelineType;\n+}\n+\n+// Maps filter name to alert property for filtering\n+export const filterToPropertyMap = {\n+  application: 'application',\n+  subscription: 'group',\n+  owner: 'createdBy',\n+  type: 'type',\n+  metric: 'metric',\n+  dataset: 'collection',\n+  granularity: 'granularity'\n+};\n+\n+// Maps filter name to alerts API params for filtering\n+export const filterToParamsMap = {\n+  application: 'application',\n+  subscription: 'subscriptionGroup',\n+  owner: 'createdBy',\n+  type: 'ruleType',\n+  metric: 'metric',\n+  dataset: 'dataset',\n+  granularity: 'granularity',\n+  status: 'active',\n+  names: 'names'\n+};\n+\n+export function populateFiltersLocal(originalAlerts, rules) {\n+  // This filter category is \"secondary\". To add more, add an entry here and edit the controller's \"filterToPropertyMap\"\n+  const filterBlocksLocal = [\n+    {\n+      name: 'status',\n+      title: 'Status',\n+      type: 'checkbox',\n+      selected: ['Active', 'Inactive'],\n+      filterKeys: ['Active', 'Inactive']\n+    },\n+    {\n+      name: 'application',\n+      title: 'Applications',\n+      type: 'search',\n+      matchWidth: true,\n+      hasNullOption: true, // allow searches for 'none'\n+      filterKeys: []\n+    },\n+    {\n+      name: 'subscription',\n+      title: 'Subscription Groups',\n+      hasNullOption: true, // allow searches for 'none'\n+      type: 'search',\n+      filterKeys: []\n+    },\n+    {\n+      name: 'owner',\n+      title: 'Owners',\n+      type: 'search',\n+      matchWidth: true,\n+      filterKeys: []\n+    },\n+    {\n+      name: 'type',\n+      title: 'Detection Type',\n+      type: 'select',\n+      filterKeys: rules\n+    },\n+    {\n+      name: 'metric',\n+      title: 'Metrics',\n+      type: 'search',\n+      filterKeys: []\n+    },\n+    {\n+      name: 'dataset',\n+      title: 'Datasets',\n+      type: 'search',\n+      filterKeys: []\n+    },\n+    {\n+      name: 'granularity',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec40bb1ebaa53283e0fe9466f81ed22fe8f0f6bb"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMzAxNg==", "bodyText": "For searching the alerts the user is subscribed to, there is a param in the alerts endpoint called subscribedBy. The UI can get the related alerts directly by passing the user name into endpoint.", "url": "https://github.com/apache/pinot/pull/5593#discussion_r443013016", "createdAt": "2020-06-19T19:35:42Z", "author": {"login": "jihaozh"}, "path": "thirdeye/thirdeye-frontend/app/pods/manage/alerts/index/controller.js", "diffHunk": "@@ -281,146 +297,50 @@ export default Controller.extend({\n   ),\n \n   /**\n-   * We are recalculating the options of each selection field. The values come from the aggregated\n-   * properties across all filtered alerts. For example, it returns all possible values for 'application'\n-   * @method _recalculateFilterKeys\n-   * @param {Array} alertsCollection - array of alerts we are extracting values from\n-   * @param {Object} blockItem - the current search filter object\n-   * @returns {Array} - a deduped array of values to use as select options\n-   * @private\n+   * flag meaning alerts are loading for current page\n+   * @type {Boolean}\n    */\n-  _recalculateFilterKeys(alertsCollection, blockItem) {\n-    const filterToPropertyMap = get(this, 'filterToPropertyMap');\n-    // Aggregate all existing values for our target properties in the current array collection\n-    let alertPropsAsKeys = [];\n-    // Make sure subscription groups are not bundled for filter parameters\n-    if (blockItem.name === 'subscription') {\n-      alertsCollection.forEach(alert => {\n-        let groups = alert[filterToPropertyMap[blockItem.name]];\n-        if (groups) {\n-          groups.split(\", \").forEach(g => {\n-            alertPropsAsKeys.push(g);\n-          });\n-        }\n-      });\n-    } else if (blockItem.name === 'application') {\n-      // Make sure applications are not bundled for filter parameters\n-      alertsCollection.forEach(alert => {\n-        let applications = alert[filterToPropertyMap[blockItem.name]];\n-        if (applications) {\n-          applications.split(\", \").forEach(a => {\n-            alertPropsAsKeys.push(a);\n-          });\n-        }\n-      });\n-    } else {\n-      alertPropsAsKeys = alertsCollection.map(alert => alert[filterToPropertyMap[blockItem.name]]);\n+  isLoading: computed(\n+    '_getAlerts.isIdle',\n+    function() {\n+      return !get(this, '_getAnomalies.isIdle');\n     }\n-    // Add 'none' select option if allowed\n-    const canInsertNullOption = alertPropsAsKeys.includes(undefined) && blockItem.hasNullOption;\n-    if (canInsertNullOption) { alertPropsAsKeys.push('none'); }\n-    // Return a deduped array containing all of the values for this property in the current set of alerts\n-    return [ ...new Set(powerSort(alertPropsAsKeys.filter(val => isPresent(val)), null)) ];\n-  },\n+  ),\n \n   /**\n-   * This is the core filtering method which acts upon a set of initial alerts to return a subset\n-   * @method _filterAlerts\n-   * @param {Array} initialAlerts - array of all alerts to start with\n-   * @param {Object} filters - filter key/values to process\n-   * @example\n-   * {\n-   *   application: ['app name a', 'app name b'],\n-   *   status: ['active'],\n-   *   owner: ['person1@linkedin.com, person2@linkedin.com'],\n-   *   type: null\n-   * }\n-   * @returns {undefined}\n-   * @private\n+   * subscription groups which user is part of\n+   * @type {Array}\n    */\n-  _filterAlerts(initialAlerts, filters) {\n-    const filterToPropertyMap = get(this, 'filterToPropertyMap');\n-    // A click on a primary alert filter will reset 'filteredAlerts'\n-    if (filters.primary) {\n-      this._processPrimaryFilters(initialAlerts, filters.primary);\n-    }\n-    // Pick up cached alert array for the secondary filters\n-    let filteredAlerts = get(this, 'filteredAlerts');\n-    // If there is a secondary filter present, filter by it, using the keys we've set up in our filter map\n-    Object.keys(filterToPropertyMap).forEach((filterKey) => {\n-      let filterValueArray = filters[filterKey];\n-      if (filterValueArray && filterValueArray.length) {\n-        let newAlerts = filteredAlerts.filter(alert => {\n-          // See 'filterToPropertyMap' in route. For filterKey = 'owner' this would map alerts by alert['createdBy'] = x\n-          const targetAlertPropertyValue = alert[filterToPropertyMap[filterKey]];\n-          let alertMeetsCriteria = false;\n-          // In the cases for subscription and application, there can be multiple values.  We just need to match on one\n-          if (filterKey === \"subscription\") {\n-            if (targetAlertPropertyValue) {\n-              filterValueArray.forEach(val => {\n-                if (targetAlertPropertyValue.includes(val)) {\n-                  alertMeetsCriteria = true;\n-                }\n-              });\n-            }\n-          } else if (filterKey === \"application\") {\n-            if (targetAlertPropertyValue) {\n-              filterValueArray.forEach(val => {\n-                if (targetAlertPropertyValue.includes(val)) {\n-                  alertMeetsCriteria = true;\n-                }\n-              });\n-            }\n-          } else {\n-            alertMeetsCriteria = targetAlertPropertyValue && filterValueArray.includes(targetAlertPropertyValue);\n-          }\n-          const isMatchForNone = !alert.hasOwnProperty(filterToPropertyMap[filterKey]) && filterValueArray.includes('none');\n-          return alertMeetsCriteria || isMatchForNone;\n-        });\n-        filteredAlerts = newAlerts;\n-      }\n-    });\n-\n-    // If status filter is present, we re-build the results array to contain only active alerts, inactive alerts, or both.\n-    if (filters.status) {\n-      const concatStatus = filters.status.length ? filters.status.join().toLowerCase() : 'active';\n-      const requireAll = filters.status.includes('Active') && filters.status.includes('Inactive');\n-      const alertsByState = {\n-        active: filteredAlerts.filter(alert => alert.active),\n-        inactive: filteredAlerts.filter(alert => !alert.active)\n-      };\n-      filteredAlerts = requireAll ? [ ...alertsByState.active, ...alertsByState.inactive ] : alertsByState[concatStatus];\n+  mySubscriptionGroups: computed(\n+    'subscriptionGroupConfig',\n+    'user',\n+    function() {\n+      const {\n+        user,\n+        subscriptionGroupConfig\n+      } = this.getProperties('user', 'subscriptionGroupConfig');\n+\n+      // Find subscription groups current user is associated with\n+      return subscriptionGroupConfig.filter((group) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec40bb1ebaa53283e0fe9466f81ed22fe8f0f6bb"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMzY5Nw==", "bodyText": "It shouldn't need to get all subscription groups anymore, is it?", "url": "https://github.com/apache/pinot/pull/5593#discussion_r443013697", "createdAt": "2020-06-19T19:37:43Z", "author": {"login": "jihaozh"}, "path": "thirdeye/thirdeye-frontend/app/pods/manage/alerts/index/route.js", "diffHunk": "@@ -27,213 +20,44 @@ export default Route.extend(AuthenticatedRouteMixin, {\n \n   model() {\n     return hash({\n-      applications: fetch('/thirdeye/entity/APPLICATION').then(checkStatus),\n-      detectionAlertConfig: fetch('/detection/subscription-groups').then(checkStatus),\n-      polishedDetectionYaml: fetch('/yaml/list').then(checkStatus)\n+      subscriptionGroupConfig: fetch('/detection/subscription-groups').then(checkStatus),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec40bb1ebaa53283e0fe9466f81ed22fe8f0f6bb"}, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec40bb1ebaa53283e0fe9466f81ed22fe8f0f6bb", "author": {"user": {"login": "harleyjj", "name": "Harley Jackson"}}, "url": "https://github.com/apache/pinot/commit/ec40bb1ebaa53283e0fe9466f81ed22fe8f0f6bb", "committedDate": "2020-06-19T01:48:53Z", "message": "[TE] frontend - harleyjj/alerts - refactor Alerts route for backend pagination and filtering"}, "afterCommit": {"oid": "417ba68b27f273ac39568dcdbe023f0a1c48489e", "author": {"user": {"login": "harleyjj", "name": "Harley Jackson"}}, "url": "https://github.com/apache/pinot/commit/417ba68b27f273ac39568dcdbe023f0a1c48489e", "committedDate": "2020-06-22T23:04:40Z", "message": "[TE] frontend - harleyjj/alerts - refactor Alerts route for backend pagination and filtering"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "417ba68b27f273ac39568dcdbe023f0a1c48489e", "author": {"user": {"login": "harleyjj", "name": "Harley Jackson"}}, "url": "https://github.com/apache/pinot/commit/417ba68b27f273ac39568dcdbe023f0a1c48489e", "committedDate": "2020-06-22T23:04:40Z", "message": "[TE] frontend - harleyjj/alerts - refactor Alerts route for backend pagination and filtering"}, "afterCommit": {"oid": "e62d5fb440ea9a34e938950436d07aeb43ddedc2", "author": {"user": {"login": "harleyjj", "name": "Harley Jackson"}}, "url": "https://github.com/apache/pinot/commit/e62d5fb440ea9a34e938950436d07aeb43ddedc2", "committedDate": "2020-06-22T23:09:50Z", "message": "[TE] frontend - harleyjj/alerts - refactor Alerts route for backend pagination and filtering"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2OTYxMzg1", "url": "https://github.com/apache/pinot/pull/5593#pullrequestreview-436961385", "createdAt": "2020-06-24T19:56:51Z", "commit": {"oid": "e62d5fb440ea9a34e938950436d07aeb43ddedc2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo1Njo1MVrOGog9dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo1Njo1MVrOGog9dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNjI0NA==", "bodyText": "One little catch here. The user string is in the format of username@linkedin.biz, but the email written in the subscription group is stored as username@linkedin.com. So directly searching the user as a string won't get any result. Maybe change it to send username@linkedin.com or username directly?", "url": "https://github.com/apache/pinot/pull/5593#discussion_r445136244", "createdAt": "2020-06-24T19:56:51Z", "author": {"login": "jihaozh"}, "path": "thirdeye/thirdeye-frontend/app/pods/manage/alerts/index/controller.js", "diffHunk": "@@ -281,190 +275,144 @@ export default Controller.extend({\n   ),\n \n   /**\n-   * We are recalculating the options of each selection field. The values come from the aggregated\n-   * properties across all filtered alerts. For example, it returns all possible values for 'application'\n-   * @method _recalculateFilterKeys\n-   * @param {Array} alertsCollection - array of alerts we are extracting values from\n-   * @param {Object} blockItem - the current search filter object\n-   * @returns {Array} - a deduped array of values to use as select options\n-   * @private\n+   * flag meaning alerts are loading for current page\n+   * @type {Boolean}\n    */\n-  _recalculateFilterKeys(alertsCollection, blockItem) {\n-    const filterToPropertyMap = get(this, 'filterToPropertyMap');\n-    // Aggregate all existing values for our target properties in the current array collection\n-    let alertPropsAsKeys = [];\n-    // Make sure subscription groups are not bundled for filter parameters\n-    if (blockItem.name === 'subscription') {\n-      alertsCollection.forEach(alert => {\n-        let groups = alert[filterToPropertyMap[blockItem.name]];\n-        if (groups) {\n-          groups.split(\", \").forEach(g => {\n-            alertPropsAsKeys.push(g);\n-          });\n-        }\n-      });\n-    } else if (blockItem.name === 'application') {\n-      // Make sure applications are not bundled for filter parameters\n-      alertsCollection.forEach(alert => {\n-        let applications = alert[filterToPropertyMap[blockItem.name]];\n-        if (applications) {\n-          applications.split(\", \").forEach(a => {\n-            alertPropsAsKeys.push(a);\n-          });\n-        }\n-      });\n-    } else {\n-      alertPropsAsKeys = alertsCollection.map(alert => alert[filterToPropertyMap[blockItem.name]]);\n+  isLoading: computed(\n+    '_getAlerts.isIdle',\n+    function() {\n+      return !get(this, '_getAnomalies.isIdle');\n     }\n-    // Add 'none' select option if allowed\n-    const canInsertNullOption = alertPropsAsKeys.includes(undefined) && blockItem.hasNullOption;\n-    if (canInsertNullOption) { alertPropsAsKeys.push('none'); }\n-    // Return a deduped array containing all of the values for this property in the current set of alerts\n-    return [ ...new Set(powerSort(alertPropsAsKeys.filter(val => isPresent(val)), null)) ];\n-  },\n+  ),\n \n   /**\n-   * This is the core filtering method which acts upon a set of initial alerts to return a subset\n-   * @method _filterAlerts\n-   * @param {Array} initialAlerts - array of all alerts to start with\n-   * @param {Object} filters - filter key/values to process\n-   * @example\n-   * {\n-   *   application: ['app name a', 'app name b'],\n-   *   status: ['active'],\n-   *   owner: ['person1@linkedin.com, person2@linkedin.com'],\n-   *   type: null\n-   * }\n+   * When user chooses to either find an alert by name, or use a global filter,\n+   * we should re-set all local filters.\n+   * @method _resetFilters\n+   * @param {Boolean} isSelectDisabled\n    * @returns {undefined}\n    * @private\n    */\n-  _filterAlerts(initialAlerts, filters) {\n-    const filterToPropertyMap = get(this, 'filterToPropertyMap');\n-    // A click on a primary alert filter will reset 'filteredAlerts'\n-    if (filters.primary) {\n-      this._processPrimaryFilters(initialAlerts, filters.primary);\n-    }\n-    // Pick up cached alert array for the secondary filters\n-    let filteredAlerts = get(this, 'filteredAlerts');\n-    // If there is a secondary filter present, filter by it, using the keys we've set up in our filter map\n-    Object.keys(filterToPropertyMap).forEach((filterKey) => {\n-      let filterValueArray = filters[filterKey];\n-      if (filterValueArray && filterValueArray.length) {\n-        let newAlerts = filteredAlerts.filter(alert => {\n-          // See 'filterToPropertyMap' in route. For filterKey = 'owner' this would map alerts by alert['createdBy'] = x\n-          const targetAlertPropertyValue = alert[filterToPropertyMap[filterKey]];\n-          let alertMeetsCriteria = false;\n-          // In the cases for subscription and application, there can be multiple values.  We just need to match on one\n-          if (filterKey === \"subscription\") {\n-            if (targetAlertPropertyValue) {\n-              filterValueArray.forEach(val => {\n-                if (targetAlertPropertyValue.includes(val)) {\n-                  alertMeetsCriteria = true;\n-                }\n-              });\n-            }\n-          } else if (filterKey === \"application\") {\n-            if (targetAlertPropertyValue) {\n-              filterValueArray.forEach(val => {\n-                if (targetAlertPropertyValue.includes(val)) {\n-                  alertMeetsCriteria = true;\n-                }\n-              });\n-            }\n-          } else {\n-            alertMeetsCriteria = targetAlertPropertyValue && filterValueArray.includes(targetAlertPropertyValue);\n-          }\n-          const isMatchForNone = !alert.hasOwnProperty(filterToPropertyMap[filterKey]) && filterValueArray.includes('none');\n-          return alertMeetsCriteria || isMatchForNone;\n-        });\n-        filteredAlerts = newAlerts;\n-      }\n-    });\n+  _resetLocalFilters() {\n+    let alertFilters = {};\n+    const newFilterBlocksLocal = _.cloneDeep(get(this, 'initialFiltersLocal'));\n \n-    // If status filter is present, we re-build the results array to contain only active alerts, inactive alerts, or both.\n-    if (filters.status) {\n-      const concatStatus = filters.status.length ? filters.status.join().toLowerCase() : 'active';\n-      const requireAll = filters.status.includes('Active') && filters.status.includes('Inactive');\n-      const alertsByState = {\n-        active: filteredAlerts.filter(alert => alert.active),\n-        inactive: filteredAlerts.filter(alert => !alert.active)\n-      };\n-      filteredAlerts = requireAll ? [ ...alertsByState.active, ...alertsByState.inactive ] : alertsByState[concatStatus];\n-    }\n+    // Do not highlight any of the primary filters\n+    Object.assign(alertFilters, { primary: 'none' });\n \n-    return filteredAlerts;\n+    // Reset local (secondary) filters, and set select fields to 'disabled'\n+    setProperties(this, {\n+      filterBlocksLocal: newFilterBlocksLocal,\n+      resetFiltersLocal: moment().valueOf(),\n+      allowFilterSummary: false,\n+      alertFilters\n+    });\n   },\n \n+  _getAlerts: task (function * (params) {\n+    const subscriptionGroups = this.get('subscriptionGroupConfig');\n+    const alerts = yield fetch(yamlAPI.getPaginatedAlertsUrl(params)).then(checkStatus);\n+    const enrichedAlerts = enrichAlertResponseObject((alerts || {}).elements, subscriptionGroups);\n+    set(this, 'originalAlerts', enrichedAlerts);\n+    set(this, 'totalNumberOfAlerts', (alerts || {}).count);\n+    // Reset secondary filters\n+    setProperties(this, {\n+      filterBlocksLocal: _.cloneDeep(get(this, 'initialFiltersLocal')),\n+      resetFiltersLocal: moment().valueOf()\n+    });\n+  }).keepLatest(),\n+\n   /**\n-   * Simply select the appropriate set of alerts called for by primary filter\n-   * @method _processPrimaryFilters\n-   * @param {Array} originalAlerts - array of all alerts from model\n-   * @param {Object} primaryFilter - filter key/value for primary filter selections\n-   * @returns {undefined}\n-   * @private\n+   * Ember concurrency task that triggers alert names autocomplete\n    */\n-  _processPrimaryFilters (originalAlerts, primaryFilter) {\n-    const { ownedAlerts, subscribedAlerts } = getProperties(this, 'ownedAlerts', 'subscribedAlerts');\n+  _searchAlertNames: task(function* (text) {\n+    yield timeout(1000);\n+    return fetch(autocompleteAPI.alertByName(text))\n+      .then(checkStatus);\n+  }),\n+\n+  _fetchAlerts() {\n+    const paramsForAlerts = get(this, 'paramsForAlerts');\n+    return this.get('_getAlerts').perform(paramsForAlerts);\n+  },\n \n-    let newAlerts = [];\n+  _handlePrimaryFilter(primaryFilter, paramsForAlerts) {\n     switch(primaryFilter) {\n       case 'Alerts I subscribe to': {\n-        newAlerts = subscribedAlerts;\n+        const user = this.get('user');\n+        paramsForAlerts['subscribedBy'] = user;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d5fb440ea9a34e938950436d07aeb43ddedc2"}, "originalPosition": 444}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87bd7dd6e7e4c79c2f3fae041acd4460a50fc49c", "author": {"user": {"login": "harleyjj", "name": "Harley Jackson"}}, "url": "https://github.com/apache/pinot/commit/87bd7dd6e7e4c79c2f3fae041acd4460a50fc49c", "committedDate": "2020-06-25T05:13:08Z", "message": "[TE] frontend - harleyjj/alerts - refactor Alerts route for backend pagination and filtering"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e62d5fb440ea9a34e938950436d07aeb43ddedc2", "author": {"user": {"login": "harleyjj", "name": "Harley Jackson"}}, "url": "https://github.com/apache/pinot/commit/e62d5fb440ea9a34e938950436d07aeb43ddedc2", "committedDate": "2020-06-22T23:09:50Z", "message": "[TE] frontend - harleyjj/alerts - refactor Alerts route for backend pagination and filtering"}, "afterCommit": {"oid": "87bd7dd6e7e4c79c2f3fae041acd4460a50fc49c", "author": {"user": {"login": "harleyjj", "name": "Harley Jackson"}}, "url": "https://github.com/apache/pinot/commit/87bd7dd6e7e4c79c2f3fae041acd4460a50fc49c", "committedDate": "2020-06-25T05:13:08Z", "message": "[TE] frontend - harleyjj/alerts - refactor Alerts route for backend pagination and filtering"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MTc0MjQ3", "url": "https://github.com/apache/pinot/pull/5593#pullrequestreview-437174247", "createdAt": "2020-06-25T05:17:49Z", "commit": {"oid": "87bd7dd6e7e4c79c2f3fae041acd4460a50fc49c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNToxNzo0OVrOGorsKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNToxNzo0OVrOGorsKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMjA0MQ==", "bodyText": "@jihaozh Here, we can extract the username by setting userNameSplitToken to '@' in environment.js", "url": "https://github.com/apache/pinot/pull/5593#discussion_r445312041", "createdAt": "2020-06-25T05:17:49Z", "author": {"login": "harleyjj"}, "path": "thirdeye/thirdeye-frontend/app/pods/manage/alerts/index/route.js", "diffHunk": "@@ -27,213 +21,44 @@ export default Route.extend(AuthenticatedRouteMixin, {\n \n   model() {\n     return hash({\n-      applications: fetch('/thirdeye/entity/APPLICATION').then(checkStatus),\n-      detectionAlertConfig: fetch('/detection/subscription-groups').then(checkStatus),\n-      polishedDetectionYaml: fetch('/yaml/list').then(checkStatus)\n+      polishedDetectionYaml: fetch(yamlAPI.getPaginatedAlertsUrl()).then(checkStatus),\n+      rules: fetch(entityMappingApi.getRulesUrl)\n+        .then(checkStatus)\n+        .then(rules => rules.map(r => r.type))\n     });\n   },\n \n   afterModel(model) {\n     this._super(model);\n \n-    // Fetch all the detection alerts\n-    const alerts = model.polishedDetectionYaml;\n-    for (let yamlAlert of alerts) {\n-      let dimensions = '';\n-      let dimensionsArray = yamlAlert.dimensionExploration ? yamlAlert.dimensionExploration.dimensions : null;\n-      if (Array.isArray(dimensionsArray)) {\n-        dimensionsArray.forEach(dim => {\n-          dimensions = dimensions + `${dim}, `;\n-        });\n-        dimensions = dimensions.substring(0, dimensions.length-2);\n-      }\n-      Object.assign(yamlAlert, {\n-        functionName: yamlAlert.name,\n-        collection: yamlAlert.datasetNames.toString(),\n-        granularity: yamlAlert.monitoringGranularity.toString(),\n-        type: this._detectionType(yamlAlert),\n-        exploreDimensions: dimensions,\n-        filters: formatYamlFilter(yamlAlert.filters),\n-        isNewPipeline: true\n-      });\n-    }\n+    const alertsFromResponse = (model.polishedDetectionYaml || {}).elements;\n \n-    // Iterate through detection alerter to enhance all yaml alert with extra properties (group name, application)\n-    for (let subscriptionGroup of model.detectionAlertConfig){\n-      const detectionConfigIds = subscriptionGroup.detectionConfigIds;\n-      for (let id of detectionConfigIds) {\n-        let foundAlert = alerts.find(yamlAlert => yamlAlert.id === id);\n-        if (foundAlert) {\n-          Object.assign(foundAlert, {\n-            application: foundAlert.application ? foundAlert.application + \", \" + subscriptionGroup.application : subscriptionGroup.application,\n-            group: foundAlert.group ? foundAlert.group + \", \" + subscriptionGroup.name : subscriptionGroup.name\n-          });\n-        }\n-      }\n-    }\n-    // Perform initial filters for our 'primary' filter types and add counts\n-    const user = getWithDefault(get(this, 'session'), 'data.authenticated.name', null);\n-    const myAlertIds = user ? this._findAlertIdsByUserGroup(user, model.detectionAlertConfig) : [];\n-    const ownedAlerts = alerts.filter(alert => alert.createdBy === user);\n-    const subscribedAlerts = alerts.filter(alert => myAlertIds.includes(alert.id));\n-    const totalCounts = [subscribedAlerts.length, ownedAlerts.length, alerts.length];\n-    // Add these filtered arrays to the model (they are only assigne once)\n-    Object.assign(model, { alerts, ownedAlerts, subscribedAlerts, totalCounts });\n-  },\n+    const alerts = enrichAlertResponseObject(alertsFromResponse);\n \n-  setupController(controller, model) {\n+    let user = getWithDefault(get(this, 'session'), 'data.authenticated.name', null);\n+    let token = config.userNameSplitToken;\n \n-    // This filter category is \"global\" in nature. When selected, they reset the rest of the filters\n-    const filterBlocksGlobal = [\n-      {\n-        name: 'primary',\n-        type: 'link',\n-        preventCollapse: true,\n-        totals: model.totalCounts,\n-        selected: ['All alerts'],\n-        filterKeys: ['Alerts I subscribe to', 'Alerts I own', 'All alerts']\n-      }\n-    ];\n+    user = user ? user.split(token)[0] : user;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87bd7dd6e7e4c79c2f3fae041acd4460a50fc49c"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NzE0NDI2", "url": "https://github.com/apache/pinot/pull/5593#pullrequestreview-437714426", "createdAt": "2020-06-25T17:36:13Z", "commit": {"oid": "87bd7dd6e7e4c79c2f3fae041acd4460a50fc49c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 651, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}