{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5MzEzOTcx", "number": 5406, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzozOTowN1rOD9Rj4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNjo0NFrOD_GdUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTc3NDQzOnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzozOTowN1rOGWq61Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1MToxMFrOGWrUAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyNTA0NQ==", "bodyText": "this should be recursively evaluated, technically a function of function of literal should still be true here.\nE.g. format_time(now(), 'yyyy-MM-dd')", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426425045", "createdAt": "2020-05-18T07:39:07Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);\n+              break;\n+            default:\n+              //no change, let the expression be handled during execution phase\n+          }\n+        }\n+\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {\n+\n+    boolean compileTimeEvaluationPossible = true;\n+    Function functionCall = funcExpr.getFunctionCall();\n+    if(functionCall.getOperandsSize() > 0) {\n+      for (Expression expression : functionCall.getOperands()) {\n+        if (expression.getType() != ExpressionType.LITERAL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTQ5MA==", "bodyText": "since logic is depth-first, it should work.\nformat_time(now(), 'yyyy-MM-dd') will first get changed to\nformat_time(123123123123, 'yyyy-MM-dd') which will be evaluated to\n2020-01-01", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426431490", "createdAt": "2020-05-18T07:51:10Z", "author": {"login": "kishoreg"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);\n+              break;\n+            default:\n+              //no change, let the expression be handled during execution phase\n+          }\n+        }\n+\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {\n+\n+    boolean compileTimeEvaluationPossible = true;\n+    Function functionCall = funcExpr.getFunctionCall();\n+    if(functionCall.getOperandsSize() > 0) {\n+      for (Expression expression : functionCall.getOperands()) {\n+        if (expression.getType() != ExpressionType.LITERAL) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyNTA0NQ=="}, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTc5ODk5OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo0NjozMFrOGWrJ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNToxMDoyMVrOGX7dJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ==", "bodyText": "better to implement method eval for each function which take operands list as argument which could be either literal or functions.\nThen this logic will just be\nfuncExpr = getScalarFunction(scalarFunctionType).eval(funcExpr.getFunctionCall().getOperands())", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426428899", "createdAt": "2020-05-18T07:46:30Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMjc3Mw==", "bodyText": "Most of the functions are already available in FunctionRegistry and FunctionInvoker added by @npawar. Unfortunately, those functions are in pinot-core, we can move the scalar functions into pinot-common in another PR and remove custom implementation for now and datetime format", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426432773", "createdAt": "2020-05-18T07:53:27Z", "author": {"login": "kishoreg"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ=="}, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0NDU1MA==", "bodyText": "Added support for eval function of functions as long as all the recursive params are literal.", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427744550", "createdAt": "2020-05-20T05:10:21Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ=="}, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTE1MzEwOnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMDozNTo0NVrOGXL3RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMTo0Njo0NVrOGXM_fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NDgwNQ==", "bodyText": "What's the purpose of this? Flexibility to support variations of function names?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426964805", "createdAt": "2020-05-19T00:35:45Z", "author": {"login": "mayankshriv"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {\n+      String upperCaseFunctionName = value.getName().toUpperCase();\n+      _scalarFunctions.put(upperCaseFunctionName, value);\n+      _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4MzI5NA==", "bodyText": "e.g. presto use _ in function names. It provides more robustness from user perspective.", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983294", "createdAt": "2020-05-19T01:46:45Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {\n+      String upperCaseFunctionName = value.getName().toUpperCase();\n+      _scalarFunctions.put(upperCaseFunctionName, value);\n+      _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NDgwNQ=="}, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTE1NDU1OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMDozNjo0MVrOGXL4HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNToxMToxMlrOGX7eDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA==", "bodyText": "Would it be easy to identify this based on function args, as opposed to pre-register?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426965020", "createdAt": "2020-05-19T00:36:41Z", "author": {"login": "mayankshriv"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4Mzk5Nw==", "bodyText": "I somehow feel, we should still pre-register those functions.", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983997", "createdAt": "2020-05-19T01:49:19Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA=="}, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0NDc4Mw==", "bodyText": "Removed these code path for now.", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427744783", "createdAt": "2020-05-20T05:11:12Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA=="}, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTE2MTE0OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMDo0MDoxNVrOGXL7sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTowMDo0M1rOGXydYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA==", "bodyText": "Will this approach scale, as number of scalar functions increase? For example, each one would need to be added here. What do you think about modelling this as a query rewrite phase that goes over all scalars and evaluates them?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426965938", "createdAt": "2020-05-19T00:40:15Z", "author": {"login": "mayankshriv"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4MzU4NQ==", "bodyText": "I think we will need to move to function registry/invoker model", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983585", "createdAt": "2020-05-19T01:47:48Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA=="}, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NzE1Mw==", "bodyText": "yes, this is to just ensure that the logic of detection if a function can be evaluated at query compile time works.", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427597153", "createdAt": "2020-05-19T21:00:43Z", "author": {"login": "kishoreg"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA=="}, "originalCommit": {"oid": "b91b4f33292c594307fe5e7087beae7f13dc0531"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjk3NjQ2OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDozMDoxMlrOGXxdQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTowMTowMlrOGXyeHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ==", "bodyText": "Instead of this, why don't we just have a constant value function registry  where all compile time evaluated functions are registered. So this check then becomes if the function is part of the constant value function registry.", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427580739", "createdAt": "2020-05-19T20:30:12Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +620,44 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n+          }\n+        }\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NjI0NQ==", "bodyText": "One thing here is that the function could be used in transform functions in query/ingestion field conversion. Ideally we should be able to evaluate any transform function with literal here.", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427596245", "createdAt": "2020-05-19T20:59:06Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +620,44 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n+          }\n+        }\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ=="}, "originalCommit": {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NzM0MA==", "bodyText": "+1", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427597340", "createdAt": "2020-05-19T21:01:02Z", "author": {"login": "kishoreg"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +620,44 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n+          }\n+        }\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ=="}, "originalCommit": {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkxNjUxOnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowOToxM1rOGZmoPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMzo1MDozNVrOGZnRvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDQ3Nw==", "bodyText": "this function is the same as fromDateTime on line 217. Do we need both?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429500477", "createdAt": "2020-05-23T01:09:13Z", "author": {"login": "npawar"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java", "diffHunk": "@@ -216,4 +217,18 @@ static String toDateTime(Long millis, String pattern) {\n   static Long fromDateTime(String dateTimeString, String pattern) {\n     return DateTimePatternHandler.parseDateTimeStringToEpochMillis(dateTimeString, pattern);\n   }\n+\n+  /**\n+   * Return current time as epoch millis\n+   */\n+  static Long now() {\n+    return System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Return epoch millis value based on a given date time string and it's corresponding format.\n+   */\n+  public static Long formatDatetime(String input, String format) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUxMTEwMg==", "bodyText": "will delete", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429511102", "createdAt": "2020-05-23T03:50:35Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java", "diffHunk": "@@ -216,4 +217,18 @@ static String toDateTime(Long millis, String pattern) {\n   static Long fromDateTime(String dateTimeString, String pattern) {\n     return DateTimePatternHandler.parseDateTimeStringToEpochMillis(dateTimeString, pattern);\n   }\n+\n+  /**\n+   * Return current time as epoch millis\n+   */\n+  static Long now() {\n+    return System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Return epoch millis value based on a given date time string and it's corresponding format.\n+   */\n+  public static Long formatDatetime(String input, String format) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDQ3Nw=="}, "originalCommit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyNjg5OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNjo0NFrOGZmt0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMzo1NjoxOFrOGZnSyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTkwNg==", "bodyText": "i didn't quite follow why there is special casing for  DISTINCTCOUNT ?", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429501906", "createdAt": "2020-05-23T01:26:44Z", "author": {"login": "npawar"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -593,29 +596,77 @@ private static Expression toExpression(SqlNode node) {\n           // Move on to process default logic.\n         }\n       default:\n-        SqlBasicCall funcSqlNode = (SqlBasicCall) node;\n-        String funcName = funcSqlNode.getOperator().getKind().name();\n-        if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n-          funcName = funcSqlNode.getOperator().getName();\n+        return evaluateFunctionExpression((SqlBasicCall) node);\n+    }\n+  }\n+\n+  private static String extractFunctionName(SqlBasicCall funcSqlNode) {\n+    String funcName = funcSqlNode.getOperator().getKind().name();\n+    if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n+      funcName = funcSqlNode.getOperator().getName();\n+    }\n+    if (funcName.equalsIgnoreCase(SqlKind.COUNT.toString()) && (funcSqlNode.getFunctionQuantifier() != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUxMTM2OA==", "bodyText": "this is a special handling for the case of COUNT(DISTINCT A).", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429511368", "createdAt": "2020-05-23T03:56:18Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -593,29 +596,77 @@ private static Expression toExpression(SqlNode node) {\n           // Move on to process default logic.\n         }\n       default:\n-        SqlBasicCall funcSqlNode = (SqlBasicCall) node;\n-        String funcName = funcSqlNode.getOperator().getKind().name();\n-        if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n-          funcName = funcSqlNode.getOperator().getName();\n+        return evaluateFunctionExpression((SqlBasicCall) node);\n+    }\n+  }\n+\n+  private static String extractFunctionName(SqlBasicCall funcSqlNode) {\n+    String funcName = funcSqlNode.getOperator().getKind().name();\n+    if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n+      funcName = funcSqlNode.getOperator().getName();\n+    }\n+    if (funcName.equalsIgnoreCase(SqlKind.COUNT.toString()) && (funcSqlNode.getFunctionQuantifier() != null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTkwNg=="}, "originalCommit": {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4453, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}