{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5OTYzNDgy", "number": 5213, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoyNjoxNVrODvzysg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjozNDoyNVrODvz4Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU4MjI2OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoyNjoxNlrOGCcygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMzozNjowMFrOGCd2JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyMjAxNg==", "bodyText": "this is needed for intermediate aggregated object like HLL?", "url": "https://github.com/apache/pinot/pull/5213#discussion_r405222016", "createdAt": "2020-04-08T02:26:16Z", "author": {"login": "snleee"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -332,11 +330,14 @@ private IndexedTable getIndexedTable(DataSchema dataSchema, Collection<DataTable\n             function = dataTable::getString;\n             break;\n           case BYTES:\n-            // FIXME: support BYTES in DataTable instead of converting to string\n-            function = (row, col) -> BytesUtils.toByteArray(dataTable.getString(row, col));\n+            function = dataTable::getBytes;\n             break;\n-          default:\n+          case OBJECT:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e867ae36ae02c211c83cde8693db81ad264396"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzOTMzMg==", "bodyText": "Yes", "url": "https://github.com/apache/pinot/pull/5213#discussion_r405239332", "createdAt": "2020-04-08T03:36:00Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -332,11 +330,14 @@ private IndexedTable getIndexedTable(DataSchema dataSchema, Collection<DataTable\n             function = dataTable::getString;\n             break;\n           case BYTES:\n-            // FIXME: support BYTES in DataTable instead of converting to string\n-            function = (row, col) -> BytesUtils.toByteArray(dataTable.getString(row, col));\n+            function = dataTable::getBytes;\n             break;\n-          default:\n+          case OBJECT:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyMjAxNg=="}, "originalCommit": {"oid": "b5e867ae36ae02c211c83cde8693db81ad264396"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU5NjE1OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/selection/SelectionOperatorUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjozNDoyNVrOGCc6ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMzozODo0NVrOGCd4aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNDA1OQ==", "bodyText": "From IntermediateResultsBlock class, you kind of directly casted types to an object instead of casting to Number.  Can we use the same approach here?", "url": "https://github.com/apache/pinot/pull/5213#discussion_r405224059", "createdAt": "2020-04-08T02:34:25Z", "author": {"login": "snleee"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/selection/SelectionOperatorUtils.java", "diffHunk": "@@ -481,55 +510,81 @@ public static ResultTable renderResultTableWithoutOrdering(List<Serializable[]>\n   }\n \n   /**\n-   * Extract columns from the row based on the given column indices.\n-   * <p>The extracted row is used to build the {@link SelectionResults}.\n-   *\n-   * @param row selection row to be extracted.\n-   * @param columnIndices column indices.\n-   * @return selection row.\n+   * Converts a value into the given data type. (Broker side)\n+   * <p>Actual value type can be different with data type passed in, but they must be type compatible.\n    */\n-  public static Serializable[] extractColumns(Serializable[] row, int[] columnIndices,\n-      @Nullable DataSchema.ColumnDataType[] columnDataTypes) {\n-    int numColumns = columnIndices.length;\n-    Serializable[] extractedRow = new Serializable[numColumns];\n-    if (columnDataTypes == null) {\n-      for (int i = 0; i < numColumns; i++) {\n-        extractedRow[i] = row[columnIndices[i]];\n-      }\n-    } else {\n-      for (int i = 0; i < numColumns; i++) {\n-        extractedRow[i] = getFormattedValue(row[columnIndices[i]], columnDataTypes[i]);\n-      }\n-    }\n-    return extractedRow;\n-  }\n+  public static Serializable convertValueToType(Object value, DataSchema.ColumnDataType dataType) {\n+    switch (dataType) {\n+      // Single-value column\n+      case INT:\n+        return ((Number) value).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e867ae36ae02c211c83cde8693db81ad264396"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzOTkxMg==", "bodyText": "We are trying to handle compatible types here (commented on line 514). This is required for cases where different segments have different schema (same column name, but different data types).\nThe long term solution should be let the query engine use the table schema instead of the schema inside each segments.", "url": "https://github.com/apache/pinot/pull/5213#discussion_r405239912", "createdAt": "2020-04-08T03:38:45Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/selection/SelectionOperatorUtils.java", "diffHunk": "@@ -481,55 +510,81 @@ public static ResultTable renderResultTableWithoutOrdering(List<Serializable[]>\n   }\n \n   /**\n-   * Extract columns from the row based on the given column indices.\n-   * <p>The extracted row is used to build the {@link SelectionResults}.\n-   *\n-   * @param row selection row to be extracted.\n-   * @param columnIndices column indices.\n-   * @return selection row.\n+   * Converts a value into the given data type. (Broker side)\n+   * <p>Actual value type can be different with data type passed in, but they must be type compatible.\n    */\n-  public static Serializable[] extractColumns(Serializable[] row, int[] columnIndices,\n-      @Nullable DataSchema.ColumnDataType[] columnDataTypes) {\n-    int numColumns = columnIndices.length;\n-    Serializable[] extractedRow = new Serializable[numColumns];\n-    if (columnDataTypes == null) {\n-      for (int i = 0; i < numColumns; i++) {\n-        extractedRow[i] = row[columnIndices[i]];\n-      }\n-    } else {\n-      for (int i = 0; i < numColumns; i++) {\n-        extractedRow[i] = getFormattedValue(row[columnIndices[i]], columnDataTypes[i]);\n-      }\n-    }\n-    return extractedRow;\n-  }\n+  public static Serializable convertValueToType(Object value, DataSchema.ColumnDataType dataType) {\n+    switch (dataType) {\n+      // Single-value column\n+      case INT:\n+        return ((Number) value).intValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNDA1OQ=="}, "originalCommit": {"oid": "b5e867ae36ae02c211c83cde8693db81ad264396"}, "originalPosition": 206}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3353, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}