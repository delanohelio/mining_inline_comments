{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NTEyOTIy", "number": 5019, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToyODo1NlrODa_wAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOTozNDozNFrODa_3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjM0MDQ4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToyODo1NlrOFiOtUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMDowODo1OVrOFiP6sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNjg4MA==", "bodyText": "When will this if block be needed? These will always be in the group by clause, and hence be handled by 269 right?", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371436880", "createdAt": "2020-01-27T19:28:56Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {\n+            finalValues[i] = null;\n+          } else {\n+            finalValues[i] = values[finalSchemaMapIdx[i]];\n+          }\n+        }\n+        rows.add(finalValues);\n+      } else {\n+        rows.add(values);\n+      }\n       numRows++;\n     }\n \n     DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n+    if (_sqlSelectionList != null) {\n+      int columnSize = _sqlSelectionList.size();\n+      String[] columns = new String[columnSize];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n+      for (int i = 0; i < columnSize; i++) {\n+        if (finalSchemaMapIdx[i] == -1) {\n+          columns[i] = RequestUtils.prettyPrint(_sqlSelectionList.get(i));\n+          columnDataTypes[i] = DataSchema.ColumnDataType.STRING;\n+        } else {\n+          columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n+          columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        }\n+      }\n+      finalDataSchema = new DataSchema(columns, columnDataTypes);\n+    }\n     brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n   }\n \n+  /**\n+   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n+   * then aggregation functions.\n+   * @param dataSchema\n+   *\n+   * @return a mapping from final schema idx to corresponding idx in data table schema.\n+   */\n+  private int[] getFinalSchemaMapIdx(DataSchema dataSchema) {\n+    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n+    int nextAggregationIdx = _numGroupBy;\n+    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n+      finalSchemaMapIdx[i] = getExpressionMapIdx(dataSchema, _sqlSelectionList.get(i), nextAggregationIdx);\n+      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n+        nextAggregationIdx++;\n+      }\n+    }\n+    return finalSchemaMapIdx;\n+  }\n+\n+  private int getExpressionMapIdx(DataSchema dataSchema, Expression expression, int nextAggregationIdx) {\n+    // Check if expression matches groupBy list.\n+    int idxFromGroupByList = getGroupByIdx(_groupByList, expression);\n+    if (idxFromGroupByList != -1) {\n+      return idxFromGroupByList;\n+    }\n+    // Handle all functions\n+    if (expression.getFunctionCall() != null) {\n+      // handle AS\n+      if (expression.getFunctionCall().getOperator().equalsIgnoreCase(\"AS\")) {\n+        return getExpressionMapIdx(dataSchema, expression.getFunctionCall().getOperands().get(0), nextAggregationIdx);\n+      }\n+      // Return next aggregation idx.\n+      return nextAggregationIdx;\n+    }\n+    // Handle identifier, which is a column.\n+    if (expression.getIdentifier() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1NjY4OA==", "bodyText": "Right, will remove this block", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371456688", "createdAt": "2020-01-27T20:08:59Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {\n+            finalValues[i] = null;\n+          } else {\n+            finalValues[i] = values[finalSchemaMapIdx[i]];\n+          }\n+        }\n+        rows.add(finalValues);\n+      } else {\n+        rows.add(values);\n+      }\n       numRows++;\n     }\n \n     DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n+    if (_sqlSelectionList != null) {\n+      int columnSize = _sqlSelectionList.size();\n+      String[] columns = new String[columnSize];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n+      for (int i = 0; i < columnSize; i++) {\n+        if (finalSchemaMapIdx[i] == -1) {\n+          columns[i] = RequestUtils.prettyPrint(_sqlSelectionList.get(i));\n+          columnDataTypes[i] = DataSchema.ColumnDataType.STRING;\n+        } else {\n+          columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n+          columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        }\n+      }\n+      finalDataSchema = new DataSchema(columns, columnDataTypes);\n+    }\n     brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n   }\n \n+  /**\n+   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n+   * then aggregation functions.\n+   * @param dataSchema\n+   *\n+   * @return a mapping from final schema idx to corresponding idx in data table schema.\n+   */\n+  private int[] getFinalSchemaMapIdx(DataSchema dataSchema) {\n+    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n+    int nextAggregationIdx = _numGroupBy;\n+    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n+      finalSchemaMapIdx[i] = getExpressionMapIdx(dataSchema, _sqlSelectionList.get(i), nextAggregationIdx);\n+      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n+        nextAggregationIdx++;\n+      }\n+    }\n+    return finalSchemaMapIdx;\n+  }\n+\n+  private int getExpressionMapIdx(DataSchema dataSchema, Expression expression, int nextAggregationIdx) {\n+    // Check if expression matches groupBy list.\n+    int idxFromGroupByList = getGroupByIdx(_groupByList, expression);\n+    if (idxFromGroupByList != -1) {\n+      return idxFromGroupByList;\n+    }\n+    // Handle all functions\n+    if (expression.getFunctionCall() != null) {\n+      // handle AS\n+      if (expression.getFunctionCall().getOperator().equalsIgnoreCase(\"AS\")) {\n+        return getExpressionMapIdx(dataSchema, expression.getFunctionCall().getOperands().get(0), nextAggregationIdx);\n+      }\n+      // Return next aggregation idx.\n+      return nextAggregationIdx;\n+    }\n+    // Handle identifier, which is a column.\n+    if (expression.getIdentifier() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNjg4MA=="}, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjM1MDk3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOTozMTo1OFrOFiOzqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMDoxODoyNFrOFiQLRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzODUwNA==", "bodyText": "this group by list will be scanned for every single expression in the selection. Do you think it's worth constructing a map upfront groupByExpr -> index , within getFinalSchemaIdx method?", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371438504", "createdAt": "2020-01-27T19:31:58Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {\n+            finalValues[i] = null;\n+          } else {\n+            finalValues[i] = values[finalSchemaMapIdx[i]];\n+          }\n+        }\n+        rows.add(finalValues);\n+      } else {\n+        rows.add(values);\n+      }\n       numRows++;\n     }\n \n     DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n+    if (_sqlSelectionList != null) {\n+      int columnSize = _sqlSelectionList.size();\n+      String[] columns = new String[columnSize];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n+      for (int i = 0; i < columnSize; i++) {\n+        if (finalSchemaMapIdx[i] == -1) {\n+          columns[i] = RequestUtils.prettyPrint(_sqlSelectionList.get(i));\n+          columnDataTypes[i] = DataSchema.ColumnDataType.STRING;\n+        } else {\n+          columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n+          columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        }\n+      }\n+      finalDataSchema = new DataSchema(columns, columnDataTypes);\n+    }\n     brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n   }\n \n+  /**\n+   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n+   * then aggregation functions.\n+   * @param dataSchema\n+   *\n+   * @return a mapping from final schema idx to corresponding idx in data table schema.\n+   */\n+  private int[] getFinalSchemaMapIdx(DataSchema dataSchema) {\n+    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n+    int nextAggregationIdx = _numGroupBy;\n+    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n+      finalSchemaMapIdx[i] = getExpressionMapIdx(dataSchema, _sqlSelectionList.get(i), nextAggregationIdx);\n+      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n+        nextAggregationIdx++;\n+      }\n+    }\n+    return finalSchemaMapIdx;\n+  }\n+\n+  private int getExpressionMapIdx(DataSchema dataSchema, Expression expression, int nextAggregationIdx) {\n+    // Check if expression matches groupBy list.\n+    int idxFromGroupByList = getGroupByIdx(_groupByList, expression);\n+    if (idxFromGroupByList != -1) {\n+      return idxFromGroupByList;\n+    }\n+    // Handle all functions\n+    if (expression.getFunctionCall() != null) {\n+      // handle AS\n+      if (expression.getFunctionCall().getOperator().equalsIgnoreCase(\"AS\")) {\n+        return getExpressionMapIdx(dataSchema, expression.getFunctionCall().getOperands().get(0), nextAggregationIdx);\n+      }\n+      // Return next aggregation idx.\n+      return nextAggregationIdx;\n+    }\n+    // Handle identifier, which is a column.\n+    if (expression.getIdentifier() != null) {\n+      String columnName = expression.getIdentifier().getName();\n+      for (int i = 0; i < dataSchema.size(); i++) {\n+        if (columnName.equalsIgnoreCase(dataSchema.getColumnName(i))) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  /**\n+   * Trying to match an expression based on given groupByList.\n+   *\n+   * @param groupByList\n+   * @param expression\n+   * @return matched idx from groupByList\n+   */\n+  private int getGroupByIdx(List<Expression> groupByList, Expression expression) {\n+    for (int i = 0; i < groupByList.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MDkzNA==", "bodyText": "I'm not too worried about this as the check would be selectionSize + groupBySize * groupBySize times", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371460934", "createdAt": "2020-01-27T20:18:24Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {\n+            finalValues[i] = null;\n+          } else {\n+            finalValues[i] = values[finalSchemaMapIdx[i]];\n+          }\n+        }\n+        rows.add(finalValues);\n+      } else {\n+        rows.add(values);\n+      }\n       numRows++;\n     }\n \n     DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n+    if (_sqlSelectionList != null) {\n+      int columnSize = _sqlSelectionList.size();\n+      String[] columns = new String[columnSize];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n+      for (int i = 0; i < columnSize; i++) {\n+        if (finalSchemaMapIdx[i] == -1) {\n+          columns[i] = RequestUtils.prettyPrint(_sqlSelectionList.get(i));\n+          columnDataTypes[i] = DataSchema.ColumnDataType.STRING;\n+        } else {\n+          columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n+          columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        }\n+      }\n+      finalDataSchema = new DataSchema(columns, columnDataTypes);\n+    }\n     brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n   }\n \n+  /**\n+   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n+   * then aggregation functions.\n+   * @param dataSchema\n+   *\n+   * @return a mapping from final schema idx to corresponding idx in data table schema.\n+   */\n+  private int[] getFinalSchemaMapIdx(DataSchema dataSchema) {\n+    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n+    int nextAggregationIdx = _numGroupBy;\n+    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n+      finalSchemaMapIdx[i] = getExpressionMapIdx(dataSchema, _sqlSelectionList.get(i), nextAggregationIdx);\n+      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n+        nextAggregationIdx++;\n+      }\n+    }\n+    return finalSchemaMapIdx;\n+  }\n+\n+  private int getExpressionMapIdx(DataSchema dataSchema, Expression expression, int nextAggregationIdx) {\n+    // Check if expression matches groupBy list.\n+    int idxFromGroupByList = getGroupByIdx(_groupByList, expression);\n+    if (idxFromGroupByList != -1) {\n+      return idxFromGroupByList;\n+    }\n+    // Handle all functions\n+    if (expression.getFunctionCall() != null) {\n+      // handle AS\n+      if (expression.getFunctionCall().getOperator().equalsIgnoreCase(\"AS\")) {\n+        return getExpressionMapIdx(dataSchema, expression.getFunctionCall().getOperands().get(0), nextAggregationIdx);\n+      }\n+      // Return next aggregation idx.\n+      return nextAggregationIdx;\n+    }\n+    // Handle identifier, which is a column.\n+    if (expression.getIdentifier() != null) {\n+      String columnName = expression.getIdentifier().getName();\n+      for (int i = 0; i < dataSchema.size(); i++) {\n+        if (columnName.equalsIgnoreCase(dataSchema.getColumnName(i))) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  /**\n+   * Trying to match an expression based on given groupByList.\n+   *\n+   * @param groupByList\n+   * @param expression\n+   * @return matched idx from groupByList\n+   */\n+  private int getGroupByIdx(List<Expression> groupByList, Expression expression) {\n+    for (int i = 0; i < groupByList.size(); i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzODUwNA=="}, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjM1ODk3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOTozNDozNFrOFiO4tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMDoxNTozOVrOFiQGaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzOTc5OA==", "bodyText": "should this ever happen? the validation during parsing should prevent this right?", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371439798", "createdAt": "2020-01-27T19:34:34Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1OTY4OQ==", "bodyText": "true, removed this block", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371459689", "createdAt": "2020-01-27T20:15:39Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzOTc5OA=="}, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3649, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}