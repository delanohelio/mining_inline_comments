{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4MjE0MzM5", "number": 5867, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzoyMDoxMlrOEZlGhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo1OTozNlrOEZmAAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjU3NzMyOnYy", "diffSide": "RIGHT", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/BaseClusterIntegrationTestSet.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzoyMDoxMlrOHCeddw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxODozODozNFrOHChM7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM1ODI2Mw==", "bodyText": "how about adding a query with literals", "url": "https://github.com/apache/pinot/pull/5867#discussion_r472358263", "createdAt": "2020-08-18T17:20:12Z", "author": {"login": "npawar"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/BaseClusterIntegrationTestSet.java", "diffHunk": "@@ -231,6 +231,13 @@ public void testHardcodedSqlQueries()\n     testSqlQuery(query, Collections.singletonList(query));\n     query = \"SELECT MAX(ArrDelay), Month FROM mytable GROUP BY Month ORDER BY ABS(Month - 6) + MAX(ArrDelay)\";\n     testSqlQuery(query, Collections.singletonList(query));\n+\n+    // Post-aggregation in SELECT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597705967ed172f0a08e6a7f46bbbbd49d7651c2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQwMzE4Mw==", "bodyText": "Sounds good, added", "url": "https://github.com/apache/pinot/pull/5867#discussion_r472403183", "createdAt": "2020-08-18T18:38:34Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/BaseClusterIntegrationTestSet.java", "diffHunk": "@@ -231,6 +231,13 @@ public void testHardcodedSqlQueries()\n     testSqlQuery(query, Collections.singletonList(query));\n     query = \"SELECT MAX(ArrDelay), Month FROM mytable GROUP BY Month ORDER BY ABS(Month - 6) + MAX(ArrDelay)\";\n     testSqlQuery(query, Collections.singletonList(query));\n+\n+    // Post-aggregation in SELECT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM1ODI2Mw=="}, "originalCommit": {"oid": "597705967ed172f0a08e6a7f46bbbbd49d7651c2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjcyNDUxOnYy", "diffSide": "LEFT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo1OTozNlrOHCf5gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxODo1MDozNVrOHChloQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4MTgyNA==", "bodyText": "looks like the reordering logic happens within postAggregationHandler, whether we have post aggregations functions or not? Can we add a comment either here or inside postAggregationHandler, that reordering is handled as one of the post aggregation operations?", "url": "https://github.com/apache/pinot/pull/5867#discussion_r472381824", "createdAt": "2020-08-18T17:59:36Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -160,103 +160,49 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n+    DataSchema prePostAggregationDataSchema = getPrePostAggregationDataSchema(dataSchema);\n     int limit = _queryContext.getLimit();\n     List<Object[]> rows = new ArrayList<>(limit);\n+    for (int i = 0; i < limit && sortedIterator.hasNext(); i++) {\n+      Object[] row = sortedIterator.next().getValues();\n+      for (int j = 0; j < _numAggregationFunctions; j++) {\n+        int valueIndex = j + _numGroupByExpressions;\n+        row[valueIndex] =\n+            AggregationFunctionUtils.getSerializableValue(_aggregationFunctions[j].extractFinalResult(row[valueIndex]));\n+      }\n+      rows.add(row);\n+    }\n \n     if (_sqlQuery) {\n       // SQL query with SQL group-by mode and response format\n-      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n-\n-      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n-      int numSelectExpressions = selectExpressionIndexMap.length;\n-      String[] columnNames = resultTableSchema.getColumnNames();\n-      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n-      String[] reorderedColumnNames = new String[numSelectExpressions];\n-      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n-      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n-      for (int i = 0; i < numSelectExpressions; i++) {\n-        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n-        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n-      }\n-      while (rows.size() < limit && sortedIterator.hasNext()) {\n-        Record nextRecord = sortedIterator.next();\n-        Object[] values = nextRecord.getValues();\n-        for (int i = 0; i < _numAggregationFunctions; i++) {\n-          int valueIndex = i + _numGroupByExpressions;\n-          values[valueIndex] = AggregationFunctionUtils\n-              .getSerializableValue(_aggregationFunctions[i].extractFinalResult(values[valueIndex]));\n-        }\n \n-        Object[] reorderedValues = new Object[numSelectExpressions];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597705967ed172f0a08e6a7f46bbbbd49d7651c2"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQwOTUwNQ==", "bodyText": "Good point. Added comment inside PostAggregationHandler stating that the column re-ordering is handled inside.", "url": "https://github.com/apache/pinot/pull/5867#discussion_r472409505", "createdAt": "2020-08-18T18:50:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -160,103 +160,49 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n+    DataSchema prePostAggregationDataSchema = getPrePostAggregationDataSchema(dataSchema);\n     int limit = _queryContext.getLimit();\n     List<Object[]> rows = new ArrayList<>(limit);\n+    for (int i = 0; i < limit && sortedIterator.hasNext(); i++) {\n+      Object[] row = sortedIterator.next().getValues();\n+      for (int j = 0; j < _numAggregationFunctions; j++) {\n+        int valueIndex = j + _numGroupByExpressions;\n+        row[valueIndex] =\n+            AggregationFunctionUtils.getSerializableValue(_aggregationFunctions[j].extractFinalResult(row[valueIndex]));\n+      }\n+      rows.add(row);\n+    }\n \n     if (_sqlQuery) {\n       // SQL query with SQL group-by mode and response format\n-      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n-\n-      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n-      int numSelectExpressions = selectExpressionIndexMap.length;\n-      String[] columnNames = resultTableSchema.getColumnNames();\n-      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n-      String[] reorderedColumnNames = new String[numSelectExpressions];\n-      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n-      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n-      for (int i = 0; i < numSelectExpressions; i++) {\n-        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n-        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n-      }\n-      while (rows.size() < limit && sortedIterator.hasNext()) {\n-        Record nextRecord = sortedIterator.next();\n-        Object[] values = nextRecord.getValues();\n-        for (int i = 0; i < _numAggregationFunctions; i++) {\n-          int valueIndex = i + _numGroupByExpressions;\n-          values[valueIndex] = AggregationFunctionUtils\n-              .getSerializableValue(_aggregationFunctions[i].extractFinalResult(values[valueIndex]));\n-        }\n \n-        Object[] reorderedValues = new Object[numSelectExpressions];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4MTgyNA=="}, "originalCommit": {"oid": "597705967ed172f0a08e6a7f46bbbbd49d7651c2"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4000, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}