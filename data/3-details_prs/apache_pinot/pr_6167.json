{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MTkzNDM2", "number": 6167, "title": "Support reloading upsert table", "bodyText": "Description\nPart of a series of PRs for #4261\nRe-implement the PartitionUpsertMetadataManager to correctly handle the following 2 scenarios:\n\nReload the segment which replaces the upsert metadata of the existing segment\nManage the valid doc ids of the consuming segment within the manager so that the updates can be applied to the consuming segment\n\nOne behavior change is that if 2 records have the same timestamp, the second one won't replace the first one in order to reduce the number of updates.\nAdd PartitionUpsertMetadataManagerTest to verify the functionalities.", "createdAt": "2020-10-21T01:50:05Z", "url": "https://github.com/apache/pinot/pull/6167", "merged": true, "mergeCommit": {"oid": "d08fd5c3069d2c20124a5edb00d8b5506cb8522c"}, "closed": true, "closedAt": "2020-10-21T23:21:58Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUmvr-AFqTUxMzMwNzg1Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdU1ch1gFqTUxNDI0NDgzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMzA3ODU3", "url": "https://github.com/apache/pinot/pull/6167#pullrequestreview-513307857", "createdAt": "2020-10-21T05:02:01Z", "commit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNTowMjowMVrOHlaWIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNTo0MzozNlrOHlbFgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MTAxMA==", "bodyText": "Not sure if this old segment check is necessary:\n\nsince the old segment will be replaced, it shall be safe to update the valid doc, since it will be gone anyway?\nif so, then the handling is identical to the branch above, and therefore can be merged?", "url": "https://github.com/apache/pinot/pull/6167#discussion_r508991010", "createdAt": "2020-10-21T05:02:01Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MzExNA==", "bodyText": "wrap this in the else branch for better readability.", "url": "https://github.com/apache/pinot/pull/6167#discussion_r508993114", "createdAt": "2020-10-21T05:10:04Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.\n+              if (recordInfo._timestamp >= currentRecordLocation.getTimestamp()) {\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            }\n+            return currentRecordLocation;\n+          }\n+\n+          // Update the record location when getting a newer timestamp", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5NDAzOA==", "bodyText": "Is it possible that this immutable segment is queried before the enableUpsert  is invoked?\nIf so, _validDocIndex  will be null and confuse the query plan", "url": "https://github.com/apache/pinot/pull/6167#discussion_r508994038", "createdAt": "2020-10-21T05:13:34Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/immutable/ImmutableSegmentImpl.java", "diffHunk": "@@ -50,25 +51,29 @@\n   private final SegmentMetadataImpl _segmentMetadata;\n   private final Map<String, ColumnIndexContainer> _indexContainerMap;\n   private final StarTreeIndexContainer _starTreeIndexContainer;\n-  private final PartitionUpsertMetadataManager _partitionUpsertMetadataManager;\n-  private final ValidDocIndexReader _validDocIndex;\n+\n+  // For upsert\n+  private PartitionUpsertMetadataManager _partitionUpsertMetadataManager;\n+  private ThreadSafeMutableRoaringBitmap _validDocIds;\n+  private ValidDocIndexReader _validDocIndex;\n \n   public ImmutableSegmentImpl(SegmentDirectory segmentDirectory, SegmentMetadataImpl segmentMetadata,\n       Map<String, ColumnIndexContainer> columnIndexContainerMap,\n-      @Nullable StarTreeIndexContainer starTreeIndexContainer,\n-      @Nullable PartitionUpsertMetadataManager partitionUpsertMetadataManager) {\n+      @Nullable StarTreeIndexContainer starTreeIndexContainer) {\n     _segmentDirectory = segmentDirectory;\n     _segmentMetadata = segmentMetadata;\n     _indexContainerMap = columnIndexContainerMap;\n     _starTreeIndexContainer = starTreeIndexContainer;\n-    if (partitionUpsertMetadataManager != null) {\n-      _partitionUpsertMetadataManager = partitionUpsertMetadataManager;\n-      _validDocIndex =\n-          new ValidDocIndexReaderImpl(partitionUpsertMetadataManager.createValidDocIds(getSegmentName()));\n-    } else {\n-      _partitionUpsertMetadataManager = null;\n-      _validDocIndex = null;\n-    }\n+  }\n+\n+  /**\n+   * Enables upsert for this segment.\n+   */\n+  public void enableUpsert(PartitionUpsertMetadataManager partitionUpsertMetadataManager,\n+      ThreadSafeMutableRoaringBitmap validDocIds) {\n+    _partitionUpsertMetadataManager = partitionUpsertMetadataManager;\n+    _validDocIds = validDocIds;\n+    _validDocIndex = new ValidDocIndexReaderImpl(validDocIds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5NjUyOA==", "bodyText": "does this check the case that a replaced segment shall not remove the keys of the newly loaded? Perhaps we shall consider a state of tracking the current segmentImpl (and its corresponding validDocIds) for a segment name?", "url": "https://github.com/apache/pinot/pull/6167#discussion_r508996528", "createdAt": "2020-10-21T05:21:52Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.\n+              if (recordInfo._timestamp >= currentRecordLocation.getTimestamp()) {\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            }\n+            return currentRecordLocation;\n+          }\n+\n+          // Update the record location when getting a newer timestamp\n+          if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+            currentRecordLocation.getValidDocIds().remove(currentRecordLocation.getDocId());\n+            validDocIds.add(recordInfo._docId);\n+            return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+          } else {\n+            return currentRecordLocation;\n+          }\n+        } else {\n+          // New primary key\n+          validDocIds.add(recordInfo._docId);\n+          return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+        }\n+      });\n     }\n     return validDocIds;\n   }\n \n   /**\n-   * Returns the valid doc ids for the given (immutable) segment.\n-   */\n-  public ThreadSafeMutableRoaringBitmap getValidDocIds(String segmentName) {\n-    return Preconditions\n-        .checkNotNull(_segmentToValidDocIdsMap.get(segmentName), \"Failed to find valid doc ids for segment: %s\",\n-            segmentName);\n-  }\n-\n-  /**\n-   * Updates the record location of the given primary key if the given record location is newer than the current record\n-   * location. Also updates the valid doc ids accordingly if the record location is updated.\n+   * Updates the upsert metadata for a new consumed record in the given consuming segment.\n    */\n-  public void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation,\n+  public synchronized void updateRecord(String segmentName, RecordInfo recordInfo,\n       ThreadSafeMutableRoaringBitmap validDocIds) {\n-    _primaryKeyToRecordLocationMap.compute(primaryKey, (k, v) -> {\n-      if (v != null) {\n+    _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+      if (currentRecordLocation != null) {\n         // Existing primary key\n \n-        if (recordLocation.getTimestamp() >= v.getTimestamp()) {\n-          // Update the record location\n-          // NOTE: Update the record location when there is a tie on the timestamp because during the segment\n-          //       commitment, when loading the committed segment, it should replace the old record locations in case\n-          //       the order of records changed.\n-\n-          // Remove the doc from the valid doc ids of the previous location\n-          if (v.isConsuming()) {\n-            // Previous location is a consuming segment, whose valid doc ids are maintained locally. Only update the\n-            // valid doc ids when the update is from the same segment.\n-            if (recordLocation.isConsuming() && recordLocation.getSegmentName().equals(v.getSegmentName())) {\n-              validDocIds.remove(v.getDocId());\n-            }\n-          } else {\n-            ThreadSafeMutableRoaringBitmap validDocIdsForPreviousLocation =\n-                _segmentToValidDocIdsMap.get(v.getSegmentName());\n-            if (validDocIdsForPreviousLocation != null) {\n-              validDocIdsForPreviousLocation.remove(v.getDocId());\n-            } else {\n-              LOGGER.warn(\"Failed to find valid doc ids for previous location: {}\", v.getSegmentName());\n-            }\n-          }\n-\n-          validDocIds.add(recordLocation.getDocId());\n-          return recordLocation;\n+        // Update the record location when getting a newer timestamp\n+        if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+          currentRecordLocation.getValidDocIds().remove(currentRecordLocation.getDocId());\n+          validDocIds.add(recordInfo._docId);\n+          return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n         } else {\n-          // No need to update\n-          return v;\n+          return currentRecordLocation;\n         }\n       } else {\n         // New primary key\n-        validDocIds.add(recordLocation.getDocId());\n-        return recordLocation;\n+        validDocIds.add(recordInfo._docId);\n+        return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n       }\n     });\n   }\n \n   /**\n-   * Removes the upsert metadata for the given segment.\n+   * Removes the upsert metadata for the given immutable segment. No need to remove the upsert metadata for the\n+   * consuming segment because it should be replaced by the committed segment.\n    */\n-  public void removeSegment(String segmentName) {\n+  public synchronized void removeSegment(String segmentName, ThreadSafeMutableRoaringBitmap validDocIds) {\n     LOGGER.info(\"Removing upsert metadata for segment: {}\", segmentName);\n-    _primaryKeyToRecordLocationMap.forEach((k, v) -> {\n-      if (v.getSegmentName().equals(segmentName)) {\n-        // NOTE: Check and remove to prevent removing the key that is just updated.\n-        _primaryKeyToRecordLocationMap.remove(k, v);\n-      }\n-    });\n-    _segmentToValidDocIdsMap.remove(segmentName);\n+\n+    if (!validDocIds.getMutableRoaringBitmap().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMDI4NA==", "bodyText": "it's worth explaining this a bit on which data structures won't be reflected.", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509000284", "createdAt": "2020-10-21T05:34:33Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMDk1MQ==", "bodyText": "how is consuming segment related?", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509000951", "createdAt": "2020-10-21T05:36:37Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.\n+              if (recordInfo._timestamp >= currentRecordLocation.getTimestamp()) {\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            }\n+            return currentRecordLocation;\n+          }\n+\n+          // Update the record location when getting a newer timestamp\n+          if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+            currentRecordLocation.getValidDocIds().remove(currentRecordLocation.getDocId());\n+            validDocIds.add(recordInfo._docId);\n+            return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+          } else {\n+            return currentRecordLocation;\n+          }\n+        } else {\n+          // New primary key\n+          validDocIds.add(recordInfo._docId);\n+          return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+        }\n+      });\n     }\n     return validDocIds;\n   }\n \n   /**\n-   * Returns the valid doc ids for the given (immutable) segment.\n-   */\n-  public ThreadSafeMutableRoaringBitmap getValidDocIds(String segmentName) {\n-    return Preconditions\n-        .checkNotNull(_segmentToValidDocIdsMap.get(segmentName), \"Failed to find valid doc ids for segment: %s\",\n-            segmentName);\n-  }\n-\n-  /**\n-   * Updates the record location of the given primary key if the given record location is newer than the current record\n-   * location. Also updates the valid doc ids accordingly if the record location is updated.\n+   * Updates the upsert metadata for a new consumed record in the given consuming segment.\n    */\n-  public void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation,\n+  public synchronized void updateRecord(String segmentName, RecordInfo recordInfo,\n       ThreadSafeMutableRoaringBitmap validDocIds) {\n-    _primaryKeyToRecordLocationMap.compute(primaryKey, (k, v) -> {\n-      if (v != null) {\n+    _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+      if (currentRecordLocation != null) {\n         // Existing primary key\n \n-        if (recordLocation.getTimestamp() >= v.getTimestamp()) {\n-          // Update the record location\n-          // NOTE: Update the record location when there is a tie on the timestamp because during the segment\n-          //       commitment, when loading the committed segment, it should replace the old record locations in case\n-          //       the order of records changed.\n-\n-          // Remove the doc from the valid doc ids of the previous location\n-          if (v.isConsuming()) {\n-            // Previous location is a consuming segment, whose valid doc ids are maintained locally. Only update the\n-            // valid doc ids when the update is from the same segment.\n-            if (recordLocation.isConsuming() && recordLocation.getSegmentName().equals(v.getSegmentName())) {\n-              validDocIds.remove(v.getDocId());\n-            }\n-          } else {\n-            ThreadSafeMutableRoaringBitmap validDocIdsForPreviousLocation =\n-                _segmentToValidDocIdsMap.get(v.getSegmentName());\n-            if (validDocIdsForPreviousLocation != null) {\n-              validDocIdsForPreviousLocation.remove(v.getDocId());\n-            } else {\n-              LOGGER.warn(\"Failed to find valid doc ids for previous location: {}\", v.getSegmentName());\n-            }\n-          }\n-\n-          validDocIds.add(recordLocation.getDocId());\n-          return recordLocation;\n+        // Update the record location when getting a newer timestamp\n+        if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+          currentRecordLocation.getValidDocIds().remove(currentRecordLocation.getDocId());\n+          validDocIds.add(recordInfo._docId);\n+          return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n         } else {\n-          // No need to update\n-          return v;\n+          return currentRecordLocation;\n         }\n       } else {\n         // New primary key\n-        validDocIds.add(recordLocation.getDocId());\n-        return recordLocation;\n+        validDocIds.add(recordInfo._docId);\n+        return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n       }\n     });\n   }\n \n   /**\n-   * Removes the upsert metadata for the given segment.\n+   * Removes the upsert metadata for the given immutable segment. No need to remove the upsert metadata for the\n+   * consuming segment because it should be replaced by the committed segment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTM5Mg==", "bodyText": "not sure if ThreadSafeMutableRoaringBitmap  is the best identifier of the containing segment. Perhaps the segmentImpl itself, in case ThreadSafeMutableRoaringBitmap  itself may be replaced?", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509001392", "createdAt": "2020-10-21T05:38:14Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/RecordLocation.java", "diffHunk": "@@ -28,13 +28,13 @@\n   private final String _segmentName;\n   private final int _docId;\n   private final long _timestamp;\n-  private final boolean _isConsuming;\n+  private final ThreadSafeMutableRoaringBitmap _validDocIds;\n \n-  public RecordLocation(String segmentName, int docId, long timestamp, boolean isConsuming) {\n+  public RecordLocation(String segmentName, int docId, long timestamp, ThreadSafeMutableRoaringBitmap validDocIds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMjIzOA==", "bodyText": "nit: I think it's preferred to enable it as early as possible (i.e in the constructor), we know this segment will be an upsert one.", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509002238", "createdAt": "2020-10-21T05:40:44Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/plan/maker/MetadataAndDictionaryAggregationPlanMakerTest.java", "diffHunk": "@@ -117,8 +119,9 @@ public void buildSegment()\n   public void loadSegment()\n       throws Exception {\n     _indexSegment = ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap);\n-    _upsertIndexSegment = ImmutableSegmentLoader\n-        .load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap, new PartitionUpsertMetadataManager());\n+    _upsertIndexSegment = ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap);\n+    ((ImmutableSegmentImpl) _upsertIndexSegment)\n+        .enableUpsert(new PartitionUpsertMetadataManager(), new ThreadSafeMutableRoaringBitmap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzEzOA==", "bodyText": "shall we include the removal as part of the replace? the removal of the old shall be after the addition of the new?", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509003138", "createdAt": "2020-10-21T05:43:36Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.core.upsert.PartitionUpsertMetadataManager.RecordInfo;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertSame;\n+\n+\n+public class PartitionUpsertMetadataManagerTest {\n+  private static final String SEGMENT_PREFIX = \"testSegment\";\n+\n+  @Test\n+  public void testAddSegment() {\n+    PartitionUpsertMetadataManager upsertMetadataManager = new PartitionUpsertMetadataManager();\n+    Map<PrimaryKey, RecordLocation> recordLocationMap = upsertMetadataManager._primaryKeyToRecordLocationMap;\n+\n+    // Add the first segment\n+    String segment1 = SEGMENT_PREFIX + 1;\n+    List<RecordInfo> recordInfoList1 = new ArrayList<>();\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(0), 0, 100));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(1), 1, 100));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(2), 2, 100));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(0), 3, 80));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(1), 4, 120));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(0), 5, 100));\n+    ThreadSafeMutableRoaringBitmap validDocIds1 =\n+        upsertMetadataManager.addSegment(segment1, recordInfoList1.iterator());\n+    // segment1: 0 -> {0, 100}, 1 -> {4, 120}, 2 -> {2, 100}\n+    checkRecordLocation(recordLocationMap, 0, segment1, 0, 100);\n+    checkRecordLocation(recordLocationMap, 1, segment1, 4, 120);\n+    checkRecordLocation(recordLocationMap, 2, segment1, 2, 100);\n+    assertEquals(validDocIds1.getMutableRoaringBitmap().toArray(), new int[]{0, 2, 4});\n+\n+    // Add the second segment\n+    String segment2 = SEGMENT_PREFIX + 2;\n+    List<RecordInfo> recordInfoList2 = new ArrayList<>();\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(0), 0, 100));\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(1), 1, 100));\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(2), 2, 120));\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(3), 3, 80));\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(0), 4, 80));\n+    ThreadSafeMutableRoaringBitmap validDocIds2 =\n+        upsertMetadataManager.addSegment(segment2, recordInfoList2.iterator());\n+    // segment1: 0 -> {0, 100}, 1 -> {4, 120}\n+    // segment2: 2 -> {2, 120}, 3 -> {3, 80}\n+    checkRecordLocation(recordLocationMap, 0, segment1, 0, 100);\n+    checkRecordLocation(recordLocationMap, 1, segment1, 4, 120);\n+    checkRecordLocation(recordLocationMap, 2, segment2, 2, 120);\n+    checkRecordLocation(recordLocationMap, 3, segment2, 3, 80);\n+    assertEquals(validDocIds1.getMutableRoaringBitmap().toArray(), new int[]{0, 4});\n+    assertEquals(validDocIds2.getMutableRoaringBitmap().toArray(), new int[]{2, 3});\n+\n+    // Replace (reload) the first segment\n+    ThreadSafeMutableRoaringBitmap newValidDocIds1 =\n+        upsertMetadataManager.addSegment(segment1, recordInfoList1.iterator());\n+    // original segment1: 0 -> {0, 100}, 1 -> {4, 120}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a413132d0be8fe54ffef0523ef208c627d848706", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/a413132d0be8fe54ffef0523ef208c627d848706", "committedDate": "2020-10-21T18:37:42Z", "message": "Support reloading upsert table"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "392dfed95f4eee2116bea415a7fd418dd970bd79", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/392dfed95f4eee2116bea415a7fd418dd970bd79", "committedDate": "2020-10-21T18:37:42Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/60b932cf4bdd7c903e168d0f473151428a7db60f", "committedDate": "2020-10-21T01:38:57Z", "message": "Support reloading upsert table"}, "afterCommit": {"oid": "392dfed95f4eee2116bea415a7fd418dd970bd79", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/392dfed95f4eee2116bea415a7fd418dd970bd79", "committedDate": "2020-10-21T18:37:42Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7789b56d5598cc52df7d6218a9baa72a0ec0231", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/e7789b56d5598cc52df7d6218a9baa72a0ec0231", "committedDate": "2020-10-21T19:53:39Z", "message": "UpsertQuickStart minor fixed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjE5ODc5", "url": "https://github.com/apache/pinot/pull/6167#pullrequestreview-514219879", "createdAt": "2020-10-21T22:04:37Z", "commit": {"oid": "e7789b56d5598cc52df7d6218a9baa72a0ec0231"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowNDozN1rOHmIIhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowNzozNVrOHmIRAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MTE5MQ==", "bodyText": "ah I see. So the window could be until the segment seal. Makes sense.", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509741191", "createdAt": "2020-10-21T22:04:37Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MTAxMA=="}, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MjU5OQ==", "bodyText": "sgtm", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509742599", "createdAt": "2020-10-21T22:06:18Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/RecordLocation.java", "diffHunk": "@@ -28,13 +28,13 @@\n   private final String _segmentName;\n   private final int _docId;\n   private final long _timestamp;\n-  private final boolean _isConsuming;\n+  private final ThreadSafeMutableRoaringBitmap _validDocIds;\n \n-  public RecordLocation(String segmentName, int docId, long timestamp, boolean isConsuming) {\n+  public RecordLocation(String segmentName, int docId, long timestamp, ThreadSafeMutableRoaringBitmap validDocIds) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTM5Mg=="}, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MzM2MQ==", "bodyText": "okay, that's fair", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509743361", "createdAt": "2020-10-21T22:07:35Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/test/java/org/apache/pinot/core/plan/maker/MetadataAndDictionaryAggregationPlanMakerTest.java", "diffHunk": "@@ -117,8 +119,9 @@ public void buildSegment()\n   public void loadSegment()\n       throws Exception {\n     _indexSegment = ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap);\n-    _upsertIndexSegment = ImmutableSegmentLoader\n-        .load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap, new PartitionUpsertMetadataManager());\n+    _upsertIndexSegment = ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap);\n+    ((ImmutableSegmentImpl) _upsertIndexSegment)\n+        .enableUpsert(new PartitionUpsertMetadataManager(), new ThreadSafeMutableRoaringBitmap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMjIzOA=="}, "originalCommit": {"oid": "60b932cf4bdd7c903e168d0f473151428a7db60f"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjQ0ODM2", "url": "https://github.com/apache/pinot/pull/6167#pullrequestreview-514244836", "createdAt": "2020-10-21T22:51:51Z", "commit": {"oid": "e7789b56d5598cc52df7d6218a9baa72a0ec0231"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1629, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}