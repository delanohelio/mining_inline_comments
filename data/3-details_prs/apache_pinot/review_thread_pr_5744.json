{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1ODk5OTQ3", "number": 5744, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxNzoyOFrOESl2hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxOToxNVrOESl33g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTI5OTg5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxNzoyOFrOG324WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxNzoyOFrOG324WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDAyNA==", "bodyText": "Can be optimized to reduce the result holder lookup\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n          \n          \n            \n                      : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n          \n          \n            \n                  Geometry geometry = groupByResultHolder.getResult(groupKey);\n          \n          \n            \n                  if (geometry != null) {\n          \n          \n            \n                    geometry.union(value);\n          \n          \n            \n                  } else {\n          \n          \n            \n                    groupByResultHolder.setValueForKey(groupKey, value);\n          \n          \n            \n                  }", "url": "https://github.com/apache/pinot/pull/5744#discussion_r461224024", "createdAt": "2020-07-27T23:17:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTMwMDY1OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxNzo1MlrOG324zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxNzo1MlrOG324zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDE0Mw==", "bodyText": "Same here", "url": "https://github.com/apache/pinot/pull/5744#discussion_r461224143", "createdAt": "2020-07-27T23:17:52Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTMwMjM3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxODo0OVrOG3258A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMDozNjo1NFrOG5JN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQzMg==", "bodyText": "Need to handle null here", "url": "https://github.com/apache/pinot/pull/5744#discussion_r461224432", "createdAt": "2020-07-27T23:18:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk4MzUzMg==", "bodyText": "Can you explain the handling here, throw exception or something? My understanding is that the caller shall do the null handling?", "url": "https://github.com/apache/pinot/pull/5744#discussion_r461983532", "createdAt": "2020-07-29T01:24:16Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQzMg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3NTQyMQ==", "bodyText": "If there is no record selected, then aggregationResultHolder.getResult(); will return null because there is no value set yet. In that case, you should return an empty geometry as the result of the current segment", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462475421", "createdAt": "2020-07-29T17:43:36Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQzMg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NjAzMA==", "bodyText": "My question is why not use null as the placeholder instead of an empty abstract geometry? For example, in line #86 I checked if the group by result is null.\nPerhaps I miss something in the general null handling strategy in agg functions.", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462486030", "createdAt": "2020-07-29T18:00:57Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQzMg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxNDkyOQ==", "bodyText": "It won't work because DataTable does not support null as input (for sending back response from server to broker)", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462514929", "createdAt": "2020-07-29T18:51:23Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQzMg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMzczNA==", "bodyText": "ah, I see. So all aggregation result and group by result cannot use null as holders.", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462523734", "createdAt": "2020-07-29T19:06:48Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQzMg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3MDgwMw==", "bodyText": "The holder might contain null, but before returning the segment result, we need to convert null to the default value", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462570803", "createdAt": "2020-07-29T20:32:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQzMg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3MzA0NQ==", "bodyText": "yup. Makes sense to me now", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462573045", "createdAt": "2020-07-29T20:36:54Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQzMg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTMwMjU5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxODo1OFrOG326GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODo1MjoyNFrOG5FtUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQ3Mg==", "bodyText": "Need to handle null here (return an empty Geometry)", "url": "https://github.com/apache/pinot/pull/5744#discussion_r461224472", "createdAt": "2020-07-27T23:18:58Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk4NDU0OQ==", "bodyText": "same question. There is no empty geometry, but emty geometry per specific type, e.g. GEOMETRYCOLLECTION EMPTY, POINT EMPTY, LINESTRING EMPTY", "url": "https://github.com/apache/pinot/pull/5744#discussion_r461984549", "createdAt": "2020-07-29T01:27:58Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQ3Mg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3ODEyMg==", "bodyText": "We need to choose a default geometry to return when no record is selected. I think we can use empty Point as the default", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462478122", "createdAt": "2020-07-29T17:47:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQ3Mg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NjQ1Mw==", "bodyText": "can you show me a query that will exhibit this no-record case?", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462486453", "createdAt": "2020-07-29T18:01:43Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQ3Mg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxNTUzOA==", "bodyText": "SELECT ... WHERE col = \"no_match_value\"", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462515538", "createdAt": "2020-07-29T18:52:24Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDQ3Mg=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3OTMwMzM0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxOToxNlrOG326gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMDozMTo0OVrOG5JDeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDU3OA==", "bodyText": "Geometry is comparable?", "url": "https://github.com/apache/pinot/pull/5744#discussion_r461224578", "createdAt": "2020-07-27T23:19:16Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);\n+  }\n+\n+  @Override\n+  public Geometry merge(Geometry intermediateResult1, Geometry intermediateResult2) {\n+    return intermediateResult1.union(intermediateResult2);\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk4NTE3OQ==", "bodyText": "yes, https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/Geometry.html#compareTo-java.lang.Object-", "url": "https://github.com/apache/pinot/pull/5744#discussion_r461985179", "createdAt": "2020-07-29T01:30:10Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);\n+  }\n+\n+  @Override\n+  public Geometry merge(Geometry intermediateResult1, Geometry intermediateResult2) {\n+    return intermediateResult1.union(intermediateResult2);\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDU3OA=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NzM4NA==", "bodyText": "This is not the same comparison logic as the final result, so we should put false here.\nThis is for ordering the union geometry for group-by queries, which will use the final result ByteArray order. It does not make a lot of sense to order them though", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462487384", "createdAt": "2020-07-29T18:03:24Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);\n+  }\n+\n+  @Override\n+  public Geometry merge(Geometry intermediateResult1, Geometry intermediateResult2) {\n+    return intermediateResult1.union(intermediateResult2);\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDU3OA=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyODIxNQ==", "bodyText": "I see. So the assumption is that the intermediate result comparable order must be the same as the final result.", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462528215", "createdAt": "2020-07-29T19:14:29Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);\n+  }\n+\n+  @Override\n+  public Geometry merge(Geometry intermediateResult1, Geometry intermediateResult2) {\n+    return intermediateResult1.union(intermediateResult2);\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDU3OA=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3MDM2MQ==", "bodyText": "Yes, because they are for the same purpose", "url": "https://github.com/apache/pinot/pull/5744#discussion_r462570361", "createdAt": "2020-07-29T20:31:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/StUnionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+public class StUnionAggregationFunction extends BaseSingleInputAggregationFunction<Geometry, ByteArray> {\n+\n+  /**\n+   * Constructor for the class.\n+   *\n+   * @param expression Expression to aggregate on.\n+   */\n+  public StUnionAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.ST_UNION;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    Geometry geometry = aggregationResultHolder.getResult();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      geometry = geometry == null ? value : geometry.union(value);\n+    }\n+    aggregationResultHolder.setValue(geometry);\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      int groupKey = groupKeyArray[i];\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+          : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    byte[][] bytesArray = blockValSetMap.get(_expression).getBytesValuesSV();\n+    for (int i = 0; i < length; i++) {\n+      Geometry value = GeometrySerializer.deserialize(bytesArray[i]);\n+      for (int groupKey : groupKeysArray[i]) {\n+        groupByResultHolder.setValueForKey(groupKey, groupByResultHolder.getResult(groupKey) == null ? value\n+            : ((Geometry) groupByResultHolder.getResult(groupKey)).union(value));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Geometry extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    return aggregationResultHolder.getResult();\n+  }\n+\n+  @Override\n+  public Geometry extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    return groupByResultHolder.getResult(groupKey);\n+  }\n+\n+  @Override\n+  public Geometry merge(Geometry intermediateResult1, Geometry intermediateResult2) {\n+    return intermediateResult1.union(intermediateResult2);\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDU3OA=="}, "originalCommit": {"oid": "6baf45ab4cf580d34c2420fe8a837ada1df915b6"}, "originalPosition": 120}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4200, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}