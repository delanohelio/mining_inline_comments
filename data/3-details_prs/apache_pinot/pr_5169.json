{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxODAzMzEx", "number": 5169, "title": "Table level timeout implementation", "bodyText": "Introduced 3 levels of query timeout, where the first available one will be used:\n\nQuery-level: Passed under the query options with key 'timeoutMs'\nTable-level: Configured under the QueryConfig inside TableConfig\nInstance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed).", "createdAt": "2020-03-21T02:23:01Z", "url": "https://github.com/apache/pinot/pull/5169", "merged": true, "mergeCommit": {"oid": "ae484e572035eb66844770db9c22cf1f0096a1cc"}, "closed": true, "closedAt": "2020-03-24T02:13:54Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPsIPNABqjMxNTEzODkyNzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQond_gFqTM3OTk0MTUyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b307728b8a77205c9631d9301b1f87de9d65912a", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/b307728b8a77205c9631d9301b1f87de9d65912a", "committedDate": "2020-03-21T02:09:23Z", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed)."}, "afterCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "committedDate": "2020-03-21T02:59:34Z", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NzI5ODM4", "url": "https://github.com/apache/pinot/pull/5169#pullrequestreview-379729838", "createdAt": "2020-03-23T18:57:53Z", "commit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxOTowMDoxM1rOF6T2bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxOTowNzoxOVrOF6UGIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4Njk1OA==", "bodyText": "Can we move this line to just below Line 315 since this is the major logic of this code change in BaseBrokerRequestHandler?", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396686958", "createdAt": "2020-03-23T19:00:13Z", "author": {"login": "jackjlli"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +312,58 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Get the per-query timeout from the broker request query options if exists\n+    long queryTimeoutMs = QueryOptions.getTimeoutMs(brokerRequest.getQueryOptions());\n+    // Remaining time in milliseconds for the server query execution\n+    // Use the max of offline table remaining time and realtime table remaining time for hybrid use case\n+    long remainingTimeMs = 0;\n+    // NOTE: Use query-level timeout if exists, or use table-level timeout if exists, or use instance-level timeout", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4NzU3OQ==", "bodyText": "You can wrap this logic into a method so that offline and realtime table can reuse the same code.", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396687579", "createdAt": "2020-03-23T19:01:14Z", "author": {"login": "jackjlli"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +312,58 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Get the per-query timeout from the broker request query options if exists\n+    long queryTimeoutMs = QueryOptions.getTimeoutMs(brokerRequest.getQueryOptions());\n+    // Remaining time in milliseconds for the server query execution\n+    // Use the max of offline table remaining time and realtime table remaining time for hybrid use case\n+    long remainingTimeMs = 0;\n+    // NOTE: Use query-level timeout if exists, or use table-level timeout if exists, or use instance-level timeout\n+    if (offlineBrokerRequest != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4ODY3OQ==", "bodyText": "I saw there are two places which use different types of long. Can we unify them together? E.g. always use -1 to denote getTimeoutMs is null.", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396688679", "createdAt": "2020-03-23T19:03:09Z", "author": {"login": "jackjlli"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -354,9 +359,12 @@ public synchronized void buildRouting(String tableNameWithType) {\n       }\n     }\n \n+    QueryConfig queryConfig = tableConfig.getQueryConfig();\n+    Long timeoutMs = queryConfig != null ? queryConfig.getTimeoutMs() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4OTMzNw==", "bodyText": "Can we specify the timeout here? Is it the max overall timeout for each query?", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396689337", "createdAt": "2020-03-23T19:04:19Z", "author": {"login": "jackjlli"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -450,11 +458,22 @@ public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n     return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n   }\n \n+  /**\n+   * Returns the timeout in milliseconds for the given table, or {@code null} if the timeout is not configured in the\n+   * table config.\n+   */\n+  @Nullable\n+  public Long getTimeoutMs(String tableNameWithType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5MDk3Nw==", "bodyText": "Also, I notice in the test you specified TimeoutMs to be 0. Does 0 has special meaning? If yes, could you add it to the description of this variable?", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396690977", "createdAt": "2020-03-23T19:07:19Z", "author": {"login": "jackjlli"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -354,9 +359,12 @@ public synchronized void buildRouting(String tableNameWithType) {\n       }\n     }\n \n+    QueryConfig queryConfig = tableConfig.getQueryConfig();\n+    Long timeoutMs = queryConfig != null ? queryConfig.getTimeoutMs() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Nzc5NTQ2", "url": "https://github.com/apache/pinot/pull/5169#pullrequestreview-379779546", "createdAt": "2020-03-23T20:02:25Z", "commit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMDowMjoyNVrOF6WDuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMDoxNzo1OFrOF6Wi3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyMzEyOA==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.error(\"Caught exception while refreshing table config for table: {} (code: {}, type: {})\",\n          \n          \n            \n                  LOGGER.error(\"Caught exception while refreshing table config for table: {} (code: {}, error type: {})\",", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396723128", "createdAt": "2020-03-23T20:02:25Z", "author": {"login": "mcvsubbu"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -115,17 +121,15 @@ public HelixTaskResult handleMessage() {\n \n     @Override\n     public void onError(Exception e, ErrorCode errorCode, ErrorType errorType) {\n-      LOGGER.error(\"Caught exception while updating query quota of table: {} (code: {}, type: {})\", _tableNameWithType,\n-          errorCode, errorType, e);\n+      LOGGER.error(\"Caught exception while refreshing table config for table: {} (code: {}, type: {})\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyNDI2NQ==", "bodyText": "not sure why we should merge the 2 managers. Fetching table config, checking for disabled table, etc.  maybe yes.", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396724265", "createdAt": "2020-03-23T20:04:30Z", "author": {"login": "mcvsubbu"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -98,15 +101,18 @@ public void onError(Exception e, ErrorCode errorCode, ErrorType errorType) {\n     }\n   }\n \n-  private class QueryQuotaUpdateMessageHandler extends DefaultMessageHandler {\n+  private class RefreshTableConfigMessageHandler extends MessageHandler {\n+    final String _tableNameWithType;\n \n-    public QueryQuotaUpdateMessageHandler(QueryQuotaUpdateMessage queryQuotaUpdateMessage,\n-        NotificationContext context) {\n-      super(queryQuotaUpdateMessage, context);\n+    RefreshTableConfigMessageHandler(TableConfigRefreshMessage tableConfigRefreshMessage, NotificationContext context) {\n+      super(tableConfigRefreshMessage, context);\n+      _tableNameWithType = tableConfigRefreshMessage.getTableNameWithType();\n     }\n \n     @Override\n     public HelixTaskResult handleMessage() {\n+      // TODO: Fetch the table config here and pass it into the managers, or consider merging these 2 managers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyNTI3NA==", "bodyText": "It is better to leave the error message here, in case there is some issue with Helix. Most likely it wont be called anyway.", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396725274", "createdAt": "2020-03-23T20:06:22Z", "author": {"login": "mcvsubbu"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -136,8 +140,7 @@ public HelixTaskResult handleMessage() {\n     }\n \n     @Override\n-    public void onError(Exception e, ErrorCode errorCode, ErrorType errorType) {\n-      LOGGER.error(\"Caught exception on table: {} (code: {}, type: {})\", _tableNameWithType, errorCode, errorType, e);\n+    public void onError(Exception e, ErrorCode code, ErrorType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyOTc4Mw==", "bodyText": "Can you make a method out of the block between lines 324 and 338?  Logic seems to be repeated. At least, lines 324 to 331?", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396729783", "createdAt": "2020-03-23T20:15:14Z", "author": {"login": "mcvsubbu"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +312,58 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Get the per-query timeout from the broker request query options if exists\n+    long queryTimeoutMs = QueryOptions.getTimeoutMs(brokerRequest.getQueryOptions());\n+    // Remaining time in milliseconds for the server query execution\n+    // Use the max of offline table remaining time and realtime table remaining time for hybrid use case\n+    long remainingTimeMs = 0;\n+    // NOTE: Use query-level timeout if exists, or use table-level timeout if exists, or use instance-level timeout\n+    if (offlineBrokerRequest != null) {\n+      long offlineTimeoutMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMTEwMg==", "bodyText": "Math.min? Should we not take the stricter time to be the timeout value?", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396731102", "createdAt": "2020-03-23T20:17:58Z", "author": {"login": "mcvsubbu"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +312,58 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Get the per-query timeout from the broker request query options if exists\n+    long queryTimeoutMs = QueryOptions.getTimeoutMs(brokerRequest.getQueryOptions());\n+    // Remaining time in milliseconds for the server query execution\n+    // Use the max of offline table remaining time and realtime table remaining time for hybrid use case\n+    long remainingTimeMs = 0;\n+    // NOTE: Use query-level timeout if exists, or use table-level timeout if exists, or use instance-level timeout\n+    if (offlineBrokerRequest != null) {\n+      long offlineTimeoutMs;\n+      if (queryTimeoutMs > 0) {\n+        offlineTimeoutMs = queryTimeoutMs;\n+      } else {\n+        Long tableTimeoutMs = _routingManager.getTimeoutMs(offlineTableName);\n+        offlineTimeoutMs = tableTimeoutMs != null ? tableTimeoutMs : _brokerTimeoutMs;\n+      }\n+      long offlineRemainingTimeMs = offlineTimeoutMs - timeSpentMs;\n+      if (offlineRemainingTimeMs <= 0) {\n+        LOGGER.info(\"Offline table timed out (time spent: {}ms, timeout: {}) before scattering the request {}: {}\",\n+            timeSpentMs, offlineTimeoutMs, requestId, query);\n+        _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.REQUEST_TIMEOUT_BEFORE_SCATTERED_EXCEPTIONS, 1);\n+        return new BrokerResponseNative(QueryException.getException(QueryException.BROKER_TIMEOUT_ERROR, String\n+            .format(\"Offline table timed out (time spent: %dms, timeout: %dms) before scattering the request\",\n+                timeSpentMs, offlineTimeoutMs)));\n+      }\n+      offlineBrokerRequest.getQueryOptions()\n+          .put(Broker.Request.QueryOptionKey.TIMEOUT_MS, Long.toString(offlineRemainingTimeMs));\n+      remainingTimeMs = offlineRemainingTimeMs;\n+    }\n+    if (realtimeBrokerRequest != null) {\n+      long realtimeTimeoutMs;\n+      if (queryTimeoutMs > 0) {\n+        realtimeTimeoutMs = queryTimeoutMs;\n+      } else {\n+        Long tableTimeoutMs = _routingManager.getTimeoutMs(realtimeTableName);\n+        realtimeTimeoutMs = tableTimeoutMs != null ? tableTimeoutMs : _brokerTimeoutMs;\n+      }\n+      long realtimeRemainingTimeMs = realtimeTimeoutMs - timeSpentMs;\n+      if (realtimeRemainingTimeMs <= 0) {\n+        LOGGER.info(\"Realtime table timed out (time spent: {}ms, timeout: {}) before scattering the request {}: {}\",\n+            timeSpentMs, realtimeTimeoutMs, requestId, query);\n+        _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.REQUEST_TIMEOUT_BEFORE_SCATTERED_EXCEPTIONS, 1);\n+        return new BrokerResponseNative(QueryException.getException(QueryException.BROKER_TIMEOUT_ERROR, String\n+            .format(\"Realtime table timed out (time spent: %dms, timeout: %dms) before scattering the request\",\n+                timeSpentMs, realtimeTimeoutMs)));\n+      }\n+      realtimeBrokerRequest.getQueryOptions()\n+          .put(Broker.Request.QueryOptionKey.TIMEOUT_MS, Long.toString(realtimeRemainingTimeMs));\n+      remainingTimeMs = Math.max(remainingTimeMs, realtimeRemainingTimeMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "committedDate": "2020-03-21T02:59:34Z", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed)."}, "afterCommit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "committedDate": "2020-03-23T23:04:26Z", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5OTA4OTU5", "url": "https://github.com/apache/pinot/pull/5169#pullrequestreview-379908959", "createdAt": "2020-03-23T23:45:41Z", "commit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo0NTo0MVrOF6cSuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo0NTo0MVrOF6cSuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNTI3NQ==", "bodyText": "Configuring the two tables to have different timeout values seems to be an admin error, given that pinot treats the table configs independently. Under the given constraints, we can either use Math.max or Math.min, I suppose. It is worth adding a comment that this is an arbitrary choice. Perhaps max is better if we dont want queries suddenly timing out or having partial results due to stricter time limits.", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396825275", "createdAt": "2020-03-23T23:45:41Z", "author": {"login": "mcvsubbu"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +313,29 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Remaining time in milliseconds for the server query execution\n+    // NOTE: Use the max of offline table remaining time and realtime table remaining time for hybrid use case if the\n+    //       timeout for them are not configured to be the same. Server side will have different remaining time set for\n+    //       each table type, and broker should wait for both types to return.\n+    long remainingTimeMs = 0;\n+    try {\n+      if (offlineBrokerRequest != null) {\n+        remainingTimeMs = setQueryTimeout(offlineTableName, offlineBrokerRequest.getQueryOptions(), timeSpentMs);\n+      }\n+      if (realtimeBrokerRequest != null) {\n+        remainingTimeMs = Math.max(remainingTimeMs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5OTEwMjMy", "url": "https://github.com/apache/pinot/pull/5169#pullrequestreview-379910232", "createdAt": "2020-03-23T23:49:16Z", "commit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo0OToxN1rOF6cXKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo0OToxN1rOF6cXKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNjQxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Returns the timeout in milliseconds for the given table, or {@code null} if the timeout is not configured in the\n          \n          \n            \n               * Returns the query timeout in milliseconds for the given table, or {@code null} if the timeout is not configured in the", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396826410", "createdAt": "2020-03-23T23:49:17Z", "author": {"login": "mcvsubbu"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -450,11 +458,22 @@ public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n     return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n   }\n \n+  /**\n+   * Returns the timeout in milliseconds for the given table, or {@code null} if the timeout is not configured in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5OTEyOTYw", "url": "https://github.com/apache/pinot/pull/5169#pullrequestreview-379912960", "createdAt": "2020-03-23T23:57:27Z", "commit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1NzoyN1rOF6cgzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1NzoyN1rOF6cgzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyODg3OA==", "bodyText": "seems like a candidate for intermittent failure, good to add a comment on the circumstances under which this test can fail. I cant think of another way to add the test", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396828878", "createdAt": "2020-03-23T23:57:27Z", "author": {"login": "mcvsubbu"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/OfflineClusterIntegrationTest.java", "diffHunk": "@@ -185,6 +191,58 @@ public void testInvalidTableConfig() {\n     }\n   }\n \n+  @Test\n+  public void testRefreshTableConfigAndQueryTimeout()\n+      throws Exception {\n+    TableConfig tableConfig = _helixResourceManager.getOfflineTableConfig(getTableName());\n+    assertNotNull(tableConfig);\n+\n+    // Set timeout as 5ms so that query will timeout\n+    tableConfig.setQueryConfig(new QueryConfig(5L));\n+    _helixResourceManager.updateTableConfig(tableConfig);\n+\n+    // Wait for at most 1 minute for broker to receive and process the table config refresh message\n+    TestUtils.waitForCondition(aVoid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5OTEzMDYw", "url": "https://github.com/apache/pinot/pull/5169#pullrequestreview-379913060", "createdAt": "2020-03-23T23:57:43Z", "commit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ef05cd4621e5018de0e670cebbf7beda54f476d", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/1ef05cd4621e5018de0e670cebbf7beda54f476d", "committedDate": "2020-03-24T00:07:53Z", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "committedDate": "2020-03-23T23:04:26Z", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed)."}, "afterCommit": {"oid": "1ef05cd4621e5018de0e670cebbf7beda54f476d", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/1ef05cd4621e5018de0e670cebbf7beda54f476d", "committedDate": "2020-03-24T00:07:53Z", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5OTQxNTI2", "url": "https://github.com/apache/pinot/pull/5169#pullrequestreview-379941526", "createdAt": "2020-03-24T01:28:11Z", "commit": {"oid": "1ef05cd4621e5018de0e670cebbf7beda54f476d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1078, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}