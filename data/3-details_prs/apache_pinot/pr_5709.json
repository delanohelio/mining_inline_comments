{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5OTE3MjE3", "number": 5709, "title": "Store column min/max value into segment metadata", "bodyText": "Description\nStore column min/max value into segment metadata\nColumn min/max value is very useful information and can be used for query optimization.\nWhen creating the segment, we already collected the column min/max value, but not save them to the metadata.\nChanges:\n\nStore the already collected min/max value to the segment metadata\nDo not store string value with special characters that cannot be handled by the PropertiesConfiguration\nEnhance the SegmentColumnarIndexCreator.removeColumnMetadataInfo() to handle the removal of new added properties (PARTITION_FUNCTION etc.)\nSupport min/max value for BYTES columns\nChange default ColumnMinMaxValueGeneratorMode to ALL so that existing segments can have min/max value generated for all dictionary-encoded columns during segment load", "createdAt": "2020-07-16T05:53:58Z", "url": "https://github.com/apache/pinot/pull/5709", "merged": true, "mergeCommit": {"oid": "158f16c8a1c3c0203c553c6e8647ba016f9ef5fd"}, "closed": true, "closedAt": "2020-07-17T01:45:11Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1YxMDgH2gAyNDQ5OTE3MjE3OmZmNjc0NGIxMTEyZjE1NWIyNDY3NGJmODAwZjU2OWI0YzhmNjdjNzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1pHFjgFqTQ1MDMwODg2OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/ff6744b1112f155b24674bf800f569b4c8f67c70", "committedDate": "2020-07-16T05:55:31Z", "message": "Store column min/max value into segment metadata"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8a887e104d263f8b556f81835f17ece067787a6", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/c8a887e104d263f8b556f81835f17ece067787a6", "committedDate": "2020-07-16T05:51:33Z", "message": "Store column min/max value into segment metadata"}, "afterCommit": {"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/ff6744b1112f155b24674bf800f569b4c8f67c70", "committedDate": "2020-07-16T05:55:31Z", "message": "Store column min/max value into segment metadata"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTk5MzEy", "url": "https://github.com/apache/pinot/pull/5709#pullrequestreview-449999312", "createdAt": "2020-07-16T16:08:16Z", "commit": {"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjowODoxN1rOGyyEUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjoxMjoyOVrOGyyQNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjI4OQ==", "bodyText": "Since this is only escaping line character, so may be it should be name escapeLineCharacter?", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455902289", "createdAt": "2020-07-16T16:08:17Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -509,71 +509,61 @@ public static void addColumnMetadataInfo(PropertiesConfiguration properties, Str\n     properties.setProperty(getKeyFor(column, HAS_NULL_VALUE), String.valueOf(columnIndexCreationInfo.hasNulls()));\n     properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), textIndexType.name());\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, HAS_INVERTED_INDEX),\n-        String.valueOf(hasInvertedIndex));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_SINGLE_VALUED),\n-        String.valueOf(fieldSpec.isSingleValueField()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n+    properties.setProperty(getKeyFor(column, HAS_INVERTED_INDEX), String.valueOf(hasInvertedIndex));\n+    properties.setProperty(getKeyFor(column, IS_SINGLE_VALUED), String.valueOf(fieldSpec.isSingleValueField()));\n+    properties.setProperty(getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n         String.valueOf(columnIndexCreationInfo.getMaxNumberOfMultiValueElements()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n+    properties.setProperty(getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n         String.valueOf(columnIndexCreationInfo.getTotalNumberOfEntries()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_AUTO_GENERATED),\n-        String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n+    properties\n+        .setProperty(getKeyFor(column, IS_AUTO_GENERATED), String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n \n     PartitionFunction partitionFunction = columnIndexCreationInfo.getPartitionFunction();\n     if (partitionFunction != null) {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_FUNCTION),\n-          partitionFunction.toString());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, NUM_PARTITIONS),\n-          columnIndexCreationInfo.getNumPartitions());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_VALUES),\n-          columnIndexCreationInfo.getPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_FUNCTION), partitionFunction.toString());\n+      properties.setProperty(getKeyFor(column, NUM_PARTITIONS), columnIndexCreationInfo.getNumPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_VALUES), columnIndexCreationInfo.getPartitions());\n     }\n \n     // datetime field\n     if (fieldSpec.getFieldType().equals(FieldType.DATE_TIME)) {\n       DateTimeFieldSpec dateTimeFieldSpec = (DateTimeFieldSpec) fieldSpec;\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_FORMAT),\n-          dateTimeFieldSpec.getFormat());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_GRANULARITY),\n-          dateTimeFieldSpec.getGranularity());\n+      properties.setProperty(getKeyFor(column, DATETIME_FORMAT), dateTimeFieldSpec.getFormat());\n+      properties.setProperty(getKeyFor(column, DATETIME_GRANULARITY), dateTimeFieldSpec.getGranularity());\n     }\n \n-    Object defaultNullValue = columnIndexCreationInfo.getDefaultNullValue();\n-    if (defaultNullValue instanceof byte[]) {\n-      String defaultNullValueString = BytesUtils.toHexString((byte[]) defaultNullValue);\n-      properties\n-          .setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValueString);\n+    String minValue = columnIndexCreationInfo.getMin().toString();\n+    String maxValue = columnIndexCreationInfo.getMax().toString();\n+    String defaultNullValue = columnIndexCreationInfo.getDefaultNullValue().toString();\n+    if (dataType == DataType.STRING) {\n+      // Escape special character for STRING column\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), escapeSpecialCharacter(minValue));\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), escapeSpecialCharacter(maxValue));\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), escapeSpecialCharacter(defaultNullValue));\n     } else {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE),\n-          String.valueOf(defaultNullValue));\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValue);\n     }\n   }\n \n   public static void addColumnMinMaxValueInfo(PropertiesConfiguration properties, String column, String minValue,\n       String maxValue) {\n-    properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n-    properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+    // Escape special character for STRING column\n+    properties.setProperty(getKeyFor(column, MIN_VALUE), escapeSpecialCharacter(minValue));\n+    properties.setProperty(getKeyFor(column, MAX_VALUE), escapeSpecialCharacter(maxValue));\n+  }\n+\n+  /**\n+   * Helper method to escape special character for the property value.\n+   */\n+  private static String escapeSpecialCharacter(String value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTMzNQ==", "bodyText": "How about no-dictionary columns? We do go over all the values, so we should be able to compute that information even without dictionary?", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455905335", "createdAt": "2020-07-16T16:12:29Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/columnminmaxvalue/ColumnMinMaxValueGenerator.java", "diffHunk": "@@ -91,33 +92,46 @@ private void addColumnMinMaxValueForColumn(String columnName) throws Exception {\n     switch (dataType) {\n       case INT:\n         try (IntDictionary intDictionary = new IntDictionary(dictionaryBuffer, length)) {\n-          SegmentColumnarIndexCreator.addColumnMinMaxValueInfo(_segmentProperties, columnName,\n-              intDictionary.getStringValue(0), intDictionary.getStringValue(length - 1));\n+          SegmentColumnarIndexCreator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMDQwMDk3", "url": "https://github.com/apache/pinot/pull/5709#pullrequestreview-450040097", "createdAt": "2020-07-16T16:59:07Z", "commit": {"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjo1OTowN1rOGy0CEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjo1OTowN1rOGy0CEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNDQ4Mw==", "bodyText": "This was essentially setting the min and max value in SegmentMetadata right? It is then used in the code during pruning etc by deserializing into ColumnMetadata. May be I am missing something here?", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455934483", "createdAt": "2020-07-16T16:59:07Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -509,71 +509,61 @@ public static void addColumnMetadataInfo(PropertiesConfiguration properties, Str\n     properties.setProperty(getKeyFor(column, HAS_NULL_VALUE), String.valueOf(columnIndexCreationInfo.hasNulls()));\n     properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), textIndexType.name());\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, HAS_INVERTED_INDEX),\n-        String.valueOf(hasInvertedIndex));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_SINGLE_VALUED),\n-        String.valueOf(fieldSpec.isSingleValueField()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n+    properties.setProperty(getKeyFor(column, HAS_INVERTED_INDEX), String.valueOf(hasInvertedIndex));\n+    properties.setProperty(getKeyFor(column, IS_SINGLE_VALUED), String.valueOf(fieldSpec.isSingleValueField()));\n+    properties.setProperty(getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n         String.valueOf(columnIndexCreationInfo.getMaxNumberOfMultiValueElements()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n+    properties.setProperty(getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n         String.valueOf(columnIndexCreationInfo.getTotalNumberOfEntries()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_AUTO_GENERATED),\n-        String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n+    properties\n+        .setProperty(getKeyFor(column, IS_AUTO_GENERATED), String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n \n     PartitionFunction partitionFunction = columnIndexCreationInfo.getPartitionFunction();\n     if (partitionFunction != null) {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_FUNCTION),\n-          partitionFunction.toString());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, NUM_PARTITIONS),\n-          columnIndexCreationInfo.getNumPartitions());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_VALUES),\n-          columnIndexCreationInfo.getPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_FUNCTION), partitionFunction.toString());\n+      properties.setProperty(getKeyFor(column, NUM_PARTITIONS), columnIndexCreationInfo.getNumPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_VALUES), columnIndexCreationInfo.getPartitions());\n     }\n \n     // datetime field\n     if (fieldSpec.getFieldType().equals(FieldType.DATE_TIME)) {\n       DateTimeFieldSpec dateTimeFieldSpec = (DateTimeFieldSpec) fieldSpec;\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_FORMAT),\n-          dateTimeFieldSpec.getFormat());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_GRANULARITY),\n-          dateTimeFieldSpec.getGranularity());\n+      properties.setProperty(getKeyFor(column, DATETIME_FORMAT), dateTimeFieldSpec.getFormat());\n+      properties.setProperty(getKeyFor(column, DATETIME_GRANULARITY), dateTimeFieldSpec.getGranularity());\n     }\n \n-    Object defaultNullValue = columnIndexCreationInfo.getDefaultNullValue();\n-    if (defaultNullValue instanceof byte[]) {\n-      String defaultNullValueString = BytesUtils.toHexString((byte[]) defaultNullValue);\n-      properties\n-          .setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValueString);\n+    String minValue = columnIndexCreationInfo.getMin().toString();\n+    String maxValue = columnIndexCreationInfo.getMax().toString();\n+    String defaultNullValue = columnIndexCreationInfo.getDefaultNullValue().toString();\n+    if (dataType == DataType.STRING) {\n+      // Escape special character for STRING column\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), escapeSpecialCharacter(minValue));\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), escapeSpecialCharacter(maxValue));\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), escapeSpecialCharacter(defaultNullValue));\n     } else {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE),\n-          String.valueOf(defaultNullValue));\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValue);\n     }\n   }\n \n   public static void addColumnMinMaxValueInfo(PropertiesConfiguration properties, String column, String minValue,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70"}, "originalPosition": 85}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "477c1fd22eedc11c3b704cb4e86800beb12056f0", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/477c1fd22eedc11c3b704cb4e86800beb12056f0", "committedDate": "2020-07-16T17:56:25Z", "message": "Address comments"}, "afterCommit": {"oid": "54b50da643c09418a0b06f6cd406d17473cdd49f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/54b50da643c09418a0b06f6cd406d17473cdd49f", "committedDate": "2020-07-16T23:26:53Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "54b50da643c09418a0b06f6cd406d17473cdd49f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/54b50da643c09418a0b06f6cd406d17473cdd49f", "committedDate": "2020-07-16T23:26:53Z", "message": "Address comments"}, "afterCommit": {"oid": "50a0d49d19a2a78e5938b10d0d35578e0f5bdb25", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/50a0d49d19a2a78e5938b10d0d35578e0f5bdb25", "committedDate": "2020-07-17T00:00:49Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7c2f04a99c3d2c587f1ffae289400eaa402defa", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/d7c2f04a99c3d2c587f1ffae289400eaa402defa", "committedDate": "2020-07-17T00:31:12Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "50a0d49d19a2a78e5938b10d0d35578e0f5bdb25", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/50a0d49d19a2a78e5938b10d0d35578e0f5bdb25", "committedDate": "2020-07-17T00:00:49Z", "message": "Address comments"}, "afterCommit": {"oid": "d7c2f04a99c3d2c587f1ffae289400eaa402defa", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/d7c2f04a99c3d2c587f1ffae289400eaa402defa", "committedDate": "2020-07-17T00:31:12Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzA4MzM5", "url": "https://github.com/apache/pinot/pull/5709#pullrequestreview-450308339", "createdAt": "2020-07-17T00:56:09Z", "commit": {"oid": "d7c2f04a99c3d2c587f1ffae289400eaa402defa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMDo1NjowOVrOGzBuqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMDo1NjowOVrOGzBuqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE1ODg5MA==", "bodyText": "Not sure how we find out that these are the only comprehensive rules", "url": "https://github.com/apache/pinot/pull/5709#discussion_r456158890", "createdAt": "2020-07-17T00:56:09Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -509,71 +510,83 @@ public static void addColumnMetadataInfo(PropertiesConfiguration properties, Str\n     properties.setProperty(getKeyFor(column, HAS_NULL_VALUE), String.valueOf(columnIndexCreationInfo.hasNulls()));\n     properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), textIndexType.name());\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, HAS_INVERTED_INDEX),\n-        String.valueOf(hasInvertedIndex));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_SINGLE_VALUED),\n-        String.valueOf(fieldSpec.isSingleValueField()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n+    properties.setProperty(getKeyFor(column, HAS_INVERTED_INDEX), String.valueOf(hasInvertedIndex));\n+    properties.setProperty(getKeyFor(column, IS_SINGLE_VALUED), String.valueOf(fieldSpec.isSingleValueField()));\n+    properties.setProperty(getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n         String.valueOf(columnIndexCreationInfo.getMaxNumberOfMultiValueElements()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n+    properties.setProperty(getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n         String.valueOf(columnIndexCreationInfo.getTotalNumberOfEntries()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_AUTO_GENERATED),\n-        String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n+    properties\n+        .setProperty(getKeyFor(column, IS_AUTO_GENERATED), String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n \n     PartitionFunction partitionFunction = columnIndexCreationInfo.getPartitionFunction();\n     if (partitionFunction != null) {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_FUNCTION),\n-          partitionFunction.toString());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, NUM_PARTITIONS),\n-          columnIndexCreationInfo.getNumPartitions());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_VALUES),\n-          columnIndexCreationInfo.getPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_FUNCTION), partitionFunction.toString());\n+      properties.setProperty(getKeyFor(column, NUM_PARTITIONS), columnIndexCreationInfo.getNumPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_VALUES), columnIndexCreationInfo.getPartitions());\n     }\n \n     // datetime field\n     if (fieldSpec.getFieldType().equals(FieldType.DATE_TIME)) {\n       DateTimeFieldSpec dateTimeFieldSpec = (DateTimeFieldSpec) fieldSpec;\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_FORMAT),\n-          dateTimeFieldSpec.getFormat());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_GRANULARITY),\n-          dateTimeFieldSpec.getGranularity());\n+      properties.setProperty(getKeyFor(column, DATETIME_FORMAT), dateTimeFieldSpec.getFormat());\n+      properties.setProperty(getKeyFor(column, DATETIME_GRANULARITY), dateTimeFieldSpec.getGranularity());\n     }\n \n-    Object defaultNullValue = columnIndexCreationInfo.getDefaultNullValue();\n-    if (defaultNullValue instanceof byte[]) {\n-      String defaultNullValueString = BytesUtils.toHexString((byte[]) defaultNullValue);\n-      properties\n-          .setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValueString);\n+    String minValue = columnIndexCreationInfo.getMin().toString();\n+    String maxValue = columnIndexCreationInfo.getMax().toString();\n+    String defaultNullValue = columnIndexCreationInfo.getDefaultNullValue().toString();\n+    if (dataType == DataType.STRING) {\n+      // Check special characters for STRING column\n+      if (isValidPropertyValue(minValue)) {\n+        properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+      }\n+      if (isValidPropertyValue(maxValue)) {\n+        properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+      }\n+      if (isValidPropertyValue(defaultNullValue)) {\n+        properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValue);\n+      }\n     } else {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE),\n-          String.valueOf(defaultNullValue));\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValue);\n     }\n   }\n \n   public static void addColumnMinMaxValueInfo(PropertiesConfiguration properties, String column, String minValue,\n       String maxValue) {\n-    properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n-    properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+    // Check special characters for STRING column\n+    if (isValidPropertyValue(minValue)) {\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+    }\n+    if (isValidPropertyValue(maxValue)) {\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+    }\n+  }\n+\n+  /**\n+   * Helper method to check whether the given value is a valid property value.\n+   * <p>Value is invalid iff:\n+   * <ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c2f04a99c3d2c587f1ffae289400eaa402defa"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzA4ODY5", "url": "https://github.com/apache/pinot/pull/5709#pullrequestreview-450308869", "createdAt": "2020-07-17T00:57:55Z", "commit": {"oid": "d7c2f04a99c3d2c587f1ffae289400eaa402defa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 354, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}