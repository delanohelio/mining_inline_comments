{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5OTQyNzU2", "number": 6352, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMzo1NjowMFrOFF8nug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNTozNjoxOVrOFF_iJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzgwNDEwOnYy", "diffSide": "RIGHT", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/SimpleMinionClusterIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMzo1NjowMFrOIGtasA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTo0MDo1MFrOIHaWAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwNjQ4MA==", "bodyText": "expand the imports", "url": "https://github.com/apache/pinot/pull/6352#discussion_r543906480", "createdAt": "2020-12-16T03:56:00Z", "author": {"login": "xiangfu0"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/SimpleMinionClusterIntegrationTest.java", "diffHunk": "@@ -48,10 +48,7 @@\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Test;\n \n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNotNull;\n-import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU2Nzk0Mg==", "bodyText": "Per the code style, if there are >= 5 imports, they will be combined into *", "url": "https://github.com/apache/pinot/pull/6352#discussion_r544567942", "createdAt": "2020-12-16T19:33:50Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/SimpleMinionClusterIntegrationTest.java", "diffHunk": "@@ -48,10 +48,7 @@\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Test;\n \n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNotNull;\n-import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwNjQ4MA=="}, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MjU2MA==", "bodyText": "ah, good to know :)", "url": "https://github.com/apache/pinot/pull/6352#discussion_r544642560", "createdAt": "2020-12-16T21:40:50Z", "author": {"login": "xiangfu0"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/SimpleMinionClusterIntegrationTest.java", "diffHunk": "@@ -48,10 +48,7 @@\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Test;\n \n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNotNull;\n-import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwNjQ4MA=="}, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxODEyODc2OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNTowNDo1MFrOIGwl0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDo0MjoxN1rOIHfccw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk1ODQ4MQ==", "bodyText": "why this is always false?", "url": "https://github.com/apache/pinot/pull/6352#discussion_r543958481", "createdAt": "2020-12-16T05:04:50Z", "author": {"login": "xiangfu0"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "diffHunk": "@@ -63,99 +65,147 @@ public PinotTaskManager(PinotHelixTaskResourceManager helixTaskResourceManager,\n   }\n \n   /**\n-   * Returns the cluster info provider.\n-   * <p>\n-   * Cluster info provider might be useful when initializing task generators.\n-   *\n-   * @return Cluster info provider\n+   * Returns the cluster info accessor.\n+   * <p>Cluster info accessor can be used to initialize the task generator.\n    */\n   public ClusterInfoAccessor getClusterInfoAccessor() {\n     return _clusterInfoAccessor;\n   }\n \n   /**\n    * Registers a task generator.\n-   * <p>\n-   * This method can be used to plug in custom task generators.\n-   *\n-   * @param pinotTaskGenerator Task generator to be registered\n+   * <p>This method can be used to plug in custom task generators.\n    */\n-  public void registerTaskGenerator(PinotTaskGenerator pinotTaskGenerator) {\n-    _taskGeneratorRegistry.registerTaskGenerator(pinotTaskGenerator);\n+  public void registerTaskGenerator(PinotTaskGenerator taskGenerator) {\n+    _taskGeneratorRegistry.registerTaskGenerator(taskGenerator);\n   }\n \n   /**\n-   * Public API to schedule tasks. It doesn't matter whether current pinot controller is leader.\n+   * Public API to schedule tasks (all task types) for all tables. It might be called from the non-leader controller.\n+   * Returns a map from the task type to the task scheduled.\n    */\n   public synchronized Map<String, String> scheduleTasks() {\n-    Map<String, String> tasksScheduled = scheduleTasks(_pinotHelixResourceManager.getAllTables());\n-\n-    // Reset the task because this method will be called from the Rest API instead of the periodic task scheduler\n-    // TODO: Clean up only the non-leader tables instead of all tables\n-    cleanUpTask();\n-    setUpTask();\n-\n-    return tasksScheduled;\n+    return scheduleTasks(_pinotHelixResourceManager.getAllTables(), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU3MDYwMw==", "bodyText": "This method is connected to the rest endpoint, so the caller might not be the leader controller", "url": "https://github.com/apache/pinot/pull/6352#discussion_r544570603", "createdAt": "2020-12-16T19:37:55Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "diffHunk": "@@ -63,99 +65,147 @@ public PinotTaskManager(PinotHelixTaskResourceManager helixTaskResourceManager,\n   }\n \n   /**\n-   * Returns the cluster info provider.\n-   * <p>\n-   * Cluster info provider might be useful when initializing task generators.\n-   *\n-   * @return Cluster info provider\n+   * Returns the cluster info accessor.\n+   * <p>Cluster info accessor can be used to initialize the task generator.\n    */\n   public ClusterInfoAccessor getClusterInfoAccessor() {\n     return _clusterInfoAccessor;\n   }\n \n   /**\n    * Registers a task generator.\n-   * <p>\n-   * This method can be used to plug in custom task generators.\n-   *\n-   * @param pinotTaskGenerator Task generator to be registered\n+   * <p>This method can be used to plug in custom task generators.\n    */\n-  public void registerTaskGenerator(PinotTaskGenerator pinotTaskGenerator) {\n-    _taskGeneratorRegistry.registerTaskGenerator(pinotTaskGenerator);\n+  public void registerTaskGenerator(PinotTaskGenerator taskGenerator) {\n+    _taskGeneratorRegistry.registerTaskGenerator(taskGenerator);\n   }\n \n   /**\n-   * Public API to schedule tasks. It doesn't matter whether current pinot controller is leader.\n+   * Public API to schedule tasks (all task types) for all tables. It might be called from the non-leader controller.\n+   * Returns a map from the task type to the task scheduled.\n    */\n   public synchronized Map<String, String> scheduleTasks() {\n-    Map<String, String> tasksScheduled = scheduleTasks(_pinotHelixResourceManager.getAllTables());\n-\n-    // Reset the task because this method will be called from the Rest API instead of the periodic task scheduler\n-    // TODO: Clean up only the non-leader tables instead of all tables\n-    cleanUpTask();\n-    setUpTask();\n-\n-    return tasksScheduled;\n+    return scheduleTasks(_pinotHelixResourceManager.getAllTables(), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk1ODQ4MQ=="}, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MjQ3Mg==", "bodyText": "ic, so we actually always assume this call is from a non-leader.", "url": "https://github.com/apache/pinot/pull/6352#discussion_r544642472", "createdAt": "2020-12-16T21:40:40Z", "author": {"login": "xiangfu0"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "diffHunk": "@@ -63,99 +65,147 @@ public PinotTaskManager(PinotHelixTaskResourceManager helixTaskResourceManager,\n   }\n \n   /**\n-   * Returns the cluster info provider.\n-   * <p>\n-   * Cluster info provider might be useful when initializing task generators.\n-   *\n-   * @return Cluster info provider\n+   * Returns the cluster info accessor.\n+   * <p>Cluster info accessor can be used to initialize the task generator.\n    */\n   public ClusterInfoAccessor getClusterInfoAccessor() {\n     return _clusterInfoAccessor;\n   }\n \n   /**\n    * Registers a task generator.\n-   * <p>\n-   * This method can be used to plug in custom task generators.\n-   *\n-   * @param pinotTaskGenerator Task generator to be registered\n+   * <p>This method can be used to plug in custom task generators.\n    */\n-  public void registerTaskGenerator(PinotTaskGenerator pinotTaskGenerator) {\n-    _taskGeneratorRegistry.registerTaskGenerator(pinotTaskGenerator);\n+  public void registerTaskGenerator(PinotTaskGenerator taskGenerator) {\n+    _taskGeneratorRegistry.registerTaskGenerator(taskGenerator);\n   }\n \n   /**\n-   * Public API to schedule tasks. It doesn't matter whether current pinot controller is leader.\n+   * Public API to schedule tasks (all task types) for all tables. It might be called from the non-leader controller.\n+   * Returns a map from the task type to the task scheduled.\n    */\n   public synchronized Map<String, String> scheduleTasks() {\n-    Map<String, String> tasksScheduled = scheduleTasks(_pinotHelixResourceManager.getAllTables());\n-\n-    // Reset the task because this method will be called from the Rest API instead of the periodic task scheduler\n-    // TODO: Clean up only the non-leader tables instead of all tables\n-    cleanUpTask();\n-    setUpTask();\n-\n-    return tasksScheduled;\n+    return scheduleTasks(_pinotHelixResourceManager.getAllTables(), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk1ODQ4MQ=="}, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyNjEzMQ==", "bodyText": "Yes, if it is not always the leader, we need to assume it is not the leader", "url": "https://github.com/apache/pinot/pull/6352#discussion_r544726131", "createdAt": "2020-12-17T00:42:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "diffHunk": "@@ -63,99 +65,147 @@ public PinotTaskManager(PinotHelixTaskResourceManager helixTaskResourceManager,\n   }\n \n   /**\n-   * Returns the cluster info provider.\n-   * <p>\n-   * Cluster info provider might be useful when initializing task generators.\n-   *\n-   * @return Cluster info provider\n+   * Returns the cluster info accessor.\n+   * <p>Cluster info accessor can be used to initialize the task generator.\n    */\n   public ClusterInfoAccessor getClusterInfoAccessor() {\n     return _clusterInfoAccessor;\n   }\n \n   /**\n    * Registers a task generator.\n-   * <p>\n-   * This method can be used to plug in custom task generators.\n-   *\n-   * @param pinotTaskGenerator Task generator to be registered\n+   * <p>This method can be used to plug in custom task generators.\n    */\n-  public void registerTaskGenerator(PinotTaskGenerator pinotTaskGenerator) {\n-    _taskGeneratorRegistry.registerTaskGenerator(pinotTaskGenerator);\n+  public void registerTaskGenerator(PinotTaskGenerator taskGenerator) {\n+    _taskGeneratorRegistry.registerTaskGenerator(taskGenerator);\n   }\n \n   /**\n-   * Public API to schedule tasks. It doesn't matter whether current pinot controller is leader.\n+   * Public API to schedule tasks (all task types) for all tables. It might be called from the non-leader controller.\n+   * Returns a map from the task type to the task scheduled.\n    */\n   public synchronized Map<String, String> scheduleTasks() {\n-    Map<String, String> tasksScheduled = scheduleTasks(_pinotHelixResourceManager.getAllTables());\n-\n-    // Reset the task because this method will be called from the Rest API instead of the periodic task scheduler\n-    // TODO: Clean up only the non-leader tables instead of all tables\n-    cleanUpTask();\n-    setUpTask();\n-\n-    return tasksScheduled;\n+    return scheduleTasks(_pinotHelixResourceManager.getAllTables(), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk1ODQ4MQ=="}, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxODI4MTMyOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNTozNjoxOVrOIGyE5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTo0MjowM1rOIHaYwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk4MjgyMg==", "bodyText": "Is it possible that we return this info to the client-side? I feel this information is useful for users to test and debug.", "url": "https://github.com/apache/pinot/pull/6352#discussion_r543982822", "createdAt": "2020-12-16T05:36:19Z", "author": {"login": "xiangfu0"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "diffHunk": "@@ -63,99 +65,147 @@ public PinotTaskManager(PinotHelixTaskResourceManager helixTaskResourceManager,\n   }\n \n   /**\n-   * Returns the cluster info provider.\n-   * <p>\n-   * Cluster info provider might be useful when initializing task generators.\n-   *\n-   * @return Cluster info provider\n+   * Returns the cluster info accessor.\n+   * <p>Cluster info accessor can be used to initialize the task generator.\n    */\n   public ClusterInfoAccessor getClusterInfoAccessor() {\n     return _clusterInfoAccessor;\n   }\n \n   /**\n    * Registers a task generator.\n-   * <p>\n-   * This method can be used to plug in custom task generators.\n-   *\n-   * @param pinotTaskGenerator Task generator to be registered\n+   * <p>This method can be used to plug in custom task generators.\n    */\n-  public void registerTaskGenerator(PinotTaskGenerator pinotTaskGenerator) {\n-    _taskGeneratorRegistry.registerTaskGenerator(pinotTaskGenerator);\n+  public void registerTaskGenerator(PinotTaskGenerator taskGenerator) {\n+    _taskGeneratorRegistry.registerTaskGenerator(taskGenerator);\n   }\n \n   /**\n-   * Public API to schedule tasks. It doesn't matter whether current pinot controller is leader.\n+   * Public API to schedule tasks (all task types) for all tables. It might be called from the non-leader controller.\n+   * Returns a map from the task type to the task scheduled.\n    */\n   public synchronized Map<String, String> scheduleTasks() {\n-    Map<String, String> tasksScheduled = scheduleTasks(_pinotHelixResourceManager.getAllTables());\n-\n-    // Reset the task because this method will be called from the Rest API instead of the periodic task scheduler\n-    // TODO: Clean up only the non-leader tables instead of all tables\n-    cleanUpTask();\n-    setUpTask();\n-\n-    return tasksScheduled;\n+    return scheduleTasks(_pinotHelixResourceManager.getAllTables(), false);\n   }\n \n   /**\n-   * Check the Pinot cluster status and schedule new tasks for the given tables.\n-   *\n-   * @param tableNamesWithType List of table names with type suffix\n-   * @return Map from task type to task scheduled\n+   * Helper method to schedule tasks (all task types) for the given tables that have the tasks enabled. Returns a map\n+   * from the task type to the task scheduled.\n    */\n-  private synchronized Map<String, String> scheduleTasks(List<String> tableNamesWithType) {\n+  private synchronized Map<String, String> scheduleTasks(List<String> tableNamesWithType, boolean isLeader) {\n     _controllerMetrics.addMeteredGlobalValue(ControllerMeter.NUMBER_TIMES_SCHEDULE_TASKS_CALLED, 1L);\n \n     Set<String> taskTypes = _taskGeneratorRegistry.getAllTaskTypes();\n-    int numTaskTypes = taskTypes.size();\n-    Map<String, List<TableConfig>> enabledTableConfigMap = new HashMap<>(numTaskTypes);\n-\n-    for (String taskType : taskTypes) {\n-      enabledTableConfigMap.put(taskType, new ArrayList<>());\n-\n-      // Ensure all task queues exist\n-      _helixTaskResourceManager.ensureTaskQueueExists(taskType);\n-    }\n+    Map<String, List<TableConfig>> enabledTableConfigMap = new HashMap<>();\n \n     // Scan all table configs to get the tables with tasks enabled\n     for (String tableNameWithType : tableNamesWithType) {\n       TableConfig tableConfig = _pinotHelixResourceManager.getTableConfig(tableNameWithType);\n-      if (tableConfig != null) {\n-        TableTaskConfig taskConfig = tableConfig.getTaskConfig();\n-        if (taskConfig != null) {\n-          for (String taskType : taskTypes) {\n-            if (taskConfig.isTaskTypeEnabled(taskType)) {\n-              enabledTableConfigMap.get(taskType).add(tableConfig);\n-            }\n+      if (tableConfig != null && tableConfig.getTaskConfig() != null) {\n+        Set<String> enabledTaskTypes = tableConfig.getTaskConfig().getTaskTypeConfigsMap().keySet();\n+        for (String enabledTaskType : enabledTaskTypes) {\n+          if (taskTypes.contains(enabledTaskType)) {\n+            enabledTableConfigMap.computeIfAbsent(enabledTaskType, k -> new ArrayList<>()).add(tableConfig);\n+          } else {\n+            LOGGER.warn(\"Task type: {} is not registered, cannot enable it for table: {}\", enabledTaskType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYwODMwMg==", "bodyText": "Good point. We cannot directly return the message without backward-incompatible change on the rest endpoint (currently returns the map from task type to task scheduled). I made the change so that the returned map contains all the task types within the table configs, and if the task type is not registered, there will be no task scheduled (value is null for the task type), and then user can look into the log and find the reason.", "url": "https://github.com/apache/pinot/pull/6352#discussion_r544608302", "createdAt": "2020-12-16T20:41:04Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "diffHunk": "@@ -63,99 +65,147 @@ public PinotTaskManager(PinotHelixTaskResourceManager helixTaskResourceManager,\n   }\n \n   /**\n-   * Returns the cluster info provider.\n-   * <p>\n-   * Cluster info provider might be useful when initializing task generators.\n-   *\n-   * @return Cluster info provider\n+   * Returns the cluster info accessor.\n+   * <p>Cluster info accessor can be used to initialize the task generator.\n    */\n   public ClusterInfoAccessor getClusterInfoAccessor() {\n     return _clusterInfoAccessor;\n   }\n \n   /**\n    * Registers a task generator.\n-   * <p>\n-   * This method can be used to plug in custom task generators.\n-   *\n-   * @param pinotTaskGenerator Task generator to be registered\n+   * <p>This method can be used to plug in custom task generators.\n    */\n-  public void registerTaskGenerator(PinotTaskGenerator pinotTaskGenerator) {\n-    _taskGeneratorRegistry.registerTaskGenerator(pinotTaskGenerator);\n+  public void registerTaskGenerator(PinotTaskGenerator taskGenerator) {\n+    _taskGeneratorRegistry.registerTaskGenerator(taskGenerator);\n   }\n \n   /**\n-   * Public API to schedule tasks. It doesn't matter whether current pinot controller is leader.\n+   * Public API to schedule tasks (all task types) for all tables. It might be called from the non-leader controller.\n+   * Returns a map from the task type to the task scheduled.\n    */\n   public synchronized Map<String, String> scheduleTasks() {\n-    Map<String, String> tasksScheduled = scheduleTasks(_pinotHelixResourceManager.getAllTables());\n-\n-    // Reset the task because this method will be called from the Rest API instead of the periodic task scheduler\n-    // TODO: Clean up only the non-leader tables instead of all tables\n-    cleanUpTask();\n-    setUpTask();\n-\n-    return tasksScheduled;\n+    return scheduleTasks(_pinotHelixResourceManager.getAllTables(), false);\n   }\n \n   /**\n-   * Check the Pinot cluster status and schedule new tasks for the given tables.\n-   *\n-   * @param tableNamesWithType List of table names with type suffix\n-   * @return Map from task type to task scheduled\n+   * Helper method to schedule tasks (all task types) for the given tables that have the tasks enabled. Returns a map\n+   * from the task type to the task scheduled.\n    */\n-  private synchronized Map<String, String> scheduleTasks(List<String> tableNamesWithType) {\n+  private synchronized Map<String, String> scheduleTasks(List<String> tableNamesWithType, boolean isLeader) {\n     _controllerMetrics.addMeteredGlobalValue(ControllerMeter.NUMBER_TIMES_SCHEDULE_TASKS_CALLED, 1L);\n \n     Set<String> taskTypes = _taskGeneratorRegistry.getAllTaskTypes();\n-    int numTaskTypes = taskTypes.size();\n-    Map<String, List<TableConfig>> enabledTableConfigMap = new HashMap<>(numTaskTypes);\n-\n-    for (String taskType : taskTypes) {\n-      enabledTableConfigMap.put(taskType, new ArrayList<>());\n-\n-      // Ensure all task queues exist\n-      _helixTaskResourceManager.ensureTaskQueueExists(taskType);\n-    }\n+    Map<String, List<TableConfig>> enabledTableConfigMap = new HashMap<>();\n \n     // Scan all table configs to get the tables with tasks enabled\n     for (String tableNameWithType : tableNamesWithType) {\n       TableConfig tableConfig = _pinotHelixResourceManager.getTableConfig(tableNameWithType);\n-      if (tableConfig != null) {\n-        TableTaskConfig taskConfig = tableConfig.getTaskConfig();\n-        if (taskConfig != null) {\n-          for (String taskType : taskTypes) {\n-            if (taskConfig.isTaskTypeEnabled(taskType)) {\n-              enabledTableConfigMap.get(taskType).add(tableConfig);\n-            }\n+      if (tableConfig != null && tableConfig.getTaskConfig() != null) {\n+        Set<String> enabledTaskTypes = tableConfig.getTaskConfig().getTaskTypeConfigsMap().keySet();\n+        for (String enabledTaskType : enabledTaskTypes) {\n+          if (taskTypes.contains(enabledTaskType)) {\n+            enabledTableConfigMap.computeIfAbsent(enabledTaskType, k -> new ArrayList<>()).add(tableConfig);\n+          } else {\n+            LOGGER.warn(\"Task type: {} is not registered, cannot enable it for table: {}\", enabledTaskType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk4MjgyMg=="}, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MzI2NA==", "bodyText": "true,  maybe we add a new array field like \"errors\" later to hold these information.", "url": "https://github.com/apache/pinot/pull/6352#discussion_r544643264", "createdAt": "2020-12-16T21:42:03Z", "author": {"login": "xiangfu0"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/PinotTaskManager.java", "diffHunk": "@@ -63,99 +65,147 @@ public PinotTaskManager(PinotHelixTaskResourceManager helixTaskResourceManager,\n   }\n \n   /**\n-   * Returns the cluster info provider.\n-   * <p>\n-   * Cluster info provider might be useful when initializing task generators.\n-   *\n-   * @return Cluster info provider\n+   * Returns the cluster info accessor.\n+   * <p>Cluster info accessor can be used to initialize the task generator.\n    */\n   public ClusterInfoAccessor getClusterInfoAccessor() {\n     return _clusterInfoAccessor;\n   }\n \n   /**\n    * Registers a task generator.\n-   * <p>\n-   * This method can be used to plug in custom task generators.\n-   *\n-   * @param pinotTaskGenerator Task generator to be registered\n+   * <p>This method can be used to plug in custom task generators.\n    */\n-  public void registerTaskGenerator(PinotTaskGenerator pinotTaskGenerator) {\n-    _taskGeneratorRegistry.registerTaskGenerator(pinotTaskGenerator);\n+  public void registerTaskGenerator(PinotTaskGenerator taskGenerator) {\n+    _taskGeneratorRegistry.registerTaskGenerator(taskGenerator);\n   }\n \n   /**\n-   * Public API to schedule tasks. It doesn't matter whether current pinot controller is leader.\n+   * Public API to schedule tasks (all task types) for all tables. It might be called from the non-leader controller.\n+   * Returns a map from the task type to the task scheduled.\n    */\n   public synchronized Map<String, String> scheduleTasks() {\n-    Map<String, String> tasksScheduled = scheduleTasks(_pinotHelixResourceManager.getAllTables());\n-\n-    // Reset the task because this method will be called from the Rest API instead of the periodic task scheduler\n-    // TODO: Clean up only the non-leader tables instead of all tables\n-    cleanUpTask();\n-    setUpTask();\n-\n-    return tasksScheduled;\n+    return scheduleTasks(_pinotHelixResourceManager.getAllTables(), false);\n   }\n \n   /**\n-   * Check the Pinot cluster status and schedule new tasks for the given tables.\n-   *\n-   * @param tableNamesWithType List of table names with type suffix\n-   * @return Map from task type to task scheduled\n+   * Helper method to schedule tasks (all task types) for the given tables that have the tasks enabled. Returns a map\n+   * from the task type to the task scheduled.\n    */\n-  private synchronized Map<String, String> scheduleTasks(List<String> tableNamesWithType) {\n+  private synchronized Map<String, String> scheduleTasks(List<String> tableNamesWithType, boolean isLeader) {\n     _controllerMetrics.addMeteredGlobalValue(ControllerMeter.NUMBER_TIMES_SCHEDULE_TASKS_CALLED, 1L);\n \n     Set<String> taskTypes = _taskGeneratorRegistry.getAllTaskTypes();\n-    int numTaskTypes = taskTypes.size();\n-    Map<String, List<TableConfig>> enabledTableConfigMap = new HashMap<>(numTaskTypes);\n-\n-    for (String taskType : taskTypes) {\n-      enabledTableConfigMap.put(taskType, new ArrayList<>());\n-\n-      // Ensure all task queues exist\n-      _helixTaskResourceManager.ensureTaskQueueExists(taskType);\n-    }\n+    Map<String, List<TableConfig>> enabledTableConfigMap = new HashMap<>();\n \n     // Scan all table configs to get the tables with tasks enabled\n     for (String tableNameWithType : tableNamesWithType) {\n       TableConfig tableConfig = _pinotHelixResourceManager.getTableConfig(tableNameWithType);\n-      if (tableConfig != null) {\n-        TableTaskConfig taskConfig = tableConfig.getTaskConfig();\n-        if (taskConfig != null) {\n-          for (String taskType : taskTypes) {\n-            if (taskConfig.isTaskTypeEnabled(taskType)) {\n-              enabledTableConfigMap.get(taskType).add(tableConfig);\n-            }\n+      if (tableConfig != null && tableConfig.getTaskConfig() != null) {\n+        Set<String> enabledTaskTypes = tableConfig.getTaskConfig().getTaskTypeConfigsMap().keySet();\n+        for (String enabledTaskType : enabledTaskTypes) {\n+          if (taskTypes.contains(enabledTaskType)) {\n+            enabledTableConfigMap.computeIfAbsent(enabledTaskType, k -> new ArrayList<>()).add(tableConfig);\n+          } else {\n+            LOGGER.warn(\"Task type: {} is not registered, cannot enable it for table: {}\", enabledTaskType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk4MjgyMg=="}, "originalCommit": {"oid": "1a3f264c66210176b0fb31d8a2e4f944a1b73119"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3035, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}