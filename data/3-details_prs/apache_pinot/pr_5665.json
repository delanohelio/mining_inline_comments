{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1ODEzOTkw", "number": 5665, "title": "Re-implement TarGzCompressionUtils", "bodyText": "Currently several tests are flaky because of the tar-gz compression\nIn thie PR:\n\nUpgrade commons-compress to 1.20 for the bug in this ticket: https://issues.apache.org/jira/browse/COMPRESS-417\nRe-implement TarGzCompressionUtils following the library user guide: https://commons.apache.org/proper/commons-compress/examples.html\nWith the re-implemented TarGzCompressionUtils, simplify the code for the caller", "createdAt": "2020-07-08T01:00:25Z", "url": "https://github.com/apache/pinot/pull/5665", "merged": true, "mergeCommit": {"oid": "7708341ebf4d3d760eaa11d83fed7ac5556d5312"}, "closed": true, "closedAt": "2020-07-17T23:57:26Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcywkESAH2gAyNDQ1ODEzOTkwOmY2ODM2ODhiZjA5ZGVmM2Q0MWE0M2IyZGVlOTYyNmNmYjFiNmQxYmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc14BAVgFqTQ1MDg2NzE0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "committedDate": "2020-07-08T01:57:08Z", "message": "Re-implement TarGzCompressionUtils\n\nCurrently several tests are flaky because of the tar-gz compression\n\nIn thie PR:\n- Upgrade commons-compress to 1.20 for the bug in this ticket: https://issues.apache.org/jira/browse/COMPRESS-417\n- Re-implement TarGzCompressionUtils following the library user guide: https://commons.apache.org/proper/commons-compress/examples.html\n- With the re-implemented TarGzCompressionUtils, simplify the code for the caller"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2de273ecb654cfa9ccda89c07b9980075657239", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/f2de273ecb654cfa9ccda89c07b9980075657239", "committedDate": "2020-07-08T00:54:46Z", "message": "Re-implement TarGzCompressionUtils\n\nCurrently several tests are flaky because of the tar-gz compression\n\nIn thie PR:\n- Upgrade commons-compress to 1.20 for the bug in this ticket: https://issues.apache.org/jira/browse/COMPRESS-417\n- Re-implement TarGzCompressionUtils following the library user guide: https://commons.apache.org/proper/commons-compress/examples.html\n- With the re-implemented TarGzCompressionUtils, simplify the code for the caller"}, "afterCommit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "committedDate": "2020-07-08T01:57:08Z", "message": "Re-implement TarGzCompressionUtils\n\nCurrently several tests are flaky because of the tar-gz compression\n\nIn thie PR:\n- Upgrade commons-compress to 1.20 for the bug in this ticket: https://issues.apache.org/jira/browse/COMPRESS-417\n- Re-implement TarGzCompressionUtils following the library user guide: https://commons.apache.org/proper/commons-compress/examples.html\n- With the re-implemented TarGzCompressionUtils, simplify the code for the caller"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDcyMjIz", "url": "https://github.com/apache/pinot/pull/5665#pullrequestreview-446072223", "createdAt": "2020-07-10T01:46:27Z", "commit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMTo0NjoyN1rOGvnOYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMTo0NjoyN1rOGvnOYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODkxNA==", "bodyText": "Which part is flakey in the current code?", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452578914", "createdAt": "2020-07-10T01:46:27Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDcyMjY4", "url": "https://github.com/apache/pinot/pull/5665#pullrequestreview-446072268", "createdAt": "2020-07-10T01:46:37Z", "commit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMTo0NjozOFrOGvnOgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMTo0NjozOFrOGvnOgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODk0NA==", "bodyText": "When will this not be true? File outputFile = outputDir should ensure it is always true?", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452578944", "createdAt": "2020-07-10T01:46:38Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);\n+  private TarGzCompressionUtils() {\n+  }\n+\n   public static final String TAR_GZ_FILE_EXTENSION = \".tar.gz\";\n+  private static final char ENTRY_NAME_SEPARATOR = '/';\n \n   /**\n-   * Creates a tar.gz file at the specified path with the contents of the\n-   * specified directory.\n-   *\n-   * @param directoryPath\n-   *          The path to the directory to create an archive of\n-   * @param tarGzPath\n-   *          The path to the archive to create. The file may not exist but\n-   *          it's parent must exist and the parent must be a directory\n-   * @return tarGzPath\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Creates a tar.gz file from the input file/directory to the output file. The output file must have \".tar.gz\" as the\n+   * file extension.\n    */\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath)\n-      throws IOException {\n-    return createTarGzOfDirectory(directoryPath, tarGzPath, \"\");\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath, String entryPrefix)\n+  public static void createTarGzFile(File inputFile, File outputFile)\n       throws IOException {\n-    if (!tarGzPath.endsWith(TAR_GZ_FILE_EXTENSION)) {\n-      tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n+    Preconditions.checkArgument(outputFile.getName().endsWith(TAR_GZ_FILE_EXTENSION),\n+        \"Output file: %s does not have '.tar.gz' file extension\", outputFile);\n+    try (OutputStream fileOut = Files.newOutputStream(outputFile.toPath());\n+        BufferedOutputStream bufferedOut = new BufferedOutputStream(fileOut);\n+        OutputStream gzipOut = new GzipCompressorOutputStream(bufferedOut);\n+        TarArchiveOutputStream tarGzOut = new TarArchiveOutputStream(gzipOut)) {\n+      tarGzOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+      addFileToTarGz(tarGzOut, inputFile, \"\");\n     }\n-    try (FileOutputStream fOut = new FileOutputStream(new File(tarGzPath));\n-        BufferedOutputStream bOut = new BufferedOutputStream(fOut);\n-        GzipCompressorOutputStream gzOut = new GzipCompressorOutputStream(bOut);\n-        TarArchiveOutputStream tOut = new TarArchiveOutputStream(gzOut)) {\n-      tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-      addFileToTarGz(tOut, directoryPath, entryPrefix);\n-    } catch (IOException e) {\n-      LOGGER.error(\"Failed to create tar.gz file for {} at path: {}\", directoryPath, tarGzPath, e);\n-      Utils.rethrowException(e);\n-    }\n-    return tarGzPath;\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath)\n-      throws IOException {\n-    String tarGzPath = directoryPath.substring(0);\n-    while (tarGzPath.endsWith(\"/\")) {\n-      tarGzPath = tarGzPath.substring(0, tarGzPath.length() - 1);\n-    }\n-    tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n-    return createTarGzOfDirectory(directoryPath, tarGzPath);\n   }\n \n   /**\n-   * Creates a tar entry for the path specified with a name built from the base\n-   * passed in and the file/directory name. If the path is a directory, a\n-   * recursive call is made such that the full directory is added to the tar.\n-   *\n-   * @param tOut\n-   *          The tar file's output stream\n-   * @param path\n-   *          The filesystem path of the file/directory being added\n-   * @param base\n-   *          The base prefix to for the name of the tar file entry\n-   *\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Helper method to write a file into the tar.gz file output stream. The base entry name is the relative path of the\n+   * file to the root directory.\n    */\n-  private static void addFileToTarGz(TarArchiveOutputStream tOut, String path, String base)\n+  private static void addFileToTarGz(ArchiveOutputStream tarGzOut, File file, String baseEntryName)\n       throws IOException {\n-    File f = new File(path);\n-    String entryName = base + f.getName();\n-    TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n-\n-    tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-    tOut.putArchiveEntry(tarEntry);\n-\n-    if (f.isFile()) {\n-      IOUtils.copy(new FileInputStream(f), tOut);\n-\n-      tOut.closeArchiveEntry();\n+    String entryName = baseEntryName + file.getName();\n+    TarArchiveEntry entry = new TarArchiveEntry(file, entryName);\n+    tarGzOut.putArchiveEntry(entry);\n+    if (file.isFile()) {\n+      try (InputStream in = Files.newInputStream(file.toPath())) {\n+        IOUtils.copy(in, tarGzOut);\n+      }\n+      tarGzOut.closeArchiveEntry();\n     } else {\n-      tOut.closeArchiveEntry();\n+      tarGzOut.closeArchiveEntry();\n \n-      File[] children = f.listFiles();\n-\n-      if (children != null) {\n-        for (File child : children) {\n-          addFileToTarGz(tOut, child.getAbsolutePath(), entryName + \"/\");\n-        }\n+      File[] children = file.listFiles();\n+      assert children != null;\n+      String baseEntryNameForChildren = entryName + ENTRY_NAME_SEPARATOR;\n+      for (File child : children) {\n+        addFileToTarGz(tarGzOut, child, baseEntryNameForChildren);\n       }\n     }\n   }\n \n-  /** Untar an input file into an output file.\n-   * The output file is created in the output folder, having the same name\n-   * as the input file, minus the '.tar' extension.\n-   *\n-   * @param inputFile     the input .tar file\n-   * @param outputDir     the output directory file.\n-   * @throws IOException\n-   * @throws FileNotFoundException\n-   *\n-   * @return The {@link List} of {@link File}s with the untared content.\n-   * @throws ArchiveException\n+  /**\n+   * Un-tars a tar.gz file into a directory, returns all the untarred files/directories.\n+   * <p>For security reason, the untarred files must reside in the output directory.\n    */\n-  public static List<File> unTar(final File inputFile, final File outputDir)\n-      throws IOException, ArchiveException {\n-\n-    String outputDirectoryPath = outputDir.getCanonicalPath();\n-    LOGGER.debug(\"Untaring {} to dir {}.\", inputFile.getAbsolutePath(), outputDirectoryPath);\n-    TarArchiveInputStream debInputStream = null;\n-    InputStream is = null;\n-    final List<File> untaredFiles = new LinkedList<File>();\n-    try {\n-      is = new GzipCompressorInputStream(new BufferedInputStream(new FileInputStream(inputFile)));\n-      debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n-      TarArchiveEntry entry = null;\n-      while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {\n-        final File outputFile = new File(outputDir, entry.getName());\n-        // Check whether the untarred file will be put outside of the target output directory.\n-        if (!outputFile.getCanonicalPath().startsWith(outputDirectoryPath)) {\n-          throw new IOException(\"Tar file must not be untarred outside of the target output directory!\");\n+  public static List<File> untar(File inputFile, File outputDir)\n+      throws IOException {\n+    String outputDirCanonicalPath = outputDir.getCanonicalPath();\n+    List<File> untarredFiles = new ArrayList<>();\n+    try (InputStream fileIn = Files.newInputStream(inputFile.toPath());\n+        InputStream bufferedIn = new BufferedInputStream(fileIn);\n+        InputStream gzipIn = new GzipCompressorInputStream(bufferedIn);\n+        ArchiveInputStream tarGzIn = new TarArchiveInputStream(gzipIn)) {\n+      ArchiveEntry entry;\n+      while ((entry = tarGzIn.getNextEntry()) != null) {\n+        String entryName = entry.getName();\n+        String[] parts = StringUtils.split(entryName, ENTRY_NAME_SEPARATOR);\n+        File outputFile = outputDir;\n+        for (String part : parts) {\n+          outputFile = new File(outputFile, part);\n         }\n         if (entry.isDirectory()) {\n-          // creating directory\n-          LOGGER.debug(String.format(\"Attempting to write output directory %s.\", outputFile.getAbsolutePath()));\n-          if (!outputFile.exists()) {\n-            // does not exist\n-            LOGGER.debug(String.format(\"Attempting to create output directory %s.\", outputFile.getAbsolutePath()));\n-            try {\n-              // create the directory including any non-existent parent directories\n-              Files.createDirectories(outputFile.toPath());\n-            } catch (Exception e) {\n-              LOGGER.error(\"Caught exception while creating directory: {}, error: {}\", outputFile.getAbsolutePath(), e);\n-              throw e;\n-            }\n-          } else {\n-            // directory already exists\n-            LOGGER.error(\"The directory already there. Deleting - \" + outputFile.getAbsolutePath());\n-            FileUtils.deleteDirectory(outputFile);\n+          if (!outputFile.getCanonicalPath().startsWith(outputDirCanonicalPath)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "originalPosition": 231}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDcyMzMz", "url": "https://github.com/apache/pinot/pull/5665#pullrequestreview-446072333", "createdAt": "2020-07-10T01:46:51Z", "commit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMTo0Njo1MVrOGvnO0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMTo0Njo1MVrOGvnO0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTAyNQ==", "bodyText": "Since entry is a directory and each part leading up to the entry is also a directory, outputFile is also a directory right since outputFile = new File(outputFile, part);", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452579025", "createdAt": "2020-07-10T01:46:51Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);\n+  private TarGzCompressionUtils() {\n+  }\n+\n   public static final String TAR_GZ_FILE_EXTENSION = \".tar.gz\";\n+  private static final char ENTRY_NAME_SEPARATOR = '/';\n \n   /**\n-   * Creates a tar.gz file at the specified path with the contents of the\n-   * specified directory.\n-   *\n-   * @param directoryPath\n-   *          The path to the directory to create an archive of\n-   * @param tarGzPath\n-   *          The path to the archive to create. The file may not exist but\n-   *          it's parent must exist and the parent must be a directory\n-   * @return tarGzPath\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Creates a tar.gz file from the input file/directory to the output file. The output file must have \".tar.gz\" as the\n+   * file extension.\n    */\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath)\n-      throws IOException {\n-    return createTarGzOfDirectory(directoryPath, tarGzPath, \"\");\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath, String entryPrefix)\n+  public static void createTarGzFile(File inputFile, File outputFile)\n       throws IOException {\n-    if (!tarGzPath.endsWith(TAR_GZ_FILE_EXTENSION)) {\n-      tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n+    Preconditions.checkArgument(outputFile.getName().endsWith(TAR_GZ_FILE_EXTENSION),\n+        \"Output file: %s does not have '.tar.gz' file extension\", outputFile);\n+    try (OutputStream fileOut = Files.newOutputStream(outputFile.toPath());\n+        BufferedOutputStream bufferedOut = new BufferedOutputStream(fileOut);\n+        OutputStream gzipOut = new GzipCompressorOutputStream(bufferedOut);\n+        TarArchiveOutputStream tarGzOut = new TarArchiveOutputStream(gzipOut)) {\n+      tarGzOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+      addFileToTarGz(tarGzOut, inputFile, \"\");\n     }\n-    try (FileOutputStream fOut = new FileOutputStream(new File(tarGzPath));\n-        BufferedOutputStream bOut = new BufferedOutputStream(fOut);\n-        GzipCompressorOutputStream gzOut = new GzipCompressorOutputStream(bOut);\n-        TarArchiveOutputStream tOut = new TarArchiveOutputStream(gzOut)) {\n-      tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-      addFileToTarGz(tOut, directoryPath, entryPrefix);\n-    } catch (IOException e) {\n-      LOGGER.error(\"Failed to create tar.gz file for {} at path: {}\", directoryPath, tarGzPath, e);\n-      Utils.rethrowException(e);\n-    }\n-    return tarGzPath;\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath)\n-      throws IOException {\n-    String tarGzPath = directoryPath.substring(0);\n-    while (tarGzPath.endsWith(\"/\")) {\n-      tarGzPath = tarGzPath.substring(0, tarGzPath.length() - 1);\n-    }\n-    tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n-    return createTarGzOfDirectory(directoryPath, tarGzPath);\n   }\n \n   /**\n-   * Creates a tar entry for the path specified with a name built from the base\n-   * passed in and the file/directory name. If the path is a directory, a\n-   * recursive call is made such that the full directory is added to the tar.\n-   *\n-   * @param tOut\n-   *          The tar file's output stream\n-   * @param path\n-   *          The filesystem path of the file/directory being added\n-   * @param base\n-   *          The base prefix to for the name of the tar file entry\n-   *\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Helper method to write a file into the tar.gz file output stream. The base entry name is the relative path of the\n+   * file to the root directory.\n    */\n-  private static void addFileToTarGz(TarArchiveOutputStream tOut, String path, String base)\n+  private static void addFileToTarGz(ArchiveOutputStream tarGzOut, File file, String baseEntryName)\n       throws IOException {\n-    File f = new File(path);\n-    String entryName = base + f.getName();\n-    TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n-\n-    tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-    tOut.putArchiveEntry(tarEntry);\n-\n-    if (f.isFile()) {\n-      IOUtils.copy(new FileInputStream(f), tOut);\n-\n-      tOut.closeArchiveEntry();\n+    String entryName = baseEntryName + file.getName();\n+    TarArchiveEntry entry = new TarArchiveEntry(file, entryName);\n+    tarGzOut.putArchiveEntry(entry);\n+    if (file.isFile()) {\n+      try (InputStream in = Files.newInputStream(file.toPath())) {\n+        IOUtils.copy(in, tarGzOut);\n+      }\n+      tarGzOut.closeArchiveEntry();\n     } else {\n-      tOut.closeArchiveEntry();\n+      tarGzOut.closeArchiveEntry();\n \n-      File[] children = f.listFiles();\n-\n-      if (children != null) {\n-        for (File child : children) {\n-          addFileToTarGz(tOut, child.getAbsolutePath(), entryName + \"/\");\n-        }\n+      File[] children = file.listFiles();\n+      assert children != null;\n+      String baseEntryNameForChildren = entryName + ENTRY_NAME_SEPARATOR;\n+      for (File child : children) {\n+        addFileToTarGz(tarGzOut, child, baseEntryNameForChildren);\n       }\n     }\n   }\n \n-  /** Untar an input file into an output file.\n-   * The output file is created in the output folder, having the same name\n-   * as the input file, minus the '.tar' extension.\n-   *\n-   * @param inputFile     the input .tar file\n-   * @param outputDir     the output directory file.\n-   * @throws IOException\n-   * @throws FileNotFoundException\n-   *\n-   * @return The {@link List} of {@link File}s with the untared content.\n-   * @throws ArchiveException\n+  /**\n+   * Un-tars a tar.gz file into a directory, returns all the untarred files/directories.\n+   * <p>For security reason, the untarred files must reside in the output directory.\n    */\n-  public static List<File> unTar(final File inputFile, final File outputDir)\n-      throws IOException, ArchiveException {\n-\n-    String outputDirectoryPath = outputDir.getCanonicalPath();\n-    LOGGER.debug(\"Untaring {} to dir {}.\", inputFile.getAbsolutePath(), outputDirectoryPath);\n-    TarArchiveInputStream debInputStream = null;\n-    InputStream is = null;\n-    final List<File> untaredFiles = new LinkedList<File>();\n-    try {\n-      is = new GzipCompressorInputStream(new BufferedInputStream(new FileInputStream(inputFile)));\n-      debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n-      TarArchiveEntry entry = null;\n-      while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {\n-        final File outputFile = new File(outputDir, entry.getName());\n-        // Check whether the untarred file will be put outside of the target output directory.\n-        if (!outputFile.getCanonicalPath().startsWith(outputDirectoryPath)) {\n-          throw new IOException(\"Tar file must not be untarred outside of the target output directory!\");\n+  public static List<File> untar(File inputFile, File outputDir)\n+      throws IOException {\n+    String outputDirCanonicalPath = outputDir.getCanonicalPath();\n+    List<File> untarredFiles = new ArrayList<>();\n+    try (InputStream fileIn = Files.newInputStream(inputFile.toPath());\n+        InputStream bufferedIn = new BufferedInputStream(fileIn);\n+        InputStream gzipIn = new GzipCompressorInputStream(bufferedIn);\n+        ArchiveInputStream tarGzIn = new TarArchiveInputStream(gzipIn)) {\n+      ArchiveEntry entry;\n+      while ((entry = tarGzIn.getNextEntry()) != null) {\n+        String entryName = entry.getName();\n+        String[] parts = StringUtils.split(entryName, ENTRY_NAME_SEPARATOR);\n+        File outputFile = outputDir;\n+        for (String part : parts) {\n+          outputFile = new File(outputFile, part);\n         }\n         if (entry.isDirectory()) {\n-          // creating directory\n-          LOGGER.debug(String.format(\"Attempting to write output directory %s.\", outputFile.getAbsolutePath()));\n-          if (!outputFile.exists()) {\n-            // does not exist\n-            LOGGER.debug(String.format(\"Attempting to create output directory %s.\", outputFile.getAbsolutePath()));\n-            try {\n-              // create the directory including any non-existent parent directories\n-              Files.createDirectories(outputFile.toPath());\n-            } catch (Exception e) {\n-              LOGGER.error(\"Caught exception while creating directory: {}, error: {}\", outputFile.getAbsolutePath(), e);\n-              throw e;\n-            }\n-          } else {\n-            // directory already exists\n-            LOGGER.error(\"The directory already there. Deleting - \" + outputFile.getAbsolutePath());\n-            FileUtils.deleteDirectory(outputFile);\n+          if (!outputFile.getCanonicalPath().startsWith(outputDirCanonicalPath)) {\n+            throw new IOException(String\n+                .format(\"Trying to create directory: %s outside of the output directory: %s\", outputFile, outputDir));\n+          }\n+          if (!outputFile.isDirectory() && !outputFile.mkdirs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "originalPosition": 235}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDcyNzI1", "url": "https://github.com/apache/pinot/pull/5665#pullrequestreview-446072725", "createdAt": "2020-07-10T01:48:21Z", "commit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMTo0ODoyMVrOGvnQNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMTo0ODoyMVrOGvnQNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTM4MA==", "bodyText": "mkdirs() will create non-existent parent directories. If it fails in between after creating some of the parent directories, do we need to recover from that?", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452579380", "createdAt": "2020-07-10T01:48:21Z", "author": {"login": "siddharthteotia"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);\n+  private TarGzCompressionUtils() {\n+  }\n+\n   public static final String TAR_GZ_FILE_EXTENSION = \".tar.gz\";\n+  private static final char ENTRY_NAME_SEPARATOR = '/';\n \n   /**\n-   * Creates a tar.gz file at the specified path with the contents of the\n-   * specified directory.\n-   *\n-   * @param directoryPath\n-   *          The path to the directory to create an archive of\n-   * @param tarGzPath\n-   *          The path to the archive to create. The file may not exist but\n-   *          it's parent must exist and the parent must be a directory\n-   * @return tarGzPath\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Creates a tar.gz file from the input file/directory to the output file. The output file must have \".tar.gz\" as the\n+   * file extension.\n    */\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath)\n-      throws IOException {\n-    return createTarGzOfDirectory(directoryPath, tarGzPath, \"\");\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath, String entryPrefix)\n+  public static void createTarGzFile(File inputFile, File outputFile)\n       throws IOException {\n-    if (!tarGzPath.endsWith(TAR_GZ_FILE_EXTENSION)) {\n-      tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n+    Preconditions.checkArgument(outputFile.getName().endsWith(TAR_GZ_FILE_EXTENSION),\n+        \"Output file: %s does not have '.tar.gz' file extension\", outputFile);\n+    try (OutputStream fileOut = Files.newOutputStream(outputFile.toPath());\n+        BufferedOutputStream bufferedOut = new BufferedOutputStream(fileOut);\n+        OutputStream gzipOut = new GzipCompressorOutputStream(bufferedOut);\n+        TarArchiveOutputStream tarGzOut = new TarArchiveOutputStream(gzipOut)) {\n+      tarGzOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+      addFileToTarGz(tarGzOut, inputFile, \"\");\n     }\n-    try (FileOutputStream fOut = new FileOutputStream(new File(tarGzPath));\n-        BufferedOutputStream bOut = new BufferedOutputStream(fOut);\n-        GzipCompressorOutputStream gzOut = new GzipCompressorOutputStream(bOut);\n-        TarArchiveOutputStream tOut = new TarArchiveOutputStream(gzOut)) {\n-      tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-      addFileToTarGz(tOut, directoryPath, entryPrefix);\n-    } catch (IOException e) {\n-      LOGGER.error(\"Failed to create tar.gz file for {} at path: {}\", directoryPath, tarGzPath, e);\n-      Utils.rethrowException(e);\n-    }\n-    return tarGzPath;\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath)\n-      throws IOException {\n-    String tarGzPath = directoryPath.substring(0);\n-    while (tarGzPath.endsWith(\"/\")) {\n-      tarGzPath = tarGzPath.substring(0, tarGzPath.length() - 1);\n-    }\n-    tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n-    return createTarGzOfDirectory(directoryPath, tarGzPath);\n   }\n \n   /**\n-   * Creates a tar entry for the path specified with a name built from the base\n-   * passed in and the file/directory name. If the path is a directory, a\n-   * recursive call is made such that the full directory is added to the tar.\n-   *\n-   * @param tOut\n-   *          The tar file's output stream\n-   * @param path\n-   *          The filesystem path of the file/directory being added\n-   * @param base\n-   *          The base prefix to for the name of the tar file entry\n-   *\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Helper method to write a file into the tar.gz file output stream. The base entry name is the relative path of the\n+   * file to the root directory.\n    */\n-  private static void addFileToTarGz(TarArchiveOutputStream tOut, String path, String base)\n+  private static void addFileToTarGz(ArchiveOutputStream tarGzOut, File file, String baseEntryName)\n       throws IOException {\n-    File f = new File(path);\n-    String entryName = base + f.getName();\n-    TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n-\n-    tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-    tOut.putArchiveEntry(tarEntry);\n-\n-    if (f.isFile()) {\n-      IOUtils.copy(new FileInputStream(f), tOut);\n-\n-      tOut.closeArchiveEntry();\n+    String entryName = baseEntryName + file.getName();\n+    TarArchiveEntry entry = new TarArchiveEntry(file, entryName);\n+    tarGzOut.putArchiveEntry(entry);\n+    if (file.isFile()) {\n+      try (InputStream in = Files.newInputStream(file.toPath())) {\n+        IOUtils.copy(in, tarGzOut);\n+      }\n+      tarGzOut.closeArchiveEntry();\n     } else {\n-      tOut.closeArchiveEntry();\n+      tarGzOut.closeArchiveEntry();\n \n-      File[] children = f.listFiles();\n-\n-      if (children != null) {\n-        for (File child : children) {\n-          addFileToTarGz(tOut, child.getAbsolutePath(), entryName + \"/\");\n-        }\n+      File[] children = file.listFiles();\n+      assert children != null;\n+      String baseEntryNameForChildren = entryName + ENTRY_NAME_SEPARATOR;\n+      for (File child : children) {\n+        addFileToTarGz(tarGzOut, child, baseEntryNameForChildren);\n       }\n     }\n   }\n \n-  /** Untar an input file into an output file.\n-   * The output file is created in the output folder, having the same name\n-   * as the input file, minus the '.tar' extension.\n-   *\n-   * @param inputFile     the input .tar file\n-   * @param outputDir     the output directory file.\n-   * @throws IOException\n-   * @throws FileNotFoundException\n-   *\n-   * @return The {@link List} of {@link File}s with the untared content.\n-   * @throws ArchiveException\n+  /**\n+   * Un-tars a tar.gz file into a directory, returns all the untarred files/directories.\n+   * <p>For security reason, the untarred files must reside in the output directory.\n    */\n-  public static List<File> unTar(final File inputFile, final File outputDir)\n-      throws IOException, ArchiveException {\n-\n-    String outputDirectoryPath = outputDir.getCanonicalPath();\n-    LOGGER.debug(\"Untaring {} to dir {}.\", inputFile.getAbsolutePath(), outputDirectoryPath);\n-    TarArchiveInputStream debInputStream = null;\n-    InputStream is = null;\n-    final List<File> untaredFiles = new LinkedList<File>();\n-    try {\n-      is = new GzipCompressorInputStream(new BufferedInputStream(new FileInputStream(inputFile)));\n-      debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n-      TarArchiveEntry entry = null;\n-      while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {\n-        final File outputFile = new File(outputDir, entry.getName());\n-        // Check whether the untarred file will be put outside of the target output directory.\n-        if (!outputFile.getCanonicalPath().startsWith(outputDirectoryPath)) {\n-          throw new IOException(\"Tar file must not be untarred outside of the target output directory!\");\n+  public static List<File> untar(File inputFile, File outputDir)\n+      throws IOException {\n+    String outputDirCanonicalPath = outputDir.getCanonicalPath();\n+    List<File> untarredFiles = new ArrayList<>();\n+    try (InputStream fileIn = Files.newInputStream(inputFile.toPath());\n+        InputStream bufferedIn = new BufferedInputStream(fileIn);\n+        InputStream gzipIn = new GzipCompressorInputStream(bufferedIn);\n+        ArchiveInputStream tarGzIn = new TarArchiveInputStream(gzipIn)) {\n+      ArchiveEntry entry;\n+      while ((entry = tarGzIn.getNextEntry()) != null) {\n+        String entryName = entry.getName();\n+        String[] parts = StringUtils.split(entryName, ENTRY_NAME_SEPARATOR);\n+        File outputFile = outputDir;\n+        for (String part : parts) {\n+          outputFile = new File(outputFile, part);\n         }\n         if (entry.isDirectory()) {\n-          // creating directory\n-          LOGGER.debug(String.format(\"Attempting to write output directory %s.\", outputFile.getAbsolutePath()));\n-          if (!outputFile.exists()) {\n-            // does not exist\n-            LOGGER.debug(String.format(\"Attempting to create output directory %s.\", outputFile.getAbsolutePath()));\n-            try {\n-              // create the directory including any non-existent parent directories\n-              Files.createDirectories(outputFile.toPath());\n-            } catch (Exception e) {\n-              LOGGER.error(\"Caught exception while creating directory: {}, error: {}\", outputFile.getAbsolutePath(), e);\n-              throw e;\n-            }\n-          } else {\n-            // directory already exists\n-            LOGGER.error(\"The directory already there. Deleting - \" + outputFile.getAbsolutePath());\n-            FileUtils.deleteDirectory(outputFile);\n+          if (!outputFile.getCanonicalPath().startsWith(outputDirCanonicalPath)) {\n+            throw new IOException(String\n+                .format(\"Trying to create directory: %s outside of the output directory: %s\", outputFile, outputDir));\n+          }\n+          if (!outputFile.isDirectory() && !outputFile.mkdirs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "originalPosition": 235}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzMxNzA0", "url": "https://github.com/apache/pinot/pull/5665#pullrequestreview-446731704", "createdAt": "2020-07-10T22:24:10Z", "commit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMjoyNDoxMFrOGwHQ6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMjoyNDoxMFrOGwHQ6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwMzg1MQ==", "bodyText": "Is this for file separator? If so, use File.separator instead?", "url": "https://github.com/apache/pinot/pull/5665#discussion_r453103851", "createdAt": "2020-07-10T22:24:10Z", "author": {"login": "mayankshriv"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);\n+  private TarGzCompressionUtils() {\n+  }\n+\n   public static final String TAR_GZ_FILE_EXTENSION = \".tar.gz\";\n+  private static final char ENTRY_NAME_SEPARATOR = '/';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwODY3MTQ1", "url": "https://github.com/apache/pinot/pull/5665#pullrequestreview-450867145", "createdAt": "2020-07-17T18:19:51Z", "commit": {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 780, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}