{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4NzY5OTI0", "number": 6113, "title": "Adding the upsert support to real-time ingestion and query", "bodyText": "Description\nPart of a series of PRs for #4261\nCheck this doc out for the new design\nAdded the major pieces for enabling upsert:\n\nthe data structures for upsert metadata per table\nthe upsert metadata processing during mutable segment ingestion\nthe upsert metadata loading during segment loading\nenabling upsert's valid document filtering during query by enhancing the filter plan node\nthe upsert metadata removal during segment removal\nan example quickstart using MeetupEventRSVP\n\nSome more followup PRs will be sent out to improve the test coverage and feature polishing such as table config validation\nExample of upsert in action:\n\nUpgrade Notes\nDoes this PR otherwise need attention when creating release notes? Things to consider:\n\nNew feature of upsert\n\n\n Yes (Please label this PR as release-notes and complete the section on Release Notes)\n\nRelease Notes\nA feature introduction doc will be added to the documents, and included in the release notes", "createdAt": "2020-10-06T18:59:41Z", "url": "https://github.com/apache/pinot/pull/6113", "merged": true, "mergeCommit": {"oid": "7602348be0e6fcd7c0bfa5b774caf11473b27fd8"}, "closed": true, "closedAt": "2020-10-14T01:29:45Z", "author": {"login": "yupeng9"}, "timelineItems": {"totalCount": 41, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQC794AFqTUwMzQ1OTAyMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSgXGeAFqTUwODU1OTQwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDU5MDIz", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503459023", "createdAt": "2020-10-07T01:07:40Z", "commit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMTowNzo0MFrOHdfD4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMTo0NDo1MFrOHdfoCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3OTY1MQ==", "bodyText": "Suggest renaming to TableUpsertMetadataManager for consistency with TableDataManager", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500679651", "createdAt": "2020-10-07T01:07:40Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataTableManager.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.data.manager.realtime.RealtimeTableDataManager;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class UpsertMetadataTableManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3OTc5Mg==", "bodyText": "Suggest renaming to PartitionUpsertMetadataManager for consistency", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500679792", "createdAt": "2020-10-07T01:08:15Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4MDEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Map<Integer, UpsertMetadataPartitionManager> _partitionMetadataManagerMap = new ConcurrentHashMap();\n          \n          \n            \n              private final Map<Integer, UpsertMetadataPartitionManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500680130", "createdAt": "2020-10-07T01:09:40Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataTableManager.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.data.manager.realtime.RealtimeTableDataManager;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class UpsertMetadataTableManager {\n+  private final Map<Integer, UpsertMetadataPartitionManager> _partitionMetadataManagerMap = new ConcurrentHashMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NDkzNg==", "bodyText": "I went through the code, and seems we don't need to do the table level management, partition level management should be good enough. Directly using PartitionUpsertMetadataManager can save lots of unnecessary map lookups, and eliminate the contention of the concurrent lookups", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500684936", "createdAt": "2020-10-07T01:28:54Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataTableManager.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.data.manager.realtime.RealtimeTableDataManager;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class UpsertMetadataTableManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NTA4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n          \n          \n            \n              // the mapping between the (sealed) segment and its validDocuments\n          \n          \n            \n              private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n          \n          \n            \n              private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n          \n          \n            \n              // the mapping between the (sealed) segment and its validDocuments\n          \n          \n            \n              private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500685084", "createdAt": "2020-10-07T01:29:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NjIwNw==", "bodyText": "Remove all the synchronized for these methods. ConcurrentHashMap can handle concurrent accesses", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500686207", "createdAt": "2020-10-07T01:34:04Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n+\n+  UpsertMetadataPartitionManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  synchronized void removeRecordLocation(PrimaryKey primaryKey) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NzAxNA==", "bodyText": "This part won't be correct if multiple segments are being loaded at the same time.\n\nSegment 1 put a key to the primaryKeyIndex\nSegment 2 put the same key with newer timestamp to the primaryKeyIndex\nSegment 2 update the metadata first\nSegment 1 will override the metadata from segment 2, which will cause wrong result", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500687014", "createdAt": "2020-10-07T01:37:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n+\n+  UpsertMetadataPartitionManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  synchronized void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  synchronized boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  synchronized void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation) {\n+    _primaryKeyIndex.put(primaryKey, recordLocation);\n+  }\n+\n+  synchronized ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  synchronized void putUpsertMetadata(String segmentName, Map<PrimaryKey, RecordLocation> primaryKeyIndex,\n+      ThreadSafeMutableRoaringBitmap validDocIndex) {\n+    //TODO(upsert) do we need to make a backup before update?\n+    _primaryKeyIndex.putAll(primaryKeyIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODExOA==", "bodyText": "Suggest renaming to removeUpsertMetadata\nPlease also add some notes stating that it won't work properly if the segment is relatively new and not removed by the retention manager (in which case it might override the value for the existing segments)", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500688118", "createdAt": "2020-10-07T01:41:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n+\n+  UpsertMetadataPartitionManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  synchronized void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  synchronized boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  synchronized void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation) {\n+    _primaryKeyIndex.put(primaryKey, recordLocation);\n+  }\n+\n+  synchronized ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  synchronized void putUpsertMetadata(String segmentName, Map<PrimaryKey, RecordLocation> primaryKeyIndex,\n+      ThreadSafeMutableRoaringBitmap validDocIndex) {\n+    //TODO(upsert) do we need to make a backup before update?\n+    _primaryKeyIndex.putAll(primaryKeyIndex);\n+    _segmentToValidDocIndexMap.put(segmentName, validDocIndex);\n+  }\n+\n+  synchronized void removeSegment(String segmentName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODkwNg==", "bodyText": "Suggest moving this logic into the PartitionUpsertMetadataManager so that all metadata management methods are at the same place", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500688906", "createdAt": "2020-10-07T01:44:50Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertProcessorUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class UpsertProcessorUtil {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(UpsertProcessorUtil.class);\n+\n+  private UpsertProcessorUtil() {\n+  }\n+\n+  public static void handleUpsert(PrimaryKey primaryKey, long timestamp, String segmentName, int docId, int partitionId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDcyMDMw", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503472030", "createdAt": "2020-10-07T01:53:49Z", "commit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMTo1Mzo0OVrOHdfxrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMTo1Mzo0OVrOHdfxrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5MTM3NQ==", "bodyText": "This should only be initialized when upsert is enabled, or addSegment() will always pass the non-null UpsertMetadataTableManager, which will enable the upsert for the segments", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500691375", "createdAt": "2020-10-07T01:53:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -96,8 +106,15 @@\n   // likely that we get fresh data each time instead of multiple copies of roughly same data.\n   private static final int MIN_INTERVAL_BETWEEN_STATS_UPDATES_MINUTES = 30;\n \n+  // TODO(upsert): TableConfig is not available at class init phase, so we have to always create a new upsertMetadataTableManager\n+  private UpsertMetadataTableManager _upsertMetadataTableManager;\n+  private UpsertConfig.Mode _upsertMode;\n+  private List<String> _primaryKeyColumns;\n+  private String _timeColumnName;\n+\n   public RealtimeTableDataManager(Semaphore segmentBuildSemaphore) {\n     _segmentBuildSemaphore = segmentBuildSemaphore;\n+    _upsertMetadataTableManager = new UpsertMetadataTableManager();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTAzNDAz", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503503403", "createdAt": "2020-10-07T03:41:18Z", "commit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMzo0MToxOVrOHdhfbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMzo1NDoxOVrOHdhrnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxOTQ3MA==", "bodyText": "Good point", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500719470", "createdAt": "2020-10-07T03:41:19Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3OTc5Mg=="}, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMDExMg==", "bodyText": "Don't quite follow. This is a batch addition with the synchronized protection?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500720112", "createdAt": "2020-10-07T03:44:26Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n+\n+  UpsertMetadataPartitionManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  synchronized void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  synchronized boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  synchronized void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation) {\n+    _primaryKeyIndex.put(primaryKey, recordLocation);\n+  }\n+\n+  synchronized ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  synchronized void putUpsertMetadata(String segmentName, Map<PrimaryKey, RecordLocation> primaryKeyIndex,\n+      ThreadSafeMutableRoaringBitmap validDocIndex) {\n+    //TODO(upsert) do we need to make a backup before update?\n+    _primaryKeyIndex.putAll(primaryKeyIndex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NzAxNA=="}, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMDM4NA==", "bodyText": "Same reason with synchronization on this?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500720384", "createdAt": "2020-10-07T03:45:31Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n+\n+  UpsertMetadataPartitionManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  synchronized void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  synchronized boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  synchronized void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation) {\n+    _primaryKeyIndex.put(primaryKey, recordLocation);\n+  }\n+\n+  synchronized ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  synchronized void putUpsertMetadata(String segmentName, Map<PrimaryKey, RecordLocation> primaryKeyIndex,\n+      ThreadSafeMutableRoaringBitmap validDocIndex) {\n+    //TODO(upsert) do we need to make a backup before update?\n+    _primaryKeyIndex.putAll(primaryKeyIndex);\n+    _segmentToValidDocIndexMap.put(segmentName, validDocIndex);\n+  }\n+\n+  synchronized void removeSegment(String segmentName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODExOA=="}, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMTUwNA==", "bodyText": "I'd like to keep this class for (1) a group of the PartitionUpsertMetadataManager  (note PartitionUpsertMetadataManager  is package-private); (2) more features might be added to this class, such as future offline table support, record retrieval for partial update, etc", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500721504", "createdAt": "2020-10-07T03:49:34Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataTableManager.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.data.manager.realtime.RealtimeTableDataManager;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class UpsertMetadataTableManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NDkzNg=="}, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMjIwNQ==", "bodyText": "Also why would there be concurrent lookup contention, since we don't the synchronized keywords on most methods?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500722205", "createdAt": "2020-10-07T03:52:42Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataTableManager.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.data.manager.realtime.RealtimeTableDataManager;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class UpsertMetadataTableManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NDkzNg=="}, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMjU4OA==", "bodyText": "hmm, I thought about that. But this logic does not fully belong to the PartitionUpsertMetadataManager , but only the part in the else if branch.\nIn fact, it's a common logic used in two places, and that's why I put it in a util class.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500722588", "createdAt": "2020-10-07T03:54:19Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertProcessorUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class UpsertProcessorUtil {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(UpsertProcessorUtil.class);\n+\n+  private UpsertProcessorUtil() {\n+  }\n+\n+  public static void handleUpsert(PrimaryKey primaryKey, long timestamp, String segmentName, int docId, int partitionId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODkwNg=="}, "originalCommit": {"oid": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTM0ODU2", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503534856", "createdAt": "2020-10-07T05:29:05Z", "commit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNToyOTowNlrOHdjGUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNToyOTowNlrOHdjGUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NTgxMA==", "bodyText": "NIT: please use parentheses in the boolean condition to avoid confusion.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500745810", "createdAt": "2020-10-07T05:29:06Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +291,59 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _upsertMetadataTableManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTQ2NTYz", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503546563", "createdAt": "2020-10-07T06:00:12Z", "commit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjowMDoxMlrOHdjsfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjowMDoxMlrOHdjsfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTU4Mg==", "bodyText": "What's the estimated memory usage for the extra data structure? if the primary key+RecordLocation is around 1K, this means we will use 10G heap for this data structure for 1M records. We might want to be careful about part of memory usage", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500755582", "createdAt": "2020-10-07T06:00:12Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +291,59 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _upsertMetadataTableManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if(isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {\n+    Preconditions.checkArgument(!_primaryKeyColumns.isEmpty(), \"the primary key columns cannot be empty\");\n+    Map<String, PinotSegmentColumnReader> columnToReaderMap = new HashMap<>();\n+    for (String primaryKeyColumn : _primaryKeyColumns) {\n+      columnToReaderMap.put(primaryKeyColumn, new PinotSegmentColumnReader(immutableSegment, primaryKeyColumn));\n+    }\n+    columnToReaderMap.put(_timeColumnName, new PinotSegmentColumnReader(immutableSegment, _timeColumnName));\n+    int numTotalDocs = immutableSegment.getSegmentMetadata().getTotalDocs();\n+\n+    // upsert metadata of the current segment\n+    Map<PrimaryKey, RecordLocation> primaryKeyIndex = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTU2MjE0", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503556214", "createdAt": "2020-10-07T06:22:33Z", "commit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjoyMjozNFrOHdkLKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjoyMjozNFrOHdkLKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2MzQzNQ==", "bodyText": "where is this class used?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500763435", "createdAt": "2020-10-07T06:22:34Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentIndexCreationDriverImpl.java", "diffHunk": "@@ -54,6 +54,7 @@\n import org.apache.pinot.core.util.IngestionUtils;\n import org.apache.pinot.spi.config.table.StarTreeIndexConfig;\n import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.UpsertConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTY0Nzc5", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503564779", "createdAt": "2020-10-07T06:39:41Z", "commit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjozOTo0MVrOHdkmUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjozOTo0MVrOHdkmUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc3MDM4NA==", "bodyText": "Does this mean all replicas of a stream partition share the same PartitionUpsertMetadataManager?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500770384", "createdAt": "2020-10-07T06:39:41Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/TableUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class TableUpsertMetadataManager {\n+  private final Map<Integer, PartitionUpsertMetadataManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTY3MjU2", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503567256", "createdAt": "2020-10-07T06:44:21Z", "commit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjo0NDoyMVrOHdkuKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjo0NDoyMVrOHdkuKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc3MjM5NQ==", "bodyText": "local means in-memory segment? local is a bit ambiguous.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500772395", "createdAt": "2020-10-07T06:44:21Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertProcessorUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class UpsertProcessorUtil {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(UpsertProcessorUtil.class);\n+\n+  private UpsertProcessorUtil() {\n+  }\n+\n+  public static void handleUpsert(PrimaryKey primaryKey, long timestamp, String segmentName, int docId, int partitionId,\n+      Map<PrimaryKey, RecordLocation> primaryKeyIndex, ThreadSafeMutableRoaringBitmap validDocIndex,\n+      TableUpsertMetadataManager upsertMetadataTableManager) {\n+    RecordLocation location = new RecordLocation(segmentName, docId, timestamp);\n+    // check local primary key index first", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTc3MTI2", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-503577126", "createdAt": "2020-10-07T07:01:24Z", "commit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzowMToyNFrOHdlN-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzowMToyNFrOHdlN-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4MDUzOA==", "bodyText": "It is pretty expensive to loop through all the records in a segment and apply the upsert handling per record. Need to think through and better do a benchmark on the performance of this addSegment() method. This method is used when a segment is becoming online from offline state \u2014 which means it is invoked when a segment is loaded when the server starts OR when a server download the segment from another server in LLC. So it means slowdown of server start and segment download operations.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500780538", "createdAt": "2020-10-07T07:01:24Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +291,59 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _upsertMetadataTableManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if(isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {\n+    Preconditions.checkArgument(!_primaryKeyColumns.isEmpty(), \"the primary key columns cannot be empty\");\n+    Map<String, PinotSegmentColumnReader> columnToReaderMap = new HashMap<>();\n+    for (String primaryKeyColumn : _primaryKeyColumns) {\n+      columnToReaderMap.put(primaryKeyColumn, new PinotSegmentColumnReader(immutableSegment, primaryKeyColumn));\n+    }\n+    columnToReaderMap.put(_timeColumnName, new PinotSegmentColumnReader(immutableSegment, _timeColumnName));\n+    int numTotalDocs = immutableSegment.getSegmentMetadata().getTotalDocs();\n+\n+    // upsert metadata of the current segment\n+    Map<PrimaryKey, RecordLocation> primaryKeyIndex = new HashMap<>();\n+    ThreadSafeMutableRoaringBitmap validDocIndex = new ThreadSafeMutableRoaringBitmap();\n+\n+    String segmentName = immutableSegment.getSegmentName();\n+    int partitionId = new LLCSegmentName(immutableSegment.getSegmentName()).getPartitionId();\n+    for (int docId = 0; docId < numTotalDocs; docId++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDM0NjY0", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-504034664", "createdAt": "2020-10-07T15:59:18Z", "commit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo1OToxOVrOHd6dpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjowNjozNVrOHd6zBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyODYxNQ==", "bodyText": "Agreed on being careful about memory usage. I discussed this in the design doc, and my estimate of the memory usage shall be < 2GB.\nI do plan a followup PR of adding metrics of the memory usage.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501128615", "createdAt": "2020-10-07T15:59:19Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +291,59 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _upsertMetadataTableManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if(isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {\n+    Preconditions.checkArgument(!_primaryKeyColumns.isEmpty(), \"the primary key columns cannot be empty\");\n+    Map<String, PinotSegmentColumnReader> columnToReaderMap = new HashMap<>();\n+    for (String primaryKeyColumn : _primaryKeyColumns) {\n+      columnToReaderMap.put(primaryKeyColumn, new PinotSegmentColumnReader(immutableSegment, primaryKeyColumn));\n+    }\n+    columnToReaderMap.put(_timeColumnName, new PinotSegmentColumnReader(immutableSegment, _timeColumnName));\n+    int numTotalDocs = immutableSegment.getSegmentMetadata().getTotalDocs();\n+\n+    // upsert metadata of the current segment\n+    Map<PrimaryKey, RecordLocation> primaryKeyIndex = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTU4Mg=="}, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMTk2Ng==", "bodyText": "That's a good point. I think some optimization on batch loading the columns can be considered in future PRs. In fact, this may improve other index loading code path such as the null vector loading etc.\nIn the initial version, we can build the foundation for the functionality first, and later via profiling we will have better understanding of the performance bottlenecks, and we can improve accordingly.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501131966", "createdAt": "2020-10-07T16:03:40Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +291,59 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _upsertMetadataTableManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if(isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {\n+    Preconditions.checkArgument(!_primaryKeyColumns.isEmpty(), \"the primary key columns cannot be empty\");\n+    Map<String, PinotSegmentColumnReader> columnToReaderMap = new HashMap<>();\n+    for (String primaryKeyColumn : _primaryKeyColumns) {\n+      columnToReaderMap.put(primaryKeyColumn, new PinotSegmentColumnReader(immutableSegment, primaryKeyColumn));\n+    }\n+    columnToReaderMap.put(_timeColumnName, new PinotSegmentColumnReader(immutableSegment, _timeColumnName));\n+    int numTotalDocs = immutableSegment.getSegmentMetadata().getTotalDocs();\n+\n+    // upsert metadata of the current segment\n+    Map<PrimaryKey, RecordLocation> primaryKeyIndex = new HashMap<>();\n+    ThreadSafeMutableRoaringBitmap validDocIndex = new ThreadSafeMutableRoaringBitmap();\n+\n+    String segmentName = immutableSegment.getSegmentName();\n+    int partitionId = new LLCSegmentName(immutableSegment.getSegmentName()).getPartitionId();\n+    for (int docId = 0; docId < numTotalDocs; docId++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4MDUzOA=="}, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMzM1Mg==", "bodyText": "No, this is per server, so it tracks local segment only. And there is at most one replica per server", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501133352", "createdAt": "2020-10-07T16:05:33Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/TableUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class TableUpsertMetadataManager {\n+  private final Map<Integer, PartitionUpsertMetadataManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc3MDM4NA=="}, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNDA4Nw==", "bodyText": "I think all segments are in-memory? Changed it to for mutable segment.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501134087", "createdAt": "2020-10-07T16:06:35Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertProcessorUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class UpsertProcessorUtil {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(UpsertProcessorUtil.class);\n+\n+  private UpsertProcessorUtil() {\n+  }\n+\n+  public static void handleUpsert(PrimaryKey primaryKey, long timestamp, String segmentName, int docId, int partitionId,\n+      Map<PrimaryKey, RecordLocation> primaryKeyIndex, ThreadSafeMutableRoaringBitmap validDocIndex,\n+      TableUpsertMetadataManager upsertMetadataTableManager) {\n+    RecordLocation location = new RecordLocation(segmentName, docId, timestamp);\n+    // check local primary key index first", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc3MjM5NQ=="}, "originalCommit": {"oid": "410b977b6830c03aab39f4e765e0689a08427790"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1Mjk3NDk4", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-505297498", "createdAt": "2020-10-09T01:48:14Z", "commit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTo0ODoxNVrOHe3dJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjowMToyMVrOHe3o_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzkxMQ==", "bodyText": "Move this part into the init(), where you can read the table config and schema from the property store passed in. It is weird to reset these variables when adding each segment", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502127911", "createdAt": "2020-10-09T01:48:15Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -224,6 +242,16 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n     Schema schema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n     Preconditions.checkNotNull(schema);\n \n+    // TODO(upsert): better checking&hanlding of upsert mode/primary key change", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyODI2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return _upsertMode != null && (_upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL);\n          \n          \n            \n                return _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502128263", "createdAt": "2020-10-09T01:49:37Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +293,71 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _tableUpsertMetadataManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && (_upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyODg0OA==", "bodyText": "Move this logic into the PartitionUpsertMetadataManager class and you need to add concurrency control for it. Currently this part of the code is not thread-safe if 2 segments are updating upsert metadata at the same time", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502128848", "createdAt": "2020-10-09T01:52:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +293,71 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _tableUpsertMetadataManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && (_upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL);\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if (isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {\n+    Preconditions.checkArgument(!_primaryKeyColumns.isEmpty(), \"the primary key columns cannot be empty\");\n+    Map<String, PinotSegmentColumnReader> columnToReaderMap = new HashMap<>();\n+    for (String primaryKeyColumn : _primaryKeyColumns) {\n+      columnToReaderMap.put(primaryKeyColumn, new PinotSegmentColumnReader(immutableSegment, primaryKeyColumn));\n+    }\n+    columnToReaderMap.put(_timeColumnName, new PinotSegmentColumnReader(immutableSegment, _timeColumnName));\n+    int numTotalDocs = immutableSegment.getSegmentMetadata().getTotalDocs();\n+    String segmentName = immutableSegment.getSegmentName();\n+    int partitionId = new LLCSegmentName(immutableSegment.getSegmentName()).getPartitionId();\n+    PartitionUpsertMetadataManager partitionUpsertMetadataManager =\n+        _tableUpsertMetadataManager.getOrCreatePartitionManager(partitionId);\n+    for (int docId = 0; docId < numTotalDocs; docId++) {\n+      Object[] fields = new Object[_primaryKeyColumns.size()];\n+      for (int i = 0; i < _primaryKeyColumns.size(); i++) {\n+        fields[i] = columnToReaderMap.get(_primaryKeyColumns.get(i)).getValue(docId);\n+      }\n+      PrimaryKey primaryKey = new PrimaryKey(fields);\n+      Object timeValue = columnToReaderMap.get(_timeColumnName).getValue(docId);\n+      Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+      long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+      RecordLocation location = new RecordLocation(segmentName, docId, timestamp);\n+      if (partitionUpsertMetadataManager.containsKey(primaryKey)) {\n+        RecordLocation prevLocation = partitionUpsertMetadataManager.getRecordLocation(primaryKey);\n+        // upsert\n+        if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+          partitionUpsertMetadataManager.removeRecordLocation(primaryKey);\n+          partitionUpsertMetadataManager.putRecordLocation(primaryKey, location);\n+          partitionUpsertMetadataManager.getValidDocIndex(prevLocation.getSegmentName())\n+              .remove(prevLocation.getDocId());\n+          partitionUpsertMetadataManager.getOrCreateValidDocIndex(segmentName).checkAndAdd(location.getDocId());\n+          LOGGER.debug(String\n+              .format(\"upsert: replace old doc id %d with %d for key: %s, hash: %d\", prevLocation.getDocId(),\n+                  location.getDocId(), primaryKey, primaryKey.hashCode()));\n+        } else {\n+          LOGGER.debug(\n+              String.format(\"upsert: ignore a late-arrived record: %s, hash: %d\", primaryKey, primaryKey.hashCode()));\n+        }\n+      } else { // append\n+        partitionUpsertMetadataManager.putRecordLocation(primaryKey, location);\n+        partitionUpsertMetadataManager.getOrCreateValidDocIndex(segmentName).checkAndAdd(location.getDocId());\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTExNw==", "bodyText": "Similarly, this part of the logic should be moved into the PartitionUpsertMetadataManager with concurrency control", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502129117", "createdAt": "2020-10-09T01:53:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -453,6 +465,49 @@ public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n     return canTakeMore;\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode != UpsertConfig.Mode.NONE;\n+  }\n+\n+  private void handleUpsert(GenericRow row, int docId) {\n+    // below are upsert operations\n+    PrimaryKey primaryKey = row.getPrimaryKey(_schema.getPrimaryKeyColumns());\n+    Object timeValue = row.getValue(_timeColumnName);\n+    Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+    long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+    RecordLocation location = new RecordLocation(_segmentName, docId, timestamp);\n+    // check local primary key index first\n+    if (_primaryKeyIndex.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _primaryKeyIndex.get(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _primaryKeyIndex.put(primaryKey, location);\n+        // update validDocIndex\n+        _validDocIndex.remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+        LOGGER.debug(String\n+            .format(\"upsert: replace old doc id %d with %d for key: %s, hash: %d\", prevLocation.getDocId(),\n+                location.getDocId(), primaryKey, primaryKey.hashCode()));\n+      } else {\n+        LOGGER.debug(\n+            String.format(\"upsert: ignore a late-arrived record: %s, hash: %d\", primaryKey, primaryKey.hashCode()));\n+      }\n+    } else if (_partitionUpsertMetadataManager.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _partitionUpsertMetadataManager.getRecordLocation(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _partitionUpsertMetadataManager.removeRecordLocation(primaryKey);\n+        _primaryKeyIndex.put(primaryKey, location);\n+\n+        // update validDocIndex\n+        _partitionUpsertMetadataManager.getValidDocIndex(prevLocation.getSegmentName())\n+            .remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+      }\n+    } else {\n+      _primaryKeyIndex.put(primaryKey, location);\n+      _validDocIndex.checkAndAdd(location.getDocId());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTg2Mg==", "bodyText": "(nit) Cache _indexSegment.getValidDocIndex() into a local variable in line 61", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502129862", "createdAt": "2020-10-09T01:56:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java", "diffHunk": "@@ -58,7 +59,17 @@ public FilterPlanNode(IndexSegment indexSegment, QueryContext queryContext) {\n   public BaseFilterOperator run() {\n     FilterContext filter = _queryContext.getFilter();\n     if (filter != null) {\n-      return constructPhysicalOperator(filter, _queryContext.getDebugOptions());\n+      BaseFilterOperator filterOperator = constructPhysicalOperator(filter, _queryContext.getDebugOptions());\n+      if (_indexSegment.getValidDocIndex() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzMDEyNQ==", "bodyText": "For better performance\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return FilterOperatorUtils.getAndFilterOperator(Lists.newArrayList(filterOperator, validDocFilter), _numDocs,\n          \n          \n            \n                    return FilterOperatorUtils.getAndFilterOperator(Arrays.asList(filterOperator, validDocFilter), _numDocs,", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502130125", "createdAt": "2020-10-09T01:57:56Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java", "diffHunk": "@@ -58,7 +59,17 @@ public FilterPlanNode(IndexSegment indexSegment, QueryContext queryContext) {\n   public BaseFilterOperator run() {\n     FilterContext filter = _queryContext.getFilter();\n     if (filter != null) {\n-      return constructPhysicalOperator(filter, _queryContext.getDebugOptions());\n+      BaseFilterOperator filterOperator = constructPhysicalOperator(filter, _queryContext.getDebugOptions());\n+      if (_indexSegment.getValidDocIndex() != null) {\n+        BaseFilterOperator validDocFilter =\n+            new BitmapBasedFilterOperator(_indexSegment.getValidDocIndex().getValidDocBitmap(), false, _numDocs);\n+        return FilterOperatorUtils.getAndFilterOperator(Lists.newArrayList(filterOperator, validDocFilter), _numDocs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzMDQyNQ==", "bodyText": "(nit) I don't think this is useful?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502130425", "createdAt": "2020-10-09T01:59:14Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/TableUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class TableUpsertMetadataManager {\n+  private final Map<Integer, PartitionUpsertMetadataManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();\n+\n+  public TableUpsertMetadataManager() {\n+  }\n+\n+  public synchronized PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) {\n+    if(!_partitionMetadataManagerMap.containsKey(partitionId)) {\n+      _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId));\n+    }\n+    return _partitionMetadataManagerMap.get(partitionId);\n+  }\n+\n+  public boolean isEmpty() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzMDk0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public synchronized PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) {\n          \n          \n            \n                if(!_partitionMetadataManagerMap.containsKey(partitionId)) {\n          \n          \n            \n                  _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId));\n          \n          \n            \n                }\n          \n          \n            \n                return _partitionMetadataManagerMap.get(partitionId);\n          \n          \n            \n              }\n          \n          \n            \n              public PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) {\n          \n          \n            \n                return _partitionMetadataManagerMap.computeIfAbsent(partitionId, PartitionUpsertMetadataManager::new);\n          \n          \n            \n              }", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502130941", "createdAt": "2020-10-09T02:01:21Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/TableUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class TableUpsertMetadataManager {\n+  private final Map<Integer, PartitionUpsertMetadataManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();\n+\n+  public TableUpsertMetadataManager() {\n+  }\n+\n+  public synchronized PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) {\n+    if(!_partitionMetadataManagerMap.containsKey(partitionId)) {\n+      _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId));\n+    }\n+    return _partitionMetadataManagerMap.get(partitionId);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjIzODky", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-506223892", "createdAt": "2020-10-11T22:39:54Z", "commit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMjozOTo1NVrOHfrL9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDowMDo1M1rOHfruyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NTQ3Ng==", "bodyText": "we can think about defining an interface and allow the implementation of upsert/append Metadata Manager. This would prevent a lot of null checking/special case handling of upsert related logics", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502975476", "createdAt": "2020-10-11T22:39:55Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NzU1Ng==", "bodyText": "recommend to use {} for string substitute in logging", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502977556", "createdAt": "2020-10-11T22:58:39Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -453,6 +465,49 @@ public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n     return canTakeMore;\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode != UpsertConfig.Mode.NONE;\n+  }\n+\n+  private void handleUpsert(GenericRow row, int docId) {\n+    // below are upsert operations\n+    PrimaryKey primaryKey = row.getPrimaryKey(_schema.getPrimaryKeyColumns());\n+    Object timeValue = row.getValue(_timeColumnName);\n+    Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+    long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+    RecordLocation location = new RecordLocation(_segmentName, docId, timestamp);\n+    // check local primary key index first\n+    if (_primaryKeyIndex.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _primaryKeyIndex.get(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _primaryKeyIndex.put(primaryKey, location);\n+        // update validDocIndex\n+        _validDocIndex.remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+        LOGGER.debug(String\n+            .format(\"upsert: replace old doc id %d with %d for key: %s, hash: %d\", prevLocation.getDocId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3ODQwOQ==", "bodyText": "It seems that we don't update the record location _partitionUpsertMetadataManager in this if condition, is that any concern for data correctness over here?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502978409", "createdAt": "2020-10-11T23:06:54Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -453,6 +465,49 @@ public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n     return canTakeMore;\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode != UpsertConfig.Mode.NONE;\n+  }\n+\n+  private void handleUpsert(GenericRow row, int docId) {\n+    // below are upsert operations\n+    PrimaryKey primaryKey = row.getPrimaryKey(_schema.getPrimaryKeyColumns());\n+    Object timeValue = row.getValue(_timeColumnName);\n+    Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+    long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+    RecordLocation location = new RecordLocation(_segmentName, docId, timestamp);\n+    // check local primary key index first\n+    if (_primaryKeyIndex.containsKey(primaryKey)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MDU1Nw==", "bodyText": "handleUpsert()?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502980557", "createdAt": "2020-10-11T23:26:38Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();\n+\n+  public PartitionUpsertMetadataManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  public void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  public boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  public RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  public ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  private ThreadSafeMutableRoaringBitmap getOrCreateValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.computeIfAbsent(segmentName, k->new ThreadSafeMutableRoaringBitmap());\n+  }\n+\n+  public synchronized void removeUpsertMetadata(String segmentName) {\n+    _segmentToValidDocIndexMap.remove(segmentName);\n+    for (Map.Entry<PrimaryKey, RecordLocation> entry : new HashSet<>(_primaryKeyIndex.entrySet())) {\n+      if (entry.getValue().getSegmentName().equals(segmentName)) {\n+        _primaryKeyIndex.remove(entry.getKey());\n+      }\n+    }\n+  }\n+\n+  int getPartitionId() {\n+    return _partitionId;\n+  }\n+\n+  public synchronized void handUpsert(PrimaryKey primaryKey, RecordLocation location, String segmentName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MDYzOQ==", "bodyText": "piggyback on @Jackie-Jiang comment in other class, I think we should abstract all primary key interaction from segment to this class", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502980639", "createdAt": "2020-10-11T23:27:19Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();\n+\n+  public PartitionUpsertMetadataManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  public void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  public boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  public RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  public ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  private ThreadSafeMutableRoaringBitmap getOrCreateValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.computeIfAbsent(segmentName, k->new ThreadSafeMutableRoaringBitmap());\n+  }\n+\n+  public synchronized void removeUpsertMetadata(String segmentName) {\n+    _segmentToValidDocIndexMap.remove(segmentName);\n+    for (Map.Entry<PrimaryKey, RecordLocation> entry : new HashSet<>(_primaryKeyIndex.entrySet())) {\n+      if (entry.getValue().getSegmentName().equals(segmentName)) {\n+        _primaryKeyIndex.remove(entry.getKey());\n+      }\n+    }\n+  }\n+\n+  int getPartitionId() {\n+    return _partitionId;\n+  }\n+\n+  public synchronized void handUpsert(PrimaryKey primaryKey, RecordLocation location, String segmentName) {\n+    if (containsKey(primaryKey)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MjQwMw==", "bodyText": "do we need to handle the case where the old DocIndex get deleted because of old segment removal? It might generate null pointer in this case", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502982403", "createdAt": "2020-10-11T23:42:55Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();\n+\n+  public PartitionUpsertMetadataManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  public void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  public boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  public RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  public ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  private ThreadSafeMutableRoaringBitmap getOrCreateValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.computeIfAbsent(segmentName, k->new ThreadSafeMutableRoaringBitmap());\n+  }\n+\n+  public synchronized void removeUpsertMetadata(String segmentName) {\n+    _segmentToValidDocIndexMap.remove(segmentName);\n+    for (Map.Entry<PrimaryKey, RecordLocation> entry : new HashSet<>(_primaryKeyIndex.entrySet())) {\n+      if (entry.getValue().getSegmentName().equals(segmentName)) {\n+        _primaryKeyIndex.remove(entry.getKey());\n+      }\n+    }\n+  }\n+\n+  int getPartitionId() {\n+    return _partitionId;\n+  }\n+\n+  public synchronized void handUpsert(PrimaryKey primaryKey, RecordLocation location, String segmentName) {\n+    if (containsKey(primaryKey)) {\n+      RecordLocation prevLocation = getRecordLocation(primaryKey);\n+      // upsert\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        removeRecordLocation(primaryKey);\n+        _primaryKeyIndex.put(primaryKey, location);\n+        getValidDocIndex(prevLocation.getSegmentName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Mzg0OQ==", "bodyText": "this question might be better addressed in the design doc, but I wonder have we measure the performance & space trade-off of using RoaringBitMap for validDoc? Another alternative will be just using simple bitArray/bytes to store this data, will be interesting to see if we can explain further in the design doc or in codes", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502983849", "createdAt": "2020-10-11T23:55:55Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/ValidDocIndexReader.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+\n+\n+public interface ValidDocIndexReader {\n+\n+  /**\n+   * Return the underlying validDoc bitmap (used in query execution)\n+   */\n+  ImmutableRoaringBitmap getValidDocBitmap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NDMzMw==", "bodyText": "back to my previous point about memory usage, I think maybe you can extract this HashMap to something like an interface wrapping the actual implmentation so we can potentially explore other implementations for primary key mapping", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502984333", "createdAt": "2020-10-12T00:00:31Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NDM5Mg==", "bodyText": "handleUpsert?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502984392", "createdAt": "2020-10-12T00:00:53Z", "author": {"login": "jamesyfshao"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();\n+\n+  public PartitionUpsertMetadataManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  public void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  public boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  public RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  public ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  private ThreadSafeMutableRoaringBitmap getOrCreateValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.computeIfAbsent(segmentName, k->new ThreadSafeMutableRoaringBitmap());\n+  }\n+\n+  public synchronized void removeUpsertMetadata(String segmentName) {\n+    _segmentToValidDocIndexMap.remove(segmentName);\n+    for (Map.Entry<PrimaryKey, RecordLocation> entry : new HashSet<>(_primaryKeyIndex.entrySet())) {\n+      if (entry.getValue().getSegmentName().equals(segmentName)) {\n+        _primaryKeyIndex.remove(entry.getKey());\n+      }\n+    }\n+  }\n+\n+  int getPartitionId() {\n+    return _partitionId;\n+  }\n+\n+  public synchronized void handUpsert(PrimaryKey primaryKey, RecordLocation location, String segmentName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6711a7d55effb22c3ee55043a5b7977fc5523417"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2ODk0MjA5", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-506894209", "createdAt": "2020-10-12T20:26:03Z", "commit": {"oid": "8420b0f171757ad7198bec17258dcec4472410c4"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyNjowNFrOHgMK0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjoyNjo1MlrOHgPKBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTg1OA==", "bodyText": "tableconfig is available at the time TableDataManager is created. Can you use that instead of fetching it again here?\nAlso, TableDataManager is not recreaated if table config changes. How do you plan to address tha?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503515858", "createdAt": "2020-10-12T20:26:04Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -132,6 +146,19 @@ protected void doInit() {\n     String consumerDirPath = getConsumerDir();\n     File consumerDir = new File(consumerDirPath);\n \n+    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, _tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8420b0f171757ad7198bec17258dcec4472410c4"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTk1Mg==", "bodyText": "Please ise _streamPartitionId member variable", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503515952", "createdAt": "2020-10-12T20:26:18Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/LLRealtimeSegmentDataManager.java", "diffHunk": "@@ -1165,6 +1172,14 @@ public LLRealtimeSegmentDataManager(RealtimeSegmentZKMetadata segmentZKMetadata,\n     Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();\n     _textIndexColumns = new ArrayList<>(textIndexColumns);\n \n+    PartitionUpsertMetadataManager partitionUpsertMetadataManager = null;\n+    UpsertConfig.Mode upsertMode = _tableConfig.getUpsertMode();\n+    if (_upsertMetadataTableManager != null && upsertMode != UpsertConfig.Mode.NONE) {\n+      int partitionId = new LLCSegmentName(_segmentNameStr).getPartitionId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8420b0f171757ad7198bec17258dcec4472410c4"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNzg1NQ==", "bodyText": "Can we move the upsert handling to a different class? Perhaps a subclass of RealtimeTableDataManager?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503517855", "createdAt": "2020-10-12T20:30:58Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +292,52 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _tableUpsertMetadataManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if (isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8420b0f171757ad7198bec17258dcec4472410c4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2NDgwNg==", "bodyText": "+1", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503564806", "createdAt": "2020-10-12T22:26:52Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -453,6 +465,49 @@ public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n     return canTakeMore;\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode != UpsertConfig.Mode.NONE;\n+  }\n+\n+  private void handleUpsert(GenericRow row, int docId) {\n+    // below are upsert operations\n+    PrimaryKey primaryKey = row.getPrimaryKey(_schema.getPrimaryKeyColumns());\n+    Object timeValue = row.getValue(_timeColumnName);\n+    Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+    long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+    RecordLocation location = new RecordLocation(_segmentName, docId, timestamp);\n+    // check local primary key index first\n+    if (_primaryKeyIndex.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _primaryKeyIndex.get(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _primaryKeyIndex.put(primaryKey, location);\n+        // update validDocIndex\n+        _validDocIndex.remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+        LOGGER.debug(String\n+            .format(\"upsert: replace old doc id %d with %d for key: %s, hash: %d\", prevLocation.getDocId(),\n+                location.getDocId(), primaryKey, primaryKey.hashCode()));\n+      } else {\n+        LOGGER.debug(\n+            String.format(\"upsert: ignore a late-arrived record: %s, hash: %d\", primaryKey, primaryKey.hashCode()));\n+      }\n+    } else if (_partitionUpsertMetadataManager.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _partitionUpsertMetadataManager.getRecordLocation(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _partitionUpsertMetadataManager.removeRecordLocation(primaryKey);\n+        _primaryKeyIndex.put(primaryKey, location);\n+\n+        // update validDocIndex\n+        _partitionUpsertMetadataManager.getValidDocIndex(prevLocation.getSegmentName())\n+            .remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+      }\n+    } else {\n+      _primaryKeyIndex.put(primaryKey, location);\n+      _validDocIndex.checkAndAdd(location.getDocId());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTExNw=="}, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MDU1ODg0", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-507055884", "createdAt": "2020-10-13T04:10:46Z", "commit": {"oid": "8420b0f171757ad7198bec17258dcec4472410c4"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNDoxMDo0NlrOHgUuLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNToxOTozMFrOHgVvrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY1NTk4MA==", "bodyText": "Good point.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503655980", "createdAt": "2020-10-13T04:10:46Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/LLRealtimeSegmentDataManager.java", "diffHunk": "@@ -1165,6 +1172,14 @@ public LLRealtimeSegmentDataManager(RealtimeSegmentZKMetadata segmentZKMetadata,\n     Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();\n     _textIndexColumns = new ArrayList<>(textIndexColumns);\n \n+    PartitionUpsertMetadataManager partitionUpsertMetadataManager = null;\n+    UpsertConfig.Mode upsertMode = _tableConfig.getUpsertMode();\n+    if (_upsertMetadataTableManager != null && upsertMode != UpsertConfig.Mode.NONE) {\n+      int partitionId = new LLCSegmentName(_segmentNameStr).getPartitionId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTk1Mg=="}, "originalCommit": {"oid": "8420b0f171757ad7198bec17258dcec4472410c4"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY2ODUzMg==", "bodyText": "hmm, I did not see how to access it but from _propertyStore . Can you be more specific?\nAlso, I am not sure the upsert config can change dynamically: partial vs full seems a disruptive change.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503668532", "createdAt": "2020-10-13T05:03:33Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -132,6 +146,19 @@ protected void doInit() {\n     String consumerDirPath = getConsumerDir();\n     File consumerDir = new File(consumerDirPath);\n \n+    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, _tableNameWithType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTg1OA=="}, "originalCommit": {"oid": "8420b0f171757ad7198bec17258dcec4472410c4"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY3MjM0OA==", "bodyText": "Do you suggest creating a RealTimeUpsertTableDataManager in TableDataManagerProvider.getTableDataManager?  It's an option to me, though I feel uspert shall be better built as a first-class citizen in realtime table. @Jackie-Jiang what do you think?", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503672348", "createdAt": "2020-10-13T05:17:55Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +292,52 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _tableUpsertMetadataManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if (isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNzg1NQ=="}, "originalCommit": {"oid": "8420b0f171757ad7198bec17258dcec4472410c4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY3Mjc0OQ==", "bodyText": "okay, let me refactor this a bit.", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503672749", "createdAt": "2020-10-13T05:19:30Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -453,6 +465,49 @@ public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n     return canTakeMore;\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode != UpsertConfig.Mode.NONE;\n+  }\n+\n+  private void handleUpsert(GenericRow row, int docId) {\n+    // below are upsert operations\n+    PrimaryKey primaryKey = row.getPrimaryKey(_schema.getPrimaryKeyColumns());\n+    Object timeValue = row.getValue(_timeColumnName);\n+    Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+    long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+    RecordLocation location = new RecordLocation(_segmentName, docId, timestamp);\n+    // check local primary key index first\n+    if (_primaryKeyIndex.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _primaryKeyIndex.get(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _primaryKeyIndex.put(primaryKey, location);\n+        // update validDocIndex\n+        _validDocIndex.remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+        LOGGER.debug(String\n+            .format(\"upsert: replace old doc id %d with %d for key: %s, hash: %d\", prevLocation.getDocId(),\n+                location.getDocId(), primaryKey, primaryKey.hashCode()));\n+      } else {\n+        LOGGER.debug(\n+            String.format(\"upsert: ignore a late-arrived record: %s, hash: %d\", primaryKey, primaryKey.hashCode()));\n+      }\n+    } else if (_partitionUpsertMetadataManager.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _partitionUpsertMetadataManager.getRecordLocation(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _partitionUpsertMetadataManager.removeRecordLocation(primaryKey);\n+        _primaryKeyIndex.put(primaryKey, location);\n+\n+        // update validDocIndex\n+        _partitionUpsertMetadataManager.getValidDocIndex(prevLocation.getSegmentName())\n+            .remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+      }\n+    } else {\n+      _primaryKeyIndex.put(primaryKey, location);\n+      _validDocIndex.checkAndAdd(location.getDocId());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTExNw=="}, "originalCommit": {"oid": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53"}, "originalPosition": 181}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7df7d77991cd679d7e4f8ab2455a4ff759317aa8", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/7df7d77991cd679d7e4f8ab2455a4ff759317aa8", "committedDate": "2020-10-13T23:03:14Z", "message": "upsert local\n\nsupport where clause\n\nclean up upsert config\n\nadd metadataPartitionManager\n\nadd upsert during segment loading\n\nupdates\n\nadd partition by key to upsert quick start"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8f292af8f5125a4b4fdb4b8fc872604bff19105", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/b8f292af8f5125a4b4fdb4b8fc872604bff19105", "committedDate": "2020-10-13T23:03:14Z", "message": "fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0873cb39f8f3c82268f0d1fa820cdde7a0f149e", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/d0873cb39f8f3c82268f0d1fa820cdde7a0f149e", "committedDate": "2020-10-13T23:03:14Z", "message": "add ingestion test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3b3a9127b7924735ca42d3cdd4a5d91ad5e7f4d", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/c3b3a9127b7924735ca42d3cdd4a5d91ad5e7f4d", "committedDate": "2020-10-13T23:03:14Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d3d2b2bdae3da7aecfa48c0dc2d4e37838aeb20", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/7d3d2b2bdae3da7aecfa48c0dc2d4e37838aeb20", "committedDate": "2020-10-13T23:03:14Z", "message": "add fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96c7e220d05fd065866ad7e0b70a33ab738b178c", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/96c7e220d05fd065866ad7e0b70a33ab738b178c", "committedDate": "2020-10-13T23:03:14Z", "message": "change back log level"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72698b6b3d8523db7ba849da98c40e72d1e93f32", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/72698b6b3d8523db7ba849da98c40e72d1e93f32", "committedDate": "2020-10-13T23:03:15Z", "message": "use logger"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17f07728d3e1d37726b13c755418be581c19de1c", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/17f07728d3e1d37726b13c755418be581c19de1c", "committedDate": "2020-10-13T23:03:15Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a721dff9ee8611c9af421de565d301ed325c40b0", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/a721dff9ee8611c9af421de565d301ed325c40b0", "committedDate": "2020-10-13T23:03:15Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71f7de576b15dfc6cdaec1351a9d338d08c31c32", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/71f7de576b15dfc6cdaec1351a9d338d08c31c32", "committedDate": "2020-10-13T23:03:15Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38f42941a5e7c5132e916dcdff9101a817898ae1", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/38f42941a5e7c5132e916dcdff9101a817898ae1", "committedDate": "2020-10-13T23:03:15Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff342fc88a759ed0754ef0abe0eea0f84a185471", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/ff342fc88a759ed0754ef0abe0eea0f84a185471", "committedDate": "2020-10-13T23:03:15Z", "message": "fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "017e03406416b04eeb89fa21300d873f71466e55", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/017e03406416b04eeb89fa21300d873f71466e55", "committedDate": "2020-10-13T23:03:15Z", "message": "more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc40ec8ed477d46221ee2879cb8d889b3bbe2900", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/bc40ec8ed477d46221ee2879cb8d889b3bbe2900", "committedDate": "2020-10-13T23:03:15Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77b2d8ad4a24e87bc0db37139e2da7cc684e3623", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/77b2d8ad4a24e87bc0db37139e2da7cc684e3623", "committedDate": "2020-10-13T23:03:15Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b78faf4db59e1f7da6aa2b8599964c723a69c9a5", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/b78faf4db59e1f7da6aa2b8599964c723a69c9a5", "committedDate": "2020-10-13T23:03:15Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b145ac6adad0c3e6f1ed0a3600dfbc1f26c72d51", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/b145ac6adad0c3e6f1ed0a3600dfbc1f26c72d51", "committedDate": "2020-10-13T23:03:15Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18060adc535d171cb4b928cc8bc9a5142c524661", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/18060adc535d171cb4b928cc8bc9a5142c524661", "committedDate": "2020-10-13T23:03:15Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bda7184fe8b7b5f87e473142a8bc2a5d9cbc756c", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/bda7184fe8b7b5f87e473142a8bc2a5d9cbc756c", "committedDate": "2020-10-13T23:03:15Z", "message": "Fix the concurrency issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c08e7222b9e12b2e222ef230ccbe20ae2703d34", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/6c08e7222b9e12b2e222ef230ccbe20ae2703d34", "committedDate": "2020-10-13T23:03:15Z", "message": "Add more logs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "382c3f5a934f6d7654425a42660d37cfd01035ff", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/382c3f5a934f6d7654425a42660d37cfd01035ff", "committedDate": "2020-10-13T23:03:15Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "242d013310bea763d78720ec7bad5916338a513f", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/242d013310bea763d78720ec7bad5916338a513f", "committedDate": "2020-10-13T23:03:15Z", "message": "add missing resources"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29a8831d56f244269f34a81025a434dc4b1fa790", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/29a8831d56f244269f34a81025a434dc4b1fa790", "committedDate": "2020-10-13T23:03:15Z", "message": "Misc fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "152dc293e995b1cddbb3b4d727b6c9b81bed49ed", "author": {"user": {"login": "yupeng9", "name": "Yupeng Fu"}}, "url": "https://github.com/apache/pinot/commit/152dc293e995b1cddbb3b4d727b6c9b81bed49ed", "committedDate": "2020-10-13T20:13:33Z", "message": "add missing resources"}, "afterCommit": {"oid": "29a8831d56f244269f34a81025a434dc4b1fa790", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/29a8831d56f244269f34a81025a434dc4b1fa790", "committedDate": "2020-10-13T23:03:15Z", "message": "Misc fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac006cd57d80f8937499c147c8401e53baae437b", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/ac006cd57d80f8937499c147c8401e53baae437b", "committedDate": "2020-10-14T00:36:32Z", "message": "Fix concurrent issue in ThreadSafeMutableRoaringBitmap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3OTE5NDk2", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-507919496", "createdAt": "2020-10-14T00:38:43Z", "commit": {"oid": "ac006cd57d80f8937499c147c8401e53baae437b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NTU5NDA2", "url": "https://github.com/apache/pinot/pull/6113#pullrequestreview-508559406", "createdAt": "2020-10-14T17:10:03Z", "commit": {"oid": "ac006cd57d80f8937499c147c8401e53baae437b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNzoxMDowNFrOHhc9zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNzoxMDowNFrOHhc9zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzOTYzMQ==", "bodyText": "We should find a better way of getting partitionId than from the segment name. We are looking to integrate with other streams where partition ID is not an integer (e.g. kinesis). In that case, this will not work.\n@npawar may also want to comment on this", "url": "https://github.com/apache/pinot/pull/6113#discussion_r504839631", "createdAt": "2020-10-14T17:10:04Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -378,7 +463,12 @@ public void replaceLLSegment(String segmentName, IndexLoadingConfig indexLoading\n     try {\n       File indexDir = new File(_indexDir, segmentName);\n       Schema schema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n-      addSegment(ImmutableSegmentLoader.load(indexDir, indexLoadingConfig, schema));\n+      PartitionUpsertMetadataManager partitionUpsertMetadataManager = null;\n+      if (_tableUpsertMetadataManager != null) {\n+        int partitionId = new LLCSegmentName(segmentName).getPartitionId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac006cd57d80f8937499c147c8401e53baae437b"}, "originalPosition": 219}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1551, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}