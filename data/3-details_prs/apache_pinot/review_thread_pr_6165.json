{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MTE0NDQ3", "number": 6165, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowNDoxMlrOEv_qJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxOTozOFrOExRicg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzYxNTExOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowNDoxMlrOHlS1aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxNzozMVrOHmF9hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ==", "bodyText": "This will increase the number of tables in the map forever. Can you do a similar approach as is done in PinotLLCRealtimeSegmentManager? Maybe you can use the same config, or a hard-coded number of locks for now.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r508867945", "createdAt": "2020-10-20T22:04:12Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1643,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMTk1MA==", "bodyText": "It will be one per table, I feel it should be ok. The purpose of adding  this lock is to ensure we only update one segment per table at a time and we can still support multiple tables to be updated simultaneously.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r508901950", "createdAt": "2020-10-20T23:39:32Z", "author": {"login": "xiangfu0"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1643,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, "originalCommit": {"oid": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0ODM3Ng==", "bodyText": "Is this for offline segments? If so, how can this prevent other controllers from updating the idealstate?\nFor realtime, a lock makes sense since there is one leader for each table that handles idealstate update. Other controllers will handle different tables. This is not the case with offline segments.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r508948376", "createdAt": "2020-10-21T02:18:25Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1643,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, "originalCommit": {"oid": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MDgzOQ==", "bodyText": "This won't prevent from other controller, just to improve on the single controller update. In practice, it will help a lot on idealstate update as well, as we have only 3 parallel writes to update idealstates instead of segment push job parallelism.\nFrom client side, we can also try to push to one single controller to avoid the race condition.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r508990839", "createdAt": "2020-10-21T05:01:25Z", "author": {"login": "xiangfu0"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1643,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, "originalCommit": {"oid": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwNTMxNQ==", "bodyText": "Also, we hold the lock while backing off, so a single cross-controller contention will start building a queue? I think a better solution may to simply reduce the backoff time and try more often?\nAlso, we have clusters with 1000s of tables, and in this case, the hash table will contain all of them.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509405315", "createdAt": "2020-10-21T15:53:32Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1643,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, "originalCommit": {"oid": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU4NzI0Ng==", "bodyText": "@mcvsubbu A map with less than 10000 entries should be tiny (less than 1MB). Actually the _segmentCrcMap and _lastKnownSegmentMetadataVersionMap might cause problem because it stores an entry per segment, but that is out of the scope of this PR", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509587246", "createdAt": "2020-10-21T18:58:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1643,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, "originalCommit": {"oid": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNTYwNQ==", "bodyText": "Discussing offline, I gather this:\n\n\nThis helps in case of thousands of segments being pushed. For metadata push, we still need to generate the metadata from segment tar file, which takes time. In order to improve that, if we increase parallelism, then metadata generation improves. However, parallel push in segments start taking longer due to retries. If we reduce parallelism, the metadata generation slows down as well.\n\n\nWith this PR, we can still keep high parallelism for metadata generation, but also reduce longer update time (or even failures), by reducing the probability of retries.\n\n\nThe Map size should be small, and the synchronization is only for IS update. So this can be thought of as a bug fix, which is reducing number of retries, without penalizing on push time with parallelism.\n\n\nWe also discussed the following:\n\nWe can also reduce number of IS updates (and hence retries) by having bulk updates to IS. For example, metadata push can pack multiple segment metadatas in one POST call.\n\n@siddharthteotia please add anything I missed.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509705605", "createdAt": "2020-10-21T21:17:31Z", "author": {"login": "mayankshriv"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1643,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, "originalCommit": {"oid": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjAwMzM3OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo0MToyNlrOHl9ghQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo0MToyNlrOHl9ghQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2NzEwOQ==", "bodyText": "(nit) we don't use final for local variable", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509567109", "createdAt": "2020-10-21T18:41:26Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1505,10 +1507,19 @@ public void deleteOfflineTable(String tableName) {\n     LOGGER.info(\"Deleting table {}: Removed table config\", offlineTableName);\n \n     // Remove instance partitions\n+    final String rawTableName = TableNameBuilder.extractRawTableName(tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "145a314b7b4209c472c12e5875a6d5a13547b04f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjAzNDUxOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo0NzoxOFrOHl91aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo0NzoxOFrOHl91aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU3MjQ1Ng==", "bodyText": "The key is offlineTableName instead of rawTableName.\nAlso, no need to do check and remove here, directly remove should be good enough\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (_tableUpdaterLockMap.containsKey(rawTableName)) {\n          \n          \n            \n                _tableUpdaterLockMap.remove(offlineTableName);", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509572456", "createdAt": "2020-10-21T18:47:18Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1505,10 +1507,19 @@ public void deleteOfflineTable(String tableName) {\n     LOGGER.info(\"Deleting table {}: Removed table config\", offlineTableName);\n \n     // Remove instance partitions\n+    final String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n     InstancePartitionsUtils.removeInstancePartitions(_propertyStore,\n-        InstancePartitionsType.OFFLINE.getInstancePartitionsName(TableNameBuilder.extractRawTableName(tableName)));\n+        InstancePartitionsType.OFFLINE.getInstancePartitionsName(rawTableName));\n     LOGGER.info(\"Deleting table {}: Removed instance partitions\", offlineTableName);\n \n+    // Remove table locker if there\n+    if (_tableUpdaterLockMap.containsKey(rawTableName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "145a314b7b4209c472c12e5875a6d5a13547b04f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjA0Nzk5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo0OToxNVrOHl9-dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo0OToxNVrOHl9-dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU3NDc3NA==", "bodyText": "Use ConcurrentHashMap", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509574774", "createdAt": "2020-10-21T18:49:15Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -140,6 +140,8 @@\n \n   private final Map<String, Map<String, Long>> _segmentCrcMap = new HashMap<>();\n   private final Map<String, Map<String, Integer>> _lastKnownSegmentMetadataVersionMap = new HashMap<>();\n+  private final Map<String, Object> _tableUpdaterLockMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "145a314b7b4209c472c12e5875a6d5a13547b04f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjA3NDA1OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo1Mjo0NlrOHl-QaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo1Mjo0NlrOHl-QaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU3OTM2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  synchronized (_tableUpdaterLockMap.get(offlineTableName)) {\n          \n          \n            \n                  synchronized (_tableUpdaterLockMap.computeIfAbsent(offlineTableName, k -> new Object())) {", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509579368", "createdAt": "2020-10-21T18:52:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1652,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());\n+          }\n         }\n-        return idealState;\n-      });\n-      LOGGER.info(\"Added segment: {} to IdealState for table: {}\", segmentName, offlineTableName);\n+      }\n+      synchronized (_tableUpdaterLockMap.get(offlineTableName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "145a314b7b4209c472c12e5875a6d5a13547b04f"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzgzMDE2OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/HelixHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjozNjoyMVrOHm2PIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNToyNTowMlrOHm9EBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5NjU0NQ==", "bodyText": "I would use a random delay policy instead of fixed. Otherwise, you can have the same controllers coming back to update the IS at the same time.\nI don't think we have the policy, so you can create one.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510496545", "createdAt": "2020-10-22T22:36:21Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/HelixHelper.java", "diffHunk": "@@ -55,6 +55,7 @@\n   private static final String ENABLE_COMPRESSIONS_KEY = \"enableCompression\";\n \n   private static final RetryPolicy DEFAULT_RETRY_POLICY = RetryPolicies.exponentialBackoffRetryPolicy(5, 1000L, 2.0f);\n+  private static final RetryPolicy DEFAULT_TABLE_IDEALSTATES_UPDATE_RETRY_POLICY = RetryPolicies.fixedDelayRetryPolicy(20, 100L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a1012671337c8c2ae9457152e8792bb969e9331"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYwODM4OQ==", "bodyText": "added.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510608389", "createdAt": "2020-10-23T05:25:02Z", "author": {"login": "xiangfu0"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/HelixHelper.java", "diffHunk": "@@ -55,6 +55,7 @@\n   private static final String ENABLE_COMPRESSIONS_KEY = \"enableCompression\";\n \n   private static final RetryPolicy DEFAULT_RETRY_POLICY = RetryPolicies.exponentialBackoffRetryPolicy(5, 1000L, 2.0f);\n+  private static final RetryPolicy DEFAULT_TABLE_IDEALSTATES_UPDATE_RETRY_POLICY = RetryPolicies.fixedDelayRetryPolicy(20, 100L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5NjU0NQ=="}, "originalCommit": {"oid": "7a1012671337c8c2ae9457152e8792bb969e9331"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzg2Mjc2OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjo1MTowNlrOHm2iKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNToyNToxN1rOHm9E0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMTQxOA==", "bodyText": "hash code can be negative. use & INTEGER_MAX to get a positive. I fell into the same trap in the realtime part :-)", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510501418", "createdAt": "2020-10-22T22:51:06Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1672,6 +1679,10 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n     }\n   }\n \n+  private Object getTableUpdaterLock(String offlineTableName) {\n+    return _tableUpdaterLocks[offlineTableName.hashCode() % _tableUpdaterLocks.length];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a1012671337c8c2ae9457152e8792bb969e9331"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYwODU5NA==", "bodyText": "good catch :)", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510608594", "createdAt": "2020-10-23T05:25:17Z", "author": {"login": "xiangfu0"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1672,6 +1679,10 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n     }\n   }\n \n+  private Object getTableUpdaterLock(String offlineTableName) {\n+    return _tableUpdaterLocks[offlineTableName.hashCode() % _tableUpdaterLocks.length];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMTQxOA=="}, "originalCommit": {"oid": "7a1012671337c8c2ae9457152e8792bb969e9331"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAyODgxOnYy", "diffSide": "RIGHT", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxOToxNlrOHnUu_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToyMzozM1rOHnbOIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjIyMw==", "bodyText": "isn't it simpler to just do:\nreturn _minDelayMs + (long)((_maxDelayMs - _minDelayMs) * RANDOM.nextDouble())?", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510996223", "createdAt": "2020-10-23T16:19:16Z", "author": {"login": "mcvsubbu"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.utils.retry;\n+\n+import java.util.Random;\n+\n+\n+/**\n+ * Delay policy with random delay between attempts.\n+ */\n+public class RandomDelayRetryPolicy extends BaseRetryPolicy {\n+  private final static Random RANDOM = new Random(System.currentTimeMillis());\n+  private final long _minDelayMs;\n+  private final int _rangeUpper;\n+  private final int _rangeLower;\n+\n+  public RandomDelayRetryPolicy(int maxNumAttempts, long minDelayMs, long maxDelayMs) {\n+    super(maxNumAttempts);\n+    _minDelayMs = minDelayMs;\n+    _rangeUpper = (int) ((maxDelayMs - minDelayMs) / Integer.MAX_VALUE + 1);\n+    _rangeLower = (int) ((maxDelayMs - minDelayMs) % Integer.MAX_VALUE);\n+  }\n+\n+  @Override\n+  protected long getDelayMs(int currentAttempt) {\n+    return RANDOM.nextInt(_rangeUpper) * Integer.MAX_VALUE + RANDOM.nextInt(_rangeLower) + _minDelayMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d910f9d4c32ddae7a64c1b83655ca1684a73c42"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwMjQ5Nw==", "bodyText": "done", "url": "https://github.com/apache/pinot/pull/6165#discussion_r511102497", "createdAt": "2020-10-23T19:23:33Z", "author": {"login": "xiangfu0"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.utils.retry;\n+\n+import java.util.Random;\n+\n+\n+/**\n+ * Delay policy with random delay between attempts.\n+ */\n+public class RandomDelayRetryPolicy extends BaseRetryPolicy {\n+  private final static Random RANDOM = new Random(System.currentTimeMillis());\n+  private final long _minDelayMs;\n+  private final int _rangeUpper;\n+  private final int _rangeLower;\n+\n+  public RandomDelayRetryPolicy(int maxNumAttempts, long minDelayMs, long maxDelayMs) {\n+    super(maxNumAttempts);\n+    _minDelayMs = minDelayMs;\n+    _rangeUpper = (int) ((maxDelayMs - minDelayMs) / Integer.MAX_VALUE + 1);\n+    _rangeLower = (int) ((maxDelayMs - minDelayMs) % Integer.MAX_VALUE);\n+  }\n+\n+  @Override\n+  protected long getDelayMs(int currentAttempt) {\n+    return RANDOM.nextInt(_rangeUpper) * Integer.MAX_VALUE + RANDOM.nextInt(_rangeLower) + _minDelayMs;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjIyMw=="}, "originalCommit": {"oid": "6d910f9d4c32ddae7a64c1b83655ca1684a73c42"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAzMDI2OnYy", "diffSide": "RIGHT", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxOTozOFrOHnUv4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxOTozOFrOHnUv4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjQ1MA==", "bodyText": "Thanks for adding this. This will be useful in other places as well.", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510996450", "createdAt": "2020-10-23T16:19:38Z", "author": {"login": "mcvsubbu"}, "path": "pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.utils.retry;\n+\n+import java.util.Random;\n+\n+\n+/**\n+ * Delay policy with random delay between attempts.\n+ */\n+public class RandomDelayRetryPolicy extends BaseRetryPolicy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d910f9d4c32ddae7a64c1b83655ca1684a73c42"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3771, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}