{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NzExMTY5", "number": 5013, "title": "For RANGE predicate queries touching offline segments, use sorted inverted index if the column is sorted", "bodyText": "Motivation:\nCurrently, we don't leverage inverted index (sorted or bitmap) for RANGE predicates. Rather we resort to scan based iterator. If a column is sorted and has RANGE predicates like:\nWHERE COL >= 20000\nWHERE COL >= 20000 AND COL <= 25000\n.....\nUsing sorted inverted index is going to be much faster in such cases since the predicate evaluator can quickly give us start and end dictionary IDs for the RANGE we are going to evaluate.. All we need now is to query the inverted index:\nQuery the inverted index with startDictID to get the corresponding startDocId.\nQuery the inverted index with endDictId to get the corresponding endDocId.\nThis change is made in SortedInvertedIndexBasedFilterOperator. Later we can iterate on these or intersect. Using a scan based iterator for RANGE predicates on sorted column isn't really taking the advantage of the sorted nature of column and the fact that we don't really have go over all docIDs literally scanning the table.\nWe can only do this for offline segments  and committed realtime segments since for realtime segments (in-memory consuming segments), until the conversion happens the records aren't really sorted.\nIn a follow-up PR, we will explore adding support for leveraging bitmap inverted index for RANGE predicate", "createdAt": "2020-01-24T07:25:57Z", "url": "https://github.com/apache/pinot/pull/5013", "merged": true, "mergeCommit": {"oid": "f6d33be3098c16bf72f69dd8b965a8a90e5685b6"}, "closed": true, "closedAt": "2020-01-27T19:29:13Z", "author": {"login": "siddharthteotia"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9jQJ_AFqTM0ODE0MTM4Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-hUqOABqjI5ODI5Njc3OTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTQxMzgy", "url": "https://github.com/apache/pinot/pull/5013#pullrequestreview-348141382", "createdAt": "2020-01-24T18:28:38Z", "commit": {"oid": "4b76ea2e2a42c8995bd61e7e9c1f88cf7cca9eec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTQyNjU3", "url": "https://github.com/apache/pinot/pull/5013#pullrequestreview-348142657", "createdAt": "2020-01-24T18:30:56Z", "commit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxODozMDo1N1rOFhmhpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxODozMDo1N1rOFhmhpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODUzMg==", "bodyText": "This had to be fixed since DaysSinceEpoch is a sorted column and will be using sorted inverted index operator and doc id set. So the number of entries scanned in filter will be 0.", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370778532", "createdAt": "2020-01-24T18:30:57Z", "author": {"login": "siddharthteotia"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java", "diffHunk": "@@ -418,7 +418,6 @@ public void testDictionaryBasedQueries()\n     pqlQuery = \"SELECT MAX(ArrTime) FROM \" + DEFAULT_TABLE_NAME + \" where DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertTrue(response.get(\"numEntriesScannedPostFilter\").asLong() > 0);\n-    assertTrue(response.get(\"numEntriesScannedInFilter\").asLong() > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTcwMzcy", "url": "https://github.com/apache/pinot/pull/5013#pullrequestreview-348170372", "createdAt": "2020-01-24T19:20:42Z", "commit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxOToyMDo0MlrOFhn33A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxOTozNToxNVrOFhoRZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDYwNA==", "bodyText": "Can you change it to  assertEquals(response.get(\"numEntriesScannedInFilter\").asLong(), 0)?", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800604", "createdAt": "2020-01-24T19:20:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java", "diffHunk": "@@ -418,7 +418,6 @@ public void testDictionaryBasedQueries()\n     pqlQuery = \"SELECT MAX(ArrTime) FROM \" + DEFAULT_TABLE_NAME + \" where DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertTrue(response.get(\"numEntriesScannedPostFilter\").asLong() > 0);\n-    assertTrue(response.get(\"numEntriesScannedInFilter\").asLong() > 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODUzMg=="}, "originalCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDY3Mw==", "bodyText": "Same here", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800673", "createdAt": "2020-01-24T19:20:51Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java", "diffHunk": "@@ -469,7 +468,6 @@ public void testMetadataBasedQueries()\n     pqlQuery = \"SELECT COUNT(*) FROM \" + DEFAULT_TABLE_NAME + \" WHERE DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertEquals(response.get(\"numEntriesScannedPostFilter\").asLong(), 0);\n-    assertTrue(response.get(\"numEntriesScannedInFilter\").asLong() > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDk4MQ==", "bodyText": "(nit) new line", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800981", "createdAt": "2020-01-24T19:21:34Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.common.utils.Pairs;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.SelectionOnlyOperator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.pql.parsers.Pql2Compiler;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.testng.collections.Lists;\n+\n+\n+public class TestRangePredicateWithSortedInvertedIndex extends BaseQueriesTest {\n+  private static final int NUM_ROWS = 30000;\n+\n+  private List<GenericRow> _rows = new ArrayList<>();\n+\n+  private static final String D1 = \"STRING_COL\";\n+  private static final String M1 = \"INT_COL\"; // sorted column\n+  private static final String M2 = \"LONG_COL\";\n+\n+  private static final int INT_BASE_VALUE = 0;\n+\n+  private static final String TABLE_NAME = \"TestTable\";\n+  private static final int NUM_SEGMENTS = 1;\n+  private static final String SEGMENT_NAME_1 = TABLE_NAME + \"_100000000_200000000\";\n+  private static final File INDEX_DIR = new File(FileUtils.getTempDirectory(), \"SortedRangeTest\");\n+\n+  private List<IndexSegment> _indexSegments = new ArrayList<>(NUM_SEGMENTS);\n+  private final String[] stringValues = new String[NUM_ROWS];\n+  private final long[] longValues = new long[NUM_ROWS];\n+\n+  private Schema _schema;\n+\n+  @BeforeClass\n+  public void setUp() {\n+    createPinotTableSchema();\n+    createTestData();\n+  }\n+\n+  @AfterClass\n+  public void tearDown() {\n+    FileUtils.deleteQuietly(INDEX_DIR);\n+  }\n+\n+  private void createPinotTableSchema() {\n+    _schema =\n+        new Schema.SchemaBuilder().setSchemaName(TABLE_NAME).addSingleValueDimension(D1, FieldSpec.DataType.STRING)\n+            .addMetric(M1, FieldSpec.DataType.INT).addMetric(M2, FieldSpec.DataType.LONG).build();\n+  }\n+\n+  private void createTestData() {\n+    Random random = new Random();\n+    for (int rowIndex = 0; rowIndex < NUM_ROWS; rowIndex++) {\n+      GenericRow row = new GenericRow();\n+      stringValues[rowIndex] = RandomStringUtils.randomAlphanumeric(10);\n+      row.putValue(D1, stringValues[rowIndex]);\n+      row.putValue(M1, INT_BASE_VALUE + rowIndex);\n+      longValues[rowIndex] = random.nextLong();\n+      row.putValue(M2, longValues[rowIndex]);\n+      _rows.add(row);\n+    }\n+  }\n+\n+  @Override\n+  protected String getFilter() {\n+    return \"\";\n+  }\n+\n+  @Override\n+  protected IndexSegment getIndexSegment() {\n+    return _indexSegments.get(0);\n+  }\n+\n+  @Override\n+  protected List<SegmentDataManager> getSegmentDataManagers() {\n+    return null;\n+  }\n+\n+  private void createSegment(Schema schema, RecordReader recordReader, String segmentName, String tableName)\n+      throws Exception {\n+    SegmentGeneratorConfig segmentGeneratorConfig = new SegmentGeneratorConfig(schema);\n+    segmentGeneratorConfig.setTableName(tableName);\n+    segmentGeneratorConfig.setOutDir(INDEX_DIR.getAbsolutePath());\n+    segmentGeneratorConfig.setSegmentName(segmentName);\n+\n+    SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();\n+    driver.init(segmentGeneratorConfig, recordReader);\n+    driver.build();\n+\n+    File segmentIndexDir = new File(INDEX_DIR.getAbsolutePath(), segmentName);\n+    if (!segmentIndexDir.exists()) {\n+      throw new IllegalStateException(\"Segment generation failed\");\n+    }\n+  }\n+\n+  private ImmutableSegment loadSegment(String segmentName)\n+      throws Exception {\n+    return ImmutableSegmentLoader.load(new File(INDEX_DIR, segmentName), ReadMode.heap);\n+  }\n+\n+  @Test\n+  public void testInnerSegmentQuery()\n+      throws Exception {\n+    Random random = new Random();\n+    try (RecordReader recordReader = new GenericRowRecordReader(_rows, _schema)) {\n+      createSegment(_schema, recordReader, SEGMENT_NAME_1, TABLE_NAME);\n+      final ImmutableSegment immutableSegment = loadSegment(SEGMENT_NAME_1);\n+      _indexSegments.add(immutableSegment);\n+\n+      String query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL >= 20000 LIMIT 100000\";\n+      Pairs.IntPair pair = new Pairs.IntPair(20000, 29999);\n+      runQuery(query, 10000, Lists.newArrayList(pair), 2);\n+\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL >= 20000 AND INT_COL <= 23666 LIMIT 100000\";\n+      pair = new Pairs.IntPair(20000, 23666);\n+      runQuery(query, 3667, Lists.newArrayList(pair), 2);\n+\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL <= 20000 LIMIT 100000\";\n+      pair = new Pairs.IntPair(0, 20000);\n+      runQuery(query, 20001, Lists.newArrayList(pair), 2);\n+\n+      String filter = \"WHERE (INT_COL >= 15000 AND INT_COL <= 16665) OR (INT_COL >= 18000 AND INT_COL <= 19887)\";\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable \" + filter + \" LIMIT 100000\";\n+      pair = new Pairs.IntPair(15000, 16665);\n+      Pairs.IntPair pair1 = new Pairs.IntPair(18000, 19987);\n+      runQuery(query, 3554, Lists.newArrayList(pair, pair1), 2);\n+\n+      // range predicate on sorted column which will use sorted inverted index based iterator\n+      // along with range predicate on unsorted column that uses scan based iterator\n+      int index = random.nextInt(NUM_ROWS + 1);\n+      long longPredicateValue = longValues[index];\n+      int count = 0;\n+      List<Pairs.IntPair> pairs = new ArrayList<>();\n+      Pairs.IntPair current = null;\n+      for (int i = 0 ; i < longValues.length; i++) {\n+        if (longValues[i] >= longPredicateValue && i >= 15000 && i <= 16665) {\n+          if (current == null) {\n+            current = new Pairs.IntPair(i, i);\n+          } else {\n+            if (i == current.getRight() + 1) {\n+              current.setRight(i);\n+            } else {\n+              if (i <= longValues.length - 2) {\n+                pairs.add(current);\n+                current = new Pairs.IntPair(i, i);\n+              }\n+            }\n+          }\n+          count++;\n+        }\n+      }\n+      pairs.add(current);\n+      filter = \"WHERE INT_COL >= 15000 AND INT_COL <= 16665 AND LONG_COL >= \" + longPredicateValue;\n+      query = \"SELECT STRING_COL, INT_COL, LONG_COL FROM TestTable \" + filter + \" LIMIT 100000\";\n+      runQuery(query, count, pairs, 3);\n+    } finally {\n+      destroySegments();\n+    }\n+  }\n+\n+  private void runQuery(String query, int count, List<Pairs.IntPair> intPairs, int numColumns) {\n+    SelectionOnlyOperator operator = getOperatorForQuery(query);\n+    IntermediateResultsBlock block = operator.nextBlock();\n+    Collection<Serializable[]> rows = block.getSelectionResult();\n+    Assert.assertNotNull(rows);\n+    Assert.assertEquals(rows.size(), count);\n+    Pairs.IntPair pair = intPairs.get(0);\n+    int startPos = pair.getLeft();\n+    int pairPos = 0;\n+    for (Serializable[] row : rows) {\n+      Assert.assertEquals(numColumns, row.length);\n+      Assert.assertEquals(row[0], stringValues[startPos]);\n+      Assert.assertEquals(row[1], startPos);\n+      if (numColumns == 3) {\n+        Assert.assertEquals(row[2], longValues[startPos]);\n+      }\n+      startPos++;\n+      if (startPos > pair.getRight() && pairPos <= intPairs.size() - 2) {\n+        pairPos++;\n+        pair = intPairs.get(pairPos);\n+        startPos = pair.getLeft();\n+      }\n+    }\n+  }\n+\n+  private void destroySegments() {\n+    for (IndexSegment indexSegment : _indexSegments) {\n+      if (indexSegment != null) {\n+        indexSegment.destroy();\n+      }\n+    }\n+    _indexSegments.clear();\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNTk0NA==", "bodyText": "This is not efficient. We should add getStartDictId() and getEndDictId() to OfflineDictionaryBasedRangePredicateEvaluator, and directly get the start and end dict id.", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370805944", "createdAt": "2020-01-24T19:32:39Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedInvertedIndexBasedFilterOperator.java", "diffHunk": "@@ -78,82 +79,92 @@ protected FilterBlock getNextBlock() {\n     int[] dictIds = exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();\n \n     if (0 < dictIds.length) {\n-      // Sort the dictIds in ascending order, so that their respective ranges are adjacent if their dictIds are adjacent\n-      Arrays.sort(dictIds);\n+      if (_predicateEvaluator instanceof RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator) {\n+        // optimized path for RANGE predicate evaluation using sorted index.\n+        // dictIds will already be sorted since we use sorted index based evaluation\n+        // for RANGE predicates only on offline segments.\n+        // so build a pair with startDocId and endDocId\n+        IntPair pair1 = invertedIndex.getDocIds(dictIds[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg==", "bodyText": "I think checking dataSourceMetadata.isSorted() should be enough?", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370807142", "createdAt": "2020-01-24T19:35:15Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java", "diffHunk": "@@ -56,16 +57,23 @@ public static BaseFilterOperator getLeafFilterOperator(PredicateEvaluator predic\n     // Use inverted index if the predicate type is not RANGE or REGEXP_LIKE for efficiency\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n-    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.RANGE) && (predicateType\n-        != Predicate.Type.REGEXP_LIKE)) {\n-      if (dataSourceMetadata.isSorted()) {\n+    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n+      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MjcwNzcz", "url": "https://github.com/apache/pinot/pull/5013#pullrequestreview-348270773", "createdAt": "2020-01-24T22:59:30Z", "commit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMjo1OTozMFrOFhspAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMjo1OTozMFrOFhspAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODcyMg==", "bodyText": "The condition here seems not consistent with the PR summary/title. For example, take the first part of OR in (2). It says sorted inverted index can be used if (1) column is sorted AND (2) predicate is not RANGE. This is not what the PR title means. Am I missing anything here?", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370878722", "createdAt": "2020-01-24T22:59:30Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java", "diffHunk": "@@ -56,16 +57,23 @@ public static BaseFilterOperator getLeafFilterOperator(PredicateEvaluator predic\n     // Use inverted index if the predicate type is not RANGE or REGEXP_LIKE for efficiency\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n-    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.RANGE) && (predicateType\n-        != Predicate.Type.REGEXP_LIKE)) {\n-      if (dataSourceMetadata.isSorted()) {\n+    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n+      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {\n         return new SortedInvertedIndexBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n-      } else {\n+      } else if (predicateType != Predicate.Type.RANGE) {\n+        // TODO: add support for bitmap inverted index operator can be used for RANGE predicate\n         return new BitmapBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n       }\n-    } else {\n-      return new ScanBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n     }\n+    return new ScanBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n+  }\n+\n+  private static boolean shouldUseSortedInvertedIndexOperator(DataSource dataSource, Predicate.Type predicateType) {\n+    boolean isSorted = dataSource.getDataSourceMetadata().isSorted();\n+    // we can sorted inverted index if:\n+    // 1. column is sorted AND\n+    // 2. predicate is not RANGE OR predicate is RANGE but this physical plan is being built for offline segment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "committedDate": "2020-01-24T18:29:08Z", "message": "Fix test failure"}, "afterCommit": {"oid": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/754a54c17cd95ff878d6efd5c039240cfdbac8f2", "committedDate": "2020-01-24T23:54:13Z", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/754a54c17cd95ff878d6efd5c039240cfdbac8f2", "committedDate": "2020-01-24T23:54:13Z", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index."}, "afterCommit": {"oid": "c9ff3dd50952719e07842b5de7c5816257404880", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c9ff3dd50952719e07842b5de7c5816257404880", "committedDate": "2020-01-27T18:24:01Z", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4ODc2NTM1", "url": "https://github.com/apache/pinot/pull/5013#pullrequestreview-348876535", "createdAt": "2020-01-27T18:22:58Z", "commit": {"oid": "754a54c17cd95ff878d6efd5c039240cfdbac8f2"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoyMjo1OFrOFiMu6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODoyNToxOFrOFiMzYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNDUyMg==", "bodyText": "Let's return _endDictId and do this -1 at the caller side with comments for readability", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371404522", "createdAt": "2020-01-27T18:22:58Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/RangePredicateEvaluatorFactory.java", "diffHunk": "@@ -129,6 +129,14 @@ public static BaseRawValueBasedPredicateEvaluator newRawValueBasedEvaluator(Rang\n       }\n     }\n \n+    public int getStartDictId() {\n+      return _startDictId;\n+    }\n+\n+    public int getEndDictId() {\n+      return _endDictId - 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "754a54c17cd95ff878d6efd5c039240cfdbac8f2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNTAxOA==", "bodyText": "You mean dataSourceMetadata.isSorted() is always false for realtime right?", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371405018", "createdAt": "2020-01-27T18:24:02Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java", "diffHunk": "@@ -56,16 +57,23 @@ public static BaseFilterOperator getLeafFilterOperator(PredicateEvaluator predic\n     // Use inverted index if the predicate type is not RANGE or REGEXP_LIKE for efficiency\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n-    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.RANGE) && (predicateType\n-        != Predicate.Type.REGEXP_LIKE)) {\n-      if (dataSourceMetadata.isSorted()) {\n+    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n+      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, "originalCommit": {"oid": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNTY2NQ==", "bodyText": "Can you rename this to RangePredicateWithSortedInvertedIndexTest?", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371405665", "createdAt": "2020-01-27T18:25:18Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.common.utils.Pairs;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.SelectionOnlyOperator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.pql.parsers.Pql2Compiler;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.testng.collections.Lists;\n+\n+\n+public class TestRangePredicateWithSortedInvertedIndex extends BaseQueriesTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ff3dd50952719e07842b5de7c5816257404880"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1728e1049d0504cf2c25a2e8252093ae90c2fd09", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/1728e1049d0504cf2c25a2e8252093ae90c2fd09", "committedDate": "2020-01-27T18:47:24Z", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9ff3dd50952719e07842b5de7c5816257404880", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c9ff3dd50952719e07842b5de7c5816257404880", "committedDate": "2020-01-27T18:24:01Z", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index."}, "afterCommit": {"oid": "1728e1049d0504cf2c25a2e8252093ae90c2fd09", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/1728e1049d0504cf2c25a2e8252093ae90c2fd09", "committedDate": "2020-01-27T18:47:24Z", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1529, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}