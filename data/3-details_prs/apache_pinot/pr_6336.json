{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NzQxMjEx", "number": 6336, "title": "Segment reset API", "bodyText": "Adding a reset API. This API will disable and then enable the segment. This API will be useful in case of resetting consumers which are stuck as reported in #6308.\nNOTE: Manual testing done. Writing tests pending.\n\nIf the segment is in ERROR state, invoking this API will send state transitions first to OFFLINE, wait for EV to stabilize, and then back to ONLINE/CONSUMING.\nIf segment is ONLINE/CONSUMING, invoking this API will send state transitions, first to OFFLINE, wait for EV to stabilize, and then back to ONLINE/CONSUMING.\n\nReset one segment:\n curl -X POST \"http://localhost:9000/segments/transcript_REALTIME/transcript__1__3__20201208T1956Z/reset\" -H \"accept: application/json\"\n{\"status\":\"Successfully reset segment: transcript__1__3__20201208T1956Z of table: transcript_REALTIME\"}\n\nReset all segments:\ncurl -X POST \"http://localhost:9000/segments/transcript_REALTIME/reset\" -H \"accept: application/json\" \n{\"status\":\"Successfully reset all segments of table: transcript_REALTIME\"}", "createdAt": "2020-12-08T21:37:58Z", "url": "https://github.com/apache/pinot/pull/6336", "merged": true, "mergeCommit": {"oid": "37f2e28a37df53f14daf4ce9205a71f9318dce1e"}, "closed": true, "closedAt": "2020-12-30T21:47:41Z", "author": {"login": "npawar"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkSTo1gFqTU0NzcwMjQ2Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdrTgvOAH2gAyNTM0NzQxMjExOjQxNWE2Yzc1ZGY3N2QyODYyN2I4Nzc2NDQxN2IyNDI0ZmViMTNhMmY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzAyNDY2", "url": "https://github.com/apache/pinot/pull/6336#pullrequestreview-547702466", "createdAt": "2020-12-08T22:56:45Z", "commit": {"oid": "28559440d71cf762b3c0605aba417e4713242d11"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo1Njo0NVrOIB6Dhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo1NzoxN1rOIB6F7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MDY2Mg==", "bodyText": "Can you document what this API call does (or, is supposed to do)?  Can it throw some exceptions that we need to catch (or not catch)?", "url": "https://github.com/apache/pinot/pull/6336#discussion_r538870662", "createdAt": "2020-12-08T22:56:45Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1768,6 +1770,63 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28559440d71cf762b3c0605aba417e4713242d11"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MDkxNw==", "bodyText": "I remember we used to have this disable/enable (aka toggle)  in segments API before, we had a lot of problems with it. We used it for refreshing segments, and then we moved to use the refresh helix message instead.", "url": "https://github.com/apache/pinot/pull/6336#discussion_r538870917", "createdAt": "2020-12-08T22:56:57Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1768,6 +1770,63 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28559440d71cf762b3c0605aba417e4713242d11"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MTI3OQ==", "bodyText": "Dont we need to wait until externalview stabiliizes before calling enable again?", "url": "https://github.com/apache/pinot/pull/6336#discussion_r538871279", "createdAt": "2020-12-08T22:57:17Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1768,6 +1770,63 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28559440d71cf762b3c0605aba417e4713242d11"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aedf147b503d212266985ca27fc7371a3fb310ae", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/aedf147b503d212266985ca27fc7371a3fb310ae", "committedDate": "2020-12-22T17:25:14Z", "message": "Segment reset API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/d4952f9e7f01143a286bed19bbd0102525ad12c2", "committedDate": "2020-12-23T03:12:28Z", "message": "Wait for EV to stabilize"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28559440d71cf762b3c0605aba417e4713242d11", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/28559440d71cf762b3c0605aba417e4713242d11", "committedDate": "2020-12-08T21:29:59Z", "message": "Segment reset API"}, "afterCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/d4952f9e7f01143a286bed19bbd0102525ad12c2", "committedDate": "2020-12-23T03:12:28Z", "message": "Wait for EV to stabilize"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4MTM4OTMz", "url": "https://github.com/apache/pinot/pull/6336#pullrequestreview-558138933", "createdAt": "2020-12-23T17:36:44Z", "commit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxNzozNjo0NFrOIKr9KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxNzo1MzoyOFrOIKsxpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3Njg0MA==", "bodyText": "Can we keep the log messages consistent? Let us call it a segment instead of partition.  (please check other log messages as well)", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548076840", "createdAt": "2020-12-23T17:36:44Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3NjkzMw==", "bodyText": "All that this parameter does is to override the admin command wait time. Why not call it something like that? We can then add it to any admin command now or later with the same name.\nSuggested:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {\n          \n          \n            \n                  @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed\") @QueryParam(\"maxWaitTimeMs\") long externalViewWaitTimeMs) {", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548076933", "createdAt": "2020-12-23T17:36:50Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +354,61 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\",\n+      notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3ODcwNQ==", "bodyText": "Please make sure that this error message shows up on the console or curl command if table type is not given. Sometimes we see that the precondition check error message does not show up, and we get a 5xx error (this should be a 4xx error)", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548078705", "createdAt": "2020-12-23T17:38:52Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +354,61 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\",\n+      notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {\n+    segmentName = URIUtils.decode(segmentName);\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3OTA4Mg==", "bodyText": "better to include the table name in the message. Also, you may want to word it such that it clearly implies that the reset is completed.", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548079082", "createdAt": "2020-12-23T17:39:21Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +354,61 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\",\n+      notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {\n+    segmentName = URIUtils.decode(segmentName);\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetSegment(tableNameWithType, segmentName,\n+          externalViewWaitTimeMs > 0 ? externalViewWaitTimeMs\n+              : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(\"Successfully invoked segment reset\");\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segment: %s in table: %s. %s\", segmentName, tableNameWithType, e.getMessage()),\n+          Status.NOT_FOUND);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of the given table\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets all segments of the table, by first disabling them, waiting for external view to stabilize, and finally enabling the segments\",\n+      notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetAllSegments(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetAllSegments(tableNameWithType, externalViewWaitTimeMs > 0 ? externalViewWaitTimeMs\n+          : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(\"Successfully invoked segment reset\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3OTgyOQ==", "bodyText": "should be a 4xx error", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548079829", "createdAt": "2020-12-23T17:40:12Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4MDE2Mw==", "bodyText": "should be 4xx error (unless pinot messed up real bad. :-))", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548080163", "createdAt": "2020-12-23T17:40:35Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4MjYzOQ==", "bodyText": "Please add a thread.sleep here instead of a busy-wait loop. Suggestion:\nThread.sleep(min(100,maxWaitTimeMillis/10))", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548082639", "createdAt": "2020-12-23T17:43:38Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4NDg0NQ==", "bodyText": "suggest naming the variables with segments instead of partritions. We do have two other semantics of partitions that is already confusing (stream partitions, and partitioning of data in segment assignment)", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548084845", "createdAt": "2020-12-23T17:46:52Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }\n+    if (!instancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of partition: %s of table: %s\",\n+          segmentName, tableNameWithType));\n+    }\n+\n+    // Enable partition\n+    LOGGER.info(\"Enabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+    for (String instance : instanceSet) {\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of a table by disabling and then enabling the segments\n+   */\n+  public void resetAllSegments(String tableNameWithType, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+\n+    Map<String, Set<String>> resetInstanceToPartitionsMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4Njk0OA==", "bodyText": "Dont you have to enable the partition (segment) again after this call?", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548086948", "createdAt": "2020-12-23T17:49:17Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4ODAxNQ==", "bodyText": "Not sure if we can start off with no external view at thsi point, since helix will still be processing the reset calls.", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548088015", "createdAt": "2020-12-23T17:50:50Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }\n+    if (!instancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of partition: %s of table: %s\",\n+          segmentName, tableNameWithType));\n+    }\n+\n+    // Enable partition\n+    LOGGER.info(\"Enabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+    for (String instance : instanceSet) {\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of a table by disabling and then enabling the segments\n+   */\n+  public void resetAllSegments(String tableNameWithType, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+\n+    Map<String, Set<String>> resetInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> disableInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> partitionInstancesToCheck = new HashMap<>();\n+\n+    for (String partition : idealState.getPartitionSet()) {\n+      Set<String> instanceSet = idealState.getInstanceSet(partition);\n+      Map<String, String> externalViewStateMap = externalView.getStateMap(partition);\n+      for (String instance : instanceSet) {\n+        if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+          resetInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        } else {\n+          disableInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        }\n+      }\n+      partitionInstancesToCheck.put(partition, new HashSet<>(instanceSet));\n+    }\n+\n+    // First, disable/reset the partitions\n+    LOGGER.info(\"Disabling/resetting partitions of table: {}\", tableNameWithType);\n+    for (Map.Entry<String, Set<String>> entry : resetInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.resetPartition(_helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+    for (Map.Entry<String, Set<String>> entry : disableInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(false, _helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partitions of table: {}\",\n+        externalViewWaitTimeMs, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    while (!partitionInstancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4ODkwMQ==", "bodyText": "Please add a sleep here like in the other case, instead of busy-waiting.", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548088901", "createdAt": "2020-12-23T17:51:48Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }\n+    if (!instancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of partition: %s of table: %s\",\n+          segmentName, tableNameWithType));\n+    }\n+\n+    // Enable partition\n+    LOGGER.info(\"Enabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+    for (String instance : instanceSet) {\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of a table by disabling and then enabling the segments\n+   */\n+  public void resetAllSegments(String tableNameWithType, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+\n+    Map<String, Set<String>> resetInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> disableInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> partitionInstancesToCheck = new HashMap<>();\n+\n+    for (String partition : idealState.getPartitionSet()) {\n+      Set<String> instanceSet = idealState.getInstanceSet(partition);\n+      Map<String, String> externalViewStateMap = externalView.getStateMap(partition);\n+      for (String instance : instanceSet) {\n+        if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+          resetInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        } else {\n+          disableInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        }\n+      }\n+      partitionInstancesToCheck.put(partition, new HashSet<>(instanceSet));\n+    }\n+\n+    // First, disable/reset the partitions\n+    LOGGER.info(\"Disabling/resetting partitions of table: {}\", tableNameWithType);\n+    for (Map.Entry<String, Set<String>> entry : resetInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.resetPartition(_helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+    for (Map.Entry<String, Set<String>> entry : disableInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(false, _helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partitions of table: {}\",\n+        externalViewWaitTimeMs, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    while (!partitionInstancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Iterator<Map.Entry<String, Set<String>>> iterator = partitionInstancesToCheck.entrySet().iterator();\n+      while (iterator.hasNext()) {\n+        Map.Entry<String, Set<String>> entryToCheck = iterator.next();\n+        String partitionToCheck = entryToCheck.getKey();\n+        Set<String> instancesToCheck = entryToCheck.getValue();\n+        Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(partitionToCheck);\n+        if (newExternalViewStateMap == null) {\n+          continue;\n+        }\n+        boolean allOffline = true;\n+        for (String instance : instancesToCheck) {\n+          if (!SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance))) {\n+            allOffline = false;\n+            break;\n+          }\n+        }\n+        if (allOffline) {\n+          iterator.remove();\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA5MDI3Ng==", "bodyText": "Why do we have an enable here and one in line 1869? Can you clarify again if helix expects two of these in the reset api ?", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548090276", "createdAt": "2020-12-23T17:53:28Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }\n+    if (!instancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of partition: %s of table: %s\",\n+          segmentName, tableNameWithType));\n+    }\n+\n+    // Enable partition\n+    LOGGER.info(\"Enabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+    for (String instance : instanceSet) {\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of a table by disabling and then enabling the segments\n+   */\n+  public void resetAllSegments(String tableNameWithType, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+\n+    Map<String, Set<String>> resetInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> disableInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> partitionInstancesToCheck = new HashMap<>();\n+\n+    for (String partition : idealState.getPartitionSet()) {\n+      Set<String> instanceSet = idealState.getInstanceSet(partition);\n+      Map<String, String> externalViewStateMap = externalView.getStateMap(partition);\n+      for (String instance : instanceSet) {\n+        if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+          resetInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        } else {\n+          disableInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        }\n+      }\n+      partitionInstancesToCheck.put(partition, new HashSet<>(instanceSet));\n+    }\n+\n+    // First, disable/reset the partitions\n+    LOGGER.info(\"Disabling/resetting partitions of table: {}\", tableNameWithType);\n+    for (Map.Entry<String, Set<String>> entry : resetInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.resetPartition(_helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+    for (Map.Entry<String, Set<String>> entry : disableInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(false, _helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partitions of table: {}\",\n+        externalViewWaitTimeMs, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    while (!partitionInstancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Iterator<Map.Entry<String, Set<String>>> iterator = partitionInstancesToCheck.entrySet().iterator();\n+      while (iterator.hasNext()) {\n+        Map.Entry<String, Set<String>> entryToCheck = iterator.next();\n+        String partitionToCheck = entryToCheck.getKey();\n+        Set<String> instancesToCheck = entryToCheck.getValue();\n+        Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(partitionToCheck);\n+        if (newExternalViewStateMap == null) {\n+          continue;\n+        }\n+        boolean allOffline = true;\n+        for (String instance : instancesToCheck) {\n+          if (!SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance))) {\n+            allOffline = false;\n+            break;\n+          }\n+        }\n+        if (allOffline) {\n+          iterator.remove();\n+        }\n+      }\n+    }\n+    if (!partitionInstancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of segments of table: %s\",\n+          tableNameWithType));\n+    }\n+\n+    // Enable partitions\n+    LOGGER.info(\"Enabling partitions of table: {}\", tableNameWithType);\n+    for (Map.Entry<String, Set<String>> entry : resetInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(true, _helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+    for (Map.Entry<String, Set<String>> entry : disableInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(true, _helixClusterName, entry.getKey(), tableNameWithType, partitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2"}, "originalPosition": 153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b85aec7b8d62f702bc633ce81243edad8219de75", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/b85aec7b8d62f702bc633ce81243edad8219de75", "committedDate": "2020-12-29T00:40:52Z", "message": "s/partitions/segments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b42d947d15256a2150074f08045b803dc11f73f", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/7b42d947d15256a2150074f08045b803dc11f73f", "committedDate": "2020-12-29T01:22:24Z", "message": "some comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5OTI2NTgw", "url": "https://github.com/apache/pinot/pull/6336#pullrequestreview-559926580", "createdAt": "2020-12-30T06:44:58Z", "commit": {"oid": "7b42d947d15256a2150074f08045b803dc11f73f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNjo0NDo1OFrOIMegxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNjo0NzozMFrOIMeoFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1MzczNQ==", "bodyText": "what is the exception thrown if it takes longer for whatever reason?", "url": "https://github.com/apache/pinot/pull/6336#discussion_r549953735", "createdAt": "2020-12-30T06:44:58Z", "author": {"login": "kishoreg"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +355,67 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\", notes = \"Resets a segment by disabling and then enabling the segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed. By default, uses serverAdminRequestTimeout\") @QueryParam(\"maxWaitTimeMs\") long maxWaitTimeMs) {\n+    segmentName = URIUtils.decode(segmentName);\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetSegment(tableNameWithType, segmentName,\n+          maxWaitTimeMs > 0 ? maxWaitTimeMs : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(\n+          String.format(\"Successfully reset segment: %s of table: %s\", segmentName, tableNameWithType));\n+    } catch (IllegalStateException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segments in table: %s. %s\", tableNameWithType, e.getMessage()),\n+          Status.NOT_FOUND);\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segment: %s of table: %s. %s\", segmentName, tableNameWithType, e.getMessage()),\n+          Status.INTERNAL_SERVER_ERROR);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of the given table\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets all segments of the table, by first disabling them, waiting for external view to stabilize, and finally enabling the segments\", notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetAllSegments(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed. By default, uses serverAdminRequestTimeout\") @QueryParam(\"maxWaitTimeMs\") long maxWaitTimeMs) {\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetAllSegments(tableNameWithType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b42d947d15256a2150074f08045b803dc11f73f"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1NTYwNQ==", "bodyText": "handle timeout exception separately and lets make sure we provide the right message that it timed out but it might get completed in the background?", "url": "https://github.com/apache/pinot/pull/6336#discussion_r549955605", "createdAt": "2020-12-30T06:47:30Z", "author": {"login": "kishoreg"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +355,67 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\", notes = \"Resets a segment by disabling and then enabling the segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed. By default, uses serverAdminRequestTimeout\") @QueryParam(\"maxWaitTimeMs\") long maxWaitTimeMs) {\n+    segmentName = URIUtils.decode(segmentName);\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetSegment(tableNameWithType, segmentName,\n+          maxWaitTimeMs > 0 ? maxWaitTimeMs : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(\n+          String.format(\"Successfully reset segment: %s of table: %s\", segmentName, tableNameWithType));\n+    } catch (IllegalStateException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segments in table: %s. %s\", tableNameWithType, e.getMessage()),\n+          Status.NOT_FOUND);\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segment: %s of table: %s. %s\", segmentName, tableNameWithType, e.getMessage()),\n+          Status.INTERNAL_SERVER_ERROR);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of the given table\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets all segments of the table, by first disabling them, waiting for external view to stabilize, and finally enabling the segments\", notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetAllSegments(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed. By default, uses serverAdminRequestTimeout\") @QueryParam(\"maxWaitTimeMs\") long maxWaitTimeMs) {\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetAllSegments(tableNameWithType,\n+          maxWaitTimeMs > 0 ? maxWaitTimeMs : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(String.format(\"Successfully reset all segments of table: %s\", tableNameWithType));\n+    } catch (IllegalStateException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segments in table: %s. %s\", tableNameWithType, e.getMessage()),\n+          Status.NOT_FOUND);\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b42d947d15256a2150074f08045b803dc11f73f"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "415a6c75df77d28627b87764417b2424feb13a2f", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/415a6c75df77d28627b87764417b2424feb13a2f", "committedDate": "2020-12-30T18:19:56Z", "message": "Better message"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1628, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}