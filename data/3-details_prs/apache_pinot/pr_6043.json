{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNjg1NDAy", "number": 6043, "title": "Add IN_PARTITIONED_SUBQUERY support", "bodyText": "Description\nAdd IN_PARTITIONED_SUBQUERY transform function to support IDSET aggregation function as the subquery on the server side. Because the subquery is solved on the server side, in order to make it work, the subquery must hit the same table as the main query, and the table must be partitioned at server level (all the segments for a partition is served by a single server).\nE.g. The following 2 queries can be combined into one query:\nSELECT ID_SET(col) FROM table WHERE date = 20200901\nSELECT DISTINCT_COUNT(col), date FROM table WHERE IN_ID_SET(col, '<serializedIdSet>') = 1 GROUP BY date\n->\nSELECT DISTINCT_COUNT(col), date FROM table WHERE IN_PARTITIONED_SUBQUERY(col, 'SELECT ID_SET(col) FROM table WHERE date = 20200901') = 1 GROUP BY date", "createdAt": "2020-09-22T04:36:11Z", "url": "https://github.com/apache/pinot/pull/6043", "merged": true, "mergeCommit": {"oid": "42427065ccceeeb497515852cb77807b07e80c5c"}, "closed": true, "closedAt": "2020-11-01T19:04:07Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLgv3ngBqjM3OTU1NzcyNzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdYRJPlAFqTUyMTIzMTQxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "78a439d7f764316b3ed12743bab5678a16ca9aaf", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/78a439d7f764316b3ed12743bab5678a16ca9aaf", "committedDate": "2020-09-22T04:32:07Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}, "afterCommit": {"oid": "49f09fb7ca84ce83284232d281bc33ab0c765767", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/49f09fb7ca84ce83284232d281bc33ab0c765767", "committedDate": "2020-09-22T23:39:26Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49f09fb7ca84ce83284232d281bc33ab0c765767", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/49f09fb7ca84ce83284232d281bc33ab0c765767", "committedDate": "2020-09-22T23:39:26Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}, "afterCommit": {"oid": "18ad00fa0c1cc938969839dacf8ada5c754a9f61", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/18ad00fa0c1cc938969839dacf8ada5c754a9f61", "committedDate": "2020-10-08T04:50:09Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDczNjc3", "url": "https://github.com/apache/pinot/pull/6043#pullrequestreview-506073677", "createdAt": "2020-10-10T07:03:26Z", "commit": {"oid": "18ad00fa0c1cc938969839dacf8ada5c754a9f61"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwNzowMzoyN1rOHfd1jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwNzoxNTowMVrOHfd5Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc1Njc0OQ==", "bodyText": "add java docs on what this method is doing", "url": "https://github.com/apache/pinot/pull/6043#discussion_r502756749", "createdAt": "2020-10-10T07:03:27Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/executor/ServerQueryExecutorV1Impl.java", "diffHunk": "@@ -277,4 +253,112 @@ public DataTable processQuery(ServerQueryRequest queryRequest, ExecutorService e\n     LOGGER.debug(\"InstanceResponse for request Id - {}: {}\", requestId, dataTable);\n     return dataTable;\n   }\n+\n+  private DataTable processQuery(List<IndexSegment> indexSegments, QueryContext queryContext, TimerContext timerContext,\n+      ExecutorService executorService, @Nullable StreamObserver<Server.ServerResponse> responseObserver, long endTimeMs,\n+      boolean enableStreaming)\n+      throws Exception {\n+    handleSubquery(queryContext, indexSegments, timerContext, executorService, endTimeMs);\n+\n+    // Compute total docs for the table before pruning the segments\n+    long numTotalDocs = 0;\n+    for (IndexSegment indexSegment : indexSegments) {\n+      numTotalDocs += indexSegment.getSegmentMetadata().getTotalDocs();\n+    }\n+\n+    TimerContext.Timer segmentPruneTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.SEGMENT_PRUNING);\n+    List<IndexSegment> selectedSegments = _segmentPrunerService.prune(indexSegments, queryContext);\n+    segmentPruneTimer.stopAndRecord();\n+    int numSelectedSegments = selectedSegments.size();\n+    LOGGER.debug(\"Matched {} segments after pruning\", numSelectedSegments);\n+    if (numSelectedSegments == 0) {\n+      // Only return metadata for streaming query\n+      DataTable dataTable = enableStreaming ? new DataTableImplV2() : DataTableUtils.buildEmptyDataTable(queryContext);\n+      Map<String, String> metadata = dataTable.getMetadata();\n+      metadata.put(DataTable.TOTAL_DOCS_METADATA_KEY, String.valueOf(numTotalDocs));\n+      metadata.put(DataTable.NUM_DOCS_SCANNED_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_ENTRIES_SCANNED_IN_FILTER_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_ENTRIES_SCANNED_POST_FILTER_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_SEGMENTS_PROCESSED, \"0\");\n+      metadata.put(DataTable.NUM_SEGMENTS_MATCHED, \"0\");\n+      return dataTable;\n+    } else {\n+      TimerContext.Timer planBuildTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.BUILD_QUERY_PLAN);\n+      Plan queryPlan = enableStreaming ? _planMaker\n+          .makeStreamingInstancePlan(selectedSegments, queryContext, executorService, responseObserver, endTimeMs)\n+          : _planMaker.makeInstancePlan(selectedSegments, queryContext, executorService, endTimeMs);\n+      planBuildTimer.stopAndRecord();\n+\n+      TimerContext.Timer planExecTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.QUERY_PLAN_EXECUTION);\n+      DataTable dataTable = queryPlan.execute();\n+      planExecTimer.stopAndRecord();\n+\n+      // Update the total docs in the metadata based on the un-pruned segments\n+      dataTable.getMetadata().put(DataTable.TOTAL_DOCS_METADATA_KEY, Long.toString(numTotalDocs));\n+\n+      return dataTable;\n+    }\n+  }\n+\n+  /**\n+   * Handles the subquery in the given query.\n+   * <p>Currently only supports subquery within IN_PARTITIONED_SUBQUERY function.\n+   */\n+  private void handleSubquery(QueryContext queryContext, List<IndexSegment> indexSegments, TimerContext timerContext,\n+      ExecutorService executorService, long endTimeMs)\n+      throws Exception {\n+    FilterContext filter = queryContext.getFilter();\n+    if (filter != null) {\n+      handleSubquery(filter, indexSegments, timerContext, executorService, endTimeMs);\n+    }\n+  }\n+\n+  /**\n+   * Handles the subquery in the filter.\n+   * <p>Currently only supports subquery within IN_PARTITIONED_SUBQUERY function.\n+   */\n+  private void handleSubquery(FilterContext filter, List<IndexSegment> indexSegments, TimerContext timerContext,\n+      ExecutorService executorService, long endTimeMs)\n+      throws Exception {\n+    Predicate predicate = filter.getPredicate();\n+    if (predicate != null) {\n+      handleSubquery(predicate.getLhs(), indexSegments, timerContext, executorService, endTimeMs);\n+    } else {\n+      for (FilterContext child : filter.getChildren()) {\n+        handleSubquery(child, indexSegments, timerContext, executorService, endTimeMs);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handles the subquery in the given expression.\n+   * <p>Currently only supports subquery within IN_PARTITIONED_SUBQUERY function.\n+   */\n+  private void handleSubquery(ExpressionContext expression, List<IndexSegment> indexSegments, TimerContext timerContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18ad00fa0c1cc938969839dacf8ada5c754a9f61"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc1Njk2Mg==", "bodyText": "docs, isn't it better to check for filter.getChildren and invert the if statement?", "url": "https://github.com/apache/pinot/pull/6043#discussion_r502756962", "createdAt": "2020-10-10T07:05:51Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/executor/ServerQueryExecutorV1Impl.java", "diffHunk": "@@ -277,4 +253,112 @@ public DataTable processQuery(ServerQueryRequest queryRequest, ExecutorService e\n     LOGGER.debug(\"InstanceResponse for request Id - {}: {}\", requestId, dataTable);\n     return dataTable;\n   }\n+\n+  private DataTable processQuery(List<IndexSegment> indexSegments, QueryContext queryContext, TimerContext timerContext,\n+      ExecutorService executorService, @Nullable StreamObserver<Server.ServerResponse> responseObserver, long endTimeMs,\n+      boolean enableStreaming)\n+      throws Exception {\n+    handleSubquery(queryContext, indexSegments, timerContext, executorService, endTimeMs);\n+\n+    // Compute total docs for the table before pruning the segments\n+    long numTotalDocs = 0;\n+    for (IndexSegment indexSegment : indexSegments) {\n+      numTotalDocs += indexSegment.getSegmentMetadata().getTotalDocs();\n+    }\n+\n+    TimerContext.Timer segmentPruneTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.SEGMENT_PRUNING);\n+    List<IndexSegment> selectedSegments = _segmentPrunerService.prune(indexSegments, queryContext);\n+    segmentPruneTimer.stopAndRecord();\n+    int numSelectedSegments = selectedSegments.size();\n+    LOGGER.debug(\"Matched {} segments after pruning\", numSelectedSegments);\n+    if (numSelectedSegments == 0) {\n+      // Only return metadata for streaming query\n+      DataTable dataTable = enableStreaming ? new DataTableImplV2() : DataTableUtils.buildEmptyDataTable(queryContext);\n+      Map<String, String> metadata = dataTable.getMetadata();\n+      metadata.put(DataTable.TOTAL_DOCS_METADATA_KEY, String.valueOf(numTotalDocs));\n+      metadata.put(DataTable.NUM_DOCS_SCANNED_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_ENTRIES_SCANNED_IN_FILTER_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_ENTRIES_SCANNED_POST_FILTER_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_SEGMENTS_PROCESSED, \"0\");\n+      metadata.put(DataTable.NUM_SEGMENTS_MATCHED, \"0\");\n+      return dataTable;\n+    } else {\n+      TimerContext.Timer planBuildTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.BUILD_QUERY_PLAN);\n+      Plan queryPlan = enableStreaming ? _planMaker\n+          .makeStreamingInstancePlan(selectedSegments, queryContext, executorService, responseObserver, endTimeMs)\n+          : _planMaker.makeInstancePlan(selectedSegments, queryContext, executorService, endTimeMs);\n+      planBuildTimer.stopAndRecord();\n+\n+      TimerContext.Timer planExecTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.QUERY_PLAN_EXECUTION);\n+      DataTable dataTable = queryPlan.execute();\n+      planExecTimer.stopAndRecord();\n+\n+      // Update the total docs in the metadata based on the un-pruned segments\n+      dataTable.getMetadata().put(DataTable.TOTAL_DOCS_METADATA_KEY, Long.toString(numTotalDocs));\n+\n+      return dataTable;\n+    }\n+  }\n+\n+  /**\n+   * Handles the subquery in the given query.\n+   * <p>Currently only supports subquery within IN_PARTITIONED_SUBQUERY function.\n+   */\n+  private void handleSubquery(QueryContext queryContext, List<IndexSegment> indexSegments, TimerContext timerContext,\n+      ExecutorService executorService, long endTimeMs)\n+      throws Exception {\n+    FilterContext filter = queryContext.getFilter();\n+    if (filter != null) {\n+      handleSubquery(filter, indexSegments, timerContext, executorService, endTimeMs);\n+    }\n+  }\n+\n+  /**\n+   * Handles the subquery in the filter.\n+   * <p>Currently only supports subquery within IN_PARTITIONED_SUBQUERY function.\n+   */\n+  private void handleSubquery(FilterContext filter, List<IndexSegment> indexSegments, TimerContext timerContext,\n+      ExecutorService executorService, long endTimeMs)\n+      throws Exception {\n+    Predicate predicate = filter.getPredicate();\n+    if (predicate != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18ad00fa0c1cc938969839dacf8ada5c754a9f61"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc1NzM1MQ==", "bodyText": "more javadocs", "url": "https://github.com/apache/pinot/pull/6043#discussion_r502757351", "createdAt": "2020-10-10T07:10:25Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/executor/ServerQueryExecutorV1Impl.java", "diffHunk": "@@ -277,4 +253,112 @@ public DataTable processQuery(ServerQueryRequest queryRequest, ExecutorService e\n     LOGGER.debug(\"InstanceResponse for request Id - {}: {}\", requestId, dataTable);\n     return dataTable;\n   }\n+\n+  private DataTable processQuery(List<IndexSegment> indexSegments, QueryContext queryContext, TimerContext timerContext,\n+      ExecutorService executorService, @Nullable StreamObserver<Server.ServerResponse> responseObserver, long endTimeMs,\n+      boolean enableStreaming)\n+      throws Exception {\n+    handleSubquery(queryContext, indexSegments, timerContext, executorService, endTimeMs);\n+\n+    // Compute total docs for the table before pruning the segments\n+    long numTotalDocs = 0;\n+    for (IndexSegment indexSegment : indexSegments) {\n+      numTotalDocs += indexSegment.getSegmentMetadata().getTotalDocs();\n+    }\n+\n+    TimerContext.Timer segmentPruneTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.SEGMENT_PRUNING);\n+    List<IndexSegment> selectedSegments = _segmentPrunerService.prune(indexSegments, queryContext);\n+    segmentPruneTimer.stopAndRecord();\n+    int numSelectedSegments = selectedSegments.size();\n+    LOGGER.debug(\"Matched {} segments after pruning\", numSelectedSegments);\n+    if (numSelectedSegments == 0) {\n+      // Only return metadata for streaming query\n+      DataTable dataTable = enableStreaming ? new DataTableImplV2() : DataTableUtils.buildEmptyDataTable(queryContext);\n+      Map<String, String> metadata = dataTable.getMetadata();\n+      metadata.put(DataTable.TOTAL_DOCS_METADATA_KEY, String.valueOf(numTotalDocs));\n+      metadata.put(DataTable.NUM_DOCS_SCANNED_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_ENTRIES_SCANNED_IN_FILTER_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_ENTRIES_SCANNED_POST_FILTER_METADATA_KEY, \"0\");\n+      metadata.put(DataTable.NUM_SEGMENTS_PROCESSED, \"0\");\n+      metadata.put(DataTable.NUM_SEGMENTS_MATCHED, \"0\");\n+      return dataTable;\n+    } else {\n+      TimerContext.Timer planBuildTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.BUILD_QUERY_PLAN);\n+      Plan queryPlan = enableStreaming ? _planMaker\n+          .makeStreamingInstancePlan(selectedSegments, queryContext, executorService, responseObserver, endTimeMs)\n+          : _planMaker.makeInstancePlan(selectedSegments, queryContext, executorService, endTimeMs);\n+      planBuildTimer.stopAndRecord();\n+\n+      TimerContext.Timer planExecTimer = timerContext.startNewPhaseTimer(ServerQueryPhase.QUERY_PLAN_EXECUTION);\n+      DataTable dataTable = queryPlan.execute();\n+      planExecTimer.stopAndRecord();\n+\n+      // Update the total docs in the metadata based on the un-pruned segments\n+      dataTable.getMetadata().put(DataTable.TOTAL_DOCS_METADATA_KEY, Long.toString(numTotalDocs));\n+\n+      return dataTable;\n+    }\n+  }\n+\n+  /**\n+   * Handles the subquery in the given query.\n+   * <p>Currently only supports subquery within IN_PARTITIONED_SUBQUERY function.\n+   */\n+  private void handleSubquery(QueryContext queryContext, List<IndexSegment> indexSegments, TimerContext timerContext,\n+      ExecutorService executorService, long endTimeMs)\n+      throws Exception {\n+    FilterContext filter = queryContext.getFilter();\n+    if (filter != null) {\n+      handleSubquery(filter, indexSegments, timerContext, executorService, endTimeMs);\n+    }\n+  }\n+\n+  /**\n+   * Handles the subquery in the filter.\n+   * <p>Currently only supports subquery within IN_PARTITIONED_SUBQUERY function.\n+   */\n+  private void handleSubquery(FilterContext filter, List<IndexSegment> indexSegments, TimerContext timerContext,\n+      ExecutorService executorService, long endTimeMs)\n+      throws Exception {\n+    Predicate predicate = filter.getPredicate();\n+    if (predicate != null) {\n+      handleSubquery(predicate.getLhs(), indexSegments, timerContext, executorService, endTimeMs);\n+    } else {\n+      for (FilterContext child : filter.getChildren()) {\n+        handleSubquery(child, indexSegments, timerContext, executorService, endTimeMs);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handles the subquery in the given expression.\n+   * <p>Currently only supports subquery within IN_PARTITIONED_SUBQUERY function.\n+   */\n+  private void handleSubquery(ExpressionContext expression, List<IndexSegment> indexSegments, TimerContext timerContext,\n+      ExecutorService executorService, long endTimeMs)\n+      throws Exception {\n+    FunctionContext function = expression.getFunction();\n+    if (function == null) {\n+      return;\n+    }\n+    List<ExpressionContext> arguments = function.getArguments();\n+    if (StringUtils.remove(function.getFunctionName(), '_').equalsIgnoreCase(IN_PARTITIONED_SUBQUERY)) {\n+      Preconditions\n+          .checkState(arguments.size() == 2, \"IN_PARTITIONED_SUBQUERY requires 2 arguments: expression, subquery\");\n+      ExpressionContext subqueryExpression = arguments.get(1);\n+      Preconditions.checkState(subqueryExpression.getType() == ExpressionContext.Type.LITERAL,\n+          \"Second argument of IN_PARTITIONED_SUBQUERY must be a literal (subquery)\");\n+      QueryContext subquery = QueryContextConverterUtils.getQueryContextFromSQL(subqueryExpression.getLiteral());\n+      DataTable dataTable =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18ad00fa0c1cc938969839dacf8ada5c754a9f61"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc1NzcyNw==", "bodyText": "why is this a public method? who is invoking this and from where", "url": "https://github.com/apache/pinot/pull/6043#discussion_r502757727", "createdAt": "2020-10-10T07:15:01Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/request/context/QueryContext.java", "diffHunk": "@@ -372,5 +399,46 @@ private static void getAggregations(FilterContext filter, List<FunctionContext>\n         getAggregations(filter.getPredicate().getLhs(), aggregations);\n       }\n     }\n+\n+    /**\n+     * Helper method to extract the columns (IDENTIFIER expressions) for the query.\n+     */\n+    public void extractColumns(QueryContext query) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18ad00fa0c1cc938969839dacf8ada5c754a9f61"}, "originalPosition": 128}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "18ad00fa0c1cc938969839dacf8ada5c754a9f61", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/18ad00fa0c1cc938969839dacf8ada5c754a9f61", "committedDate": "2020-10-08T04:50:09Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}, "afterCommit": {"oid": "9466ab4504fa73584e9bc10caf8761518ee2e584", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/9466ab4504fa73584e9bc10caf8761518ee2e584", "committedDate": "2020-10-13T20:31:13Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9466ab4504fa73584e9bc10caf8761518ee2e584", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/9466ab4504fa73584e9bc10caf8761518ee2e584", "committedDate": "2020-10-13T20:31:13Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}, "afterCommit": {"oid": "97ff7a6deb1dd1384f4c47ef896f606c045e152f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/97ff7a6deb1dd1384f4c47ef896f606c045e152f", "committedDate": "2020-10-13T20:45:35Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97ff7a6deb1dd1384f4c47ef896f606c045e152f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/97ff7a6deb1dd1384f4c47ef896f606c045e152f", "committedDate": "2020-10-13T20:45:35Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}, "afterCommit": {"oid": "95c4496da2263f5a2b2c32b00d5d0b688931314d", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/95c4496da2263f5a2b2c32b00d5d0b688931314d", "committedDate": "2020-10-13T22:12:17Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b729442d2ef9cfc736254159b0227cd9014d214b", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/b729442d2ef9cfc736254159b0227cd9014d214b", "committedDate": "2020-10-21T23:22:35Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95c4496da2263f5a2b2c32b00d5d0b688931314d", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/95c4496da2263f5a2b2c32b00d5d0b688931314d", "committedDate": "2020-10-13T22:12:17Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}, "afterCommit": {"oid": "b729442d2ef9cfc736254159b0227cd9014d214b", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/b729442d2ef9cfc736254159b0227cd9014d214b", "committedDate": "2020-10-21T23:22:35Z", "message": "Add IN_PARTITIONED_SUBQUERY support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMjMxNDE0", "url": "https://github.com/apache/pinot/pull/6043#pullrequestreview-521231414", "createdAt": "2020-11-01T14:49:54Z", "commit": {"oid": "b729442d2ef9cfc736254159b0227cd9014d214b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 82, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}