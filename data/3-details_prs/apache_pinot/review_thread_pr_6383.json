{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1NDgzNzYx", "number": 6383, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQyMzozMDowM1rOFJMjpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDoyODoxOVrOFJ3Ejw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MTg3MjM3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQyMzozMDowM1rOILfiGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QyMzo0OToxMVrOILvJ-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTg4MQ==", "bodyText": "Do we need to assume a dim table is always an offline table?", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548921881", "createdAt": "2020-12-25T23:30:03Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3Nzg0OA==", "bodyText": "Hi Xiang, yes you're right. In current design Dimension Table has the following constraints:\n\nMust be of OFFLINE type\nMust have a primary key (we support lookups by primary key for now)\nMust have ingestion type REFRESH\n\nPlease check out #6286 and #6346 to see implementation details.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549177848", "createdAt": "2020-12-27T23:49:11Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTg4MQ=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MTg3MzEwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQyMzozMjowNVrOILfiaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQwMToyNDozOVrOILvrIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTk2MA==", "bodyText": "Can you update it with an ANSI SQL query here?\nE.g.\nSELECT baseballstats.playername,\n       baseballstats.teamid,\n       baseballteams.teamname\nFROM   baseballstats\n       JOIN baseballteams\n         ON baseballteams.teamid = baseballstats.teamid\nLIMIT  10", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548921960", "createdAt": "2020-12-25T23:32:05Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE4NjMzOA==", "bodyText": "Updated.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549186338", "createdAt": "2020-12-28T01:24:39Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTk2MA=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MTg3NzU3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQyMzozODowMVrOILfkNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQwMToyNDo0NFrOILvrKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMjQyMw==", "bodyText": "format: identation.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548922423", "createdAt": "2020-12-25T23:38:01Z", "author": {"login": "xiangfu0"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE4NjM0Nw==", "bodyText": "Done.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549186347", "createdAt": "2020-12-28T01:24:44Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMjQyMw=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1Mzg3NjI3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxOToxNjozMlrOILtsMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQwMToyNDo0N1rOILvrMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1Mzg0Mw==", "bodyText": "takes", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549153843", "createdAt": "2020-12-27T19:16:32Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE4NjM1NA==", "bodyText": "Done.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549186354", "createdAt": "2020-12-28T01:24:47Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1Mzg0Mw=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NDA1MDUxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QyMzowMjo1NFrOILu7qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxNDoxNFrOIME6Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw==", "bodyText": "also check that all the primary keys are provided.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549174187", "createdAt": "2020-12-27T23:02:54Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5NDE4Ng==", "bodyText": "I'm assuming you are referring to the validation of the joinValue argument below.\nLOOKUP(tableName, columnName, joinKey, joinValue)\n\nUnlike the first three arguments, joinValue isn't a 'literal', so its value is only resolved when we get a projection block. So rather than validating at initialization stage, we check its existence in transformTo...Values methods, on a row by row basis.\nFor instance, take the sample query:\nSELECT\n    baseballStats.playerName,\n    baseballStats.teamID,\n    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\nFROM\n    baseballStats\nLIMIT 10\nWe can validate the first three arguments of the LOOKUP function without reading data from baseballStats. However the last argument is only available once we start reading table contents.\nHope this makes sense, and please let me know if I missed something.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549194186", "createdAt": "2020-12-28T02:28:44Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIzNjk0OQ==", "bodyText": "I meant checking the join keys are the same as the primary keys defined on a table. Assume a table has 2 columns of the primary key, then this lookup function shall take two join keys too, to ensure the same cardinality in the output.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549236949", "createdAt": "2020-12-28T06:58:56Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNDI3MQ==", "bodyText": "Got it, this makes more sense. Just updated the validation logic to assert the provided key list is equal to primary key columns. Thanks for the suggestion.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549534271", "createdAt": "2020-12-29T01:14:14Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NDA1Mjg0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QyMzowNTo0MVrOILu8pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMTo1MDo1MVrOIMFQDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA==", "bodyText": "how about byte?", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549174438", "createdAt": "2020-12-27T23:05:41Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,\n+                    String.format(\"Primary key column doesn't exist in dimension table: %s:%s\",_dimTableName, joinKey));\n+            _joinValueFieldSpecs.add(pkColumnSpec);\n+        }\n+    }\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+            _lookupColumnFieldSpec.isSingleValueField(),\n+            false);\n+    }\n+\n+    private Object[] lookup(ProjectionBlock projectionBlock) {\n+        int numPkColumns = _joinKeys.size();\n+        int numDocuments = projectionBlock.getNumDocs();\n+        Object[][] pkColumns = new Object[numPkColumns][];\n+        for (int i=0; i<numPkColumns; i++) {\n+            FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+            TransformFunction tf = _joinValueFunctions.get(i);\n+            switch (colType) {\n+                case STRING:\n+                    pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+                    break;\n+                case INT:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+                    break;\n+                case LONG:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown column type for primary key\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwNTA0MA==", "bodyText": "Updated to support all types: INT, LONG, FLOAT, DOUBLE, STRING, BYTES", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549505040", "createdAt": "2020-12-28T22:23:47Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,\n+                    String.format(\"Primary key column doesn't exist in dimension table: %s:%s\",_dimTableName, joinKey));\n+            _joinValueFieldSpecs.add(pkColumnSpec);\n+        }\n+    }\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+            _lookupColumnFieldSpec.isSingleValueField(),\n+            false);\n+    }\n+\n+    private Object[] lookup(ProjectionBlock projectionBlock) {\n+        int numPkColumns = _joinKeys.size();\n+        int numDocuments = projectionBlock.getNumDocs();\n+        Object[][] pkColumns = new Object[numPkColumns][];\n+        for (int i=0; i<numPkColumns; i++) {\n+            FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+            TransformFunction tf = _joinValueFunctions.get(i);\n+            switch (colType) {\n+                case STRING:\n+                    pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+                    break;\n+                case INT:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+                    break;\n+                case LONG:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown column type for primary key\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyODUzMg==", "bodyText": "fyi, double is hard to check equality.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549528532", "createdAt": "2020-12-29T00:37:03Z", "author": {"login": "yupeng9"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,\n+                    String.format(\"Primary key column doesn't exist in dimension table: %s:%s\",_dimTableName, joinKey));\n+            _joinValueFieldSpecs.add(pkColumnSpec);\n+        }\n+    }\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+            _lookupColumnFieldSpec.isSingleValueField(),\n+            false);\n+    }\n+\n+    private Object[] lookup(ProjectionBlock projectionBlock) {\n+        int numPkColumns = _joinKeys.size();\n+        int numDocuments = projectionBlock.getNumDocs();\n+        Object[][] pkColumns = new Object[numPkColumns][];\n+        for (int i=0; i<numPkColumns; i++) {\n+            FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+            TransformFunction tf = _joinValueFunctions.get(i);\n+            switch (colType) {\n+                case STRING:\n+                    pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+                    break;\n+                case INT:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+                    break;\n+                case LONG:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown column type for primary key\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzOTg1Mw==", "bodyText": "For lookupByPrimaryKey we are relying on the PrimaryKey.hashCode implementation you added here. Here is the dimension table HashMap which is keyed by 'PrimaryKey's. Let me know if you see any potential issues with this usage.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549539853", "createdAt": "2020-12-29T01:50:51Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,\n+                    String.format(\"Primary key column doesn't exist in dimension table: %s:%s\",_dimTableName, joinKey));\n+            _joinValueFieldSpecs.add(pkColumnSpec);\n+        }\n+    }\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+            _lookupColumnFieldSpec.isSingleValueField(),\n+            false);\n+    }\n+\n+    private Object[] lookup(ProjectionBlock projectionBlock) {\n+        int numPkColumns = _joinKeys.size();\n+        int numDocuments = projectionBlock.getNumDocs();\n+        Object[][] pkColumns = new Object[numPkColumns][];\n+        for (int i=0; i<numPkColumns; i++) {\n+            FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+            TransformFunction tf = _joinValueFunctions.get(i);\n+            switch (colType) {\n+                case STRING:\n+                    pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+                    break;\n+                case INT:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+                    break;\n+                case LONG:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown column type for primary key\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA=="}, "originalCommit": {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NjA5NDQ0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowMDo0NVrOIMABRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxMTo1OVrOIME5Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDE0OA==", "bodyText": "List the expected arguments in the message", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454148", "createdAt": "2020-12-28T19:00:45Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzk2Mg==", "bodyText": "Added.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533962", "createdAt": "2020-12-29T01:11:59Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDE0OA=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NjA5NzQzOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowMjoyMVrOIMAC3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxMTo1NVrOIME4_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDU1Ng==", "bodyText": "Handle table name with suffix\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n          \n          \n            \n                _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(((LiteralTransformFunction) dimTableNameFunction).getLiteral());", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454556", "createdAt": "2020-12-28T19:02:21Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzk0OQ==", "bodyText": "Thanks for the suggestion, added.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533949", "createdAt": "2020-12-29T01:11:55Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDU1Ng=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NjA5NzkwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowMjo0M1rOIMADJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxMTo0OFrOIME48g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDYyOA==", "bodyText": "Use TableNameBuilder instead", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454628", "createdAt": "2020-12-28T19:02:43Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzkzOA==", "bodyText": "Done.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533938", "createdAt": "2020-12-29T01:11:48Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDYyOA=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NjEwMDAyOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowMzo0MlrOIMAEQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNTo0Nzo1OFrOIMHfSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw==", "bodyText": "(nit) extract joinArguments.size() as a local variable", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454913", "createdAt": "2020-12-28T19:03:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzkyNA==", "bodyText": "It is not really reused anywhere else. Let me know if you have a specific reason to extract.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533924", "createdAt": "2020-12-29T01:11:41Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Nzc4NQ==", "bodyText": "The for loop will keep calling joinArguments.size() for each iteration", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549547785", "createdAt": "2020-12-29T02:42:24Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3NjUyMQ==", "bodyText": ":) Alright, extracted.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549576521", "createdAt": "2020-12-29T05:47:58Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NjI5MjIxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMDo0NzowM1rOIMBu-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMjoyNDoyOVrOIMDIkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjIzMg==", "bodyText": "Please support all data types (usually we order them as followings: INT, LONG, FLOAT, DOUBLE, STRING, BYTES)", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549482232", "createdAt": "2020-12-28T20:47:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwNTE2OA==", "bodyText": "Updated to support all types", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549505168", "createdAt": "2020-12-28T22:24:29Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjIzMg=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NjI5NjI0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMDo0OTozNVrOIMBxNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxMTozNFrOIME4zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjgwNQ==", "bodyText": "Need to check null, same for other places", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549482805", "createdAt": "2020-12-28T20:49:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n+      if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n+        resultSet[i] = row.getValue(_dimColumnName);\n+      }\n+    }\n+    return resultSet;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    Object[] lookupObjects = lookup(projectionBlock);\n+    int[] resultSet = new int[lookupObjects.length];\n+    Arrays.fill(resultSet, ((Number) _lookupColumnFieldSpec.getDefaultNullValue()).intValue());\n+    for (int i = 0; i < lookupObjects.length; i++) {\n+      resultSet[i] = ((Number) lookupObjects[i]).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzkwMQ==", "bodyText": "Great catch, thanks! Updated.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533901", "createdAt": "2020-12-29T01:11:34Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n+      if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n+        resultSet[i] = row.getValue(_dimColumnName);\n+      }\n+    }\n+    return resultSet;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    Object[] lookupObjects = lookup(projectionBlock);\n+    int[] resultSet = new int[lookupObjects.length];\n+    Arrays.fill(resultSet, ((Number) _lookupColumnFieldSpec.getDefaultNullValue()).intValue());\n+    for (int i = 0; i < lookupObjects.length; i++) {\n+      resultSet[i] = ((Number) lookupObjects[i]).intValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjgwNQ=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NjI5ODg2OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMDo1MToyOVrOIMByxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMToxMToyN1rOIME4tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MzIwNA==", "bodyText": "We can save one map lookup\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n          \n          \n            \n                    resultSet[i] = row.getValue(_dimColumnName);\n          \n          \n            \n                  }\n          \n          \n            \n                  if (row != null) {\n          \n          \n            \n                    resultSet[i] = row.getValue(_dimColumnName);\n          \n          \n            \n                  }", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549483204", "createdAt": "2020-12-28T20:51:29Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n+      if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n+        resultSet[i] = row.getValue(_dimColumnName);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzg3OA==", "bodyText": "Right, looks like a useless check. Removed.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533878", "createdAt": "2020-12-29T01:11:27Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n+      if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n+        resultSet[i] = row.getValue(_dimColumnName);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MzIwNA=="}, "originalCommit": {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODc5OTk5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDowNzoyMFrOIMXE3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzo0MDowNlrOIMahKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMTkwMw==", "bodyText": "(nit) no need to make a copy of the array (save the garbage). We don't usually guard the callers from modifying the list as it is internal code.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549831903", "createdAt": "2020-12-29T20:07:20Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -161,4 +168,8 @@ public GenericRow lookupRowByPrimaryKey(PrimaryKey pk) {\n   public FieldSpec getColumnFieldSpec(String columnName) {\n     return _tableSchema.getFieldSpecFor(columnName);\n   }\n+\n+  public List<String> getPrimaryKeyColumns() {\n+    return new ArrayList<>(_primaryKeyColumns);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODI5OA==", "bodyText": "Removed.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888298", "createdAt": "2020-12-29T23:40:06Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -161,4 +168,8 @@ public GenericRow lookupRowByPrimaryKey(PrimaryKey pk) {\n   public FieldSpec getColumnFieldSpec(String columnName) {\n     return _tableSchema.getFieldSpecFor(columnName);\n   }\n+\n+  public List<String> getPrimaryKeyColumns() {\n+    return new ArrayList<>(_primaryKeyColumns);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMTkwMw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODgwNDc4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDoxMDoxMFrOIMXHiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzo0MDoxM1rOIMahMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMjU4NQ==", "bodyText": "No need to format string as Preconditions supports %s, same for other places", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549832585", "createdAt": "2020-12-29T20:10:10Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODMwNg==", "bodyText": "Oh I didn't know about that, thanks for the tip. Updated.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888306", "createdAt": "2020-12-29T23:40:13Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMjU4NQ=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODgzMDkzOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDoyNDozOFrOIMXVww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzo0MDoxN1rOIMahPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjIyNw==", "bodyText": "(nit) move STRING after DOUBLE for consistency", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549836227", "createdAt": "2020-12-29T20:24:38Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODMxNw==", "bodyText": "Moved.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888317", "createdAt": "2020-12-29T23:40:17Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjIyNw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODgzMjUwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDoyNTozM1rOIMXWqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMjoxMzozOVrOIMb_mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw==", "bodyText": "pkColumns should be stored as ByteArray[numDocuments]. Please add a test for all these data types to ensure them working", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549836457", "createdAt": "2020-12-29T20:25:33Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODM0Ng==", "bodyText": "Double checked and can't see how this is wrong. What we are doing here is translating the output of the transform function from type byte[numDocuments][] to Byte[numDocuments][] so it can be passed back as Object[]. Second [] is indicating that we simply have 'byte arrays' for each row/entry. I'm updating the loop index variable name to make it a bit more clear.\nWe already have test coverage for this behavior here (as well as other types).\nLet me know if I missed something.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888346", "createdAt": "2020-12-29T23:40:25Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5MjAxNg==", "bodyText": "The equals() in PrimaryKey won't do deep comparison for array, and Byte[] won't be compared correctly (it will only compare the references). We use ByteArray as a wrapper to bypass this problem. It is used to store byte[] internally", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549892016", "createdAt": "2020-12-30T00:01:29Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkxMjQ3NA==", "bodyText": "Oh, I see what you mean, great catch. Looks like the reason unit tests didn't catch this was, I was mocking the lookupRowByPrimaryKey to match byte array type PKs by their string representation \ud83e\udd26. Fixed it and revamped all the test cases to match only by the 'hashCode' of the PK instance. Thanks \ud83d\udc4d", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549912474", "createdAt": "2020-12-30T02:13:39Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODgzNjQ2OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDoyNzozNFrOIMXY1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxODo0NTo0N1rOIMzIFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw==", "bodyText": "Reuse this Object[] instead of creating a new one per iteration", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549837013", "createdAt": "2020-12-29T20:27:34Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODM2Ng==", "bodyText": "I can do something like:\n  Object[] resultSet = new Object[numDocuments];\n  Object[] pkValues = new Object[numPkColumns];\n  for (int i = 0; i < numDocuments; i++) {\n    // prepare pk\n    for (int j = 0; j < numPkColumns; j++) {\n      pkValues[j] = pkColumns[j][i];\n    }\n    // lookup\n    GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n    if (row != null) {\n      resultSet[i] = row.getValue(_dimColumnName);\n    }\n  }\nI don't see much point in doing the same for PrimaryKey though. We will only be reusing the pointer which is not really helpful.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888366", "createdAt": "2020-12-29T23:40:38Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5MjI5Nw==", "bodyText": "It will reuse the object instead of creating one per doc:\n  Object[] resultSet = new Object[numDocuments];\n  Object[] pkValues = new Object[numPkColumns];\n  PrimaryKey primaryKey = new PrimaryKey(pkValues);\n  for (int i = 0; i < numDocuments; i++) {\n    ...", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549892297", "createdAt": "2020-12-30T00:03:26Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkxMzcyNA==", "bodyText": "I don't think this will work. We have to create a new 'PrimaryKey' instance per document since the values (pkValues) are going to be different.", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549913724", "createdAt": "2020-12-30T02:22:59Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI5MTQ3OQ==", "bodyText": "You can directly modify pkValues without changing primaryKey. They share the same reference.\nThis is not critical, so both ways are fine. It just saves minor garbages", "url": "https://github.com/apache/pinot/pull/6383#discussion_r550291479", "createdAt": "2020-12-30T18:45:47Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODgzNzkxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMDoyODoxOVrOIMXZpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzo0MDo0N1rOIMahjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzIyMQ==", "bodyText": "PrimaryKey object can also be reused", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549837221", "createdAt": "2020-12-29T20:28:19Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODM5OA==", "bodyText": "Replied above", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888398", "createdAt": "2020-12-29T23:40:47Z", "author": {"login": "cbalci"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzIyMQ=="}, "originalCommit": {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433"}, "originalPosition": 188}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3053, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}