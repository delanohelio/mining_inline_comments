{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxMjcwMzkx", "number": 5712, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDowNjowMVrOEPtLIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODoyODoxOFrOERKu9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA0MjI1OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDowNjowMVrOGzkCsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNDoxMzo0OVrOG0nccQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMTA3Mw==", "bodyText": "Can segmentsFromStr be null?\nAlso avoid using the regex split\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String segmentsFromStr = value.get(0);\n          \n          \n            \n                  List<String> segmentsFrom = (segmentsFromStr == null || segmentsFromStr.length() == 0) ? new ArrayList<>()\n          \n          \n            \n                      : Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n          \n          \n            \n                  List<String> segmentsTo = Arrays.asList(value.get(1).split(COMMA_SEPARATOR));\n          \n          \n            \n                  List<String> segmentsFrom = Arrays.asList(StringUtils.split(value.get(0), ','));\n          \n          \n            \n                  List<String> segmentsTo = Arrays.asList(StringUtils.split(value.get(1), ','));", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456721073", "createdAt": "2020-07-18T00:06:01Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -108,7 +120,9 @@ public static SegmentLineage fromZNRecord(ZNRecord record) {\n       String lineageId = listField.getKey();\n       List<String> value = listField.getValue();\n       Preconditions.checkState(value.size() == 4);\n-      List<String> segmentsFrom = Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n+      String segmentsFromStr = value.get(0);\n+      List<String> segmentsFrom = (segmentsFromStr == null || segmentsFromStr.length() == 0) ? new ArrayList<>()\n+          : Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n       List<String> segmentsTo = Arrays.asList(value.get(1).split(COMMA_SEPARATOR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTM5Mw==", "bodyText": "changed to StringUtils.split().", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457825393", "createdAt": "2020-07-21T04:13:49Z", "author": {"login": "snleee"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -108,7 +120,9 @@ public static SegmentLineage fromZNRecord(ZNRecord record) {\n       String lineageId = listField.getKey();\n       List<String> value = listField.getValue();\n       Preconditions.checkState(value.size() == 4);\n-      List<String> segmentsFrom = Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n+      String segmentsFromStr = value.get(0);\n+      List<String> segmentsFrom = (segmentsFromStr == null || segmentsFromStr.length() == 0) ? new ArrayList<>()\n+          : Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n       List<String> segmentsTo = Arrays.asList(value.get(1).split(COMMA_SEPARATOR));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMTA3Mw=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA0NzY1OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDoxMDozM1rOGzkFlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTowNjo1NVrOG0oQ8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMTgxMg==", "bodyText": "Keep only String addLineageEntry(LineageEntry lineageEntry) or void addLineageEntry(String lineageEntryId, LineageEntry lineageEntry), don't keep both because it will be confusing. In other world, always generate UUID inside or outside of this class.\nMy suggestion is keeping String addLineageEntry(LineageEntry lineageEntry), you can check existence of the lineageId (or not because UUID collision change is too low)\nIn order to update the lineage entry, you can add a method void updateLineageEntry(String lineageEntryId, LineageEntry lineageEntry)", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456721812", "createdAt": "2020-07-18T00:10:33Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -70,6 +71,17 @@ public String addLineageEntry(LineageEntry lineageEntry) {\n     return lineageId;\n   }\n \n+  /**\n+   * Add lineage entry to the segment lineage metadata with the given lineage entry id\n+   * @param lineageEntryId the id for the lineage entry\n+   * @param lineageEntry a lineage entry\n+   * @return the id for the input lineage entry for the access\n+   */\n+  public String addLineageEntry(String lineageEntryId, LineageEntry lineageEntry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzODgzNQ==", "bodyText": "One reason I added void addLineageEntry(String lineageEntryId, LineageEntry lineageEntry) was because there's no easy way to pass lineageEntryId outside of the retry policy block. (lineageEntryId  is generated within retry function and it needs to be passed back to the top caller)\nDue to the above reason, I have removed String addLineageEntry(LineageEntry lineageEntry) and kept void addLineageEntry(String lineageEntryId, LineageEntry lineageEntry).\nI also added void updateLineageEntry(String lineageEntryId, LineageEntry lineageEntry)", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457838835", "createdAt": "2020-07-21T05:06:55Z", "author": {"login": "snleee"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -70,6 +71,17 @@ public String addLineageEntry(LineageEntry lineageEntry) {\n     return lineageId;\n   }\n \n+  /**\n+   * Add lineage entry to the segment lineage metadata with the given lineage entry id\n+   * @param lineageEntryId the id for the lineage entry\n+   * @param lineageEntry a lineage entry\n+   * @return the id for the input lineage entry for the access\n+   */\n+  public String addLineageEntry(String lineageEntryId, LineageEntry lineageEntry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMTgxMg=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA1MjA0OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/BatchId.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDoxMzo1NVrOGzkH2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNDoxNToxN1rOG0ndzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMjM5Mw==", "bodyText": "Any reason introducing this object? I feel it will be easier to use if we directly use string batch id instead of json batch id", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456722393", "createdAt": "2020-07-18T00:13:55Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/BatchId.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+\n+public class BatchId {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTc0Mg==", "bodyText": "removed", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457825742", "createdAt": "2020-07-21T04:15:17Z", "author": {"login": "snleee"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/BatchId.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+\n+public class BatchId {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMjM5Mw=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA2ODA5OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/StartBatchUploadRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDoyNzowMVrOGzkQRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNToyMDozN1rOG0ogtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDU1MQ==", "bodyText": "Put default or check they cannot be null?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456724551", "createdAt": "2020-07-18T00:27:01Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/StartBatchUploadRequest.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.List;\n+\n+\n+public class StartBatchUploadRequest {\n+  private List<String> _segmentsFrom;\n+  private List<String> _segmentsTo;\n+\n+  public StartBatchUploadRequest(@JsonProperty(\"segmentsFrom\") List<String> segmentsFrom,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0Mjg2OA==", "bodyText": "added default & null check", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457842868", "createdAt": "2020-07-21T05:20:37Z", "author": {"login": "snleee"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/StartBatchUploadRequest.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.List;\n+\n+\n+public class StartBatchUploadRequest {\n+  private List<String> _segmentsFrom;\n+  private List<String> _segmentsTo;\n+\n+  public StartBatchUploadRequest(@JsonProperty(\"segmentsFrom\") List<String> segmentsFrom,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDU1MQ=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA2ODU4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDoyNzoyOVrOGzkQiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNToyMToyNVrOG0ohog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDYxNg==", "bodyText": "You can directly put StartBatchUploadRequest as the parameter\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)\n          \n          \n            \n                  @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, StartBatchUploadRequest request)", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456724616", "createdAt": "2020-07-18T00:27:29Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +459,45 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0MzEwNg==", "bodyText": "fixed", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457843106", "createdAt": "2020-07-21T05:21:25Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +459,45 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDYxNg=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA2OTExOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDoyODowNFrOGzkQ1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNToxMTo0N1rOG0oWqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDY5Mg==", "bodyText": "Send batchId as query param?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456724692", "createdAt": "2020-07-18T00:28:04Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +459,45 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)\n+      throws IOException {\n+    StartBatchUploadRequest request = JsonUtils.stringToObject(body, StartBatchUploadRequest.class);\n+    String tableNameWithType =\n+        TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+    try {\n+      String batchId = _pinotHelixResourceManager\n+          .startBatchUpload(tableNameWithType, request.getSegmentsFrom(), request.getSegmentsTo());\n+      return Response.ok(new BatchId(batchId)).build();\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.INTERNAL_SERVER_ERROR, e);\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"segments/{tableName}/endBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"End the batch upload\", notes = \"End the batch upload\")\n+  public Response endBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0MDI5Ng==", "bodyText": "fixed", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457840296", "createdAt": "2020-07-21T05:11:47Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +459,45 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)\n+      throws IOException {\n+    StartBatchUploadRequest request = JsonUtils.stringToObject(body, StartBatchUploadRequest.class);\n+    String tableNameWithType =\n+        TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+    try {\n+      String batchId = _pinotHelixResourceManager\n+          .startBatchUpload(tableNameWithType, request.getSegmentsFrom(), request.getSegmentsTo());\n+      return Response.ok(new BatchId(batchId)).build();\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.INTERNAL_SERVER_ERROR, e);\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"segments/{tableName}/endBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"End the batch upload\", notes = \"End the batch upload\")\n+  public Response endBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDY5Mg=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA3MTk4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDozMDozOVrOGzkSVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDozMDozOVrOGzkSVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTA3OA==", "bodyText": "Perform null check within the request?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456725078", "createdAt": "2020-07-18T00:30:39Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA3MjQ5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDozMTowOVrOGzkSmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTozMDo0NVrOG0osUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTE0Ng==", "bodyText": "Can be simplified with Preconditions.checkArgument()", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456725146", "createdAt": "2020-07-18T00:31:09Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0NTg0Mg==", "bodyText": "I have changed all checks to use Preconditions", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457845842", "createdAt": "2020-07-21T05:30:45Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTE0Ng=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA3Mjk3OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDozMTo0NlrOGzkS4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDozMTo0NlrOGzkS4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTIxNw==", "bodyText": "Can be simplified with Preconditions.checkArgument(), same for other validation checks", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456725217", "createdAt": "2020-07-18T00:31:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA3OTY2OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDozODoyNlrOGzkWhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTozMDowOFrOG0ormw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjE1MQ==", "bodyText": "For readability\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n          \n          \n            \n                      Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), ...)", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456726151", "createdAt": "2020-07-18T00:38:26Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0NTY1OQ==", "bodyText": "changed to Collections.disjoint", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457845659", "createdAt": "2020-07-21T05:30:08Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjE1MQ=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA4NTE1OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDo0MjozNVrOGzkZOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTozMDoxOVrOG0or0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjg0MQ==", "bodyText": "Need to check both Collections.disjoint(lineageEntry.getSegmentsFrom(), segmentsTo)) and Collections.disjoint(lineageEntry.getSegmentsTo(), segmentsTo))", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456726841", "createdAt": "2020-07-18T00:42:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                    + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsFrom(), finalSegmentsFrom);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+\n+          // Check that merged segments name cannot be the same for different lineage entry\n+          if (lineageEntry.getSegmentsTo().stream().anyMatch(segmentsTo::contains)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0NTcxMw==", "bodyText": "yes, we need to check both.", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457845713", "createdAt": "2020-07-21T05:30:19Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                    + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsFrom(), finalSegmentsFrom);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+\n+          // Check that merged segments name cannot be the same for different lineage entry\n+          if (lineageEntry.getSegmentsTo().stream().anyMatch(segmentsTo::contains)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjg0MQ=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA5MTM2OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDo0ODoxN1rOGzkcXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDo0ODoxN1rOGzkcXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNzY0Ng==", "bodyText": "Probably WARN? This is unexpected. Also, move this in front of the segments check", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456727646", "createdAt": "2020-07-18T00:48:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                    + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsFrom(), finalSegmentsFrom);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+\n+          // Check that merged segments name cannot be the same for different lineage entry\n+          if (lineageEntry.getSegmentsTo().stream().anyMatch(segmentsTo::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                    + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsTo(), segmentsTo);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+        }\n+\n+        // Update lineage entry\n+        segmentLineage.addLineageEntry(batchId,\n+            new LineageEntry(finalSegmentsFrom, segmentsTo, LineageEntryState.IN_PROGRESS, System.currentTimeMillis()));\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed while updating the segment lineage. (tableName = %s, segmentsFrom = %s, segmentsTo = %s)\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"startBatchUpload is successfully processed. (tableNameWithType = {}, segmentsFrom = {}, \"\n+        + \"segmentsTo = {}, batchId = {})\", tableNameWithType, segmentsFrom, segmentsTo, batchId);\n+    return batchId;\n+  }\n+\n+  /**\n+   * Computes the end batch upload phase\n+   *\n+   * 1. Compute validation\n+   * 2. Update the lineage entry state to \"COMPLETED\" and write metadata to the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType\n+   * @param batchId\n+   */\n+  public void endBatchUpload(String tableNameWithType, String batchId) {\n+    // Check that the batch id is valid\n+    if (batchId == null || batchId.isEmpty()) {\n+      throw new IllegalArgumentException(\"'batchId' cannot be null or empty\");\n+    }\n+\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          String errorMsg = String\n+              .format(\"Segment lineage does not exist. (tableNameWithType = '%s', batchId = '%s')\", tableNameWithType,\n+                  batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Look up the lineage entry based on the batch id\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(batchId);\n+        if (lineageEntry == null) {\n+          String errorMsg =\n+              String.format(\"Invalid batch id (tableName='%s', batchId='%s')\", tableNameWithType, batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // Check that all the segments from 'segmentsTo' exist in the table\n+        Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+        if (!segmentsForTable.containsAll(lineageEntry.getSegmentsTo())) {\n+          String errorMsg = String.format(\n+              \"Not all segments from 'segmentsTo' are available in the table. (tableName = '%s', segmentsTo = '%s', \"\n+                  + \"segmentsFromTable = '%s')\", tableNameWithType, lineageEntry.getSegmentsTo(), segmentsForTable);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // NO-OPS if the entry is already completed\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          LOGGER.info(\"Lineage entry state is already COMPLETED. Nothing to update. (tableNameWithType={}, batchId={})\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTA5NzEwOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDo1Mzo0MVrOGzkfRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNToyMjo1NlrOG0ojNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyODM5MQ==", "bodyText": "Log something after it succeeds?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456728391", "createdAt": "2020-07-18T00:53:41Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                    + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsFrom(), finalSegmentsFrom);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+\n+          // Check that merged segments name cannot be the same for different lineage entry\n+          if (lineageEntry.getSegmentsTo().stream().anyMatch(segmentsTo::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                    + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsTo(), segmentsTo);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+        }\n+\n+        // Update lineage entry\n+        segmentLineage.addLineageEntry(batchId,\n+            new LineageEntry(finalSegmentsFrom, segmentsTo, LineageEntryState.IN_PROGRESS, System.currentTimeMillis()));\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed while updating the segment lineage. (tableName = %s, segmentsFrom = %s, segmentsTo = %s)\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"startBatchUpload is successfully processed. (tableNameWithType = {}, segmentsFrom = {}, \"\n+        + \"segmentsTo = {}, batchId = {})\", tableNameWithType, segmentsFrom, segmentsTo, batchId);\n+    return batchId;\n+  }\n+\n+  /**\n+   * Computes the end batch upload phase\n+   *\n+   * 1. Compute validation\n+   * 2. Update the lineage entry state to \"COMPLETED\" and write metadata to the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType\n+   * @param batchId\n+   */\n+  public void endBatchUpload(String tableNameWithType, String batchId) {\n+    // Check that the batch id is valid\n+    if (batchId == null || batchId.isEmpty()) {\n+      throw new IllegalArgumentException(\"'batchId' cannot be null or empty\");\n+    }\n+\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          String errorMsg = String\n+              .format(\"Segment lineage does not exist. (tableNameWithType = '%s', batchId = '%s')\", tableNameWithType,\n+                  batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Look up the lineage entry based on the batch id\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(batchId);\n+        if (lineageEntry == null) {\n+          String errorMsg =\n+              String.format(\"Invalid batch id (tableName='%s', batchId='%s')\", tableNameWithType, batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // Check that all the segments from 'segmentsTo' exist in the table\n+        Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+        if (!segmentsForTable.containsAll(lineageEntry.getSegmentsTo())) {\n+          String errorMsg = String.format(\n+              \"Not all segments from 'segmentsTo' are available in the table. (tableName = '%s', segmentsTo = '%s', \"\n+                  + \"segmentsFromTable = '%s')\", tableNameWithType, lineageEntry.getSegmentsTo(), segmentsForTable);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // NO-OPS if the entry is already completed\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          LOGGER.info(\"Lineage entry state is already COMPLETED. Nothing to update. (tableNameWithType={}, batchId={})\",\n+              tableNameWithType, batchId);\n+          return true;\n+        }\n+\n+        // Update lineage entry\n+        LineageEntry newLineageEntry =\n+            new LineageEntry(lineageEntry.getSegmentsFrom(), lineageEntry.getSegmentsTo(), LineageEntryState.COMPLETED,\n+                System.currentTimeMillis());\n+        segmentLineage.addLineageEntry(batchId, newLineageEntry);\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed to update the segment lineage. (tableName = %s, batchId = %s)\", tableNameWithType, batchId);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0MzUxMA==", "bodyText": "added", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457843510", "createdAt": "2020-07-21T05:22:56Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                    + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsFrom(), finalSegmentsFrom);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+\n+          // Check that merged segments name cannot be the same for different lineage entry\n+          if (lineageEntry.getSegmentsTo().stream().anyMatch(segmentsTo::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                    + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsTo(), segmentsTo);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+        }\n+\n+        // Update lineage entry\n+        segmentLineage.addLineageEntry(batchId,\n+            new LineageEntry(finalSegmentsFrom, segmentsTo, LineageEntryState.IN_PROGRESS, System.currentTimeMillis()));\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed while updating the segment lineage. (tableName = %s, segmentsFrom = %s, segmentsTo = %s)\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"startBatchUpload is successfully processed. (tableNameWithType = {}, segmentsFrom = {}, \"\n+        + \"segmentsTo = {}, batchId = {})\", tableNameWithType, segmentsFrom, segmentsTo, batchId);\n+    return batchId;\n+  }\n+\n+  /**\n+   * Computes the end batch upload phase\n+   *\n+   * 1. Compute validation\n+   * 2. Update the lineage entry state to \"COMPLETED\" and write metadata to the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType\n+   * @param batchId\n+   */\n+  public void endBatchUpload(String tableNameWithType, String batchId) {\n+    // Check that the batch id is valid\n+    if (batchId == null || batchId.isEmpty()) {\n+      throw new IllegalArgumentException(\"'batchId' cannot be null or empty\");\n+    }\n+\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          String errorMsg = String\n+              .format(\"Segment lineage does not exist. (tableNameWithType = '%s', batchId = '%s')\", tableNameWithType,\n+                  batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Look up the lineage entry based on the batch id\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(batchId);\n+        if (lineageEntry == null) {\n+          String errorMsg =\n+              String.format(\"Invalid batch id (tableName='%s', batchId='%s')\", tableNameWithType, batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // Check that all the segments from 'segmentsTo' exist in the table\n+        Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+        if (!segmentsForTable.containsAll(lineageEntry.getSegmentsTo())) {\n+          String errorMsg = String.format(\n+              \"Not all segments from 'segmentsTo' are available in the table. (tableName = '%s', segmentsTo = '%s', \"\n+                  + \"segmentsFromTable = '%s')\", tableNameWithType, lineageEntry.getSegmentsTo(), segmentsForTable);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // NO-OPS if the entry is already completed\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          LOGGER.info(\"Lineage entry state is already COMPLETED. Nothing to update. (tableNameWithType={}, batchId={})\",\n+              tableNameWithType, batchId);\n+          return true;\n+        }\n+\n+        // Update lineage entry\n+        LineageEntry newLineageEntry =\n+            new LineageEntry(lineageEntry.getSegmentsFrom(), lineageEntry.getSegmentsTo(), LineageEntryState.COMPLETED,\n+                System.currentTimeMillis());\n+        segmentLineage.addLineageEntry(batchId, newLineageEntry);\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed to update the segment lineage. (tableName = %s, batchId = %s)\", tableNameWithType, batchId);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyODM5MQ=="}, "originalCommit": {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTM2MTM4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1NzozNVrOG0-2Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1NzozNVrOG0-2Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODc3MA==", "bodyText": "Will minion reference \"batchId\"  to do automatic merges? In that case, it is useful to add this to CommonConstants. Even otherwise, if we are building any client software to interact with the controller, it is useful, so I would suggest to move it to common constants.", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458208770", "createdAt": "2020-07-21T15:57:35Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +460,46 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr,\n+      StartBatchUploadRequest startBatchUploadRequest) {\n+    try {\n+      String tableNameWithType =\n+          TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+      String batchId = _pinotHelixResourceManager\n+          .startBatchUpload(tableNameWithType, startBatchUploadRequest.getSegmentsFrom(),\n+              startBatchUploadRequest.getSegmentsTo());\n+      return Response.ok(JsonUtils.newObjectNode().put(\"batchId\", batchId)).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTM2NjMwOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1ODoyOFrOG0-43w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTo1NzozOFrOG1LSBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwOTUwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Preconditions.checkNotNull(batchId, \"'batchId' cannot be null\");\n          \n          \n            \n                  Preconditions.checkNotNull(batchId, \"'batchId' should not be null\");", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458209503", "createdAt": "2020-07-21T15:58:28Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +460,46 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr,\n+      StartBatchUploadRequest startBatchUploadRequest) {\n+    try {\n+      String tableNameWithType =\n+          TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+      String batchId = _pinotHelixResourceManager\n+          .startBatchUpload(tableNameWithType, startBatchUploadRequest.getSegmentsFrom(),\n+              startBatchUploadRequest.getSegmentsTo());\n+      return Response.ok(JsonUtils.newObjectNode().put(\"batchId\", batchId)).build();\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.INTERNAL_SERVER_ERROR, e);\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"segments/{tableName}/endBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"End the batch upload\", notes = \"End the batch upload\")\n+  public Response endBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr,\n+      @ApiParam(value = \"Batch Id returned by startBatchUpload API\") @QueryParam(\"batchId\") String batchId) {\n+    try {\n+      String tableNameWithType =\n+          TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+      // Check that the batch id is valid\n+      Preconditions.checkNotNull(batchId, \"'batchId' cannot be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQxMjU1MQ==", "bodyText": "fixed", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458412551", "createdAt": "2020-07-21T21:57:38Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +460,46 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr,\n+      StartBatchUploadRequest startBatchUploadRequest) {\n+    try {\n+      String tableNameWithType =\n+          TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+      String batchId = _pinotHelixResourceManager\n+          .startBatchUpload(tableNameWithType, startBatchUploadRequest.getSegmentsFrom(),\n+              startBatchUploadRequest.getSegmentsTo());\n+      return Response.ok(JsonUtils.newObjectNode().put(\"batchId\", batchId)).build();\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.INTERNAL_SERVER_ERROR, e);\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"segments/{tableName}/endBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"End the batch upload\", notes = \"End the batch upload\")\n+  public Response endBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr,\n+      @ApiParam(value = \"Batch Id returned by startBatchUpload API\") @QueryParam(\"batchId\") String batchId) {\n+    try {\n+      String tableNameWithType =\n+          TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+      // Check that the batch id is valid\n+      Preconditions.checkNotNull(batchId, \"'batchId' cannot be null\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwOTUwMw=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTM3MjQwOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1OTo0OVrOG0-8jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTo0OTowMFrOG1LCnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDQ0NA==", "bodyText": "Can we move this check to the caller? Or, do you expect multiple callers to this API?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458210444", "createdAt": "2020-07-21T15:59:49Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwODYwNQ==", "bodyText": "I moved this to the constructor of StartBatchUploadRequest", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458408605", "createdAt": "2020-07-21T21:49:00Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDQ0NA=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTM5MTQ4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjowNDoyMlrOG0_I1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTo0NzoxN1rOG1K_rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMzU5MQ==", "bodyText": "Do you want to include lineage in the log?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458213591", "createdAt": "2020-07-21T16:04:22Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String\n+              .format(\"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                      + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                  lineageEntry.getSegmentsFrom(), finalSegmentsFrom));\n+\n+          // Check that merged segments name cannot be the same.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsTo(), segmentsTo), String.format(\n+              \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                  + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+              lineageEntry.getSegmentsTo(), segmentsTo));\n+        }\n+\n+        // Update lineage entry\n+        segmentLineage.addLineageEntry(batchId,\n+            new LineageEntry(finalSegmentsFrom, segmentsTo, LineageEntryState.IN_PROGRESS, System.currentTimeMillis()));\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed while updating the segment lineage. (tableName = %s, segmentsFrom = %s, segmentsTo = %s)\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"startBatchUpload is successfully processed. (tableNameWithType = {}, segmentsFrom = {}, \"\n+        + \"segmentsTo = {}, batchId = {})\", tableNameWithType, segmentsFrom, segmentsTo, batchId);\n+    return batchId;\n+  }\n+\n+  /**\n+   * Computes the end batch upload phase\n+   *\n+   * 1. Compute validation\n+   * 2. Update the lineage entry state to \"COMPLETED\" and write metadata to the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType\n+   * @param batchId\n+   */\n+  public void endBatchUpload(String tableNameWithType, String batchId) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        Preconditions.checkArgument(segmentLineageZNRecord != null, String\n+            .format(\"Segment lineage does not exist. (tableNameWithType = '%s', batchId = '%s')\", tableNameWithType,\n+                batchId));\n+        segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Look up the lineage entry based on the batch id\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(batchId);\n+        Preconditions.checkArgument(lineageEntry != null,\n+            String.format(\"Invalid batch id (tableName='%s', batchId='%s')\", tableNameWithType, batchId));\n+\n+        // Check that all the segments from 'segmentsTo' exist in the table\n+        Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+        Preconditions.checkArgument(segmentsForTable.containsAll(lineageEntry.getSegmentsTo()), String.format(\n+            \"Not all segments from 'segmentsTo' are available in the table. (tableName = '%s', segmentsTo = '%s', \"\n+                + \"segmentsFromTable = '%s')\", tableNameWithType, lineageEntry.getSegmentsTo(), segmentsForTable));\n+\n+        // NO-OPS if the entry is already completed\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          LOGGER.warn(\"Lineage entry state is already COMPLETED. Nothing to update. (tableNameWithType={}, batchId={})\",\n+              tableNameWithType, batchId);\n+          return true;\n+        }\n+\n+        // Update lineage entry\n+        LineageEntry newLineageEntry =\n+            new LineageEntry(lineageEntry.getSegmentsFrom(), lineageEntry.getSegmentsTo(), LineageEntryState.COMPLETED,\n+                System.currentTimeMillis());\n+        segmentLineage.updateLineageEntry(batchId, newLineageEntry);\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed to update the segment lineage. (tableName = %s, batchId = %s)\", tableNameWithType, batchId);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"endBatchUpload is successfully processed. (tableNameWithType = {}, batchId = {})\", tableNameWithType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwNzg1NQ==", "bodyText": "We can easily find the lineage info from zookeeper (and we can also add an API that fetches lineage entry given batchId if we need to fetch lineage info frequently).", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458407855", "createdAt": "2020-07-21T21:47:17Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String\n+              .format(\"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                      + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                  lineageEntry.getSegmentsFrom(), finalSegmentsFrom));\n+\n+          // Check that merged segments name cannot be the same.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsTo(), segmentsTo), String.format(\n+              \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                  + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+              lineageEntry.getSegmentsTo(), segmentsTo));\n+        }\n+\n+        // Update lineage entry\n+        segmentLineage.addLineageEntry(batchId,\n+            new LineageEntry(finalSegmentsFrom, segmentsTo, LineageEntryState.IN_PROGRESS, System.currentTimeMillis()));\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed while updating the segment lineage. (tableName = %s, segmentsFrom = %s, segmentsTo = %s)\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"startBatchUpload is successfully processed. (tableNameWithType = {}, segmentsFrom = {}, \"\n+        + \"segmentsTo = {}, batchId = {})\", tableNameWithType, segmentsFrom, segmentsTo, batchId);\n+    return batchId;\n+  }\n+\n+  /**\n+   * Computes the end batch upload phase\n+   *\n+   * 1. Compute validation\n+   * 2. Update the lineage entry state to \"COMPLETED\" and write metadata to the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType\n+   * @param batchId\n+   */\n+  public void endBatchUpload(String tableNameWithType, String batchId) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        Preconditions.checkArgument(segmentLineageZNRecord != null, String\n+            .format(\"Segment lineage does not exist. (tableNameWithType = '%s', batchId = '%s')\", tableNameWithType,\n+                batchId));\n+        segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Look up the lineage entry based on the batch id\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(batchId);\n+        Preconditions.checkArgument(lineageEntry != null,\n+            String.format(\"Invalid batch id (tableName='%s', batchId='%s')\", tableNameWithType, batchId));\n+\n+        // Check that all the segments from 'segmentsTo' exist in the table\n+        Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+        Preconditions.checkArgument(segmentsForTable.containsAll(lineageEntry.getSegmentsTo()), String.format(\n+            \"Not all segments from 'segmentsTo' are available in the table. (tableName = '%s', segmentsTo = '%s', \"\n+                + \"segmentsFromTable = '%s')\", tableNameWithType, lineageEntry.getSegmentsTo(), segmentsForTable));\n+\n+        // NO-OPS if the entry is already completed\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          LOGGER.warn(\"Lineage entry state is already COMPLETED. Nothing to update. (tableNameWithType={}, batchId={})\",\n+              tableNameWithType, batchId);\n+          return true;\n+        }\n+\n+        // Update lineage entry\n+        LineageEntry newLineageEntry =\n+            new LineageEntry(lineageEntry.getSegmentsFrom(), lineageEntry.getSegmentsTo(), LineageEntryState.COMPLETED,\n+                System.currentTimeMillis());\n+        segmentLineage.updateLineageEntry(batchId, newLineageEntry);\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed to update the segment lineage. (tableName = %s, batchId = %s)\", tableNameWithType, batchId);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"endBatchUpload is successfully processed. (tableNameWithType = {}, batchId = {})\", tableNameWithType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMzU5MQ=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDE1MTkwOnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyODowN1rOG1Gowg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyODowN1rOG1Gowg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNjQ1MA==", "bodyText": "Let's use lang3\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import org.apache.commons.lang.StringUtils;\n          \n          \n            \n            import org.apache.commons.lang3.StringUtils;", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458336450", "createdAt": "2020-07-21T19:28:07Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -24,7 +24,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.UUID;\n+import org.apache.commons.lang.StringUtils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDE1NjgwOnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyOTo0MlrOG1Gr-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyOTo0MlrOG1Gr-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzI3Mw==", "bodyText": "(nit) Use constant?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458337273", "createdAt": "2020-07-21T19:29:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -108,8 +119,8 @@ public static SegmentLineage fromZNRecord(ZNRecord record) {\n       String lineageId = listField.getKey();\n       List<String> value = listField.getValue();\n       Preconditions.checkState(value.size() == 4);\n-      List<String> segmentsFrom = Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n-      List<String> segmentsTo = Arrays.asList(value.get(1).split(COMMA_SEPARATOR));\n+      List<String> segmentsFrom = Arrays.asList(StringUtils.split(value.get(0), ','));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDE1OTA3OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineageUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOTozMDoyM1rOG1GtUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOTozMDoyM1rOG1GtUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzYxOA==", "bodyText": "(nit) SegmentLineageUtils\nAlso add a private constructor", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458337618", "createdAt": "2020-07-21T19:30:23Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineageUtil.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.lineage;\n+\n+import java.util.UUID;\n+\n+\n+/**\n+ * Util class for Segment Lineage\n+ */\n+public class SegmentLineageUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDE3MzIyOnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/StartBatchUploadRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOTozNDo1N1rOG1G2EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOTozNDo1N1rOG1G2EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzOTg1Ng==", "bodyText": "(nit)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                _segmentsFrom = (segmentsFrom == null) ? new ArrayList<>() : segmentsFrom;\n          \n          \n            \n                _segmentsFrom = (segmentsFrom == null) ? Collections.emptyList() : segmentsFrom;", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458339856", "createdAt": "2020-07-21T19:34:57Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/StartBatchUploadRequest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Request object for startBatchUpload API.\n+ *\n+ * 1. segmentsFrom : original segments. This field can be empty in case the user tries to upload the original segments\n+ *    and wants to achieve the atomic update of multiple segments.\n+ * 2. segmentsTo : merged segments.\n+ */\n+public class StartBatchUploadRequest {\n+  private List<String> _segmentsFrom;\n+  private List<String> _segmentsTo;\n+\n+  public StartBatchUploadRequest(@JsonProperty(\"segmentsFrom\") @Nullable List<String> segmentsFrom,\n+      @JsonProperty(\"segmentsTo\") List<String> segmentsTo) {\n+    _segmentsFrom = (segmentsFrom == null) ? new ArrayList<>() : segmentsFrom;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDcwMjk4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjoyMjozOFrOG1L7ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMTo1MjoxNVrOG1P0rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzE0MQ==", "bodyText": "Use the SegmentLineageUtils and move it into the retry logic so that it handles the case of collision", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458423141", "createdAt": "2020-07-21T22:22:38Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4Njk1Nw==", "bodyText": "good catch!", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458486957", "createdAt": "2020-07-22T01:52:15Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzE0MQ=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDcwNjQ5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjoyNDowN1rOG1L9qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMTo1NzozNVrOG1P6sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzcyMA==", "bodyText": "(nit) I don't think you need to have this extra finalSegmentsFrom because segmentsFrom is never changed", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458423720", "createdAt": "2020-07-21T22:24:07Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4ODQ5Ng==", "bodyText": "Yes you're right. Previous code needed it because I reassigned the value after some validation but this is no longer needed.", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458488496", "createdAt": "2020-07-22T01:57:35Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzcyMA=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDcxNTU4OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjoyNzoyN1rOG1MDCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMjo1MzozNlrOG1Q0mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNTA5OQ==", "bodyText": "Don't directly throw exception as it will abort the retry.\nYou can keep generating batchId until get a new one (in most case there is no collision)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Check that the batchId doesn't exists in the segment lineage\n          \n          \n            \n                    Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n          \n          \n            \n                        String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n          \n          \n            \n                    String batchId = SegmentLineageUtils. generateLineageEntryId();\n          \n          \n            \n                    while (segmentLineage.getLineageEntry(batchId) != null) {\n          \n          \n            \n                      batchId = SegmentLineageUtils. generateLineageEntryId();\n          \n          \n            \n                    }", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458425099", "createdAt": "2020-07-21T22:27:27Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMzMyMg==", "bodyText": "The reason why I generate batchId outside of retry block is that it's a bit hard to pass some information from retry block to the caller based on the current RetryPolicy interface. For now, let's not deal with the id collision. Throwing exception should be fine. Once this part shows up frequently (likely not because it's extremely hard to observe UUID collision), we can deal with this by improving retry policy interface to allow pass information back to the caller.", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458503322", "createdAt": "2020-07-22T02:53:36Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNTA5OQ=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDczMDAzOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjozMjozNVrOG1MLQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMjoxMDoyMFrOG1QIEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNzIwMg==", "bodyText": "You need to catch the exception in order to do retries. Same for other places that can throw exception", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458427202", "createdAt": "2020-07-21T22:32:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5MTkyMw==", "bodyText": "Do we want to retry for the validation check failure? I thought that we can kill the process if validation fails and retries if zk update fails. How do you think?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458491923", "createdAt": "2020-07-22T02:10:20Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNzIwMg=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDczMDg5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjozMjo1OVrOG1MLzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMjoxMDo1NlrOG1QIng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNzM0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Check\n          \n          \n            \n                    // Check ...", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458427343", "createdAt": "2020-07-21T22:32:59Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5MjA2Mg==", "bodyText": "removed", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458492062", "createdAt": "2020-07-22T02:10:56Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNzM0Mw=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDczNTM3OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjozNDo1MlrOG1MOgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMzowNjoxOVrOG1RBuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyODAzNQ==", "bodyText": "segmentsTo must not be any of the existing segmentsFrom as well", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458428035", "createdAt": "2020-07-21T22:34:52Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String\n+              .format(\"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                      + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                  lineageEntry.getSegmentsFrom(), finalSegmentsFrom));\n+\n+          // Check that merged segments name cannot be the same.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsTo(), segmentsTo), String.format(\n+              \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                  + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+              lineageEntry.getSegmentsTo(), segmentsTo));\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwNjY4Mw==", "bodyText": "This check is actually covered by the initial validation\n    // Check that all the segments from 'segmentsFrom' exist in the table\n    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom));\n\n    // Check that all the segments from 'segmentTo' does not exist in the table.\n    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo));\n\nsegmentsForTable is superset of segmentFrom, so checking Collections.disjoint(segmentsForTable, segmentsTo) includes the check of Collection.disjoint(segmentsTo, segmentsFrom)\nI will add the test case for this.", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458506683", "createdAt": "2020-07-22T03:06:19Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String\n+              .format(\"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                      + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                  lineageEntry.getSegmentsFrom(), finalSegmentsFrom));\n+\n+          // Check that merged segments name cannot be the same.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsTo(), segmentsTo), String.format(\n+              \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                  + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+              lineageEntry.getSegmentsTo(), segmentsTo));\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyODAzNQ=="}, "originalCommit": {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDM3MTEwOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODoyODoxOFrOG1u9pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMzozODoxMlrOG132oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5NzE1Ng==", "bodyText": "Do you also need to check that any of the segmentsFrom are not in another merge that has been started (but not finished)?", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458997156", "createdAt": "2020-07-22T18:28:18Z", "author": {"login": "mcvsubbu"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,160 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start segment replace phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Batch Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startReplaceSegments(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = SegmentLineageUtils.generateLineageEntryId();\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8a51381dc08d8cebb191d09c8f648f8f9a3a002"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MjgxNg==", "bodyText": "Good point. It's very important that for any segment, it should appear on segmentsFrom at most once because we will have the issue with double-counting otherwise. In order to prevent that, we will do the following:\n\nMerge task scheduler will check the segments that are running (started but not finished) not to schedule the segments that are already scheduled.\nDuring the \"startReplaceSegments\", we reject if the input segmentFrom appears any of segmentFrom field in the segment lineage.", "url": "https://github.com/apache/pinot/pull/5712#discussion_r459142816", "createdAt": "2020-07-22T23:38:12Z", "author": {"login": "snleee"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,160 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start segment replace phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Batch Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startReplaceSegments(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = SegmentLineageUtils.generateLineageEntryId();\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5NzE1Ng=="}, "originalCommit": {"oid": "e8a51381dc08d8cebb191d09c8f648f8f9a3a002"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4136, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}