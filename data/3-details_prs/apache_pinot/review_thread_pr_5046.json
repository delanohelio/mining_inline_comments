{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNTY3NDg4", "number": 5046, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwNzo1MjoxMlrODdluog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0NDo0OFrODd2x1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzUzNDQyOnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentselector/OfflineSegmentSelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwNzo1MjoxMlrOFmR09g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwNzo1MjoxMlrOFmR09g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4MjI5NA==", "bodyText": "+1 on this idea. This can potentially help use cases that are using onheap dictionary with very high qps.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375682294", "createdAt": "2020-02-06T07:52:12Z", "author": {"login": "snleee"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentselector/OfflineSegmentSelector.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentselector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+public class OfflineSegmentSelector implements SegmentSelector {\n+  private volatile List<String> _segments;\n+\n+  @Override\n+  public void init(ExternalView externalView, Set<String> onlineSegments) {\n+    onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Override\n+  public void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {\n+    Set<String> externalViewSegments = externalView.getPartitionSet();\n+    List<String> segments = new ArrayList<>(externalViewSegments.size());\n+\n+    for (String segment : externalViewSegments) {\n+      // Keep segments in both external view and ideal state\n+      // - New added segment might only exist in ideal state\n+      // - New removed segment might only exist in external view\n+      if (!onlineSegments.contains(segment)) {\n+        continue;\n+      }\n+\n+      // TODO: for new added segments, before all replicas are up, consider not selecting them to avoid causing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzU1OTQ0OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentselector/SegmentSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODowMzo0MVrOFmSD6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMzo1OToyMVrOFmuUqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NjEyMA==", "bodyText": "The segments selected should the whole dataset (table) without overlap is a bit vague. This statement naturally makes me think of the selection step for merge/roll up use case where we can have segments with duplicate data within the same table. If I look at the actual offline, realtime segment selector implementation, it currently handles \"OFFLINE/ONLINE/ERROR/CONSUMING\" issues, which is slightly different from selecting whole dataset. Current code looks more like filtering out invalid segments.\nAlso, the definition of whole dataset can be either all segments from idealstate or all segments in external view with at least one ONLINE and so on.  Are we considering this as the implementation specific issue for each type of segment selector?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375686120", "createdAt": "2020-02-06T08:03:41Z", "author": {"login": "snleee"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentselector/SegmentSelector.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentselector;\n+\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+/**\n+ * The segment selector selects the segments for the query. The segments selected should cover the whole dataset (table)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTE2MQ==", "bodyText": "Only LLC realtime table looks at the external view CONSUMING state to ensure only the first CONSUMING segment for each partition getting selected to prevent overlap data. It will not look at other states, which will be handled by the instance selector instead.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376149161", "createdAt": "2020-02-06T23:59:21Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentselector/SegmentSelector.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentselector;\n+\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+/**\n+ * The segment selector selects the segments for the query. The segments selected should cover the whole dataset (table)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NjEyMA=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzU4ODg4OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODoxNjoyN1rOFmSV5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTozNTowM1rOFnK9kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5MDcyNA==", "bodyText": "We should consider to make this to List<SegmentPruner>.\nFor instance, it's a valid use case to do the pruning on both partition and time column value.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375690724", "createdAt": "2020-02-06T08:16:27Z", "author": {"login": "snleee"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RoutingManager.class);\n+\n+  private final BrokerMetrics _brokerMetrics;\n+  private final Map<String, RoutingEntry> _routingEntryMap = new ConcurrentHashMap<>();\n+  private final Map<String, ServerInstance> _enabledServerInstanceMap = new ConcurrentHashMap<>();\n+\n+  private BaseDataAccessor<ZNRecord> _zkDataAccessor;\n+  private String _externalViewPathPrefix;\n+  private String _idealStatePathPrefix;\n+  private String _instanceConfigsPath;\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+\n+  public RoutingManager(BrokerMetrics brokerMetrics) {\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(HelixManager helixManager) {\n+    HelixDataAccessor helixDataAccessor = helixManager.getHelixDataAccessor();\n+    _zkDataAccessor = helixDataAccessor.getBaseDataAccessor();\n+    _externalViewPathPrefix = helixDataAccessor.keyBuilder().externalViews().getPath() + \"/\";\n+    _idealStatePathPrefix = helixDataAccessor.keyBuilder().idealStates().getPath() + \"/\";\n+    _instanceConfigsPath = helixDataAccessor.keyBuilder().instanceConfigs().getPath();\n+    _propertyStore = helixManager.getHelixPropertyStore();\n+  }\n+\n+  @Override\n+  public synchronized void processClusterChange(HelixConstants.ChangeType changeType) {\n+    Preconditions.checkState(changeType == HelixConstants.ChangeType.EXTERNAL_VIEW\n+        || changeType == HelixConstants.ChangeType.INSTANCE_CONFIG, \"Illegal change type: \" + changeType);\n+    if (changeType == HelixConstants.ChangeType.EXTERNAL_VIEW) {\n+      processExternalViewChange();\n+    } else {\n+      processInstanceConfigChange();\n+    }\n+  }\n+\n+  private void processExternalViewChange() {\n+    LOGGER.info(\"Processing external view change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    int numTables = _routingEntryMap.size();\n+    if (numTables == 0) {\n+      LOGGER.info(\"No table exists in the routing, skipping processing external view change\");\n+      return;\n+    }\n+\n+    List<RoutingEntry> routingEntries = new ArrayList<>(numTables);\n+    List<String> externalViewPaths = new ArrayList<>(numTables);\n+    for (Map.Entry<String, RoutingEntry> entry : _routingEntryMap.entrySet()) {\n+      String tableNameWithType = entry.getKey();\n+      routingEntries.add(entry.getValue());\n+      externalViewPaths.add(_externalViewPathPrefix + tableNameWithType);\n+    }\n+    Stat[] stats = _zkDataAccessor.getStats(externalViewPaths, AccessOption.PERSISTENT);\n+    long fetchStatsEndTimeMs = System.currentTimeMillis();\n+\n+    int numRoutingEntriesToUpdate = 0;\n+    for (int i = 0; i < numTables; i++) {\n+      Stat stat = stats[i];\n+      if (stat != null) {\n+        RoutingEntry routingEntry = routingEntries.get(i);\n+        if (stat.getVersion() != routingEntry.getLastUpdateExternalViewVersion()) {\n+          numRoutingEntriesToUpdate++;\n+          try {\n+            updateRoutingEntryOnExternalViewChange(routingEntry);\n+          } catch (Exception e) {\n+            LOGGER\n+                .error(\"Caught unexpected exception while updating routing entry on external view change for table: {}\",\n+                    routingEntry.getTableNameWithType(), e);\n+          }\n+        }\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    LOGGER.info(\n+        \"Processed external view change in {}ms (fetch {} external view stats: {}ms, update {} routing entries: {}ms)\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, numTables, fetchStatsEndTimeMs - startTimeMs,\n+        numRoutingEntriesToUpdate, updateRoutingEntriesEndTimeMs - fetchStatsEndTimeMs);\n+  }\n+\n+  private void updateRoutingEntryOnExternalViewChange(RoutingEntry routingEntry) {\n+    String tableNameWithType = routingEntry.getTableNameWithType();\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    if (externalView == null) {\n+      LOGGER.warn(\"Failed to find external view for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    if (onlineSegments == null) {\n+      LOGGER.warn(\"Failed to find ideal state for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    routingEntry.onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Nullable\n+  private ExternalView getExternalView(String tableNameWithType) {\n+    Stat stat = new Stat();\n+    ZNRecord znRecord = _zkDataAccessor.get(_externalViewPathPrefix + tableNameWithType, stat, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      znRecord.setVersion(stat.getVersion());\n+      return new ExternalView(znRecord);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  private Set<String> getOnlineSegments(String tableNameWithType) {\n+    ZNRecord znRecord = _zkDataAccessor.get(_idealStatePathPrefix + tableNameWithType, null, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      Map<String, Map<String, String>> segmentAssignment = znRecord.getMapFields();\n+      Set<String> onlineSegments = new HashSet<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+      for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+        Map<String, String> instanceStateMap = entry.getValue();\n+        if (instanceStateMap.containsValue(RealtimeSegmentOnlineOfflineStateModel.ONLINE) || instanceStateMap\n+            .containsValue(RealtimeSegmentOnlineOfflineStateModel.CONSUMING)) {\n+          onlineSegments.add(entry.getKey());\n+        }\n+      }\n+      return onlineSegments;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private void processInstanceConfigChange() {\n+    LOGGER.info(\"Processing instance config change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    List<ZNRecord> instanceConfigZNRecords =\n+        _zkDataAccessor.getChildren(_instanceConfigsPath, null, AccessOption.PERSISTENT);\n+    long fetchInstanceConfigsEndTimeMs = System.currentTimeMillis();\n+\n+    // Calculate new enabled and disabled instances\n+    Set<String> enabledInstances = new HashSet<>();\n+    List<String> newEnabledInstances = new ArrayList<>();\n+    for (ZNRecord instanceConfigZNRecord : instanceConfigZNRecords) {\n+      String instance = instanceConfigZNRecord.getId();\n+      if (isInstanceEnabled(instanceConfigZNRecord)) {\n+        enabledInstances.add(instance);\n+\n+        // Always refresh the server instance with the latest instance config in case it changes\n+        ServerInstance serverInstance = new ServerInstance(new InstanceConfig(instanceConfigZNRecord));\n+        if (_enabledServerInstanceMap.put(instance, serverInstance) == null) {\n+          newEnabledInstances.add(instance);\n+        }\n+      }\n+    }\n+    List<String> newDisabledInstances = new ArrayList<>();\n+    for (String instance : _enabledServerInstanceMap.keySet()) {\n+      if (!enabledInstances.contains(instance)) {\n+        newDisabledInstances.add(instance);\n+      }\n+    }\n+    List<String> changedInstances = new ArrayList<>(newEnabledInstances.size() + newDisabledInstances.size());\n+    changedInstances.addAll(newEnabledInstances);\n+    changedInstances.addAll(newDisabledInstances);\n+    long calculateChangedInstancesEndTimeMs = System.currentTimeMillis();\n+\n+    // Update routing entry for all tables\n+    for (RoutingEntry routingEntry : _routingEntryMap.values()) {\n+      try {\n+        routingEntry.onInstancesChange(enabledInstances, changedInstances);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Caught unexpected exception while updating routing entry on instances change for table: {}\",\n+            routingEntry.getTableNameWithType(), e);\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    // Remove new disabled instances from _enabledServerInstanceMap after updating all routing entries to ensure it\n+    // always contains the selected instances\n+    _enabledServerInstanceMap.keySet().removeAll(newDisabledInstances);\n+\n+    LOGGER.info(\n+        \"Processed instance config change in {}ms (fetch {} instance configs: {}ms, calculate changed instances: {}ms, update {} routing entries: {}ms), new enabled instances: {}, new disabled instances: {}\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, instanceConfigZNRecords.size(),\n+        fetchInstanceConfigsEndTimeMs - startTimeMs, calculateChangedInstancesEndTimeMs - fetchInstanceConfigsEndTimeMs,\n+        _routingEntryMap.size(), updateRoutingEntriesEndTimeMs - calculateChangedInstancesEndTimeMs,\n+        newEnabledInstances, newDisabledInstances);\n+  }\n+\n+  private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {\n+    if (\"false\"\n+        .equals(instanceConfigZNRecord.getSimpleField(InstanceConfig.InstanceConfigProperty.HELIX_ENABLED.name()))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.IS_SHUTDOWN_IN_PROGRESS))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.QUERIES_DISABLED))) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Builds/rebuilds the routing for the given table.\n+   */\n+  public synchronized void buildRouting(String tableNameWithType) {\n+    LOGGER.info(\"Building routing for table: {}\", tableNameWithType);\n+\n+    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, tableNameWithType);\n+    Preconditions.checkState(tableConfig != null, \"Failed to find table config for table: {}\", tableNameWithType);\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Failed to find external view for table: {}\", tableNameWithType);\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    Preconditions.checkState(onlineSegments != null, \"Failed to find ideal state for table: {}\", tableNameWithType);\n+    Set<String> enabledInstances = _enabledServerInstanceMap.keySet();\n+\n+    SegmentSelector segmentSelector = SegmentSelectorFactory.getSegmentSelector(tableConfig);\n+    segmentSelector.init(externalView, onlineSegments);\n+    SegmentPruner segmentPruner = SegmentPrunerFactory.getSegmentPruner(tableConfig, _propertyStore);\n+    segmentPruner.init(externalView, onlineSegments);\n+    InstanceSelector instanceSelector = InstanceSelectorFactory.getInstanceSelector(tableConfig, _brokerMetrics);\n+    instanceSelector.init(enabledInstances, externalView, onlineSegments);\n+    int externalViewVersion = externalView.getRecord().getVersion();\n+\n+    // Add time boundary manager if both offline and real-time part exist for a hybrid table\n+    TimeBoundaryManager timeBoundaryManager = null;\n+    String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n+      // Current table is offline\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+      if (_routingEntryMap.containsKey(realtimeTableName)) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", tableNameWithType);\n+        timeBoundaryManager = new TimeBoundaryManager(tableConfig, _propertyStore);\n+        timeBoundaryManager.init(externalView, onlineSegments);\n+      }\n+    } else {\n+      // Current table is real-time\n+      String offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(rawTableName);\n+      RoutingEntry offlineTableRoutingEntry = _routingEntryMap.get(offlineTableName);\n+      if (offlineTableRoutingEntry != null && offlineTableRoutingEntry.getTimeBoundaryManager() == null) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", offlineTableName);\n+\n+        // NOTE: Add time boundary manager to the offline part before adding the routing for the real-time part to\n+        // ensure no overlapping data getting queried\n+        TableConfig offlineTableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, offlineTableName);\n+        Preconditions\n+            .checkState(offlineTableConfig != null, \"Failed to find table config for table: {}\", offlineTableName);\n+        ExternalView offlineTableExternalView = getExternalView(offlineTableName);\n+        Preconditions.checkState(offlineTableExternalView != null, \"Failed to find external view for table: {}\",\n+            offlineTableName);\n+        Set<String> offlineTableOnlineSegments = getOnlineSegments(offlineTableName);\n+        Preconditions.checkState(offlineTableOnlineSegments != null, \"Failed to find ideal state for table: {}\",\n+            offlineTableName);\n+        TimeBoundaryManager offlineTableTimeBoundaryManager =\n+            new TimeBoundaryManager(offlineTableConfig, _propertyStore);\n+        offlineTableTimeBoundaryManager.init(offlineTableExternalView, offlineTableOnlineSegments);\n+        offlineTableRoutingEntry.setTimeBoundaryManager(offlineTableTimeBoundaryManager);\n+      }\n+    }\n+\n+    RoutingEntry routingEntry =\n+        new RoutingEntry(tableNameWithType, segmentSelector, segmentPruner, instanceSelector, externalViewVersion,\n+            timeBoundaryManager);\n+    if (_routingEntryMap.put(tableNameWithType, routingEntry) == null) {\n+      LOGGER.info(\"Built routing for table: {}\", tableNameWithType);\n+    } else {\n+      LOGGER.info(\"Rebuilt routing for table: {}\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Removes the routing for the given table.\n+   */\n+  public synchronized void removeRouting(String tableNameWithType) {\n+    LOGGER.info(\"Removing routing for table: {}\", tableNameWithType);\n+    if (_routingEntryMap.remove(tableNameWithType) != null) {\n+      LOGGER.info(\"Removed routing for table: {}\", tableNameWithType);\n+\n+      // Remove time boundary manager for the offline part routing if the removed routing is the real-time part of a\n+      // hybrid table\n+      if (TableNameBuilder.isRealtimeTableResource(tableNameWithType)) {\n+        String offlineTableName =\n+            TableNameBuilder.OFFLINE.tableNameWithType(TableNameBuilder.extractRawTableName(tableNameWithType));\n+        RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+        if (routingEntry != null) {\n+          routingEntry.setTimeBoundaryManager(null);\n+          LOGGER.info(\"Removed time boundary manager for table: {}\", offlineTableName);\n+        }\n+      }\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping removing routing\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the metadata for the given segment (called when segment is getting refreshed).\n+   */\n+  public synchronized void refreshSegment(String tableNameWithType, String segment) {\n+    LOGGER.info(\"Refreshing segment: {} for table: {}\", segment, tableNameWithType);\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    if (routingEntry != null) {\n+      routingEntry.refreshSegment(segment);\n+      LOGGER.info(\"Refreshed segment: {} for table: {}\", segment, tableNameWithType);\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping refreshing segment\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if the routing exists for the given table.\n+   */\n+  public boolean routingExists(String tableNameWithType) {\n+    return _routingEntryMap.containsKey(tableNameWithType);\n+  }\n+\n+  /**\n+   * Returns the routing table (map from server instance to list of segments hosted by the server) based on the broker\n+   * request.\n+   * <p>NOTE: The broker request should already have the table suffix (_OFFLINE or _REALTIME) appended.\n+   */\n+  public Map<ServerInstance, List<String>> getRoutingTable(BrokerRequest brokerRequest) {\n+    String tableNameWithType = brokerRequest.getQuerySource().getTableName();\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", tableNameWithType);\n+\n+    Map<String, String> segmentToInstanceMap = routingEntry.calculateSegmentToInstanceMap(brokerRequest);\n+    Map<ServerInstance, List<String>> routingTable = new HashMap<>();\n+    for (Map.Entry<String, String> entry : segmentToInstanceMap.entrySet()) {\n+      ServerInstance serverInstance = _enabledServerInstanceMap.get(entry.getValue());\n+      if (serverInstance != null) {\n+        routingTable.computeIfAbsent(serverInstance, k -> new ArrayList<>()).add(entry.getKey());\n+      } else {\n+        // Should not happen in normal case unless encountered unexpected exception when updating routing entries\n+        _brokerMetrics.addMeteredTableValue(tableNameWithType, BrokerMeter.SERVER_MISSING_FOR_ROUTING, 1L);\n+      }\n+    }\n+    return routingTable;\n+  }\n+\n+  /**\n+   * Returns the time boundary info for the given offline table name.\n+   * <p>NOTE: Time boundary info is only available for the offline part of the hybrid table.\n+   */\n+  @Nullable\n+  public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n+    RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", offlineTableName);\n+    TimeBoundaryManager timeBoundaryManager = routingEntry.getTimeBoundaryManager();\n+    return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n+  }\n+\n+  private static class RoutingEntry {\n+    final String _tableNameWithType;\n+    final SegmentSelector _segmentSelector;\n+    final SegmentPruner _segmentPruner;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAxMzQwMQ==", "bodyText": "Good point. I was planning to add this later when more segment pruners are implemented, but I can also add them now to avoid unnecessary config change in the future", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376013401", "createdAt": "2020-02-06T18:42:22Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RoutingManager.class);\n+\n+  private final BrokerMetrics _brokerMetrics;\n+  private final Map<String, RoutingEntry> _routingEntryMap = new ConcurrentHashMap<>();\n+  private final Map<String, ServerInstance> _enabledServerInstanceMap = new ConcurrentHashMap<>();\n+\n+  private BaseDataAccessor<ZNRecord> _zkDataAccessor;\n+  private String _externalViewPathPrefix;\n+  private String _idealStatePathPrefix;\n+  private String _instanceConfigsPath;\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+\n+  public RoutingManager(BrokerMetrics brokerMetrics) {\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(HelixManager helixManager) {\n+    HelixDataAccessor helixDataAccessor = helixManager.getHelixDataAccessor();\n+    _zkDataAccessor = helixDataAccessor.getBaseDataAccessor();\n+    _externalViewPathPrefix = helixDataAccessor.keyBuilder().externalViews().getPath() + \"/\";\n+    _idealStatePathPrefix = helixDataAccessor.keyBuilder().idealStates().getPath() + \"/\";\n+    _instanceConfigsPath = helixDataAccessor.keyBuilder().instanceConfigs().getPath();\n+    _propertyStore = helixManager.getHelixPropertyStore();\n+  }\n+\n+  @Override\n+  public synchronized void processClusterChange(HelixConstants.ChangeType changeType) {\n+    Preconditions.checkState(changeType == HelixConstants.ChangeType.EXTERNAL_VIEW\n+        || changeType == HelixConstants.ChangeType.INSTANCE_CONFIG, \"Illegal change type: \" + changeType);\n+    if (changeType == HelixConstants.ChangeType.EXTERNAL_VIEW) {\n+      processExternalViewChange();\n+    } else {\n+      processInstanceConfigChange();\n+    }\n+  }\n+\n+  private void processExternalViewChange() {\n+    LOGGER.info(\"Processing external view change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    int numTables = _routingEntryMap.size();\n+    if (numTables == 0) {\n+      LOGGER.info(\"No table exists in the routing, skipping processing external view change\");\n+      return;\n+    }\n+\n+    List<RoutingEntry> routingEntries = new ArrayList<>(numTables);\n+    List<String> externalViewPaths = new ArrayList<>(numTables);\n+    for (Map.Entry<String, RoutingEntry> entry : _routingEntryMap.entrySet()) {\n+      String tableNameWithType = entry.getKey();\n+      routingEntries.add(entry.getValue());\n+      externalViewPaths.add(_externalViewPathPrefix + tableNameWithType);\n+    }\n+    Stat[] stats = _zkDataAccessor.getStats(externalViewPaths, AccessOption.PERSISTENT);\n+    long fetchStatsEndTimeMs = System.currentTimeMillis();\n+\n+    int numRoutingEntriesToUpdate = 0;\n+    for (int i = 0; i < numTables; i++) {\n+      Stat stat = stats[i];\n+      if (stat != null) {\n+        RoutingEntry routingEntry = routingEntries.get(i);\n+        if (stat.getVersion() != routingEntry.getLastUpdateExternalViewVersion()) {\n+          numRoutingEntriesToUpdate++;\n+          try {\n+            updateRoutingEntryOnExternalViewChange(routingEntry);\n+          } catch (Exception e) {\n+            LOGGER\n+                .error(\"Caught unexpected exception while updating routing entry on external view change for table: {}\",\n+                    routingEntry.getTableNameWithType(), e);\n+          }\n+        }\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    LOGGER.info(\n+        \"Processed external view change in {}ms (fetch {} external view stats: {}ms, update {} routing entries: {}ms)\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, numTables, fetchStatsEndTimeMs - startTimeMs,\n+        numRoutingEntriesToUpdate, updateRoutingEntriesEndTimeMs - fetchStatsEndTimeMs);\n+  }\n+\n+  private void updateRoutingEntryOnExternalViewChange(RoutingEntry routingEntry) {\n+    String tableNameWithType = routingEntry.getTableNameWithType();\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    if (externalView == null) {\n+      LOGGER.warn(\"Failed to find external view for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    if (onlineSegments == null) {\n+      LOGGER.warn(\"Failed to find ideal state for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    routingEntry.onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Nullable\n+  private ExternalView getExternalView(String tableNameWithType) {\n+    Stat stat = new Stat();\n+    ZNRecord znRecord = _zkDataAccessor.get(_externalViewPathPrefix + tableNameWithType, stat, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      znRecord.setVersion(stat.getVersion());\n+      return new ExternalView(znRecord);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  private Set<String> getOnlineSegments(String tableNameWithType) {\n+    ZNRecord znRecord = _zkDataAccessor.get(_idealStatePathPrefix + tableNameWithType, null, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      Map<String, Map<String, String>> segmentAssignment = znRecord.getMapFields();\n+      Set<String> onlineSegments = new HashSet<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+      for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+        Map<String, String> instanceStateMap = entry.getValue();\n+        if (instanceStateMap.containsValue(RealtimeSegmentOnlineOfflineStateModel.ONLINE) || instanceStateMap\n+            .containsValue(RealtimeSegmentOnlineOfflineStateModel.CONSUMING)) {\n+          onlineSegments.add(entry.getKey());\n+        }\n+      }\n+      return onlineSegments;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private void processInstanceConfigChange() {\n+    LOGGER.info(\"Processing instance config change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    List<ZNRecord> instanceConfigZNRecords =\n+        _zkDataAccessor.getChildren(_instanceConfigsPath, null, AccessOption.PERSISTENT);\n+    long fetchInstanceConfigsEndTimeMs = System.currentTimeMillis();\n+\n+    // Calculate new enabled and disabled instances\n+    Set<String> enabledInstances = new HashSet<>();\n+    List<String> newEnabledInstances = new ArrayList<>();\n+    for (ZNRecord instanceConfigZNRecord : instanceConfigZNRecords) {\n+      String instance = instanceConfigZNRecord.getId();\n+      if (isInstanceEnabled(instanceConfigZNRecord)) {\n+        enabledInstances.add(instance);\n+\n+        // Always refresh the server instance with the latest instance config in case it changes\n+        ServerInstance serverInstance = new ServerInstance(new InstanceConfig(instanceConfigZNRecord));\n+        if (_enabledServerInstanceMap.put(instance, serverInstance) == null) {\n+          newEnabledInstances.add(instance);\n+        }\n+      }\n+    }\n+    List<String> newDisabledInstances = new ArrayList<>();\n+    for (String instance : _enabledServerInstanceMap.keySet()) {\n+      if (!enabledInstances.contains(instance)) {\n+        newDisabledInstances.add(instance);\n+      }\n+    }\n+    List<String> changedInstances = new ArrayList<>(newEnabledInstances.size() + newDisabledInstances.size());\n+    changedInstances.addAll(newEnabledInstances);\n+    changedInstances.addAll(newDisabledInstances);\n+    long calculateChangedInstancesEndTimeMs = System.currentTimeMillis();\n+\n+    // Update routing entry for all tables\n+    for (RoutingEntry routingEntry : _routingEntryMap.values()) {\n+      try {\n+        routingEntry.onInstancesChange(enabledInstances, changedInstances);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Caught unexpected exception while updating routing entry on instances change for table: {}\",\n+            routingEntry.getTableNameWithType(), e);\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    // Remove new disabled instances from _enabledServerInstanceMap after updating all routing entries to ensure it\n+    // always contains the selected instances\n+    _enabledServerInstanceMap.keySet().removeAll(newDisabledInstances);\n+\n+    LOGGER.info(\n+        \"Processed instance config change in {}ms (fetch {} instance configs: {}ms, calculate changed instances: {}ms, update {} routing entries: {}ms), new enabled instances: {}, new disabled instances: {}\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, instanceConfigZNRecords.size(),\n+        fetchInstanceConfigsEndTimeMs - startTimeMs, calculateChangedInstancesEndTimeMs - fetchInstanceConfigsEndTimeMs,\n+        _routingEntryMap.size(), updateRoutingEntriesEndTimeMs - calculateChangedInstancesEndTimeMs,\n+        newEnabledInstances, newDisabledInstances);\n+  }\n+\n+  private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {\n+    if (\"false\"\n+        .equals(instanceConfigZNRecord.getSimpleField(InstanceConfig.InstanceConfigProperty.HELIX_ENABLED.name()))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.IS_SHUTDOWN_IN_PROGRESS))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.QUERIES_DISABLED))) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Builds/rebuilds the routing for the given table.\n+   */\n+  public synchronized void buildRouting(String tableNameWithType) {\n+    LOGGER.info(\"Building routing for table: {}\", tableNameWithType);\n+\n+    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, tableNameWithType);\n+    Preconditions.checkState(tableConfig != null, \"Failed to find table config for table: {}\", tableNameWithType);\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Failed to find external view for table: {}\", tableNameWithType);\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    Preconditions.checkState(onlineSegments != null, \"Failed to find ideal state for table: {}\", tableNameWithType);\n+    Set<String> enabledInstances = _enabledServerInstanceMap.keySet();\n+\n+    SegmentSelector segmentSelector = SegmentSelectorFactory.getSegmentSelector(tableConfig);\n+    segmentSelector.init(externalView, onlineSegments);\n+    SegmentPruner segmentPruner = SegmentPrunerFactory.getSegmentPruner(tableConfig, _propertyStore);\n+    segmentPruner.init(externalView, onlineSegments);\n+    InstanceSelector instanceSelector = InstanceSelectorFactory.getInstanceSelector(tableConfig, _brokerMetrics);\n+    instanceSelector.init(enabledInstances, externalView, onlineSegments);\n+    int externalViewVersion = externalView.getRecord().getVersion();\n+\n+    // Add time boundary manager if both offline and real-time part exist for a hybrid table\n+    TimeBoundaryManager timeBoundaryManager = null;\n+    String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n+      // Current table is offline\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+      if (_routingEntryMap.containsKey(realtimeTableName)) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", tableNameWithType);\n+        timeBoundaryManager = new TimeBoundaryManager(tableConfig, _propertyStore);\n+        timeBoundaryManager.init(externalView, onlineSegments);\n+      }\n+    } else {\n+      // Current table is real-time\n+      String offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(rawTableName);\n+      RoutingEntry offlineTableRoutingEntry = _routingEntryMap.get(offlineTableName);\n+      if (offlineTableRoutingEntry != null && offlineTableRoutingEntry.getTimeBoundaryManager() == null) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", offlineTableName);\n+\n+        // NOTE: Add time boundary manager to the offline part before adding the routing for the real-time part to\n+        // ensure no overlapping data getting queried\n+        TableConfig offlineTableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, offlineTableName);\n+        Preconditions\n+            .checkState(offlineTableConfig != null, \"Failed to find table config for table: {}\", offlineTableName);\n+        ExternalView offlineTableExternalView = getExternalView(offlineTableName);\n+        Preconditions.checkState(offlineTableExternalView != null, \"Failed to find external view for table: {}\",\n+            offlineTableName);\n+        Set<String> offlineTableOnlineSegments = getOnlineSegments(offlineTableName);\n+        Preconditions.checkState(offlineTableOnlineSegments != null, \"Failed to find ideal state for table: {}\",\n+            offlineTableName);\n+        TimeBoundaryManager offlineTableTimeBoundaryManager =\n+            new TimeBoundaryManager(offlineTableConfig, _propertyStore);\n+        offlineTableTimeBoundaryManager.init(offlineTableExternalView, offlineTableOnlineSegments);\n+        offlineTableRoutingEntry.setTimeBoundaryManager(offlineTableTimeBoundaryManager);\n+      }\n+    }\n+\n+    RoutingEntry routingEntry =\n+        new RoutingEntry(tableNameWithType, segmentSelector, segmentPruner, instanceSelector, externalViewVersion,\n+            timeBoundaryManager);\n+    if (_routingEntryMap.put(tableNameWithType, routingEntry) == null) {\n+      LOGGER.info(\"Built routing for table: {}\", tableNameWithType);\n+    } else {\n+      LOGGER.info(\"Rebuilt routing for table: {}\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Removes the routing for the given table.\n+   */\n+  public synchronized void removeRouting(String tableNameWithType) {\n+    LOGGER.info(\"Removing routing for table: {}\", tableNameWithType);\n+    if (_routingEntryMap.remove(tableNameWithType) != null) {\n+      LOGGER.info(\"Removed routing for table: {}\", tableNameWithType);\n+\n+      // Remove time boundary manager for the offline part routing if the removed routing is the real-time part of a\n+      // hybrid table\n+      if (TableNameBuilder.isRealtimeTableResource(tableNameWithType)) {\n+        String offlineTableName =\n+            TableNameBuilder.OFFLINE.tableNameWithType(TableNameBuilder.extractRawTableName(tableNameWithType));\n+        RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+        if (routingEntry != null) {\n+          routingEntry.setTimeBoundaryManager(null);\n+          LOGGER.info(\"Removed time boundary manager for table: {}\", offlineTableName);\n+        }\n+      }\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping removing routing\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the metadata for the given segment (called when segment is getting refreshed).\n+   */\n+  public synchronized void refreshSegment(String tableNameWithType, String segment) {\n+    LOGGER.info(\"Refreshing segment: {} for table: {}\", segment, tableNameWithType);\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    if (routingEntry != null) {\n+      routingEntry.refreshSegment(segment);\n+      LOGGER.info(\"Refreshed segment: {} for table: {}\", segment, tableNameWithType);\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping refreshing segment\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if the routing exists for the given table.\n+   */\n+  public boolean routingExists(String tableNameWithType) {\n+    return _routingEntryMap.containsKey(tableNameWithType);\n+  }\n+\n+  /**\n+   * Returns the routing table (map from server instance to list of segments hosted by the server) based on the broker\n+   * request.\n+   * <p>NOTE: The broker request should already have the table suffix (_OFFLINE or _REALTIME) appended.\n+   */\n+  public Map<ServerInstance, List<String>> getRoutingTable(BrokerRequest brokerRequest) {\n+    String tableNameWithType = brokerRequest.getQuerySource().getTableName();\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", tableNameWithType);\n+\n+    Map<String, String> segmentToInstanceMap = routingEntry.calculateSegmentToInstanceMap(brokerRequest);\n+    Map<ServerInstance, List<String>> routingTable = new HashMap<>();\n+    for (Map.Entry<String, String> entry : segmentToInstanceMap.entrySet()) {\n+      ServerInstance serverInstance = _enabledServerInstanceMap.get(entry.getValue());\n+      if (serverInstance != null) {\n+        routingTable.computeIfAbsent(serverInstance, k -> new ArrayList<>()).add(entry.getKey());\n+      } else {\n+        // Should not happen in normal case unless encountered unexpected exception when updating routing entries\n+        _brokerMetrics.addMeteredTableValue(tableNameWithType, BrokerMeter.SERVER_MISSING_FOR_ROUTING, 1L);\n+      }\n+    }\n+    return routingTable;\n+  }\n+\n+  /**\n+   * Returns the time boundary info for the given offline table name.\n+   * <p>NOTE: Time boundary info is only available for the offline part of the hybrid table.\n+   */\n+  @Nullable\n+  public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n+    RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", offlineTableName);\n+    TimeBoundaryManager timeBoundaryManager = routingEntry.getTimeBoundaryManager();\n+    return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n+  }\n+\n+  private static class RoutingEntry {\n+    final String _tableNameWithType;\n+    final SegmentSelector _segmentSelector;\n+    final SegmentPruner _segmentPruner;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5MDcyNA=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxODM4Nw==", "bodyText": "Added", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376618387", "createdAt": "2020-02-07T21:35:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RoutingManager.class);\n+\n+  private final BrokerMetrics _brokerMetrics;\n+  private final Map<String, RoutingEntry> _routingEntryMap = new ConcurrentHashMap<>();\n+  private final Map<String, ServerInstance> _enabledServerInstanceMap = new ConcurrentHashMap<>();\n+\n+  private BaseDataAccessor<ZNRecord> _zkDataAccessor;\n+  private String _externalViewPathPrefix;\n+  private String _idealStatePathPrefix;\n+  private String _instanceConfigsPath;\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+\n+  public RoutingManager(BrokerMetrics brokerMetrics) {\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(HelixManager helixManager) {\n+    HelixDataAccessor helixDataAccessor = helixManager.getHelixDataAccessor();\n+    _zkDataAccessor = helixDataAccessor.getBaseDataAccessor();\n+    _externalViewPathPrefix = helixDataAccessor.keyBuilder().externalViews().getPath() + \"/\";\n+    _idealStatePathPrefix = helixDataAccessor.keyBuilder().idealStates().getPath() + \"/\";\n+    _instanceConfigsPath = helixDataAccessor.keyBuilder().instanceConfigs().getPath();\n+    _propertyStore = helixManager.getHelixPropertyStore();\n+  }\n+\n+  @Override\n+  public synchronized void processClusterChange(HelixConstants.ChangeType changeType) {\n+    Preconditions.checkState(changeType == HelixConstants.ChangeType.EXTERNAL_VIEW\n+        || changeType == HelixConstants.ChangeType.INSTANCE_CONFIG, \"Illegal change type: \" + changeType);\n+    if (changeType == HelixConstants.ChangeType.EXTERNAL_VIEW) {\n+      processExternalViewChange();\n+    } else {\n+      processInstanceConfigChange();\n+    }\n+  }\n+\n+  private void processExternalViewChange() {\n+    LOGGER.info(\"Processing external view change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    int numTables = _routingEntryMap.size();\n+    if (numTables == 0) {\n+      LOGGER.info(\"No table exists in the routing, skipping processing external view change\");\n+      return;\n+    }\n+\n+    List<RoutingEntry> routingEntries = new ArrayList<>(numTables);\n+    List<String> externalViewPaths = new ArrayList<>(numTables);\n+    for (Map.Entry<String, RoutingEntry> entry : _routingEntryMap.entrySet()) {\n+      String tableNameWithType = entry.getKey();\n+      routingEntries.add(entry.getValue());\n+      externalViewPaths.add(_externalViewPathPrefix + tableNameWithType);\n+    }\n+    Stat[] stats = _zkDataAccessor.getStats(externalViewPaths, AccessOption.PERSISTENT);\n+    long fetchStatsEndTimeMs = System.currentTimeMillis();\n+\n+    int numRoutingEntriesToUpdate = 0;\n+    for (int i = 0; i < numTables; i++) {\n+      Stat stat = stats[i];\n+      if (stat != null) {\n+        RoutingEntry routingEntry = routingEntries.get(i);\n+        if (stat.getVersion() != routingEntry.getLastUpdateExternalViewVersion()) {\n+          numRoutingEntriesToUpdate++;\n+          try {\n+            updateRoutingEntryOnExternalViewChange(routingEntry);\n+          } catch (Exception e) {\n+            LOGGER\n+                .error(\"Caught unexpected exception while updating routing entry on external view change for table: {}\",\n+                    routingEntry.getTableNameWithType(), e);\n+          }\n+        }\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    LOGGER.info(\n+        \"Processed external view change in {}ms (fetch {} external view stats: {}ms, update {} routing entries: {}ms)\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, numTables, fetchStatsEndTimeMs - startTimeMs,\n+        numRoutingEntriesToUpdate, updateRoutingEntriesEndTimeMs - fetchStatsEndTimeMs);\n+  }\n+\n+  private void updateRoutingEntryOnExternalViewChange(RoutingEntry routingEntry) {\n+    String tableNameWithType = routingEntry.getTableNameWithType();\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    if (externalView == null) {\n+      LOGGER.warn(\"Failed to find external view for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    if (onlineSegments == null) {\n+      LOGGER.warn(\"Failed to find ideal state for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    routingEntry.onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Nullable\n+  private ExternalView getExternalView(String tableNameWithType) {\n+    Stat stat = new Stat();\n+    ZNRecord znRecord = _zkDataAccessor.get(_externalViewPathPrefix + tableNameWithType, stat, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      znRecord.setVersion(stat.getVersion());\n+      return new ExternalView(znRecord);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  private Set<String> getOnlineSegments(String tableNameWithType) {\n+    ZNRecord znRecord = _zkDataAccessor.get(_idealStatePathPrefix + tableNameWithType, null, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      Map<String, Map<String, String>> segmentAssignment = znRecord.getMapFields();\n+      Set<String> onlineSegments = new HashSet<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+      for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+        Map<String, String> instanceStateMap = entry.getValue();\n+        if (instanceStateMap.containsValue(RealtimeSegmentOnlineOfflineStateModel.ONLINE) || instanceStateMap\n+            .containsValue(RealtimeSegmentOnlineOfflineStateModel.CONSUMING)) {\n+          onlineSegments.add(entry.getKey());\n+        }\n+      }\n+      return onlineSegments;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private void processInstanceConfigChange() {\n+    LOGGER.info(\"Processing instance config change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    List<ZNRecord> instanceConfigZNRecords =\n+        _zkDataAccessor.getChildren(_instanceConfigsPath, null, AccessOption.PERSISTENT);\n+    long fetchInstanceConfigsEndTimeMs = System.currentTimeMillis();\n+\n+    // Calculate new enabled and disabled instances\n+    Set<String> enabledInstances = new HashSet<>();\n+    List<String> newEnabledInstances = new ArrayList<>();\n+    for (ZNRecord instanceConfigZNRecord : instanceConfigZNRecords) {\n+      String instance = instanceConfigZNRecord.getId();\n+      if (isInstanceEnabled(instanceConfigZNRecord)) {\n+        enabledInstances.add(instance);\n+\n+        // Always refresh the server instance with the latest instance config in case it changes\n+        ServerInstance serverInstance = new ServerInstance(new InstanceConfig(instanceConfigZNRecord));\n+        if (_enabledServerInstanceMap.put(instance, serverInstance) == null) {\n+          newEnabledInstances.add(instance);\n+        }\n+      }\n+    }\n+    List<String> newDisabledInstances = new ArrayList<>();\n+    for (String instance : _enabledServerInstanceMap.keySet()) {\n+      if (!enabledInstances.contains(instance)) {\n+        newDisabledInstances.add(instance);\n+      }\n+    }\n+    List<String> changedInstances = new ArrayList<>(newEnabledInstances.size() + newDisabledInstances.size());\n+    changedInstances.addAll(newEnabledInstances);\n+    changedInstances.addAll(newDisabledInstances);\n+    long calculateChangedInstancesEndTimeMs = System.currentTimeMillis();\n+\n+    // Update routing entry for all tables\n+    for (RoutingEntry routingEntry : _routingEntryMap.values()) {\n+      try {\n+        routingEntry.onInstancesChange(enabledInstances, changedInstances);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Caught unexpected exception while updating routing entry on instances change for table: {}\",\n+            routingEntry.getTableNameWithType(), e);\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    // Remove new disabled instances from _enabledServerInstanceMap after updating all routing entries to ensure it\n+    // always contains the selected instances\n+    _enabledServerInstanceMap.keySet().removeAll(newDisabledInstances);\n+\n+    LOGGER.info(\n+        \"Processed instance config change in {}ms (fetch {} instance configs: {}ms, calculate changed instances: {}ms, update {} routing entries: {}ms), new enabled instances: {}, new disabled instances: {}\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, instanceConfigZNRecords.size(),\n+        fetchInstanceConfigsEndTimeMs - startTimeMs, calculateChangedInstancesEndTimeMs - fetchInstanceConfigsEndTimeMs,\n+        _routingEntryMap.size(), updateRoutingEntriesEndTimeMs - calculateChangedInstancesEndTimeMs,\n+        newEnabledInstances, newDisabledInstances);\n+  }\n+\n+  private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {\n+    if (\"false\"\n+        .equals(instanceConfigZNRecord.getSimpleField(InstanceConfig.InstanceConfigProperty.HELIX_ENABLED.name()))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.IS_SHUTDOWN_IN_PROGRESS))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.QUERIES_DISABLED))) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Builds/rebuilds the routing for the given table.\n+   */\n+  public synchronized void buildRouting(String tableNameWithType) {\n+    LOGGER.info(\"Building routing for table: {}\", tableNameWithType);\n+\n+    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, tableNameWithType);\n+    Preconditions.checkState(tableConfig != null, \"Failed to find table config for table: {}\", tableNameWithType);\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Failed to find external view for table: {}\", tableNameWithType);\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    Preconditions.checkState(onlineSegments != null, \"Failed to find ideal state for table: {}\", tableNameWithType);\n+    Set<String> enabledInstances = _enabledServerInstanceMap.keySet();\n+\n+    SegmentSelector segmentSelector = SegmentSelectorFactory.getSegmentSelector(tableConfig);\n+    segmentSelector.init(externalView, onlineSegments);\n+    SegmentPruner segmentPruner = SegmentPrunerFactory.getSegmentPruner(tableConfig, _propertyStore);\n+    segmentPruner.init(externalView, onlineSegments);\n+    InstanceSelector instanceSelector = InstanceSelectorFactory.getInstanceSelector(tableConfig, _brokerMetrics);\n+    instanceSelector.init(enabledInstances, externalView, onlineSegments);\n+    int externalViewVersion = externalView.getRecord().getVersion();\n+\n+    // Add time boundary manager if both offline and real-time part exist for a hybrid table\n+    TimeBoundaryManager timeBoundaryManager = null;\n+    String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n+      // Current table is offline\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+      if (_routingEntryMap.containsKey(realtimeTableName)) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", tableNameWithType);\n+        timeBoundaryManager = new TimeBoundaryManager(tableConfig, _propertyStore);\n+        timeBoundaryManager.init(externalView, onlineSegments);\n+      }\n+    } else {\n+      // Current table is real-time\n+      String offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(rawTableName);\n+      RoutingEntry offlineTableRoutingEntry = _routingEntryMap.get(offlineTableName);\n+      if (offlineTableRoutingEntry != null && offlineTableRoutingEntry.getTimeBoundaryManager() == null) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", offlineTableName);\n+\n+        // NOTE: Add time boundary manager to the offline part before adding the routing for the real-time part to\n+        // ensure no overlapping data getting queried\n+        TableConfig offlineTableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, offlineTableName);\n+        Preconditions\n+            .checkState(offlineTableConfig != null, \"Failed to find table config for table: {}\", offlineTableName);\n+        ExternalView offlineTableExternalView = getExternalView(offlineTableName);\n+        Preconditions.checkState(offlineTableExternalView != null, \"Failed to find external view for table: {}\",\n+            offlineTableName);\n+        Set<String> offlineTableOnlineSegments = getOnlineSegments(offlineTableName);\n+        Preconditions.checkState(offlineTableOnlineSegments != null, \"Failed to find ideal state for table: {}\",\n+            offlineTableName);\n+        TimeBoundaryManager offlineTableTimeBoundaryManager =\n+            new TimeBoundaryManager(offlineTableConfig, _propertyStore);\n+        offlineTableTimeBoundaryManager.init(offlineTableExternalView, offlineTableOnlineSegments);\n+        offlineTableRoutingEntry.setTimeBoundaryManager(offlineTableTimeBoundaryManager);\n+      }\n+    }\n+\n+    RoutingEntry routingEntry =\n+        new RoutingEntry(tableNameWithType, segmentSelector, segmentPruner, instanceSelector, externalViewVersion,\n+            timeBoundaryManager);\n+    if (_routingEntryMap.put(tableNameWithType, routingEntry) == null) {\n+      LOGGER.info(\"Built routing for table: {}\", tableNameWithType);\n+    } else {\n+      LOGGER.info(\"Rebuilt routing for table: {}\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Removes the routing for the given table.\n+   */\n+  public synchronized void removeRouting(String tableNameWithType) {\n+    LOGGER.info(\"Removing routing for table: {}\", tableNameWithType);\n+    if (_routingEntryMap.remove(tableNameWithType) != null) {\n+      LOGGER.info(\"Removed routing for table: {}\", tableNameWithType);\n+\n+      // Remove time boundary manager for the offline part routing if the removed routing is the real-time part of a\n+      // hybrid table\n+      if (TableNameBuilder.isRealtimeTableResource(tableNameWithType)) {\n+        String offlineTableName =\n+            TableNameBuilder.OFFLINE.tableNameWithType(TableNameBuilder.extractRawTableName(tableNameWithType));\n+        RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+        if (routingEntry != null) {\n+          routingEntry.setTimeBoundaryManager(null);\n+          LOGGER.info(\"Removed time boundary manager for table: {}\", offlineTableName);\n+        }\n+      }\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping removing routing\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the metadata for the given segment (called when segment is getting refreshed).\n+   */\n+  public synchronized void refreshSegment(String tableNameWithType, String segment) {\n+    LOGGER.info(\"Refreshing segment: {} for table: {}\", segment, tableNameWithType);\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    if (routingEntry != null) {\n+      routingEntry.refreshSegment(segment);\n+      LOGGER.info(\"Refreshed segment: {} for table: {}\", segment, tableNameWithType);\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping refreshing segment\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if the routing exists for the given table.\n+   */\n+  public boolean routingExists(String tableNameWithType) {\n+    return _routingEntryMap.containsKey(tableNameWithType);\n+  }\n+\n+  /**\n+   * Returns the routing table (map from server instance to list of segments hosted by the server) based on the broker\n+   * request.\n+   * <p>NOTE: The broker request should already have the table suffix (_OFFLINE or _REALTIME) appended.\n+   */\n+  public Map<ServerInstance, List<String>> getRoutingTable(BrokerRequest brokerRequest) {\n+    String tableNameWithType = brokerRequest.getQuerySource().getTableName();\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", tableNameWithType);\n+\n+    Map<String, String> segmentToInstanceMap = routingEntry.calculateSegmentToInstanceMap(brokerRequest);\n+    Map<ServerInstance, List<String>> routingTable = new HashMap<>();\n+    for (Map.Entry<String, String> entry : segmentToInstanceMap.entrySet()) {\n+      ServerInstance serverInstance = _enabledServerInstanceMap.get(entry.getValue());\n+      if (serverInstance != null) {\n+        routingTable.computeIfAbsent(serverInstance, k -> new ArrayList<>()).add(entry.getKey());\n+      } else {\n+        // Should not happen in normal case unless encountered unexpected exception when updating routing entries\n+        _brokerMetrics.addMeteredTableValue(tableNameWithType, BrokerMeter.SERVER_MISSING_FOR_ROUTING, 1L);\n+      }\n+    }\n+    return routingTable;\n+  }\n+\n+  /**\n+   * Returns the time boundary info for the given offline table name.\n+   * <p>NOTE: Time boundary info is only available for the offline part of the hybrid table.\n+   */\n+  @Nullable\n+  public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n+    RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", offlineTableName);\n+    TimeBoundaryManager timeBoundaryManager = routingEntry.getTimeBoundaryManager();\n+    return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n+  }\n+\n+  private static class RoutingEntry {\n+    final String _tableNameWithType;\n+    final SegmentSelector _segmentSelector;\n+    final SegmentPruner _segmentPruner;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5MDcyNA=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 418}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzYyMTI1OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODoyODo0NVrOFmSpUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDowMDoxMVrOFmuVqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5NTY5Nw==", "bodyText": "does this mean that all the v2 broker routing approaches compute the final mapping on the fly (no pre-computed routing tables)?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375695697", "createdAt": "2020-02-06T08:28:45Z", "author": {"login": "snleee"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "diffHunk": "@@ -25,25 +25,48 @@\n \n \n public class RoutingConfig extends BaseJsonConfig {\n+  public static final String PARTITION_AWARE_SEGMENT_PRUNER_TYPE = \"partitionAware\";\n+  public static final String REPLICA_GROUP_INSTANCE_SELECTOR_TYPE = \"replicaGroup\";\n+\n+  @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTQxNw==", "bodyText": "Yes.\nRemoved the deprecated key now, and will deprecate it once the new implementation getting plugged in.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376149417", "createdAt": "2020-02-07T00:00:11Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "diffHunk": "@@ -25,25 +25,48 @@\n \n \n public class RoutingConfig extends BaseJsonConfig {\n+  public static final String PARTITION_AWARE_SEGMENT_PRUNER_TYPE = \"partitionAware\";\n+  public static final String REPLICA_GROUP_INSTANCE_SELECTOR_TYPE = \"replicaGroup\";\n+\n+  @Deprecated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5NTY5Nw=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzYyOTM1OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODozMTozNlrOFmSuEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDowNzozMFrOFnNrlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5NjkxNQ==", "bodyText": "IMO partition segment pruner seems to be better name? up to you.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375696915", "createdAt": "2020-02-06T08:31:36Z", "author": {"login": "snleee"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "diffHunk": "@@ -25,25 +25,48 @@\n \n \n public class RoutingConfig extends BaseJsonConfig {\n+  public static final String PARTITION_AWARE_SEGMENT_PRUNER_TYPE = \"partitionAware\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MjkzMw==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376662933", "createdAt": "2020-02-08T00:07:30Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "diffHunk": "@@ -25,25 +25,48 @@\n \n \n public class RoutingConfig extends BaseJsonConfig {\n+  public static final String PARTITION_AWARE_SEGMENT_PRUNER_TYPE = \"partitionAware\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5NjkxNQ=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzYzNjk1OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODozNDoyNVrOFmSyig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDowNzo1MlrOFnNr0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5ODA1OA==", "bodyText": "Let's add @Deprecated with the PR that will hook this up with the real routing. Technically, we still depend on routingTableBuilderName.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375698058", "createdAt": "2020-02-06T08:34:25Z", "author": {"login": "snleee"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "diffHunk": "@@ -25,25 +25,48 @@\n \n \n public class RoutingConfig extends BaseJsonConfig {\n+  public static final String PARTITION_AWARE_SEGMENT_PRUNER_TYPE = \"partitionAware\";\n+  public static final String REPLICA_GROUP_INSTANCE_SELECTOR_TYPE = \"replicaGroup\";\n+\n+  @Deprecated\n   public static final String ENABLE_DYNAMIC_COMPUTING_KEY = \"enableDynamicComputing\";\n \n   private final String _routingTableBuilderName;\n   private final Map<String, String> _routingTableBuilderOptions;\n \n+  private final String _segmentPrunerType;\n+  private final String _instanceSelectorType;\n+\n   @JsonCreator\n   public RoutingConfig(@JsonProperty(\"routingTableBuilderName\") @Nullable String routingTableBuilderName,\n-      @JsonProperty(\"routingTableBuilderOptions\") @Nullable Map<String, String> routingTableBuilderOptions) {\n+      @JsonProperty(\"routingTableBuilderOptions\") @Nullable Map<String, String> routingTableBuilderOptions,\n+      @JsonProperty(\"segmentPrunerType\") @Nullable String segmentPrunerType,\n+      @JsonProperty(\"instanceSelectorType\") @Nullable String instanceSelectorType) {\n     _routingTableBuilderName = routingTableBuilderName;\n     _routingTableBuilderOptions = routingTableBuilderOptions;\n+    _segmentPrunerType = segmentPrunerType;\n+    _instanceSelectorType = instanceSelectorType;\n   }\n \n+  @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2Mjk5Mw==", "bodyText": "Good point", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376662993", "createdAt": "2020-02-08T00:07:52Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/config/RoutingConfig.java", "diffHunk": "@@ -25,25 +25,48 @@\n \n \n public class RoutingConfig extends BaseJsonConfig {\n+  public static final String PARTITION_AWARE_SEGMENT_PRUNER_TYPE = \"partitionAware\";\n+  public static final String REPLICA_GROUP_INSTANCE_SELECTOR_TYPE = \"replicaGroup\";\n+\n+  @Deprecated\n   public static final String ENABLE_DYNAMIC_COMPUTING_KEY = \"enableDynamicComputing\";\n \n   private final String _routingTableBuilderName;\n   private final Map<String, String> _routingTableBuilderOptions;\n \n+  private final String _segmentPrunerType;\n+  private final String _instanceSelectorType;\n+\n   @JsonCreator\n   public RoutingConfig(@JsonProperty(\"routingTableBuilderName\") @Nullable String routingTableBuilderName,\n-      @JsonProperty(\"routingTableBuilderOptions\") @Nullable Map<String, String> routingTableBuilderOptions) {\n+      @JsonProperty(\"routingTableBuilderOptions\") @Nullable Map<String, String> routingTableBuilderOptions,\n+      @JsonProperty(\"segmentPrunerType\") @Nullable String segmentPrunerType,\n+      @JsonProperty(\"instanceSelectorType\") @Nullable String instanceSelectorType) {\n     _routingTableBuilderName = routingTableBuilderName;\n     _routingTableBuilderOptions = routingTableBuilderOptions;\n+    _segmentPrunerType = segmentPrunerType;\n+    _instanceSelectorType = instanceSelectorType;\n   }\n \n+  @Deprecated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5ODA1OA=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzY0MDgxOnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/timeboundary/TimeBoundaryManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODozNjowMlrOFmS0xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDowNzowNFrOFnNrSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5ODYyOA==", "bodyText": "Does this introduce any different behavior compared to the existing time boundary manager?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375698628", "createdAt": "2020-02-06T08:36:02Z", "author": {"login": "snleee"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/timeboundary/TimeBoundaryManager.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.timeboundary;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.TableType;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code TimeBoundaryManager} class manages the time boundary information for a table.\n+ * <p>TODO: Support SDF (simple date format) time column\n+ */\n+public class TimeBoundaryManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2Mjg1OQ==", "bodyText": "No, they are the same functioning wise. We make it table level so that we can rebuild it if necessary.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376662859", "createdAt": "2020-02-08T00:07:04Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/timeboundary/TimeBoundaryManager.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.timeboundary;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.TableType;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code TimeBoundaryManager} class manages the time boundary information for a table.\n+ * <p>TODO: Support SDF (simple date format) time column\n+ */\n+public class TimeBoundaryManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5ODYyOA=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzY4NzUwOnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODo1MzoyMVrOFmTR2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxODo0ODo0OVrOFmmPAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcwNjA3NQ==", "bodyText": "What if calculateSegmentToInstanceMap() got hit while we are processing onExternalViewChange() in the middle? (e.g. segment selector/pruner got updated while instance selector not updated. So, in the instance selection phase, some new segments came as part of prunedSegments but they don't exist in cached information in the instance selector -- probably the answer is simply not to route to new segments...).  - I'm pretty sure you already thought all of about this :)", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375706075", "createdAt": "2020-02-06T08:53:21Z", "author": {"login": "snleee"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RoutingManager.class);\n+\n+  private final BrokerMetrics _brokerMetrics;\n+  private final Map<String, RoutingEntry> _routingEntryMap = new ConcurrentHashMap<>();\n+  private final Map<String, ServerInstance> _enabledServerInstanceMap = new ConcurrentHashMap<>();\n+\n+  private BaseDataAccessor<ZNRecord> _zkDataAccessor;\n+  private String _externalViewPathPrefix;\n+  private String _idealStatePathPrefix;\n+  private String _instanceConfigsPath;\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+\n+  public RoutingManager(BrokerMetrics brokerMetrics) {\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(HelixManager helixManager) {\n+    HelixDataAccessor helixDataAccessor = helixManager.getHelixDataAccessor();\n+    _zkDataAccessor = helixDataAccessor.getBaseDataAccessor();\n+    _externalViewPathPrefix = helixDataAccessor.keyBuilder().externalViews().getPath() + \"/\";\n+    _idealStatePathPrefix = helixDataAccessor.keyBuilder().idealStates().getPath() + \"/\";\n+    _instanceConfigsPath = helixDataAccessor.keyBuilder().instanceConfigs().getPath();\n+    _propertyStore = helixManager.getHelixPropertyStore();\n+  }\n+\n+  @Override\n+  public synchronized void processClusterChange(HelixConstants.ChangeType changeType) {\n+    Preconditions.checkState(changeType == HelixConstants.ChangeType.EXTERNAL_VIEW\n+        || changeType == HelixConstants.ChangeType.INSTANCE_CONFIG, \"Illegal change type: \" + changeType);\n+    if (changeType == HelixConstants.ChangeType.EXTERNAL_VIEW) {\n+      processExternalViewChange();\n+    } else {\n+      processInstanceConfigChange();\n+    }\n+  }\n+\n+  private void processExternalViewChange() {\n+    LOGGER.info(\"Processing external view change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    int numTables = _routingEntryMap.size();\n+    if (numTables == 0) {\n+      LOGGER.info(\"No table exists in the routing, skipping processing external view change\");\n+      return;\n+    }\n+\n+    List<RoutingEntry> routingEntries = new ArrayList<>(numTables);\n+    List<String> externalViewPaths = new ArrayList<>(numTables);\n+    for (Map.Entry<String, RoutingEntry> entry : _routingEntryMap.entrySet()) {\n+      String tableNameWithType = entry.getKey();\n+      routingEntries.add(entry.getValue());\n+      externalViewPaths.add(_externalViewPathPrefix + tableNameWithType);\n+    }\n+    Stat[] stats = _zkDataAccessor.getStats(externalViewPaths, AccessOption.PERSISTENT);\n+    long fetchStatsEndTimeMs = System.currentTimeMillis();\n+\n+    int numRoutingEntriesToUpdate = 0;\n+    for (int i = 0; i < numTables; i++) {\n+      Stat stat = stats[i];\n+      if (stat != null) {\n+        RoutingEntry routingEntry = routingEntries.get(i);\n+        if (stat.getVersion() != routingEntry.getLastUpdateExternalViewVersion()) {\n+          numRoutingEntriesToUpdate++;\n+          try {\n+            updateRoutingEntryOnExternalViewChange(routingEntry);\n+          } catch (Exception e) {\n+            LOGGER\n+                .error(\"Caught unexpected exception while updating routing entry on external view change for table: {}\",\n+                    routingEntry.getTableNameWithType(), e);\n+          }\n+        }\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    LOGGER.info(\n+        \"Processed external view change in {}ms (fetch {} external view stats: {}ms, update {} routing entries: {}ms)\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, numTables, fetchStatsEndTimeMs - startTimeMs,\n+        numRoutingEntriesToUpdate, updateRoutingEntriesEndTimeMs - fetchStatsEndTimeMs);\n+  }\n+\n+  private void updateRoutingEntryOnExternalViewChange(RoutingEntry routingEntry) {\n+    String tableNameWithType = routingEntry.getTableNameWithType();\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    if (externalView == null) {\n+      LOGGER.warn(\"Failed to find external view for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    if (onlineSegments == null) {\n+      LOGGER.warn(\"Failed to find ideal state for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    routingEntry.onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Nullable\n+  private ExternalView getExternalView(String tableNameWithType) {\n+    Stat stat = new Stat();\n+    ZNRecord znRecord = _zkDataAccessor.get(_externalViewPathPrefix + tableNameWithType, stat, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      znRecord.setVersion(stat.getVersion());\n+      return new ExternalView(znRecord);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  private Set<String> getOnlineSegments(String tableNameWithType) {\n+    ZNRecord znRecord = _zkDataAccessor.get(_idealStatePathPrefix + tableNameWithType, null, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      Map<String, Map<String, String>> segmentAssignment = znRecord.getMapFields();\n+      Set<String> onlineSegments = new HashSet<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+      for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+        Map<String, String> instanceStateMap = entry.getValue();\n+        if (instanceStateMap.containsValue(RealtimeSegmentOnlineOfflineStateModel.ONLINE) || instanceStateMap\n+            .containsValue(RealtimeSegmentOnlineOfflineStateModel.CONSUMING)) {\n+          onlineSegments.add(entry.getKey());\n+        }\n+      }\n+      return onlineSegments;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private void processInstanceConfigChange() {\n+    LOGGER.info(\"Processing instance config change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    List<ZNRecord> instanceConfigZNRecords =\n+        _zkDataAccessor.getChildren(_instanceConfigsPath, null, AccessOption.PERSISTENT);\n+    long fetchInstanceConfigsEndTimeMs = System.currentTimeMillis();\n+\n+    // Calculate new enabled and disabled instances\n+    Set<String> enabledInstances = new HashSet<>();\n+    List<String> newEnabledInstances = new ArrayList<>();\n+    for (ZNRecord instanceConfigZNRecord : instanceConfigZNRecords) {\n+      String instance = instanceConfigZNRecord.getId();\n+      if (isInstanceEnabled(instanceConfigZNRecord)) {\n+        enabledInstances.add(instance);\n+\n+        // Always refresh the server instance with the latest instance config in case it changes\n+        ServerInstance serverInstance = new ServerInstance(new InstanceConfig(instanceConfigZNRecord));\n+        if (_enabledServerInstanceMap.put(instance, serverInstance) == null) {\n+          newEnabledInstances.add(instance);\n+        }\n+      }\n+    }\n+    List<String> newDisabledInstances = new ArrayList<>();\n+    for (String instance : _enabledServerInstanceMap.keySet()) {\n+      if (!enabledInstances.contains(instance)) {\n+        newDisabledInstances.add(instance);\n+      }\n+    }\n+    List<String> changedInstances = new ArrayList<>(newEnabledInstances.size() + newDisabledInstances.size());\n+    changedInstances.addAll(newEnabledInstances);\n+    changedInstances.addAll(newDisabledInstances);\n+    long calculateChangedInstancesEndTimeMs = System.currentTimeMillis();\n+\n+    // Update routing entry for all tables\n+    for (RoutingEntry routingEntry : _routingEntryMap.values()) {\n+      try {\n+        routingEntry.onInstancesChange(enabledInstances, changedInstances);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Caught unexpected exception while updating routing entry on instances change for table: {}\",\n+            routingEntry.getTableNameWithType(), e);\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    // Remove new disabled instances from _enabledServerInstanceMap after updating all routing entries to ensure it\n+    // always contains the selected instances\n+    _enabledServerInstanceMap.keySet().removeAll(newDisabledInstances);\n+\n+    LOGGER.info(\n+        \"Processed instance config change in {}ms (fetch {} instance configs: {}ms, calculate changed instances: {}ms, update {} routing entries: {}ms), new enabled instances: {}, new disabled instances: {}\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, instanceConfigZNRecords.size(),\n+        fetchInstanceConfigsEndTimeMs - startTimeMs, calculateChangedInstancesEndTimeMs - fetchInstanceConfigsEndTimeMs,\n+        _routingEntryMap.size(), updateRoutingEntriesEndTimeMs - calculateChangedInstancesEndTimeMs,\n+        newEnabledInstances, newDisabledInstances);\n+  }\n+\n+  private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {\n+    if (\"false\"\n+        .equals(instanceConfigZNRecord.getSimpleField(InstanceConfig.InstanceConfigProperty.HELIX_ENABLED.name()))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.IS_SHUTDOWN_IN_PROGRESS))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.QUERIES_DISABLED))) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Builds/rebuilds the routing for the given table.\n+   */\n+  public synchronized void buildRouting(String tableNameWithType) {\n+    LOGGER.info(\"Building routing for table: {}\", tableNameWithType);\n+\n+    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, tableNameWithType);\n+    Preconditions.checkState(tableConfig != null, \"Failed to find table config for table: {}\", tableNameWithType);\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Failed to find external view for table: {}\", tableNameWithType);\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    Preconditions.checkState(onlineSegments != null, \"Failed to find ideal state for table: {}\", tableNameWithType);\n+    Set<String> enabledInstances = _enabledServerInstanceMap.keySet();\n+\n+    SegmentSelector segmentSelector = SegmentSelectorFactory.getSegmentSelector(tableConfig);\n+    segmentSelector.init(externalView, onlineSegments);\n+    SegmentPruner segmentPruner = SegmentPrunerFactory.getSegmentPruner(tableConfig, _propertyStore);\n+    segmentPruner.init(externalView, onlineSegments);\n+    InstanceSelector instanceSelector = InstanceSelectorFactory.getInstanceSelector(tableConfig, _brokerMetrics);\n+    instanceSelector.init(enabledInstances, externalView, onlineSegments);\n+    int externalViewVersion = externalView.getRecord().getVersion();\n+\n+    // Add time boundary manager if both offline and real-time part exist for a hybrid table\n+    TimeBoundaryManager timeBoundaryManager = null;\n+    String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n+      // Current table is offline\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+      if (_routingEntryMap.containsKey(realtimeTableName)) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", tableNameWithType);\n+        timeBoundaryManager = new TimeBoundaryManager(tableConfig, _propertyStore);\n+        timeBoundaryManager.init(externalView, onlineSegments);\n+      }\n+    } else {\n+      // Current table is real-time\n+      String offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(rawTableName);\n+      RoutingEntry offlineTableRoutingEntry = _routingEntryMap.get(offlineTableName);\n+      if (offlineTableRoutingEntry != null && offlineTableRoutingEntry.getTimeBoundaryManager() == null) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", offlineTableName);\n+\n+        // NOTE: Add time boundary manager to the offline part before adding the routing for the real-time part to\n+        // ensure no overlapping data getting queried\n+        TableConfig offlineTableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, offlineTableName);\n+        Preconditions\n+            .checkState(offlineTableConfig != null, \"Failed to find table config for table: {}\", offlineTableName);\n+        ExternalView offlineTableExternalView = getExternalView(offlineTableName);\n+        Preconditions.checkState(offlineTableExternalView != null, \"Failed to find external view for table: {}\",\n+            offlineTableName);\n+        Set<String> offlineTableOnlineSegments = getOnlineSegments(offlineTableName);\n+        Preconditions.checkState(offlineTableOnlineSegments != null, \"Failed to find ideal state for table: {}\",\n+            offlineTableName);\n+        TimeBoundaryManager offlineTableTimeBoundaryManager =\n+            new TimeBoundaryManager(offlineTableConfig, _propertyStore);\n+        offlineTableTimeBoundaryManager.init(offlineTableExternalView, offlineTableOnlineSegments);\n+        offlineTableRoutingEntry.setTimeBoundaryManager(offlineTableTimeBoundaryManager);\n+      }\n+    }\n+\n+    RoutingEntry routingEntry =\n+        new RoutingEntry(tableNameWithType, segmentSelector, segmentPruner, instanceSelector, externalViewVersion,\n+            timeBoundaryManager);\n+    if (_routingEntryMap.put(tableNameWithType, routingEntry) == null) {\n+      LOGGER.info(\"Built routing for table: {}\", tableNameWithType);\n+    } else {\n+      LOGGER.info(\"Rebuilt routing for table: {}\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Removes the routing for the given table.\n+   */\n+  public synchronized void removeRouting(String tableNameWithType) {\n+    LOGGER.info(\"Removing routing for table: {}\", tableNameWithType);\n+    if (_routingEntryMap.remove(tableNameWithType) != null) {\n+      LOGGER.info(\"Removed routing for table: {}\", tableNameWithType);\n+\n+      // Remove time boundary manager for the offline part routing if the removed routing is the real-time part of a\n+      // hybrid table\n+      if (TableNameBuilder.isRealtimeTableResource(tableNameWithType)) {\n+        String offlineTableName =\n+            TableNameBuilder.OFFLINE.tableNameWithType(TableNameBuilder.extractRawTableName(tableNameWithType));\n+        RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+        if (routingEntry != null) {\n+          routingEntry.setTimeBoundaryManager(null);\n+          LOGGER.info(\"Removed time boundary manager for table: {}\", offlineTableName);\n+        }\n+      }\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping removing routing\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the metadata for the given segment (called when segment is getting refreshed).\n+   */\n+  public synchronized void refreshSegment(String tableNameWithType, String segment) {\n+    LOGGER.info(\"Refreshing segment: {} for table: {}\", segment, tableNameWithType);\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    if (routingEntry != null) {\n+      routingEntry.refreshSegment(segment);\n+      LOGGER.info(\"Refreshed segment: {} for table: {}\", segment, tableNameWithType);\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping refreshing segment\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if the routing exists for the given table.\n+   */\n+  public boolean routingExists(String tableNameWithType) {\n+    return _routingEntryMap.containsKey(tableNameWithType);\n+  }\n+\n+  /**\n+   * Returns the routing table (map from server instance to list of segments hosted by the server) based on the broker\n+   * request.\n+   * <p>NOTE: The broker request should already have the table suffix (_OFFLINE or _REALTIME) appended.\n+   */\n+  public Map<ServerInstance, List<String>> getRoutingTable(BrokerRequest brokerRequest) {\n+    String tableNameWithType = brokerRequest.getQuerySource().getTableName();\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", tableNameWithType);\n+\n+    Map<String, String> segmentToInstanceMap = routingEntry.calculateSegmentToInstanceMap(brokerRequest);\n+    Map<ServerInstance, List<String>> routingTable = new HashMap<>();\n+    for (Map.Entry<String, String> entry : segmentToInstanceMap.entrySet()) {\n+      ServerInstance serverInstance = _enabledServerInstanceMap.get(entry.getValue());\n+      if (serverInstance != null) {\n+        routingTable.computeIfAbsent(serverInstance, k -> new ArrayList<>()).add(entry.getKey());\n+      } else {\n+        // Should not happen in normal case unless encountered unexpected exception when updating routing entries\n+        _brokerMetrics.addMeteredTableValue(tableNameWithType, BrokerMeter.SERVER_MISSING_FOR_ROUTING, 1L);\n+      }\n+    }\n+    return routingTable;\n+  }\n+\n+  /**\n+   * Returns the time boundary info for the given offline table name.\n+   * <p>NOTE: Time boundary info is only available for the offline part of the hybrid table.\n+   */\n+  @Nullable\n+  public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n+    RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", offlineTableName);\n+    TimeBoundaryManager timeBoundaryManager = routingEntry.getTimeBoundaryManager();\n+    return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n+  }\n+\n+  private static class RoutingEntry {\n+    final String _tableNameWithType;\n+    final SegmentSelector _segmentSelector;\n+    final SegmentPruner _segmentPruner;\n+    final InstanceSelector _instanceSelector;\n+\n+    // Cache the ExternalView version for the last update\n+    transient int _lastUpdateExternalViewVersion;\n+    // Time boundary manager is only available for the offline part of the hybrid table\n+    transient TimeBoundaryManager _timeBoundaryManager;\n+\n+    RoutingEntry(String tableNameWithType, SegmentSelector segmentSelector, SegmentPruner segmentPruner,\n+        InstanceSelector instanceSelector, int lastUpdateExternalViewVersion,\n+        @Nullable TimeBoundaryManager timeBoundaryManager) {\n+      _tableNameWithType = tableNameWithType;\n+      _segmentSelector = segmentSelector;\n+      _segmentPruner = segmentPruner;\n+      _instanceSelector = instanceSelector;\n+      _lastUpdateExternalViewVersion = lastUpdateExternalViewVersion;\n+      _timeBoundaryManager = timeBoundaryManager;\n+    }\n+\n+    String getTableNameWithType() {\n+      return _tableNameWithType;\n+    }\n+\n+    int getLastUpdateExternalViewVersion() {\n+      return _lastUpdateExternalViewVersion;\n+    }\n+\n+    void setTimeBoundaryManager(@Nullable TimeBoundaryManager timeBoundaryManager) {\n+      _timeBoundaryManager = timeBoundaryManager;\n+    }\n+\n+    @Nullable\n+    TimeBoundaryManager getTimeBoundaryManager() {\n+      return _timeBoundaryManager;\n+    }\n+\n+    void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 454}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAxNjY0Mg==", "bodyText": "Yes, we won't route to the new segments before the whole routing entry gets updated. Will add some comments here", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376016642", "createdAt": "2020-02-06T18:48:49Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RoutingManager.class);\n+\n+  private final BrokerMetrics _brokerMetrics;\n+  private final Map<String, RoutingEntry> _routingEntryMap = new ConcurrentHashMap<>();\n+  private final Map<String, ServerInstance> _enabledServerInstanceMap = new ConcurrentHashMap<>();\n+\n+  private BaseDataAccessor<ZNRecord> _zkDataAccessor;\n+  private String _externalViewPathPrefix;\n+  private String _idealStatePathPrefix;\n+  private String _instanceConfigsPath;\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+\n+  public RoutingManager(BrokerMetrics brokerMetrics) {\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(HelixManager helixManager) {\n+    HelixDataAccessor helixDataAccessor = helixManager.getHelixDataAccessor();\n+    _zkDataAccessor = helixDataAccessor.getBaseDataAccessor();\n+    _externalViewPathPrefix = helixDataAccessor.keyBuilder().externalViews().getPath() + \"/\";\n+    _idealStatePathPrefix = helixDataAccessor.keyBuilder().idealStates().getPath() + \"/\";\n+    _instanceConfigsPath = helixDataAccessor.keyBuilder().instanceConfigs().getPath();\n+    _propertyStore = helixManager.getHelixPropertyStore();\n+  }\n+\n+  @Override\n+  public synchronized void processClusterChange(HelixConstants.ChangeType changeType) {\n+    Preconditions.checkState(changeType == HelixConstants.ChangeType.EXTERNAL_VIEW\n+        || changeType == HelixConstants.ChangeType.INSTANCE_CONFIG, \"Illegal change type: \" + changeType);\n+    if (changeType == HelixConstants.ChangeType.EXTERNAL_VIEW) {\n+      processExternalViewChange();\n+    } else {\n+      processInstanceConfigChange();\n+    }\n+  }\n+\n+  private void processExternalViewChange() {\n+    LOGGER.info(\"Processing external view change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    int numTables = _routingEntryMap.size();\n+    if (numTables == 0) {\n+      LOGGER.info(\"No table exists in the routing, skipping processing external view change\");\n+      return;\n+    }\n+\n+    List<RoutingEntry> routingEntries = new ArrayList<>(numTables);\n+    List<String> externalViewPaths = new ArrayList<>(numTables);\n+    for (Map.Entry<String, RoutingEntry> entry : _routingEntryMap.entrySet()) {\n+      String tableNameWithType = entry.getKey();\n+      routingEntries.add(entry.getValue());\n+      externalViewPaths.add(_externalViewPathPrefix + tableNameWithType);\n+    }\n+    Stat[] stats = _zkDataAccessor.getStats(externalViewPaths, AccessOption.PERSISTENT);\n+    long fetchStatsEndTimeMs = System.currentTimeMillis();\n+\n+    int numRoutingEntriesToUpdate = 0;\n+    for (int i = 0; i < numTables; i++) {\n+      Stat stat = stats[i];\n+      if (stat != null) {\n+        RoutingEntry routingEntry = routingEntries.get(i);\n+        if (stat.getVersion() != routingEntry.getLastUpdateExternalViewVersion()) {\n+          numRoutingEntriesToUpdate++;\n+          try {\n+            updateRoutingEntryOnExternalViewChange(routingEntry);\n+          } catch (Exception e) {\n+            LOGGER\n+                .error(\"Caught unexpected exception while updating routing entry on external view change for table: {}\",\n+                    routingEntry.getTableNameWithType(), e);\n+          }\n+        }\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    LOGGER.info(\n+        \"Processed external view change in {}ms (fetch {} external view stats: {}ms, update {} routing entries: {}ms)\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, numTables, fetchStatsEndTimeMs - startTimeMs,\n+        numRoutingEntriesToUpdate, updateRoutingEntriesEndTimeMs - fetchStatsEndTimeMs);\n+  }\n+\n+  private void updateRoutingEntryOnExternalViewChange(RoutingEntry routingEntry) {\n+    String tableNameWithType = routingEntry.getTableNameWithType();\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    if (externalView == null) {\n+      LOGGER.warn(\"Failed to find external view for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    if (onlineSegments == null) {\n+      LOGGER.warn(\"Failed to find ideal state for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    routingEntry.onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Nullable\n+  private ExternalView getExternalView(String tableNameWithType) {\n+    Stat stat = new Stat();\n+    ZNRecord znRecord = _zkDataAccessor.get(_externalViewPathPrefix + tableNameWithType, stat, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      znRecord.setVersion(stat.getVersion());\n+      return new ExternalView(znRecord);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  private Set<String> getOnlineSegments(String tableNameWithType) {\n+    ZNRecord znRecord = _zkDataAccessor.get(_idealStatePathPrefix + tableNameWithType, null, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      Map<String, Map<String, String>> segmentAssignment = znRecord.getMapFields();\n+      Set<String> onlineSegments = new HashSet<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+      for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+        Map<String, String> instanceStateMap = entry.getValue();\n+        if (instanceStateMap.containsValue(RealtimeSegmentOnlineOfflineStateModel.ONLINE) || instanceStateMap\n+            .containsValue(RealtimeSegmentOnlineOfflineStateModel.CONSUMING)) {\n+          onlineSegments.add(entry.getKey());\n+        }\n+      }\n+      return onlineSegments;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private void processInstanceConfigChange() {\n+    LOGGER.info(\"Processing instance config change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    List<ZNRecord> instanceConfigZNRecords =\n+        _zkDataAccessor.getChildren(_instanceConfigsPath, null, AccessOption.PERSISTENT);\n+    long fetchInstanceConfigsEndTimeMs = System.currentTimeMillis();\n+\n+    // Calculate new enabled and disabled instances\n+    Set<String> enabledInstances = new HashSet<>();\n+    List<String> newEnabledInstances = new ArrayList<>();\n+    for (ZNRecord instanceConfigZNRecord : instanceConfigZNRecords) {\n+      String instance = instanceConfigZNRecord.getId();\n+      if (isInstanceEnabled(instanceConfigZNRecord)) {\n+        enabledInstances.add(instance);\n+\n+        // Always refresh the server instance with the latest instance config in case it changes\n+        ServerInstance serverInstance = new ServerInstance(new InstanceConfig(instanceConfigZNRecord));\n+        if (_enabledServerInstanceMap.put(instance, serverInstance) == null) {\n+          newEnabledInstances.add(instance);\n+        }\n+      }\n+    }\n+    List<String> newDisabledInstances = new ArrayList<>();\n+    for (String instance : _enabledServerInstanceMap.keySet()) {\n+      if (!enabledInstances.contains(instance)) {\n+        newDisabledInstances.add(instance);\n+      }\n+    }\n+    List<String> changedInstances = new ArrayList<>(newEnabledInstances.size() + newDisabledInstances.size());\n+    changedInstances.addAll(newEnabledInstances);\n+    changedInstances.addAll(newDisabledInstances);\n+    long calculateChangedInstancesEndTimeMs = System.currentTimeMillis();\n+\n+    // Update routing entry for all tables\n+    for (RoutingEntry routingEntry : _routingEntryMap.values()) {\n+      try {\n+        routingEntry.onInstancesChange(enabledInstances, changedInstances);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Caught unexpected exception while updating routing entry on instances change for table: {}\",\n+            routingEntry.getTableNameWithType(), e);\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    // Remove new disabled instances from _enabledServerInstanceMap after updating all routing entries to ensure it\n+    // always contains the selected instances\n+    _enabledServerInstanceMap.keySet().removeAll(newDisabledInstances);\n+\n+    LOGGER.info(\n+        \"Processed instance config change in {}ms (fetch {} instance configs: {}ms, calculate changed instances: {}ms, update {} routing entries: {}ms), new enabled instances: {}, new disabled instances: {}\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, instanceConfigZNRecords.size(),\n+        fetchInstanceConfigsEndTimeMs - startTimeMs, calculateChangedInstancesEndTimeMs - fetchInstanceConfigsEndTimeMs,\n+        _routingEntryMap.size(), updateRoutingEntriesEndTimeMs - calculateChangedInstancesEndTimeMs,\n+        newEnabledInstances, newDisabledInstances);\n+  }\n+\n+  private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {\n+    if (\"false\"\n+        .equals(instanceConfigZNRecord.getSimpleField(InstanceConfig.InstanceConfigProperty.HELIX_ENABLED.name()))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.IS_SHUTDOWN_IN_PROGRESS))) {\n+      return false;\n+    }\n+    if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.QUERIES_DISABLED))) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Builds/rebuilds the routing for the given table.\n+   */\n+  public synchronized void buildRouting(String tableNameWithType) {\n+    LOGGER.info(\"Building routing for table: {}\", tableNameWithType);\n+\n+    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, tableNameWithType);\n+    Preconditions.checkState(tableConfig != null, \"Failed to find table config for table: {}\", tableNameWithType);\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Failed to find external view for table: {}\", tableNameWithType);\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    Preconditions.checkState(onlineSegments != null, \"Failed to find ideal state for table: {}\", tableNameWithType);\n+    Set<String> enabledInstances = _enabledServerInstanceMap.keySet();\n+\n+    SegmentSelector segmentSelector = SegmentSelectorFactory.getSegmentSelector(tableConfig);\n+    segmentSelector.init(externalView, onlineSegments);\n+    SegmentPruner segmentPruner = SegmentPrunerFactory.getSegmentPruner(tableConfig, _propertyStore);\n+    segmentPruner.init(externalView, onlineSegments);\n+    InstanceSelector instanceSelector = InstanceSelectorFactory.getInstanceSelector(tableConfig, _brokerMetrics);\n+    instanceSelector.init(enabledInstances, externalView, onlineSegments);\n+    int externalViewVersion = externalView.getRecord().getVersion();\n+\n+    // Add time boundary manager if both offline and real-time part exist for a hybrid table\n+    TimeBoundaryManager timeBoundaryManager = null;\n+    String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n+      // Current table is offline\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+      if (_routingEntryMap.containsKey(realtimeTableName)) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", tableNameWithType);\n+        timeBoundaryManager = new TimeBoundaryManager(tableConfig, _propertyStore);\n+        timeBoundaryManager.init(externalView, onlineSegments);\n+      }\n+    } else {\n+      // Current table is real-time\n+      String offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(rawTableName);\n+      RoutingEntry offlineTableRoutingEntry = _routingEntryMap.get(offlineTableName);\n+      if (offlineTableRoutingEntry != null && offlineTableRoutingEntry.getTimeBoundaryManager() == null) {\n+        LOGGER.info(\"Adding time boundary manager for table: {}\", offlineTableName);\n+\n+        // NOTE: Add time boundary manager to the offline part before adding the routing for the real-time part to\n+        // ensure no overlapping data getting queried\n+        TableConfig offlineTableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, offlineTableName);\n+        Preconditions\n+            .checkState(offlineTableConfig != null, \"Failed to find table config for table: {}\", offlineTableName);\n+        ExternalView offlineTableExternalView = getExternalView(offlineTableName);\n+        Preconditions.checkState(offlineTableExternalView != null, \"Failed to find external view for table: {}\",\n+            offlineTableName);\n+        Set<String> offlineTableOnlineSegments = getOnlineSegments(offlineTableName);\n+        Preconditions.checkState(offlineTableOnlineSegments != null, \"Failed to find ideal state for table: {}\",\n+            offlineTableName);\n+        TimeBoundaryManager offlineTableTimeBoundaryManager =\n+            new TimeBoundaryManager(offlineTableConfig, _propertyStore);\n+        offlineTableTimeBoundaryManager.init(offlineTableExternalView, offlineTableOnlineSegments);\n+        offlineTableRoutingEntry.setTimeBoundaryManager(offlineTableTimeBoundaryManager);\n+      }\n+    }\n+\n+    RoutingEntry routingEntry =\n+        new RoutingEntry(tableNameWithType, segmentSelector, segmentPruner, instanceSelector, externalViewVersion,\n+            timeBoundaryManager);\n+    if (_routingEntryMap.put(tableNameWithType, routingEntry) == null) {\n+      LOGGER.info(\"Built routing for table: {}\", tableNameWithType);\n+    } else {\n+      LOGGER.info(\"Rebuilt routing for table: {}\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Removes the routing for the given table.\n+   */\n+  public synchronized void removeRouting(String tableNameWithType) {\n+    LOGGER.info(\"Removing routing for table: {}\", tableNameWithType);\n+    if (_routingEntryMap.remove(tableNameWithType) != null) {\n+      LOGGER.info(\"Removed routing for table: {}\", tableNameWithType);\n+\n+      // Remove time boundary manager for the offline part routing if the removed routing is the real-time part of a\n+      // hybrid table\n+      if (TableNameBuilder.isRealtimeTableResource(tableNameWithType)) {\n+        String offlineTableName =\n+            TableNameBuilder.OFFLINE.tableNameWithType(TableNameBuilder.extractRawTableName(tableNameWithType));\n+        RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+        if (routingEntry != null) {\n+          routingEntry.setTimeBoundaryManager(null);\n+          LOGGER.info(\"Removed time boundary manager for table: {}\", offlineTableName);\n+        }\n+      }\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping removing routing\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the metadata for the given segment (called when segment is getting refreshed).\n+   */\n+  public synchronized void refreshSegment(String tableNameWithType, String segment) {\n+    LOGGER.info(\"Refreshing segment: {} for table: {}\", segment, tableNameWithType);\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    if (routingEntry != null) {\n+      routingEntry.refreshSegment(segment);\n+      LOGGER.info(\"Refreshed segment: {} for table: {}\", segment, tableNameWithType);\n+    } else {\n+      LOGGER.warn(\"Routing does not exist for table: {}, skipping refreshing segment\", tableNameWithType);\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if the routing exists for the given table.\n+   */\n+  public boolean routingExists(String tableNameWithType) {\n+    return _routingEntryMap.containsKey(tableNameWithType);\n+  }\n+\n+  /**\n+   * Returns the routing table (map from server instance to list of segments hosted by the server) based on the broker\n+   * request.\n+   * <p>NOTE: The broker request should already have the table suffix (_OFFLINE or _REALTIME) appended.\n+   */\n+  public Map<ServerInstance, List<String>> getRoutingTable(BrokerRequest brokerRequest) {\n+    String tableNameWithType = brokerRequest.getQuerySource().getTableName();\n+    RoutingEntry routingEntry = _routingEntryMap.get(tableNameWithType);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", tableNameWithType);\n+\n+    Map<String, String> segmentToInstanceMap = routingEntry.calculateSegmentToInstanceMap(brokerRequest);\n+    Map<ServerInstance, List<String>> routingTable = new HashMap<>();\n+    for (Map.Entry<String, String> entry : segmentToInstanceMap.entrySet()) {\n+      ServerInstance serverInstance = _enabledServerInstanceMap.get(entry.getValue());\n+      if (serverInstance != null) {\n+        routingTable.computeIfAbsent(serverInstance, k -> new ArrayList<>()).add(entry.getKey());\n+      } else {\n+        // Should not happen in normal case unless encountered unexpected exception when updating routing entries\n+        _brokerMetrics.addMeteredTableValue(tableNameWithType, BrokerMeter.SERVER_MISSING_FOR_ROUTING, 1L);\n+      }\n+    }\n+    return routingTable;\n+  }\n+\n+  /**\n+   * Returns the time boundary info for the given offline table name.\n+   * <p>NOTE: Time boundary info is only available for the offline part of the hybrid table.\n+   */\n+  @Nullable\n+  public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n+    RoutingEntry routingEntry = _routingEntryMap.get(offlineTableName);\n+    Preconditions.checkState(routingEntry != null, \"Failed to find routing for table: %s\", offlineTableName);\n+    TimeBoundaryManager timeBoundaryManager = routingEntry.getTimeBoundaryManager();\n+    return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n+  }\n+\n+  private static class RoutingEntry {\n+    final String _tableNameWithType;\n+    final SegmentSelector _segmentSelector;\n+    final SegmentPruner _segmentPruner;\n+    final InstanceSelector _instanceSelector;\n+\n+    // Cache the ExternalView version for the last update\n+    transient int _lastUpdateExternalViewVersion;\n+    // Time boundary manager is only available for the offline part of the hybrid table\n+    transient TimeBoundaryManager _timeBoundaryManager;\n+\n+    RoutingEntry(String tableNameWithType, SegmentSelector segmentSelector, SegmentPruner segmentPruner,\n+        InstanceSelector instanceSelector, int lastUpdateExternalViewVersion,\n+        @Nullable TimeBoundaryManager timeBoundaryManager) {\n+      _tableNameWithType = tableNameWithType;\n+      _segmentSelector = segmentSelector;\n+      _segmentPruner = segmentPruner;\n+      _instanceSelector = instanceSelector;\n+      _lastUpdateExternalViewVersion = lastUpdateExternalViewVersion;\n+      _timeBoundaryManager = timeBoundaryManager;\n+    }\n+\n+    String getTableNameWithType() {\n+      return _tableNameWithType;\n+    }\n+\n+    int getLastUpdateExternalViewVersion() {\n+      return _lastUpdateExternalViewVersion;\n+    }\n+\n+    void setTimeBoundaryManager(@Nullable TimeBoundaryManager timeBoundaryManager) {\n+      _timeBoundaryManager = timeBoundaryManager;\n+    }\n+\n+    @Nullable\n+    TimeBoundaryManager getTimeBoundaryManager() {\n+      return _timeBoundaryManager;\n+    }\n+\n+    void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcwNjA3NQ=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 454}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzY5MTgxOnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BaseInstanceSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODo1NDo0NlrOFmTUdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzoxMDozM1rOFnM5eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcwNjc0Mw==", "bodyText": "I see some very similar code from Offline/Realtime Segment Selector. It's inevitable to put on both?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r375706743", "createdAt": "2020-02-06T08:54:46Z", "author": {"login": "snleee"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BaseInstanceSelector.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+abstract class BaseInstanceSelector implements InstanceSelector {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(BaseInstanceSelector.class);\n+\n+  // To prevent int overflow, reset the request id once it reaches this value\n+  private static final int MAX_REQUEST_ID = 1_000_000_000;\n+\n+  private final AtomicLong _requestId = new AtomicLong();\n+  private final String _tableNameWithType;\n+  private final BrokerMetrics _brokerMetrics;\n+\n+  private volatile Set<String> _enabledInstances;\n+  private volatile Map<String, List<String>> _segmentToInstancesMap;\n+  private volatile Map<String, List<String>> _instanceToSegmentsMap;\n+  private volatile Map<String, List<String>> _segmentToEnabledInstancesMap;\n+\n+  BaseInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    _tableNameWithType = tableNameWithType;\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(Set<String> enabledInstances, ExternalView externalView, Set<String> onlineSegments) {\n+    _enabledInstances = enabledInstances;\n+    onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Override\n+  public void onInstancesChange(Set<String> enabledInstances, List<String> changedInstances) {\n+    _enabledInstances = enabledInstances;\n+\n+    // Update all segments served by the changed instances\n+    Set<String> segmentsToUpdate = new HashSet<>();\n+    Map<String, List<String>> instanceToSegmentsMap = _instanceToSegmentsMap;\n+    for (String instance : changedInstances) {\n+      List<String> segments = instanceToSegmentsMap.get(instance);\n+      if (segments != null) {\n+        segmentsToUpdate.addAll(segments);\n+      }\n+    }\n+\n+    // Directly return if no segment needs to be updated\n+    if (segmentsToUpdate.isEmpty()) {\n+      return;\n+    }\n+\n+    // Generate a new map from segment to enabled instances\n+    Map<String, List<String>> segmentToInstancesMap = _segmentToInstancesMap;\n+    Map<String, List<String>> segmentToEnabledInstancesMap = _segmentToEnabledInstancesMap;\n+    Map<String, List<String>> newSegmentToEnabledInstancesMap =\n+        new HashMap<>(HashUtil.getHashMapCapacity(segmentToEnabledInstancesMap.size()));\n+    for (Map.Entry<String, List<String>> entry : segmentToEnabledInstancesMap.entrySet()) {\n+      String segment = entry.getKey();\n+      if (segmentsToUpdate.contains(segment)) {\n+        newSegmentToEnabledInstancesMap.put(segment,\n+            calculateEnabledInstancesForSegment(segment, segmentToInstancesMap.get(segment), enabledInstances));\n+      } else {\n+        newSegmentToEnabledInstancesMap.put(segment, entry.getValue());\n+      }\n+    }\n+    _segmentToEnabledInstancesMap = newSegmentToEnabledInstancesMap;\n+  }\n+\n+  @Override\n+  public void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {\n+    Map<String, Map<String, String>> segmentAssignment = externalView.getRecord().getMapFields();\n+    Map<String, List<String>> segmentToInstancesMap =\n+        new HashMap<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+    Map<String, List<String>> instanceToSegmentsMap = new HashMap<>();\n+\n+    for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+      // Keep segments in both external view and ideal state", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MDEwNg==", "bodyText": "We don't need to skip segments not in the ideal state here. Updated", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376650106", "createdAt": "2020-02-07T23:10:33Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BaseInstanceSelector.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+abstract class BaseInstanceSelector implements InstanceSelector {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(BaseInstanceSelector.class);\n+\n+  // To prevent int overflow, reset the request id once it reaches this value\n+  private static final int MAX_REQUEST_ID = 1_000_000_000;\n+\n+  private final AtomicLong _requestId = new AtomicLong();\n+  private final String _tableNameWithType;\n+  private final BrokerMetrics _brokerMetrics;\n+\n+  private volatile Set<String> _enabledInstances;\n+  private volatile Map<String, List<String>> _segmentToInstancesMap;\n+  private volatile Map<String, List<String>> _instanceToSegmentsMap;\n+  private volatile Map<String, List<String>> _segmentToEnabledInstancesMap;\n+\n+  BaseInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    _tableNameWithType = tableNameWithType;\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(Set<String> enabledInstances, ExternalView externalView, Set<String> onlineSegments) {\n+    _enabledInstances = enabledInstances;\n+    onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Override\n+  public void onInstancesChange(Set<String> enabledInstances, List<String> changedInstances) {\n+    _enabledInstances = enabledInstances;\n+\n+    // Update all segments served by the changed instances\n+    Set<String> segmentsToUpdate = new HashSet<>();\n+    Map<String, List<String>> instanceToSegmentsMap = _instanceToSegmentsMap;\n+    for (String instance : changedInstances) {\n+      List<String> segments = instanceToSegmentsMap.get(instance);\n+      if (segments != null) {\n+        segmentsToUpdate.addAll(segments);\n+      }\n+    }\n+\n+    // Directly return if no segment needs to be updated\n+    if (segmentsToUpdate.isEmpty()) {\n+      return;\n+    }\n+\n+    // Generate a new map from segment to enabled instances\n+    Map<String, List<String>> segmentToInstancesMap = _segmentToInstancesMap;\n+    Map<String, List<String>> segmentToEnabledInstancesMap = _segmentToEnabledInstancesMap;\n+    Map<String, List<String>> newSegmentToEnabledInstancesMap =\n+        new HashMap<>(HashUtil.getHashMapCapacity(segmentToEnabledInstancesMap.size()));\n+    for (Map.Entry<String, List<String>> entry : segmentToEnabledInstancesMap.entrySet()) {\n+      String segment = entry.getKey();\n+      if (segmentsToUpdate.contains(segment)) {\n+        newSegmentToEnabledInstancesMap.put(segment,\n+            calculateEnabledInstancesForSegment(segment, segmentToInstancesMap.get(segment), enabledInstances));\n+      } else {\n+        newSegmentToEnabledInstancesMap.put(segment, entry.getValue());\n+      }\n+    }\n+    _segmentToEnabledInstancesMap = newSegmentToEnabledInstancesMap;\n+  }\n+\n+  @Override\n+  public void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {\n+    Map<String, Map<String, String>> segmentAssignment = externalView.getRecord().getMapFields();\n+    Map<String, List<String>> segmentToInstancesMap =\n+        new HashMap<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+    Map<String, List<String>> instanceToSegmentsMap = new HashMap<>();\n+\n+    for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+      // Keep segments in both external view and ideal state", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcwNjc0Mw=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTc2NzgyOnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToyNTo0OFrOFmnVnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDowMjowM1rOFmuX7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzNDcxOQ==", "bodyText": "why is this static?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376034719", "createdAt": "2020-02-06T19:25:48Z", "author": {"login": "mcvsubbu"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RoutingManager.class);\n+\n+  private final BrokerMetrics _brokerMetrics;\n+  private final Map<String, RoutingEntry> _routingEntryMap = new ConcurrentHashMap<>();\n+  private final Map<String, ServerInstance> _enabledServerInstanceMap = new ConcurrentHashMap<>();\n+\n+  private BaseDataAccessor<ZNRecord> _zkDataAccessor;\n+  private String _externalViewPathPrefix;\n+  private String _idealStatePathPrefix;\n+  private String _instanceConfigsPath;\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+\n+  public RoutingManager(BrokerMetrics brokerMetrics) {\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(HelixManager helixManager) {\n+    HelixDataAccessor helixDataAccessor = helixManager.getHelixDataAccessor();\n+    _zkDataAccessor = helixDataAccessor.getBaseDataAccessor();\n+    _externalViewPathPrefix = helixDataAccessor.keyBuilder().externalViews().getPath() + \"/\";\n+    _idealStatePathPrefix = helixDataAccessor.keyBuilder().idealStates().getPath() + \"/\";\n+    _instanceConfigsPath = helixDataAccessor.keyBuilder().instanceConfigs().getPath();\n+    _propertyStore = helixManager.getHelixPropertyStore();\n+  }\n+\n+  @Override\n+  public synchronized void processClusterChange(HelixConstants.ChangeType changeType) {\n+    Preconditions.checkState(changeType == HelixConstants.ChangeType.EXTERNAL_VIEW\n+        || changeType == HelixConstants.ChangeType.INSTANCE_CONFIG, \"Illegal change type: \" + changeType);\n+    if (changeType == HelixConstants.ChangeType.EXTERNAL_VIEW) {\n+      processExternalViewChange();\n+    } else {\n+      processInstanceConfigChange();\n+    }\n+  }\n+\n+  private void processExternalViewChange() {\n+    LOGGER.info(\"Processing external view change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    int numTables = _routingEntryMap.size();\n+    if (numTables == 0) {\n+      LOGGER.info(\"No table exists in the routing, skipping processing external view change\");\n+      return;\n+    }\n+\n+    List<RoutingEntry> routingEntries = new ArrayList<>(numTables);\n+    List<String> externalViewPaths = new ArrayList<>(numTables);\n+    for (Map.Entry<String, RoutingEntry> entry : _routingEntryMap.entrySet()) {\n+      String tableNameWithType = entry.getKey();\n+      routingEntries.add(entry.getValue());\n+      externalViewPaths.add(_externalViewPathPrefix + tableNameWithType);\n+    }\n+    Stat[] stats = _zkDataAccessor.getStats(externalViewPaths, AccessOption.PERSISTENT);\n+    long fetchStatsEndTimeMs = System.currentTimeMillis();\n+\n+    int numRoutingEntriesToUpdate = 0;\n+    for (int i = 0; i < numTables; i++) {\n+      Stat stat = stats[i];\n+      if (stat != null) {\n+        RoutingEntry routingEntry = routingEntries.get(i);\n+        if (stat.getVersion() != routingEntry.getLastUpdateExternalViewVersion()) {\n+          numRoutingEntriesToUpdate++;\n+          try {\n+            updateRoutingEntryOnExternalViewChange(routingEntry);\n+          } catch (Exception e) {\n+            LOGGER\n+                .error(\"Caught unexpected exception while updating routing entry on external view change for table: {}\",\n+                    routingEntry.getTableNameWithType(), e);\n+          }\n+        }\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    LOGGER.info(\n+        \"Processed external view change in {}ms (fetch {} external view stats: {}ms, update {} routing entries: {}ms)\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, numTables, fetchStatsEndTimeMs - startTimeMs,\n+        numRoutingEntriesToUpdate, updateRoutingEntriesEndTimeMs - fetchStatsEndTimeMs);\n+  }\n+\n+  private void updateRoutingEntryOnExternalViewChange(RoutingEntry routingEntry) {\n+    String tableNameWithType = routingEntry.getTableNameWithType();\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    if (externalView == null) {\n+      LOGGER.warn(\"Failed to find external view for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    if (onlineSegments == null) {\n+      LOGGER.warn(\"Failed to find ideal state for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    routingEntry.onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Nullable\n+  private ExternalView getExternalView(String tableNameWithType) {\n+    Stat stat = new Stat();\n+    ZNRecord znRecord = _zkDataAccessor.get(_externalViewPathPrefix + tableNameWithType, stat, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      znRecord.setVersion(stat.getVersion());\n+      return new ExternalView(znRecord);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  private Set<String> getOnlineSegments(String tableNameWithType) {\n+    ZNRecord znRecord = _zkDataAccessor.get(_idealStatePathPrefix + tableNameWithType, null, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      Map<String, Map<String, String>> segmentAssignment = znRecord.getMapFields();\n+      Set<String> onlineSegments = new HashSet<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+      for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+        Map<String, String> instanceStateMap = entry.getValue();\n+        if (instanceStateMap.containsValue(RealtimeSegmentOnlineOfflineStateModel.ONLINE) || instanceStateMap\n+            .containsValue(RealtimeSegmentOnlineOfflineStateModel.CONSUMING)) {\n+          onlineSegments.add(entry.getKey());\n+        }\n+      }\n+      return onlineSegments;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private void processInstanceConfigChange() {\n+    LOGGER.info(\"Processing instance config change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    List<ZNRecord> instanceConfigZNRecords =\n+        _zkDataAccessor.getChildren(_instanceConfigsPath, null, AccessOption.PERSISTENT);\n+    long fetchInstanceConfigsEndTimeMs = System.currentTimeMillis();\n+\n+    // Calculate new enabled and disabled instances\n+    Set<String> enabledInstances = new HashSet<>();\n+    List<String> newEnabledInstances = new ArrayList<>();\n+    for (ZNRecord instanceConfigZNRecord : instanceConfigZNRecords) {\n+      String instance = instanceConfigZNRecord.getId();\n+      if (isInstanceEnabled(instanceConfigZNRecord)) {\n+        enabledInstances.add(instance);\n+\n+        // Always refresh the server instance with the latest instance config in case it changes\n+        ServerInstance serverInstance = new ServerInstance(new InstanceConfig(instanceConfigZNRecord));\n+        if (_enabledServerInstanceMap.put(instance, serverInstance) == null) {\n+          newEnabledInstances.add(instance);\n+        }\n+      }\n+    }\n+    List<String> newDisabledInstances = new ArrayList<>();\n+    for (String instance : _enabledServerInstanceMap.keySet()) {\n+      if (!enabledInstances.contains(instance)) {\n+        newDisabledInstances.add(instance);\n+      }\n+    }\n+    List<String> changedInstances = new ArrayList<>(newEnabledInstances.size() + newDisabledInstances.size());\n+    changedInstances.addAll(newEnabledInstances);\n+    changedInstances.addAll(newDisabledInstances);\n+    long calculateChangedInstancesEndTimeMs = System.currentTimeMillis();\n+\n+    // Update routing entry for all tables\n+    for (RoutingEntry routingEntry : _routingEntryMap.values()) {\n+      try {\n+        routingEntry.onInstancesChange(enabledInstances, changedInstances);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Caught unexpected exception while updating routing entry on instances change for table: {}\",\n+            routingEntry.getTableNameWithType(), e);\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    // Remove new disabled instances from _enabledServerInstanceMap after updating all routing entries to ensure it\n+    // always contains the selected instances\n+    _enabledServerInstanceMap.keySet().removeAll(newDisabledInstances);\n+\n+    LOGGER.info(\n+        \"Processed instance config change in {}ms (fetch {} instance configs: {}ms, calculate changed instances: {}ms, update {} routing entries: {}ms), new enabled instances: {}, new disabled instances: {}\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, instanceConfigZNRecords.size(),\n+        fetchInstanceConfigsEndTimeMs - startTimeMs, calculateChangedInstancesEndTimeMs - fetchInstanceConfigsEndTimeMs,\n+        _routingEntryMap.size(), updateRoutingEntriesEndTimeMs - calculateChangedInstancesEndTimeMs,\n+        newEnabledInstances, newDisabledInstances);\n+  }\n+\n+  private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTk5OQ==", "bodyText": "Because it does not rely on any member variable (helper util method)", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376149999", "createdAt": "2020-02-07T00:02:03Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RoutingManager.class);\n+\n+  private final BrokerMetrics _brokerMetrics;\n+  private final Map<String, RoutingEntry> _routingEntryMap = new ConcurrentHashMap<>();\n+  private final Map<String, ServerInstance> _enabledServerInstanceMap = new ConcurrentHashMap<>();\n+\n+  private BaseDataAccessor<ZNRecord> _zkDataAccessor;\n+  private String _externalViewPathPrefix;\n+  private String _idealStatePathPrefix;\n+  private String _instanceConfigsPath;\n+  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+\n+  public RoutingManager(BrokerMetrics brokerMetrics) {\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(HelixManager helixManager) {\n+    HelixDataAccessor helixDataAccessor = helixManager.getHelixDataAccessor();\n+    _zkDataAccessor = helixDataAccessor.getBaseDataAccessor();\n+    _externalViewPathPrefix = helixDataAccessor.keyBuilder().externalViews().getPath() + \"/\";\n+    _idealStatePathPrefix = helixDataAccessor.keyBuilder().idealStates().getPath() + \"/\";\n+    _instanceConfigsPath = helixDataAccessor.keyBuilder().instanceConfigs().getPath();\n+    _propertyStore = helixManager.getHelixPropertyStore();\n+  }\n+\n+  @Override\n+  public synchronized void processClusterChange(HelixConstants.ChangeType changeType) {\n+    Preconditions.checkState(changeType == HelixConstants.ChangeType.EXTERNAL_VIEW\n+        || changeType == HelixConstants.ChangeType.INSTANCE_CONFIG, \"Illegal change type: \" + changeType);\n+    if (changeType == HelixConstants.ChangeType.EXTERNAL_VIEW) {\n+      processExternalViewChange();\n+    } else {\n+      processInstanceConfigChange();\n+    }\n+  }\n+\n+  private void processExternalViewChange() {\n+    LOGGER.info(\"Processing external view change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    int numTables = _routingEntryMap.size();\n+    if (numTables == 0) {\n+      LOGGER.info(\"No table exists in the routing, skipping processing external view change\");\n+      return;\n+    }\n+\n+    List<RoutingEntry> routingEntries = new ArrayList<>(numTables);\n+    List<String> externalViewPaths = new ArrayList<>(numTables);\n+    for (Map.Entry<String, RoutingEntry> entry : _routingEntryMap.entrySet()) {\n+      String tableNameWithType = entry.getKey();\n+      routingEntries.add(entry.getValue());\n+      externalViewPaths.add(_externalViewPathPrefix + tableNameWithType);\n+    }\n+    Stat[] stats = _zkDataAccessor.getStats(externalViewPaths, AccessOption.PERSISTENT);\n+    long fetchStatsEndTimeMs = System.currentTimeMillis();\n+\n+    int numRoutingEntriesToUpdate = 0;\n+    for (int i = 0; i < numTables; i++) {\n+      Stat stat = stats[i];\n+      if (stat != null) {\n+        RoutingEntry routingEntry = routingEntries.get(i);\n+        if (stat.getVersion() != routingEntry.getLastUpdateExternalViewVersion()) {\n+          numRoutingEntriesToUpdate++;\n+          try {\n+            updateRoutingEntryOnExternalViewChange(routingEntry);\n+          } catch (Exception e) {\n+            LOGGER\n+                .error(\"Caught unexpected exception while updating routing entry on external view change for table: {}\",\n+                    routingEntry.getTableNameWithType(), e);\n+          }\n+        }\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    LOGGER.info(\n+        \"Processed external view change in {}ms (fetch {} external view stats: {}ms, update {} routing entries: {}ms)\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, numTables, fetchStatsEndTimeMs - startTimeMs,\n+        numRoutingEntriesToUpdate, updateRoutingEntriesEndTimeMs - fetchStatsEndTimeMs);\n+  }\n+\n+  private void updateRoutingEntryOnExternalViewChange(RoutingEntry routingEntry) {\n+    String tableNameWithType = routingEntry.getTableNameWithType();\n+    ExternalView externalView = getExternalView(tableNameWithType);\n+    if (externalView == null) {\n+      LOGGER.warn(\"Failed to find external view for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    Set<String> onlineSegments = getOnlineSegments(tableNameWithType);\n+    if (onlineSegments == null) {\n+      LOGGER.warn(\"Failed to find ideal state for table: {}, skipping updating routing entry\", tableNameWithType);\n+      return;\n+    }\n+    routingEntry.onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Nullable\n+  private ExternalView getExternalView(String tableNameWithType) {\n+    Stat stat = new Stat();\n+    ZNRecord znRecord = _zkDataAccessor.get(_externalViewPathPrefix + tableNameWithType, stat, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      znRecord.setVersion(stat.getVersion());\n+      return new ExternalView(znRecord);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  private Set<String> getOnlineSegments(String tableNameWithType) {\n+    ZNRecord znRecord = _zkDataAccessor.get(_idealStatePathPrefix + tableNameWithType, null, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      Map<String, Map<String, String>> segmentAssignment = znRecord.getMapFields();\n+      Set<String> onlineSegments = new HashSet<>(HashUtil.getHashMapCapacity(segmentAssignment.size()));\n+      for (Map.Entry<String, Map<String, String>> entry : segmentAssignment.entrySet()) {\n+        Map<String, String> instanceStateMap = entry.getValue();\n+        if (instanceStateMap.containsValue(RealtimeSegmentOnlineOfflineStateModel.ONLINE) || instanceStateMap\n+            .containsValue(RealtimeSegmentOnlineOfflineStateModel.CONSUMING)) {\n+          onlineSegments.add(entry.getKey());\n+        }\n+      }\n+      return onlineSegments;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private void processInstanceConfigChange() {\n+    LOGGER.info(\"Processing instance config change\");\n+    long startTimeMs = System.currentTimeMillis();\n+\n+    List<ZNRecord> instanceConfigZNRecords =\n+        _zkDataAccessor.getChildren(_instanceConfigsPath, null, AccessOption.PERSISTENT);\n+    long fetchInstanceConfigsEndTimeMs = System.currentTimeMillis();\n+\n+    // Calculate new enabled and disabled instances\n+    Set<String> enabledInstances = new HashSet<>();\n+    List<String> newEnabledInstances = new ArrayList<>();\n+    for (ZNRecord instanceConfigZNRecord : instanceConfigZNRecords) {\n+      String instance = instanceConfigZNRecord.getId();\n+      if (isInstanceEnabled(instanceConfigZNRecord)) {\n+        enabledInstances.add(instance);\n+\n+        // Always refresh the server instance with the latest instance config in case it changes\n+        ServerInstance serverInstance = new ServerInstance(new InstanceConfig(instanceConfigZNRecord));\n+        if (_enabledServerInstanceMap.put(instance, serverInstance) == null) {\n+          newEnabledInstances.add(instance);\n+        }\n+      }\n+    }\n+    List<String> newDisabledInstances = new ArrayList<>();\n+    for (String instance : _enabledServerInstanceMap.keySet()) {\n+      if (!enabledInstances.contains(instance)) {\n+        newDisabledInstances.add(instance);\n+      }\n+    }\n+    List<String> changedInstances = new ArrayList<>(newEnabledInstances.size() + newDisabledInstances.size());\n+    changedInstances.addAll(newEnabledInstances);\n+    changedInstances.addAll(newDisabledInstances);\n+    long calculateChangedInstancesEndTimeMs = System.currentTimeMillis();\n+\n+    // Update routing entry for all tables\n+    for (RoutingEntry routingEntry : _routingEntryMap.values()) {\n+      try {\n+        routingEntry.onInstancesChange(enabledInstances, changedInstances);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Caught unexpected exception while updating routing entry on instances change for table: {}\",\n+            routingEntry.getTableNameWithType(), e);\n+      }\n+    }\n+    long updateRoutingEntriesEndTimeMs = System.currentTimeMillis();\n+\n+    // Remove new disabled instances from _enabledServerInstanceMap after updating all routing entries to ensure it\n+    // always contains the selected instances\n+    _enabledServerInstanceMap.keySet().removeAll(newDisabledInstances);\n+\n+    LOGGER.info(\n+        \"Processed instance config change in {}ms (fetch {} instance configs: {}ms, calculate changed instances: {}ms, update {} routing entries: {}ms), new enabled instances: {}, new disabled instances: {}\",\n+        updateRoutingEntriesEndTimeMs - startTimeMs, instanceConfigZNRecords.size(),\n+        fetchInstanceConfigsEndTimeMs - startTimeMs, calculateChangedInstancesEndTimeMs - fetchInstanceConfigsEndTimeMs,\n+        _routingEntryMap.size(), updateRoutingEntriesEndTimeMs - calculateChangedInstancesEndTimeMs,\n+        newEnabledInstances, newDisabledInstances);\n+  }\n+\n+  private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzNDcxOQ=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMxOTM4OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentpruner/SegmentPruner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0MTozMVrOFmst2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo1NzoxN1rOFnNjmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjg0Mg==", "bodyText": "It would be helpful to document how the set of offline segments is used", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376122842", "createdAt": "2020-02-06T22:41:31Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentpruner/SegmentPruner.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentpruner;\n+\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+/**\n+ * The segment pruner prunes the selected segments based on the query.\n+ */\n+public interface SegmentPruner {\n+\n+  /**\n+   * Initializes the segment pruner with the external view and online segments (segments with ONLINE/CONSUMING instances\n+   * in ideal state). Should be called only once before calling other methods.\n+   */\n+  void init(ExternalView externalView, Set<String> onlineSegments);\n+\n+  /**\n+   * Processes the external view change based on the given online segments (segments with ONLINE/CONSUMING instances in\n+   * ideal state).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MDg4OA==", "bodyText": "externalView is not used. Added the doc", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376660888", "createdAt": "2020-02-07T23:57:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentpruner/SegmentPruner.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentpruner;\n+\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+/**\n+ * The segment pruner prunes the selected segments based on the query.\n+ */\n+public interface SegmentPruner {\n+\n+  /**\n+   * Initializes the segment pruner with the external view and online segments (segments with ONLINE/CONSUMING instances\n+   * in ideal state). Should be called only once before calling other methods.\n+   */\n+  void init(ExternalView externalView, Set<String> onlineSegments);\n+\n+  /**\n+   * Processes the external view change based on the given online segments (segments with ONLINE/CONSUMING instances in\n+   * ideal state).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjg0Mg=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMxOTc4OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentpruner/PartitionAwareSegmentPruner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0MTo0M1rOFmsuFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo1NTo0MVrOFnNiOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjkwMg==", "bodyText": "(nit) Javadoc would be good", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376122902", "createdAt": "2020-02-06T22:41:43Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentpruner/PartitionAwareSegmentPruner.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentpruner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metadata.segment.ColumnPartitionMetadata;\n+import org.apache.pinot.common.metadata.segment.SegmentPartitionMetadata;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.request.FilterQueryTree;\n+import org.apache.pinot.common.utils.request.RequestUtils;\n+import org.apache.pinot.core.data.partition.PartitionFunction;\n+import org.apache.pinot.core.data.partition.PartitionFunctionFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class PartitionAwareSegmentPruner implements SegmentPruner {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MDUzOA==", "bodyText": "Added", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376660538", "createdAt": "2020-02-07T23:55:41Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentpruner/PartitionAwareSegmentPruner.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentpruner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metadata.segment.ColumnPartitionMetadata;\n+import org.apache.pinot.common.metadata.segment.SegmentPartitionMetadata;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.request.FilterQueryTree;\n+import org.apache.pinot.common.utils.request.RequestUtils;\n+import org.apache.pinot.core.data.partition.PartitionFunction;\n+import org.apache.pinot.core.data.partition.PartitionFunctionFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class PartitionAwareSegmentPruner implements SegmentPruner {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjkwMg=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMyMDE3OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/ReplicaGroupInstanceSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0MTo0OVrOFmsuRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo1MDozMVrOFnNd4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjk0OQ==", "bodyText": "What is meant by picking up the same replica group id?\nIf we have 3 replica groups RG1, RG2 and RG3, each with 2 hosts (S1, S2), (S3, S4), (S5, S6) respectively then the problem of evenly distributing the queries boils down to evenly picking up replica groups assuming the mirror segment assignment did the right thing. Correct?\nSo let's say we have 3 queries (exact same) touching the same number of segment fired concurrently. Can we say that each query will go to a different replica group?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376122949", "createdAt": "2020-02-06T22:41:49Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/ReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for replica-group routing strategy.\n+ * <p>The selection algorithm will always evenly distribute the traffic to all replicas of each segment, and will select\n+ * the same replica id for all segments with the same number of replicas. The algorithm is very light-weight and will\n+ * do best effort to select the least servers for the request.\n+ * <p>The algorithm relies on the mirror segment assignment from replica-group segment assignment strategy. With mirror\n+ * segment assignment, any server in one replica-group will always have a corresponding server in other replica-groups\n+ * that have the same segments assigned. For an example, if S1 is a server in replica-group 1, and it has mirror server\n+ * S2 in replica-group 2 and S3 in replica-group 3. All segments assigned to S1 will also be assigned to S2 and S3. In\n+ * stable scenario (external view matches ideal state), if we always pick the same replica id for all segments, only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1OTQyNA==", "bodyText": "There is no guarantee on selecting the servers from the same replica-group, but it is guaranteed that only 2 servers are selected for each query, and each server only need to answer 1 query.\nUpdated the doc for more explaination", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376659424", "createdAt": "2020-02-07T23:50:31Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/ReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for replica-group routing strategy.\n+ * <p>The selection algorithm will always evenly distribute the traffic to all replicas of each segment, and will select\n+ * the same replica id for all segments with the same number of replicas. The algorithm is very light-weight and will\n+ * do best effort to select the least servers for the request.\n+ * <p>The algorithm relies on the mirror segment assignment from replica-group segment assignment strategy. With mirror\n+ * segment assignment, any server in one replica-group will always have a corresponding server in other replica-groups\n+ * that have the same segments assigned. For an example, if S1 is a server in replica-group 1, and it has mirror server\n+ * S2 in replica-group 2 and S3 in replica-group 3. All segments assigned to S1 will also be assigned to S2 and S3. In\n+ * stable scenario (external view matches ideal state), if we always pick the same replica id for all segments, only", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjk0OQ=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMyMDM1OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/ReplicaGroupInstanceSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0MTo1MlrOFmsuXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzoyOToxNFrOFnNLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjk3NQ==", "bodyText": "This might be a dumb question: As per the existing design, don't we have a table level constraint that each segment will have the same number of replicas?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376122975", "createdAt": "2020-02-06T22:41:52Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/ReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for replica-group routing strategy.\n+ * <p>The selection algorithm will always evenly distribute the traffic to all replicas of each segment, and will select\n+ * the same replica id for all segments with the same number of replicas. The algorithm is very light-weight and will", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1NDcwOA==", "bodyText": "Yes, but no guarantee on the number of replicas up in external view", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376654708", "createdAt": "2020-02-07T23:29:14Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/ReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for replica-group routing strategy.\n+ * <p>The selection algorithm will always evenly distribute the traffic to all replicas of each segment, and will select\n+ * the same replica id for all segments with the same number of replicas. The algorithm is very light-weight and will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjk3NQ=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMyMDcwOnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/InstanceSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0MTo1OVrOFmsujw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzoyNToxOVrOFnNHsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzAyMw==", "bodyText": "Same here.. I think it will be great to explain the relevance of onlineSegments for future readers. We should indicate how they are used and when will they be empty/null", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376123023", "createdAt": "2020-02-06T22:41:59Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/InstanceSelector.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+/**\n+ * The instance selector selects server instances to serve the query based on the selected segments.\n+ */\n+public interface InstanceSelector {\n+\n+  /**\n+   * Initializes the instance selector with the enabled instances, external view and online segments (segments with\n+   * ONLINE/CONSUMING instances in ideal state). Should be called only once before calling other methods.\n+   */\n+  void init(Set<String> enabledInstances, ExternalView externalView, Set<String> onlineSegments);\n+\n+  /**\n+   * Processes the instances change. Changed instances are pre-computed based on the current and previous enabled\n+   * instances only once on the caller side and passed to all the instance selectors.\n+   */\n+  void onInstancesChange(Set<String> enabledInstances, List<String> changedInstances);\n+\n+  /**\n+   * Processes the external view change based on the given online segments (segments with ONLINE/CONSUMING instances in\n+   * ideal state).\n+   */\n+  void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1Mzc0NQ==", "bodyText": "It won't be null if it is not annotated as nullable. We don't use it right now, but maybe useful for future implementations. Added some description", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376653745", "createdAt": "2020-02-07T23:25:19Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/InstanceSelector.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+/**\n+ * The instance selector selects server instances to serve the query based on the selected segments.\n+ */\n+public interface InstanceSelector {\n+\n+  /**\n+   * Initializes the instance selector with the enabled instances, external view and online segments (segments with\n+   * ONLINE/CONSUMING instances in ideal state). Should be called only once before calling other methods.\n+   */\n+  void init(Set<String> enabledInstances, ExternalView externalView, Set<String> onlineSegments);\n+\n+  /**\n+   * Processes the instances change. Changed instances are pre-computed based on the current and previous enabled\n+   * instances only once on the caller side and passed to all the instance selectors.\n+   */\n+  void onInstancesChange(Set<String> enabledInstances, List<String> changedInstances);\n+\n+  /**\n+   * Processes the external view change based on the given online segments (segments with ONLINE/CONSUMING instances in\n+   * ideal state).\n+   */\n+  void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzAyMw=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMyMTAzOnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BaseInstanceSelector.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0MjowN1rOFmsuww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzoxNTo0NFrOFnM-yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzA3NQ==", "bodyText": "Can we add some documentation here explaining how the \"onlineSegments\" is used? It will empty or null if the table is offline?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376123075", "createdAt": "2020-02-06T22:42:07Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BaseInstanceSelector.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+abstract class BaseInstanceSelector implements InstanceSelector {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(BaseInstanceSelector.class);\n+\n+  // To prevent int overflow, reset the request id once it reaches this value\n+  private static final int MAX_REQUEST_ID = 1_000_000_000;\n+\n+  private final AtomicLong _requestId = new AtomicLong();\n+  private final String _tableNameWithType;\n+  private final BrokerMetrics _brokerMetrics;\n+\n+  private volatile Set<String> _enabledInstances;\n+  private volatile Map<String, List<String>> _segmentToInstancesMap;\n+  private volatile Map<String, List<String>> _instanceToSegmentsMap;\n+  private volatile Map<String, List<String>> _segmentToEnabledInstancesMap;\n+\n+  BaseInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    _tableNameWithType = tableNameWithType;\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(Set<String> enabledInstances, ExternalView externalView, Set<String> onlineSegments) {\n+    _enabledInstances = enabledInstances;\n+    onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Override\n+  public void onInstancesChange(Set<String> enabledInstances, List<String> changedInstances) {\n+    _enabledInstances = enabledInstances;\n+\n+    // Update all segments served by the changed instances\n+    Set<String> segmentsToUpdate = new HashSet<>();\n+    Map<String, List<String>> instanceToSegmentsMap = _instanceToSegmentsMap;\n+    for (String instance : changedInstances) {\n+      List<String> segments = instanceToSegmentsMap.get(instance);\n+      if (segments != null) {\n+        segmentsToUpdate.addAll(segments);\n+      }\n+    }\n+\n+    // Directly return if no segment needs to be updated\n+    if (segmentsToUpdate.isEmpty()) {\n+      return;\n+    }\n+\n+    // Generate a new map from segment to enabled instances\n+    Map<String, List<String>> segmentToInstancesMap = _segmentToInstancesMap;\n+    Map<String, List<String>> segmentToEnabledInstancesMap = _segmentToEnabledInstancesMap;\n+    Map<String, List<String>> newSegmentToEnabledInstancesMap =\n+        new HashMap<>(HashUtil.getHashMapCapacity(segmentToEnabledInstancesMap.size()));\n+    for (Map.Entry<String, List<String>> entry : segmentToEnabledInstancesMap.entrySet()) {\n+      String segment = entry.getKey();\n+      if (segmentsToUpdate.contains(segment)) {\n+        newSegmentToEnabledInstancesMap.put(segment,\n+            calculateEnabledInstancesForSegment(segment, segmentToInstancesMap.get(segment), enabledInstances));\n+      } else {\n+        newSegmentToEnabledInstancesMap.put(segment, entry.getValue());\n+      }\n+    }\n+    _segmentToEnabledInstancesMap = newSegmentToEnabledInstancesMap;\n+  }\n+\n+  @Override\n+  public void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0ODU0OQ==", "bodyText": "onlineSegments are segments with ONLINE/CONSUMING instances in ideal state. There are javadoc in the interface", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376648549", "createdAt": "2020-02-07T23:05:18Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BaseInstanceSelector.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+abstract class BaseInstanceSelector implements InstanceSelector {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(BaseInstanceSelector.class);\n+\n+  // To prevent int overflow, reset the request id once it reaches this value\n+  private static final int MAX_REQUEST_ID = 1_000_000_000;\n+\n+  private final AtomicLong _requestId = new AtomicLong();\n+  private final String _tableNameWithType;\n+  private final BrokerMetrics _brokerMetrics;\n+\n+  private volatile Set<String> _enabledInstances;\n+  private volatile Map<String, List<String>> _segmentToInstancesMap;\n+  private volatile Map<String, List<String>> _instanceToSegmentsMap;\n+  private volatile Map<String, List<String>> _segmentToEnabledInstancesMap;\n+\n+  BaseInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    _tableNameWithType = tableNameWithType;\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(Set<String> enabledInstances, ExternalView externalView, Set<String> onlineSegments) {\n+    _enabledInstances = enabledInstances;\n+    onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Override\n+  public void onInstancesChange(Set<String> enabledInstances, List<String> changedInstances) {\n+    _enabledInstances = enabledInstances;\n+\n+    // Update all segments served by the changed instances\n+    Set<String> segmentsToUpdate = new HashSet<>();\n+    Map<String, List<String>> instanceToSegmentsMap = _instanceToSegmentsMap;\n+    for (String instance : changedInstances) {\n+      List<String> segments = instanceToSegmentsMap.get(instance);\n+      if (segments != null) {\n+        segmentsToUpdate.addAll(segments);\n+      }\n+    }\n+\n+    // Directly return if no segment needs to be updated\n+    if (segmentsToUpdate.isEmpty()) {\n+      return;\n+    }\n+\n+    // Generate a new map from segment to enabled instances\n+    Map<String, List<String>> segmentToInstancesMap = _segmentToInstancesMap;\n+    Map<String, List<String>> segmentToEnabledInstancesMap = _segmentToEnabledInstancesMap;\n+    Map<String, List<String>> newSegmentToEnabledInstancesMap =\n+        new HashMap<>(HashUtil.getHashMapCapacity(segmentToEnabledInstancesMap.size()));\n+    for (Map.Entry<String, List<String>> entry : segmentToEnabledInstancesMap.entrySet()) {\n+      String segment = entry.getKey();\n+      if (segmentsToUpdate.contains(segment)) {\n+        newSegmentToEnabledInstancesMap.put(segment,\n+            calculateEnabledInstancesForSegment(segment, segmentToInstancesMap.get(segment), enabledInstances));\n+      } else {\n+        newSegmentToEnabledInstancesMap.put(segment, entry.getValue());\n+      }\n+    }\n+    _segmentToEnabledInstancesMap = newSegmentToEnabledInstancesMap;\n+  }\n+\n+  @Override\n+  public void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzA3NQ=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MTQ2Nw==", "bodyText": "We don't need to skip segments not in the ideal state in the instance selector because they won't be selected in the instance selector. I excluded them to save the calculation for the unnecessary segments. While, maybe the overhead of the map lookup is higher, and because that is causing confusion, I just removed this check.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376651467", "createdAt": "2020-02-07T23:15:44Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BaseInstanceSelector.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+abstract class BaseInstanceSelector implements InstanceSelector {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(BaseInstanceSelector.class);\n+\n+  // To prevent int overflow, reset the request id once it reaches this value\n+  private static final int MAX_REQUEST_ID = 1_000_000_000;\n+\n+  private final AtomicLong _requestId = new AtomicLong();\n+  private final String _tableNameWithType;\n+  private final BrokerMetrics _brokerMetrics;\n+\n+  private volatile Set<String> _enabledInstances;\n+  private volatile Map<String, List<String>> _segmentToInstancesMap;\n+  private volatile Map<String, List<String>> _instanceToSegmentsMap;\n+  private volatile Map<String, List<String>> _segmentToEnabledInstancesMap;\n+\n+  BaseInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    _tableNameWithType = tableNameWithType;\n+    _brokerMetrics = brokerMetrics;\n+  }\n+\n+  @Override\n+  public void init(Set<String> enabledInstances, ExternalView externalView, Set<String> onlineSegments) {\n+    _enabledInstances = enabledInstances;\n+    onExternalViewChange(externalView, onlineSegments);\n+  }\n+\n+  @Override\n+  public void onInstancesChange(Set<String> enabledInstances, List<String> changedInstances) {\n+    _enabledInstances = enabledInstances;\n+\n+    // Update all segments served by the changed instances\n+    Set<String> segmentsToUpdate = new HashSet<>();\n+    Map<String, List<String>> instanceToSegmentsMap = _instanceToSegmentsMap;\n+    for (String instance : changedInstances) {\n+      List<String> segments = instanceToSegmentsMap.get(instance);\n+      if (segments != null) {\n+        segmentsToUpdate.addAll(segments);\n+      }\n+    }\n+\n+    // Directly return if no segment needs to be updated\n+    if (segmentsToUpdate.isEmpty()) {\n+      return;\n+    }\n+\n+    // Generate a new map from segment to enabled instances\n+    Map<String, List<String>> segmentToInstancesMap = _segmentToInstancesMap;\n+    Map<String, List<String>> segmentToEnabledInstancesMap = _segmentToEnabledInstancesMap;\n+    Map<String, List<String>> newSegmentToEnabledInstancesMap =\n+        new HashMap<>(HashUtil.getHashMapCapacity(segmentToEnabledInstancesMap.size()));\n+    for (Map.Entry<String, List<String>> entry : segmentToEnabledInstancesMap.entrySet()) {\n+      String segment = entry.getKey();\n+      if (segmentsToUpdate.contains(segment)) {\n+        newSegmentToEnabledInstancesMap.put(segment,\n+            calculateEnabledInstancesForSegment(segment, segmentToInstancesMap.get(segment), enabledInstances));\n+      } else {\n+        newSegmentToEnabledInstancesMap.put(segment, entry.getValue());\n+      }\n+    }\n+    _segmentToEnabledInstancesMap = newSegmentToEnabledInstancesMap;\n+  }\n+\n+  @Override\n+  public void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzA3NQ=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMyMTQ3OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BalancedInstanceSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0MjoxNlrOFmsu-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzowMjo0OFrOFnMwhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzEzMQ==", "bodyText": "Can this really be null? Before we enter this function, we already selected the segments to use for a given query. Right? This function selects the hosts/instances for those set of selected segments. There should be at least one instance on which the segment is enabled right?\nAlso, javadoc for this function would be good for future readers.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376123131", "createdAt": "2020-02-06T22:42:16Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BalancedInstanceSelector.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector to balance the number of segments served by each selected server instance.\n+ * <p>The selection algorithm will always evenly distribute the traffic to all replicas of each segment, and will try\n+ * to select different replica id for each segment. The algorithm is very light-weight and will do best effort to\n+ * balance the number of segments served by each selected server instance.\n+ */\n+public class BalancedInstanceSelector extends BaseInstanceSelector {\n+\n+  public BalancedInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    super(tableNameWithType, brokerMetrics);\n+  }\n+\n+  @Override\n+  Map<String, String> select(List<String> segments, int requestId,\n+      Map<String, List<String>> segmentToEnabledInstancesMap) {\n+    Map<String, String> segmentToSelectedInstanceMap = new HashMap<>(HashUtil.getHashMapCapacity(segments.size()));\n+    for (String segment : segments) {\n+      List<String> enabledInstances = segmentToEnabledInstancesMap.get(segment);\n+      if (enabledInstances != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0NzgxNQ==", "bodyText": "No, this can be null when there is no enabled instances for the segment (in which case we log a warning and emit metrics), or the instance selector has not been updated (we update all components for routing in sequence).\nAdded comments", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376647815", "createdAt": "2020-02-07T23:02:48Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/instanceselector/BalancedInstanceSelector.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.instanceselector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector to balance the number of segments served by each selected server instance.\n+ * <p>The selection algorithm will always evenly distribute the traffic to all replicas of each segment, and will try\n+ * to select different replica id for each segment. The algorithm is very light-weight and will do best effort to\n+ * balance the number of segments served by each selected server instance.\n+ */\n+public class BalancedInstanceSelector extends BaseInstanceSelector {\n+\n+  public BalancedInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    super(tableNameWithType, brokerMetrics);\n+  }\n+\n+  @Override\n+  Map<String, String> select(List<String> segments, int requestId,\n+      Map<String, List<String>> segmentToEnabledInstancesMap) {\n+    Map<String, String> segmentToSelectedInstanceMap = new HashMap<>(HashUtil.getHashMapCapacity(segments.size()));\n+    for (String segment : segments) {\n+      List<String> enabledInstances = segmentToEnabledInstancesMap.get(segment);\n+      if (enabledInstances != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzEzMQ=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMyMjA0OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0MjoyOVrOFmsvUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToxNjo1MVrOFnKirw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzIxOA==", "bodyText": "With this new class, what happens to HelixExternalViewBasedRouiting? How is this different from HelixExternalViewBasedRouting?\nThat class also implements ClusterChangeHandler interface. Is the plan to make this an abstract class and have HelixExternalViewBasedRouting extend it or do we plan to remove it?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376123218", "createdAt": "2020-02-06T22:42:29Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMTUwMw==", "bodyText": "The implementation in this pr will replace everything under the package org.apache.pinot.broker.routing once we plug them in", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376611503", "createdAt": "2020-02-07T21:16:51Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/RoutingManager.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixConstants;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.store.zk.ZkHelixPropertyStore;\n+import org.apache.pinot.broker.broker.helix.ClusterChangeHandler;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelector;\n+import org.apache.pinot.broker.routing.v2.instanceselector.InstanceSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPruner;\n+import org.apache.pinot.broker.routing.v2.segmentpruner.SegmentPrunerFactory;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelector;\n+import org.apache.pinot.broker.routing.v2.segmentselector.SegmentSelectorFactory;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryInfo;\n+import org.apache.pinot.broker.routing.v2.timeboundary.TimeBoundaryManager;\n+import org.apache.pinot.common.config.TableConfig;\n+import org.apache.pinot.common.config.TableNameBuilder;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.pinot.common.metrics.BrokerMeter;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.request.BrokerRequest;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.RealtimeSegmentOnlineOfflineStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+import org.apache.pinot.core.transport.ServerInstance;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@code RoutingManager} manages the routing of all tables hosted by the broker instance.\n+ */\n+public class RoutingManager implements ClusterChangeHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzIxOA=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMyNjAzOnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentselector/SegmentSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0Mzo1OVrOFmsxrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo1OTo1MVrOFnNlpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzgyMA==", "bodyText": "Can we not enhance the existing SegmentSelector?", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376123820", "createdAt": "2020-02-06T22:43:59Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentselector/SegmentSelector.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentselector;\n+\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+/**\n+ * The segment selector selects the segments for the query. The segments selected should cover the whole dataset (table)\n+ * without overlap.\n+ */\n+public interface SegmentSelector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MTQxMg==", "bodyText": "The current SegmentSelector is not wired up, and serves different purpose. In the future, that should be integrated into this segment selector.", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376661412", "createdAt": "2020-02-07T23:59:51Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/segmentselector/SegmentSelector.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.segmentselector;\n+\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.pinot.common.request.BrokerRequest;\n+\n+\n+/**\n+ * The segment selector selects the segments for the query. The segments selected should cover the whole dataset (table)\n+ * without overlap.\n+ */\n+public interface SegmentSelector {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMzgyMA=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjMyNzg5OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/timeboundary/TimeBoundaryInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo0NDo0OFrOFmsy2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDowMTo1MlrOFnNnNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNDEyMg==", "bodyText": "This exact same class is already there in the code", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376124122", "createdAt": "2020-02-06T22:44:48Z", "author": {"login": "siddharthteotia"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/timeboundary/TimeBoundaryInfo.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.timeboundary;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MTgxMg==", "bodyText": "Yes. The purpose of this pr is to directly replace all the existing implementation, so I made a copy of all the needed classes. (Also don't want to make it a sub-class of an interface).", "url": "https://github.com/apache/pinot/pull/5046#discussion_r376661812", "createdAt": "2020-02-08T00:01:52Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/v2/timeboundary/TimeBoundaryInfo.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.v2.timeboundary;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNDEyMg=="}, "originalCommit": {"oid": "e60e9f19a7cca30a2f7950f6094c72a3d37c20f6"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3672, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}