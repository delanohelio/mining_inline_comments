{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MDkxMTI4", "number": 5856, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwMTozMzoxMVrOEY3RVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwMTozNjo0NFrOEY3THw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTA2ODM3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/TableResizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwMTozMzoxMVrOHBXMFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzozNTowOVrOHBzT3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5MDU0OQ==", "bodyText": "what does it mean to have ORDER BY a literal? can you give an example?", "url": "https://github.com/apache/pinot/pull/5856#discussion_r471190549", "createdAt": "2020-08-17T01:33:11Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/TableResizer.java", "diffHunk": "@@ -98,14 +93,37 @@\n     };\n   }\n \n+  /**\n+   * Helper method to construct a OrderByValueExtractor based on the given expression.\n+   */\n+  private OrderByValueExtractor getOrderByValueExtractor(ExpressionContext expression) {\n+    if (expression.getType() == ExpressionContext.Type.LITERAL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1MTI5NQ==", "bodyText": "Order-by with literal itself does not make a lot of sense, but post-aggregation might contain literal (e.g. ORDER BY SUM(col1) * 2 - SUM(col2))", "url": "https://github.com/apache/pinot/pull/5856#discussion_r471651295", "createdAt": "2020-08-17T17:35:09Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/TableResizer.java", "diffHunk": "@@ -98,14 +93,37 @@\n     };\n   }\n \n+  /**\n+   * Helper method to construct a OrderByValueExtractor based on the given expression.\n+   */\n+  private OrderByValueExtractor getOrderByValueExtractor(ExpressionContext expression) {\n+    if (expression.getType() == ExpressionContext.Type.LITERAL) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5MDU0OQ=="}, "originalCommit": {"oid": "75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTA3Mjk1OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/TableResizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwMTozNjo0NFrOHBXOkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzo1MjoyNVrOHBz4aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5MTE4Ng==", "bodyText": "why using assert instead of Preconditions.checkState?", "url": "https://github.com/apache/pinot/pull/5856#discussion_r471191186", "createdAt": "2020-08-17T01:36:44Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/TableResizer.java", "diffHunk": "@@ -28,66 +28,61 @@\n import java.util.List;\n import java.util.Map;\n import java.util.PriorityQueue;\n-import java.util.function.Function;\n import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.query.aggregation.function.AggregationFunction;\n+import org.apache.pinot.core.query.postaggregation.PostAggregationFunction;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FunctionContext;\n import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n \n \n /**\n  * Helper class for trimming and sorting records in the IndexedTable, based on the order by information\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class TableResizer {\n+  private final DataSchema _dataSchema;\n+  private final int _numGroupByExpressions;\n+  private final Map<ExpressionContext, Integer> _groupByExpressionIndexMap;\n+  private final AggregationFunction[] _aggregationFunctions;\n+  private final Map<FunctionContext, Integer> _aggregationFunctionIndexMap;\n+  private final int _numOrderByExpressions;\n   private final OrderByValueExtractor[] _orderByValueExtractors;\n   private final Comparator<IntermediateRecord> _intermediateRecordComparator;\n-  private final int _numOrderByExpressions;\n \n-  TableResizer(DataSchema dataSchema, AggregationFunction[] aggregationFunctions,\n-      List<OrderByExpressionContext> orderByExpressions) {\n+  public TableResizer(DataSchema dataSchema, QueryContext queryContext) {\n+    _dataSchema = dataSchema;\n \n-    // NOTE: the assumption here is that the key columns will appear before the aggregation columns in the data schema\n-    // This is handled in the only in the AggregationGroupByOrderByOperator for now\n+    // NOTE: The data schema will always have group-by expressions in the front, followed by aggregation functions of\n+    //       the same order as in the query context. This is handled in AggregationGroupByOrderByOperator.\n \n-    int numColumns = dataSchema.size();\n-    int numAggregations = aggregationFunctions.length;\n-    int numKeyColumns = numColumns - numAggregations;\n-\n-    Map<String, Integer> columnIndexMap = new HashMap<>();\n-    Map<String, AggregationFunction> aggregationColumnToFunction = new HashMap<>();\n-    for (int i = 0; i < numColumns; i++) {\n-      String columnName = dataSchema.getColumnName(i);\n-      columnIndexMap.put(columnName, i);\n-      if (i >= numKeyColumns) {\n-        aggregationColumnToFunction.put(columnName, aggregationFunctions[i - numKeyColumns]);\n-      }\n+    List<ExpressionContext> groupByExpressions = queryContext.getGroupByExpressions();\n+    assert groupByExpressions != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2MDY0OQ==", "bodyText": "I usually use assert to indicate that the value is not possible to be null, which has zero run-time impact, and use checkState to verify certain states", "url": "https://github.com/apache/pinot/pull/5856#discussion_r471660649", "createdAt": "2020-08-17T17:52:25Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/TableResizer.java", "diffHunk": "@@ -28,66 +28,61 @@\n import java.util.List;\n import java.util.Map;\n import java.util.PriorityQueue;\n-import java.util.function.Function;\n import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.query.aggregation.function.AggregationFunction;\n+import org.apache.pinot.core.query.postaggregation.PostAggregationFunction;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FunctionContext;\n import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n \n \n /**\n  * Helper class for trimming and sorting records in the IndexedTable, based on the order by information\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class TableResizer {\n+  private final DataSchema _dataSchema;\n+  private final int _numGroupByExpressions;\n+  private final Map<ExpressionContext, Integer> _groupByExpressionIndexMap;\n+  private final AggregationFunction[] _aggregationFunctions;\n+  private final Map<FunctionContext, Integer> _aggregationFunctionIndexMap;\n+  private final int _numOrderByExpressions;\n   private final OrderByValueExtractor[] _orderByValueExtractors;\n   private final Comparator<IntermediateRecord> _intermediateRecordComparator;\n-  private final int _numOrderByExpressions;\n \n-  TableResizer(DataSchema dataSchema, AggregationFunction[] aggregationFunctions,\n-      List<OrderByExpressionContext> orderByExpressions) {\n+  public TableResizer(DataSchema dataSchema, QueryContext queryContext) {\n+    _dataSchema = dataSchema;\n \n-    // NOTE: the assumption here is that the key columns will appear before the aggregation columns in the data schema\n-    // This is handled in the only in the AggregationGroupByOrderByOperator for now\n+    // NOTE: The data schema will always have group-by expressions in the front, followed by aggregation functions of\n+    //       the same order as in the query context. This is handled in AggregationGroupByOrderByOperator.\n \n-    int numColumns = dataSchema.size();\n-    int numAggregations = aggregationFunctions.length;\n-    int numKeyColumns = numColumns - numAggregations;\n-\n-    Map<String, Integer> columnIndexMap = new HashMap<>();\n-    Map<String, AggregationFunction> aggregationColumnToFunction = new HashMap<>();\n-    for (int i = 0; i < numColumns; i++) {\n-      String columnName = dataSchema.getColumnName(i);\n-      columnIndexMap.put(columnName, i);\n-      if (i >= numKeyColumns) {\n-        aggregationColumnToFunction.put(columnName, aggregationFunctions[i - numKeyColumns]);\n-      }\n+    List<ExpressionContext> groupByExpressions = queryContext.getGroupByExpressions();\n+    assert groupByExpressions != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5MTE4Ng=="}, "originalCommit": {"oid": "75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3978, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}