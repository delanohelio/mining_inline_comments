{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MzAyNDMx", "number": 5364, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMDoyOToxNlrOD7ZJzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoxMjozNFrOD7uXfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjA0Njg3OnYy", "diffSide": "RIGHT", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMDoyOToxNlrOGTsL7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjo0ODo0NlrOGTwDng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwMDA3OQ==", "bodyText": "Seems like AggregationFunctionUtils.getArguments first creates List, then converts to String[], and here we are doing the reverse, creating [] from List. Is that not redundant? Or is it because of more callers of getArguments() benefit if it returns String[]?", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423300079", "createdAt": "2020-05-11T20:29:16Z", "author": {"login": "mayankshriv"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -456,9 +457,9 @@ private void handleCaseSensitivity(BrokerRequest brokerRequest) {\n       for (AggregationInfo info : brokerRequest.getAggregationsInfo()) {\n         if (!info.getAggregationType().equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n           // Always read from backward compatible api in AggregationFunctionUtils.\n-          List<String> expressions = AggregationFunctionUtils.getAggregationExpressions(info);\n+          String[] expressions = AggregationFunctionUtils.getArguments(info);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MzQ4Ng==", "bodyText": "Changed it back to List. For the new format, no conversion is required. For the old backward-compatible format, there will be an array to list conversion, which is fine.", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423363486", "createdAt": "2020-05-11T22:48:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -456,9 +457,9 @@ private void handleCaseSensitivity(BrokerRequest brokerRequest) {\n       for (AggregationInfo info : brokerRequest.getAggregationsInfo()) {\n         if (!info.getAggregationType().equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n           // Always read from backward compatible api in AggregationFunctionUtils.\n-          List<String> expressions = AggregationFunctionUtils.getAggregationExpressions(info);\n+          String[] expressions = AggregationFunctionUtils.getArguments(info);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwMDA3OQ=="}, "originalCommit": {"oid": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjEyNDY4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMDo1MzowMlrOGTs9cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjo1MDo0MlrOGTwGAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxMjc1Mg==", "bodyText": "Are there other callers of this api, other than Star tree? If not, then may be better to throw exception?", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423312752", "createdAt": "2020-05-11T20:53:02Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -128,6 +79,29 @@ public static AggregationFunctionContext getAggregationFunctionContext(Aggregati\n     return aggregationFunctions;\n   }\n \n+  /**\n+   * Creates an {@link AggregationFunctionColumnPair} from the {@link AggregationFunction}. Returns {@code null} if\n+   * the {@link AggregationFunction} cannot be represented as an {@link AggregationFunctionColumnPair} (e.g. has\n+   * multiple arguments, argument is not column etc.).\n+   */\n+  @Nullable\n+  public static AggregationFunctionColumnPair getAggregationFunctionColumnPair(\n+      AggregationFunction aggregationFunction) {\n+    AggregationFunctionType aggregationFunctionType = aggregationFunction.getType();\n+    if (aggregationFunctionType == AggregationFunctionType.COUNT) {\n+      return AggregationFunctionColumnPair.COUNT_STAR;\n+    }\n+    //noinspection unchecked\n+    List<TransformExpressionTree> inputExpressions = aggregationFunction.getInputExpressions();\n+    if (inputExpressions.size() == 1) {\n+      TransformExpressionTree inputExpression = inputExpressions.get(0);\n+      if (inputExpression.isColumn()) {\n+        return new AggregationFunctionColumnPair(aggregationFunctionType, inputExpression.getValue());\n+      }\n+    }\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2NDA5Ng==", "bodyText": "This is for star-tree only, but we use it to check whether the query can be solved by star-tree. We use null to notify the caller that the function cannot be solved by star-tree.", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423364096", "createdAt": "2020-05-11T22:50:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -128,6 +79,29 @@ public static AggregationFunctionContext getAggregationFunctionContext(Aggregati\n     return aggregationFunctions;\n   }\n \n+  /**\n+   * Creates an {@link AggregationFunctionColumnPair} from the {@link AggregationFunction}. Returns {@code null} if\n+   * the {@link AggregationFunction} cannot be represented as an {@link AggregationFunctionColumnPair} (e.g. has\n+   * multiple arguments, argument is not column etc.).\n+   */\n+  @Nullable\n+  public static AggregationFunctionColumnPair getAggregationFunctionColumnPair(\n+      AggregationFunction aggregationFunction) {\n+    AggregationFunctionType aggregationFunctionType = aggregationFunction.getType();\n+    if (aggregationFunctionType == AggregationFunctionType.COUNT) {\n+      return AggregationFunctionColumnPair.COUNT_STAR;\n+    }\n+    //noinspection unchecked\n+    List<TransformExpressionTree> inputExpressions = aggregationFunction.getInputExpressions();\n+    if (inputExpressions.size() == 1) {\n+      TransformExpressionTree inputExpression = inputExpressions.get(0);\n+      if (inputExpression.isColumn()) {\n+        return new AggregationFunctionColumnPair(aggregationFunctionType, inputExpression.getValue());\n+      }\n+    }\n+    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxMjc1Mg=="}, "originalCommit": {"oid": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjEzNDI4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleExpressionAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMDo1NTo0MFrOGTtDRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjo1MjoyOVrOGTwIIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNDI0Ng==", "bodyText": "SingleInput instead?", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423314246", "createdAt": "2020-05-11T20:55:40Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleExpressionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+\n+\n+/**\n+ * Base implementation of {@link AggregationFunction} with single expression.\n+ */\n+public abstract class BaseSingleExpressionAggregationFunction<I, F extends Comparable> implements AggregationFunction<I, F> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2NDY0Mw==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423364643", "createdAt": "2020-05-11T22:52:29Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleExpressionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+\n+\n+/**\n+ * Base implementation of {@link AggregationFunction} with single expression.\n+ */\n+public abstract class BaseSingleExpressionAggregationFunction<I, F extends Comparable> implements AggregationFunction<I, F> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNDI0Ng=="}, "originalCommit": {"oid": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjE0MzQyOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMDo1ODo0MVrOGTtJWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjo1Mzo1M1rOGTwKAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNTgwMw==", "bodyText": "Most aggregations today take single input. Converting them into expression trees may penalize the common case?", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423315803", "createdAt": "2020-05-11T20:58:41Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "diffHunk": "@@ -188,13 +186,13 @@ public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int ma\n \n   @Override\n   public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n-      Map<String, BlockValSet> blockValSetMap) {\n+      Map<TransformExpressionTree, BlockValSet> blockValSetMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2NTEyMw==", "bodyText": "We get the expressions from AggregationFunction.getInputExpressions(), which is already compiled. We only compile the expression once.", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423365123", "createdAt": "2020-05-11T22:53:53Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "diffHunk": "@@ -188,13 +186,13 @@ public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int ma\n \n   @Override\n   public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n-      Map<String, BlockValSet> blockValSetMap) {\n+      Map<TransformExpressionTree, BlockValSet> blockValSetMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNTgwMw=="}, "originalCommit": {"oid": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTQ4ODI0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjowNDozMlrOGUN97A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODozMTowNFrOGUTrVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzU0OA==", "bodyText": "Do we agree that there will be some (may be marginal only) overhead in terms of computing equals() on TransformExpressionTree (which will compare the expression type and the expression value which is column name for the general case)? Earlier it was being done directly on String identifier. Same goes for hashcode.", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423853548", "createdAt": "2020-05-12T16:04:32Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "diffHunk": "@@ -104,23 +104,23 @@ public AggregationResultHolder createAggregationResultHolder() {\n \n   @Override\n   public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n-      Map<String, BlockValSet> blockValSetMap) {\n-    int numColumns = _columns.length;\n+      Map<TransformExpressionTree, BlockValSet> blockValSetMap) {\n     int numBlockValSets = blockValSetMap.size();\n-    Preconditions.checkState(numBlockValSets == numColumns, \"Size mismatch: numBlockValSets = %s, numColumns = %s\",\n-        numBlockValSets, numColumns);\n-\n-    DistinctTable distinctTable = aggregationResultHolder.getResult();\n-    BlockValSet[] blockValSets = new BlockValSet[numColumns];\n-\n-    for (int i = 0; i < numColumns; i++) {\n-      blockValSets[i] = blockValSetMap.get(_columns[i]);\n+    int numExpressions = _inputExpressions.size();\n+    Preconditions\n+        .checkState(numBlockValSets == numExpressions, \"Size mismatch: numBlockValSets = %s, numExpressions = %s\",\n+            numBlockValSets, numExpressions);\n+\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      blockValSets[i] = blockValSetMap.get(_inputExpressions.get(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27dbef6b45d0d9d60483d619d10c05b41d5b2595"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0NzA5Mg==", "bodyText": "For column (not function expression), there might be minimal overhead (overhead should be much smaller comparing to creating the map). For function expression, IMO comparing TransformExpressionTree should be cheaper comparing to the expression string.\nAlso, here we saved the overhead of converting expression to string, so directly using expression should give better performance.", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423947092", "createdAt": "2020-05-12T18:31:04Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "diffHunk": "@@ -104,23 +104,23 @@ public AggregationResultHolder createAggregationResultHolder() {\n \n   @Override\n   public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n-      Map<String, BlockValSet> blockValSetMap) {\n-    int numColumns = _columns.length;\n+      Map<TransformExpressionTree, BlockValSet> blockValSetMap) {\n     int numBlockValSets = blockValSetMap.size();\n-    Preconditions.checkState(numBlockValSets == numColumns, \"Size mismatch: numBlockValSets = %s, numColumns = %s\",\n-        numBlockValSets, numColumns);\n-\n-    DistinctTable distinctTable = aggregationResultHolder.getResult();\n-    BlockValSet[] blockValSets = new BlockValSet[numColumns];\n-\n-    for (int i = 0; i < numColumns; i++) {\n-      blockValSets[i] = blockValSetMap.get(_columns[i]);\n+    int numExpressions = _inputExpressions.size();\n+    Preconditions\n+        .checkState(numBlockValSets == numExpressions, \"Size mismatch: numBlockValSets = %s, numExpressions = %s\",\n+            numBlockValSets, numExpressions);\n+\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      blockValSets[i] = blockValSetMap.get(_inputExpressions.get(i));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzU0OA=="}, "originalCommit": {"oid": "27dbef6b45d0d9d60483d619d10c05b41d5b2595"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTUxODY5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoxMTo0MFrOGUORiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo0MzozOFrOGUYNxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1ODU2OA==", "bodyText": "Why do we need these special checks for 0 and 1?\nIIUC, instead of executing the for loop once for numExpressions == 1, you are using a branch. Can we just have the loop? It will be much cleaner unless I am missing the performance benefit of doing it this way. Loop will take care of returning the empty map, map with 1 KV pair or more", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423858568", "createdAt": "2020-05-12T16:11:40Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -181,37 +162,63 @@ public static int parsePercentile(String percentileString) {\n    * @param arguments Arguments to concatenate\n    * @return Concatenated String of arguments\n    */\n-  public static String concatArgs(List<String> arguments) {\n-    return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n-        : arguments.get(0);\n+  public static String concatArgs(String[] arguments) {\n+    return arguments.length > 1 ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n+        : arguments[0];\n   }\n \n   /**\n-   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n-   * and order-by\n-   *\n-   * @param brokerRequest Broker Request\n-   * @param functionContexts Aggregation Function contexts\n-   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   * Collects all transform expressions required for aggregation/group-by queries.\n+   * <p>NOTE: We don't need to consider order-by columns here as the ordering is only allowed for aggregation functions\n+   *          or group-by expressions.\n    */\n-  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n-      AggregationFunctionContext[] functionContexts) {\n-\n-    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n-    for (AggregationFunctionContext functionContext : functionContexts) {\n-      AggregationFunction function = functionContext.getAggregationFunction();\n-      expressionTrees.addAll(function.getInputExpressions());\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(AggregationFunction[] aggregationFunctions,\n+      @Nullable TransformExpressionTree[] groupByExpressions) {\n+    Set<TransformExpressionTree> expressions = new HashSet<>();\n+    for (AggregationFunction aggregationFunction : aggregationFunctions) {\n+      //noinspection unchecked\n+      expressions.addAll(aggregationFunction.getInputExpressions());\n+    }\n+    if (groupByExpressions != null) {\n+      expressions.addAll(Arrays.asList(groupByExpressions));\n     }\n+    return expressions;\n+  }\n \n-    // Extract group-by expressions\n-    if (brokerRequest.isSetGroupBy()) {\n-      for (String expression : brokerRequest.getGroupBy().getExpressions()) {\n-        expressionTrees.add(TransformExpressionTree.compileToExpressionTree(expression));\n-      }\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunction} to {@link BlockValSet} fetched from the\n+   * {@link TransformBlock}.\n+   */\n+  public static Map<TransformExpressionTree, BlockValSet> getBlockValSetMap(AggregationFunction aggregationFunction,\n+      TransformBlock transformBlock) {\n+    //noinspection unchecked\n+    List<TransformExpressionTree> expressions = aggregationFunction.getInputExpressions();\n+    int numExpressions = expressions.size();\n+    if (numExpressions == 0) {\n+      return Collections.emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27dbef6b45d0d9d60483d619d10c05b41d5b2595"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0OTQ3Ng==", "bodyText": "We can use loop, but that will always create a HashMap, where all the operations are much more expensive than EmptyMap and SingletonMap. Because most of the functions are zero (COUNT(*)) or single input expression, this should give better performance.", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423949476", "createdAt": "2020-05-12T18:35:13Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -181,37 +162,63 @@ public static int parsePercentile(String percentileString) {\n    * @param arguments Arguments to concatenate\n    * @return Concatenated String of arguments\n    */\n-  public static String concatArgs(List<String> arguments) {\n-    return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n-        : arguments.get(0);\n+  public static String concatArgs(String[] arguments) {\n+    return arguments.length > 1 ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n+        : arguments[0];\n   }\n \n   /**\n-   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n-   * and order-by\n-   *\n-   * @param brokerRequest Broker Request\n-   * @param functionContexts Aggregation Function contexts\n-   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   * Collects all transform expressions required for aggregation/group-by queries.\n+   * <p>NOTE: We don't need to consider order-by columns here as the ordering is only allowed for aggregation functions\n+   *          or group-by expressions.\n    */\n-  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n-      AggregationFunctionContext[] functionContexts) {\n-\n-    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n-    for (AggregationFunctionContext functionContext : functionContexts) {\n-      AggregationFunction function = functionContext.getAggregationFunction();\n-      expressionTrees.addAll(function.getInputExpressions());\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(AggregationFunction[] aggregationFunctions,\n+      @Nullable TransformExpressionTree[] groupByExpressions) {\n+    Set<TransformExpressionTree> expressions = new HashSet<>();\n+    for (AggregationFunction aggregationFunction : aggregationFunctions) {\n+      //noinspection unchecked\n+      expressions.addAll(aggregationFunction.getInputExpressions());\n+    }\n+    if (groupByExpressions != null) {\n+      expressions.addAll(Arrays.asList(groupByExpressions));\n     }\n+    return expressions;\n+  }\n \n-    // Extract group-by expressions\n-    if (brokerRequest.isSetGroupBy()) {\n-      for (String expression : brokerRequest.getGroupBy().getExpressions()) {\n-        expressionTrees.add(TransformExpressionTree.compileToExpressionTree(expression));\n-      }\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunction} to {@link BlockValSet} fetched from the\n+   * {@link TransformBlock}.\n+   */\n+  public static Map<TransformExpressionTree, BlockValSet> getBlockValSetMap(AggregationFunction aggregationFunction,\n+      TransformBlock transformBlock) {\n+    //noinspection unchecked\n+    List<TransformExpressionTree> expressions = aggregationFunction.getInputExpressions();\n+    int numExpressions = expressions.size();\n+    if (numExpressions == 0) {\n+      return Collections.emptyMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1ODU2OA=="}, "originalCommit": {"oid": "27dbef6b45d0d9d60483d619d10c05b41d5b2595"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMTQ0NA==", "bodyText": "Got it. Thanks", "url": "https://github.com/apache/pinot/pull/5364#discussion_r424021444", "createdAt": "2020-05-12T20:43:38Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -181,37 +162,63 @@ public static int parsePercentile(String percentileString) {\n    * @param arguments Arguments to concatenate\n    * @return Concatenated String of arguments\n    */\n-  public static String concatArgs(List<String> arguments) {\n-    return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n-        : arguments.get(0);\n+  public static String concatArgs(String[] arguments) {\n+    return arguments.length > 1 ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n+        : arguments[0];\n   }\n \n   /**\n-   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n-   * and order-by\n-   *\n-   * @param brokerRequest Broker Request\n-   * @param functionContexts Aggregation Function contexts\n-   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   * Collects all transform expressions required for aggregation/group-by queries.\n+   * <p>NOTE: We don't need to consider order-by columns here as the ordering is only allowed for aggregation functions\n+   *          or group-by expressions.\n    */\n-  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n-      AggregationFunctionContext[] functionContexts) {\n-\n-    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n-    for (AggregationFunctionContext functionContext : functionContexts) {\n-      AggregationFunction function = functionContext.getAggregationFunction();\n-      expressionTrees.addAll(function.getInputExpressions());\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(AggregationFunction[] aggregationFunctions,\n+      @Nullable TransformExpressionTree[] groupByExpressions) {\n+    Set<TransformExpressionTree> expressions = new HashSet<>();\n+    for (AggregationFunction aggregationFunction : aggregationFunctions) {\n+      //noinspection unchecked\n+      expressions.addAll(aggregationFunction.getInputExpressions());\n+    }\n+    if (groupByExpressions != null) {\n+      expressions.addAll(Arrays.asList(groupByExpressions));\n     }\n+    return expressions;\n+  }\n \n-    // Extract group-by expressions\n-    if (brokerRequest.isSetGroupBy()) {\n-      for (String expression : brokerRequest.getGroupBy().getExpressions()) {\n-        expressionTrees.add(TransformExpressionTree.compileToExpressionTree(expression));\n-      }\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunction} to {@link BlockValSet} fetched from the\n+   * {@link TransformBlock}.\n+   */\n+  public static Map<TransformExpressionTree, BlockValSet> getBlockValSetMap(AggregationFunction aggregationFunction,\n+      TransformBlock transformBlock) {\n+    //noinspection unchecked\n+    List<TransformExpressionTree> expressions = aggregationFunction.getInputExpressions();\n+    int numExpressions = expressions.size();\n+    if (numExpressions == 0) {\n+      return Collections.emptyMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1ODU2OA=="}, "originalCommit": {"oid": "27dbef6b45d0d9d60483d619d10c05b41d5b2595"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTUyMjU0OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoxMjozNFrOGUOT_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODozNzoyMVrOGUT5Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1OTE5OA==", "bodyText": "(nit) - For better readability, consider putting \"for star tree\" at the beginning something like This function is used in start tree code path only", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423859198", "createdAt": "2020-05-12T16:12:34Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -181,37 +162,63 @@ public static int parsePercentile(String percentileString) {\n    * @param arguments Arguments to concatenate\n    * @return Concatenated String of arguments\n    */\n-  public static String concatArgs(List<String> arguments) {\n-    return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n-        : arguments.get(0);\n+  public static String concatArgs(String[] arguments) {\n+    return arguments.length > 1 ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n+        : arguments[0];\n   }\n \n   /**\n-   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n-   * and order-by\n-   *\n-   * @param brokerRequest Broker Request\n-   * @param functionContexts Aggregation Function contexts\n-   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   * Collects all transform expressions required for aggregation/group-by queries.\n+   * <p>NOTE: We don't need to consider order-by columns here as the ordering is only allowed for aggregation functions\n+   *          or group-by expressions.\n    */\n-  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n-      AggregationFunctionContext[] functionContexts) {\n-\n-    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n-    for (AggregationFunctionContext functionContext : functionContexts) {\n-      AggregationFunction function = functionContext.getAggregationFunction();\n-      expressionTrees.addAll(function.getInputExpressions());\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(AggregationFunction[] aggregationFunctions,\n+      @Nullable TransformExpressionTree[] groupByExpressions) {\n+    Set<TransformExpressionTree> expressions = new HashSet<>();\n+    for (AggregationFunction aggregationFunction : aggregationFunctions) {\n+      //noinspection unchecked\n+      expressions.addAll(aggregationFunction.getInputExpressions());\n+    }\n+    if (groupByExpressions != null) {\n+      expressions.addAll(Arrays.asList(groupByExpressions));\n     }\n+    return expressions;\n+  }\n \n-    // Extract group-by expressions\n-    if (brokerRequest.isSetGroupBy()) {\n-      for (String expression : brokerRequest.getGroupBy().getExpressions()) {\n-        expressionTrees.add(TransformExpressionTree.compileToExpressionTree(expression));\n-      }\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunction} to {@link BlockValSet} fetched from the\n+   * {@link TransformBlock}.\n+   */\n+  public static Map<TransformExpressionTree, BlockValSet> getBlockValSetMap(AggregationFunction aggregationFunction,\n+      TransformBlock transformBlock) {\n+    //noinspection unchecked\n+    List<TransformExpressionTree> expressions = aggregationFunction.getInputExpressions();\n+    int numExpressions = expressions.size();\n+    if (numExpressions == 0) {\n+      return Collections.emptyMap();\n     }\n+    if (numExpressions == 1) {\n+      TransformExpressionTree expression = expressions.get(0);\n+      return Collections.singletonMap(expression, transformBlock.getBlockValueSet(expression));\n+    }\n+    Map<TransformExpressionTree, BlockValSet> blockValSetMap = new HashMap<>();\n+    for (TransformExpressionTree expression : expressions) {\n+      blockValSetMap.put(expression, transformBlock.getBlockValueSet(expression));\n+    }\n+    return blockValSetMap;\n+  }\n \n-    // TODO: Add order-by expressions when available in brokerRequest for aggregation queries.\n-    // The current order-by implementation assumes that ordering will be on aggregation/group-by columns.\n-    return expressionTrees;\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunctionColumnPair} to {@link BlockValSet} fetched\n+   * from the {@link TransformBlock} (for star-tree).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27dbef6b45d0d9d60483d619d10c05b41d5b2595"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1MDY1NA==", "bodyText": "Done", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423950654", "createdAt": "2020-05-12T18:37:21Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -181,37 +162,63 @@ public static int parsePercentile(String percentileString) {\n    * @param arguments Arguments to concatenate\n    * @return Concatenated String of arguments\n    */\n-  public static String concatArgs(List<String> arguments) {\n-    return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n-        : arguments.get(0);\n+  public static String concatArgs(String[] arguments) {\n+    return arguments.length > 1 ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n+        : arguments[0];\n   }\n \n   /**\n-   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n-   * and order-by\n-   *\n-   * @param brokerRequest Broker Request\n-   * @param functionContexts Aggregation Function contexts\n-   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   * Collects all transform expressions required for aggregation/group-by queries.\n+   * <p>NOTE: We don't need to consider order-by columns here as the ordering is only allowed for aggregation functions\n+   *          or group-by expressions.\n    */\n-  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n-      AggregationFunctionContext[] functionContexts) {\n-\n-    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n-    for (AggregationFunctionContext functionContext : functionContexts) {\n-      AggregationFunction function = functionContext.getAggregationFunction();\n-      expressionTrees.addAll(function.getInputExpressions());\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(AggregationFunction[] aggregationFunctions,\n+      @Nullable TransformExpressionTree[] groupByExpressions) {\n+    Set<TransformExpressionTree> expressions = new HashSet<>();\n+    for (AggregationFunction aggregationFunction : aggregationFunctions) {\n+      //noinspection unchecked\n+      expressions.addAll(aggregationFunction.getInputExpressions());\n+    }\n+    if (groupByExpressions != null) {\n+      expressions.addAll(Arrays.asList(groupByExpressions));\n     }\n+    return expressions;\n+  }\n \n-    // Extract group-by expressions\n-    if (brokerRequest.isSetGroupBy()) {\n-      for (String expression : brokerRequest.getGroupBy().getExpressions()) {\n-        expressionTrees.add(TransformExpressionTree.compileToExpressionTree(expression));\n-      }\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunction} to {@link BlockValSet} fetched from the\n+   * {@link TransformBlock}.\n+   */\n+  public static Map<TransformExpressionTree, BlockValSet> getBlockValSetMap(AggregationFunction aggregationFunction,\n+      TransformBlock transformBlock) {\n+    //noinspection unchecked\n+    List<TransformExpressionTree> expressions = aggregationFunction.getInputExpressions();\n+    int numExpressions = expressions.size();\n+    if (numExpressions == 0) {\n+      return Collections.emptyMap();\n     }\n+    if (numExpressions == 1) {\n+      TransformExpressionTree expression = expressions.get(0);\n+      return Collections.singletonMap(expression, transformBlock.getBlockValueSet(expression));\n+    }\n+    Map<TransformExpressionTree, BlockValSet> blockValSetMap = new HashMap<>();\n+    for (TransformExpressionTree expression : expressions) {\n+      blockValSetMap.put(expression, transformBlock.getBlockValueSet(expression));\n+    }\n+    return blockValSetMap;\n+  }\n \n-    // TODO: Add order-by expressions when available in brokerRequest for aggregation queries.\n-    // The current order-by implementation assumes that ordering will be on aggregation/group-by columns.\n-    return expressionTrees;\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunctionColumnPair} to {@link BlockValSet} fetched\n+   * from the {@link TransformBlock} (for star-tree).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1OTE5OA=="}, "originalCommit": {"oid": "27dbef6b45d0d9d60483d619d10c05b41d5b2595"}, "originalPosition": 243}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3260, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}