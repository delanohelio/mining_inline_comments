{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMjU2MzI5", "number": 6050, "title": "Minion taskExecutor for RealtimeToOfflineSegments task", "bodyText": "#5753\nThe minion task executor which receives\n\nsegments (from realtime tables)\na time window\nAnd then creates Pinot segments using data from that time window.\n\nUses the SegmentProcessorFramework. Applies:\n\nTime column transformations as configured in PinotTaskConfig\nPartitioning as specified in table config\nData sorting as specified in table config\nAggregations across common dimension+time, as configured in the PinotTaskConfig\n\nNext steps:\nRealtimeToOfflineSegmentsTaskGenerator", "createdAt": "2020-09-23T00:10:23Z", "url": "https://github.com/apache/pinot/pull/6050", "merged": true, "mergeCommit": {"oid": "a0dcc662363e156d01bd6f199d2c66ff74dfa6d2"}, "closed": true, "closedAt": "2020-09-30T18:34:56Z", "author": {"login": "npawar"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLvoBHgH2gAyNDkxMjU2MzI5OjQ0MzVhNTczNWY2OGI2ZmJiNzllNWZlYWVmM2JlMDY2YWQyZGI2ZmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOAjAugH2gAyNDkxMjU2MzI5OmM2OTVhYjJmMDZmZTNhZjEzZGFmMTdhM2UzZTM2Njk5YmQ0NzRiODk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4435a5735f68b6fbb79e5feaef3be066ad2db6fb", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/4435a5735f68b6fbb79e5feaef3be066ad2db6fb", "committedDate": "2020-09-23T16:59:39Z", "message": "Minion taskExecutor for RealtimeToOfflineSegments task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/1010a8f3ac7717c63fd16fba600152fec7b31f32", "committedDate": "2020-09-23T17:02:30Z", "message": "Fix compilation issue"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "96fa857b8e0b36c03f4968ecdbdf6aba3ccdd6aa", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/96fa857b8e0b36c03f4968ecdbdf6aba3ccdd6aa", "committedDate": "2020-09-23T00:03:17Z", "message": "Minion taskExecutor for RealtimeToOfflineSegments task"}, "afterCommit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/1010a8f3ac7717c63fd16fba600152fec7b31f32", "committedDate": "2020-09-23T17:02:30Z", "message": "Fix compilation issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NzI5ODE4", "url": "https://github.com/apache/pinot/pull/6050#pullrequestreview-495729818", "createdAt": "2020-09-24T16:06:18Z", "commit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNjowNjoxOFrOHXiJYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODoxMDowN1rOHXmu1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQzODc1NA==", "bodyText": "Can you use Preconditions instead of assert? Some runtime environments turns assert off. Thanks.", "url": "https://github.com/apache/pinot/pull/6050#discussion_r494438754", "createdAt": "2020-09-24T16:06:18Z", "author": {"login": "mcvsubbu"}, "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0MTU5NQ==", "bodyText": "Good to add a duration in this log.", "url": "https://github.com/apache/pinot/pull/6050#discussion_r494441595", "createdAt": "2020-09-24T16:10:35Z", "author": {"login": "mcvsubbu"}, "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    LOGGER.info(\"Finished task: {} with configs: {}\", taskType, configs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxMzg3OA==", "bodyText": "why this check, given that we are pulling from tableconfig (at least in this task). If you are checking, then you should perhaps also check that this sorted column is not same as one of the aggregation columns?", "url": "https://github.com/apache/pinot/pull/6050#discussion_r494513878", "createdAt": "2020-09-24T18:10:07Z", "author": {"login": "mcvsubbu"}, "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    LOGGER.info(\"Finished task: {} with configs: {}\", taskType, configs);\n+    List<SegmentConversionResult> results = new ArrayList<>();\n+    for (File file : outputSegmentsDir.listFiles()) {\n+      String outputSegmentName = file.getName();\n+      results.add(new SegmentConversionResult.Builder().setFile(file).setSegmentName(outputSegmentName)\n+          .setTableNameWithType(tableNameWithType).build());\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Construct a {@link RecordTransformerConfig} for time column transformation\n+   */\n+  private RecordTransformerConfig getRecordTransformerConfigForTime(String timeColumnTransformFunction,\n+      String timeColumn) {\n+    Map<String, String> transformationsMap = new HashMap<>();\n+    transformationsMap.put(timeColumn, timeColumnTransformFunction);\n+    return new RecordTransformerConfig.Builder().setTransformFunctionsMap(transformationsMap).build();\n+  }\n+\n+  /**\n+   * Construct a {@link RecordFilterConfig} by setting a filter function on the time column, for extracting data between window start/end\n+   */\n+  private RecordFilterConfig getRecordFilterConfigForWindow(long windowStartMs, long windowEndMs,\n+      DateTimeFieldSpec dateTimeFieldSpec, String timeColumn) {\n+    String filterFunction;\n+    DateTimeFormatSpec dateTimeFormatSpec = new DateTimeFormatSpec(dateTimeFieldSpec.getFormat());\n+    TimeUnit timeUnit = dateTimeFormatSpec.getColumnUnit();\n+    DateTimeFieldSpec.TimeFormat timeFormat = dateTimeFormatSpec.getTimeFormat();\n+    if (timeUnit.equals(TimeUnit.MILLISECONDS) && timeFormat.equals(DateTimeFieldSpec.TimeFormat.EPOCH)) {\n+      // If time column is in EPOCH millis, use windowStart and windowEnd directly to filter\n+      filterFunction = getFilterFunctionLong(windowStartMs, windowEndMs, timeColumn);\n+    } else {\n+      // Convert windowStart and windowEnd to time format of the data\n+      if (dateTimeFormatSpec.getTimeFormat().equals(DateTimeFieldSpec.TimeFormat.EPOCH)) {\n+        long windowStart = dateTimeFormatSpec.fromMillisToFormat(windowStartMs, Long.class);\n+        long windowEnd = dateTimeFormatSpec.fromMillisToFormat(windowEndMs, Long.class);\n+        filterFunction = getFilterFunctionLong(windowStart, windowEnd, timeColumn);\n+      } else {\n+        String windowStart = dateTimeFormatSpec.fromMillisToFormat(windowStartMs, String.class);\n+        String windowEnd = dateTimeFormatSpec.fromMillisToFormat(windowEndMs, String.class);\n+        if (dateTimeFieldSpec.getDataType().isNumeric()) {\n+          filterFunction = getFilterFunctionLong(Long.parseLong(windowStart), Long.parseLong(windowEnd), timeColumn);\n+        } else {\n+          filterFunction = getFilterFunctionString(windowStart, windowEnd, timeColumn);\n+        }\n+      }\n+    }\n+    return new RecordFilterConfig.Builder().setRecordFilterType(RecordFilterFactory.RecordFilterType.FILTER_FUNCTION)\n+        .setFilterFunction(filterFunction).build();\n+  }\n+\n+  /**\n+   * Construct a {@link PartitionerConfig} using {@link org.apache.pinot.spi.config.table.SegmentPartitionConfig} from the table config\n+   */\n+  private PartitionerConfig getPartitionerConfig(Map<String, ColumnPartitionConfig> columnPartitionMap,\n+      String tableNameWithType, Set<String> schemaColumns) {\n+\n+    Preconditions.checkState(columnPartitionMap.size() == 1,\n+        \"Cannot partition using more than 1 ColumnPartitionConfig for table: %s\", tableNameWithType);\n+    String partitionColumn = columnPartitionMap.keySet().iterator().next();\n+    Preconditions.checkState(schemaColumns.contains(partitionColumn),\n+        \"Partition column: %s is not a physical column in the schema\", partitionColumn);\n+    return new PartitionerConfig.Builder().setPartitionerType(PartitionerFactory.PartitionerType.TABLE_PARTITION_CONFIG)\n+        .setColumnName(partitionColumn).setColumnPartitionConfig(columnPartitionMap.get(partitionColumn)).build();\n+  }\n+\n+  /**\n+   * Construct a {@link CollectorConfig} using configured collector configs and sorted columns from table config\n+   */\n+  private CollectorConfig getCollectorConfig(String collectorTypeStr, Map<String, String> aggregateConfigs,\n+      Set<String> schemaColumns, List<String> sortedColumns) {\n+    CollectorFactory.CollectorType collectorType = collectorTypeStr == null ? CollectorFactory.CollectorType.CONCAT\n+        : CollectorFactory.CollectorType.valueOf(collectorTypeStr.toUpperCase());\n+\n+    Map<String, ValueAggregatorFactory.ValueAggregatorType> aggregatorTypeMap = new HashMap<>();\n+    for (Map.Entry<String, String> entry : aggregateConfigs.entrySet()) {\n+      String column = entry.getKey();\n+      Preconditions\n+          .checkState(schemaColumns.contains(column), \"Aggregate column: %s is not a physical column in the schema\",\n+              column);\n+      aggregatorTypeMap.put(column, ValueAggregatorFactory.ValueAggregatorType.valueOf(entry.getValue().toUpperCase()));\n+    }\n+\n+    if (sortedColumns != null) {\n+      for (String column : sortedColumns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "originalPosition": 241}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3OTExOTIz", "url": "https://github.com/apache/pinot/pull/6050#pullrequestreview-497911923", "createdAt": "2020-09-28T21:33:42Z", "commit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMTozMzo0MlrOHZQaYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDoxNjoyMlrOHZ_izA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NTM0Nw==", "bodyText": "maxNumRecordsPerSegment makes more sense since this configuration is indeed the upper bound of the number of rows in the segment", "url": "https://github.com/apache/pinot/pull/6050#discussion_r496245347", "createdAt": "2020-09-28T21:33:42Z", "author": {"login": "snleee"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/common/MinionConstants.java", "diffHunk": "@@ -61,4 +61,17 @@ private MinionConstants() {\n     public static final String MERGE_TYPE_KEY = \"mergeTypeKey\";\n     public static final String MERGED_SEGMENT_NAME_KEY = \"mergedSegmentNameKey\";\n   }\n+\n+  public static class RealtimeToOfflineSegmentsTask {\n+    public static final String TASK_TYPE = \"realtimeToOfflineSegmentsTask\";\n+    // window\n+    public static final String WINDOW_START_MILLIS_KEY = \"windowStartMillis\";\n+    public static final String WINDOW_END_MILLIS_KEY = \"windowEndMillis\";\n+    // segment processing\n+    public static final String TIME_COLUMN_TRANSFORM_FUNCTION_KEY = \"timeColumnTransformFunction\";\n+    public static final String COLLECTOR_TYPE_KEY = \"collectorType\";\n+    public static final String AGGREGATION_TYPE_KEY_SUFFIX = \".aggregationType\";\n+    public static final String NUM_RECORDS_PER_SEGMENT_KEY = \"numRecordsPerSegment\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMzI1MQ==", "bodyText": "Does this mean that we will drop the late data once the data from a window get moved to offline?\ne.g.\n\nday1 gets moved to offline table\nday1 data arrived late (this row shows up in the result because of realtime table will index and serve this row)\nday2 gets moved to offline table (the above late data will be dropped by the filter)", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497013251", "createdAt": "2020-09-29T20:08:10Z", "author": {"login": "snleee"}, "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    LOGGER.info(\"Finished task: {} with configs: {}\", taskType, configs);\n+    List<SegmentConversionResult> results = new ArrayList<>();\n+    for (File file : outputSegmentsDir.listFiles()) {\n+      String outputSegmentName = file.getName();\n+      results.add(new SegmentConversionResult.Builder().setFile(file).setSegmentName(outputSegmentName)\n+          .setTableNameWithType(tableNameWithType).build());\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Construct a {@link RecordTransformerConfig} for time column transformation\n+   */\n+  private RecordTransformerConfig getRecordTransformerConfigForTime(String timeColumnTransformFunction,\n+      String timeColumn) {\n+    Map<String, String> transformationsMap = new HashMap<>();\n+    transformationsMap.put(timeColumn, timeColumnTransformFunction);\n+    return new RecordTransformerConfig.Builder().setTransformFunctionsMap(transformationsMap).build();\n+  }\n+\n+  /**\n+   * Construct a {@link RecordFilterConfig} by setting a filter function on the time column, for extracting data between window start/end\n+   */\n+  private RecordFilterConfig getRecordFilterConfigForWindow(long windowStartMs, long windowEndMs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNjIwNw==", "bodyText": "+1", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497016207", "createdAt": "2020-09-29T20:13:56Z", "author": {"login": "snleee"}, "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    LOGGER.info(\"Finished task: {} with configs: {}\", taskType, configs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0MTU5NQ=="}, "originalCommit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNzU0OA==", "bodyText": "Let's move the segment processing framework related configs to a static separate class. These configs will also be used by other tasks.", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497017548", "createdAt": "2020-09-29T20:16:22Z", "author": {"login": "snleee"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/common/MinionConstants.java", "diffHunk": "@@ -61,4 +61,17 @@ private MinionConstants() {\n     public static final String MERGE_TYPE_KEY = \"mergeTypeKey\";\n     public static final String MERGED_SEGMENT_NAME_KEY = \"mergedSegmentNameKey\";\n   }\n+\n+  public static class RealtimeToOfflineSegmentsTask {\n+    public static final String TASK_TYPE = \"realtimeToOfflineSegmentsTask\";\n+    // window", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e29fdda136d4fe982f502ffe4aa4ff7b448dfe43", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/e29fdda136d4fe982f502ffe4aa4ff7b448dfe43", "committedDate": "2020-09-29T22:53:16Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NjIyMTg4", "url": "https://github.com/apache/pinot/pull/6050#pullrequestreview-499622188", "createdAt": "2020-09-30T16:42:37Z", "commit": {"oid": "e29fdda136d4fe982f502ffe4aa4ff7b448dfe43"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjo0MjozN1rOHamVqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjo0MjozN1rOHamVqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MzE2Mw==", "bodyText": "remove line", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497653163", "createdAt": "2020-09-30T16:42:37Z", "author": {"login": "snleee"}, "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+    long startMillis = System.currentTimeMillis();\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    Preconditions\n+        .checkState(dateTimeFieldSpec != null, \"No valid spec found for time column: %s in schema for table: %s\",\n+            timeColumn, tableNameWithType);\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.MAX_NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    long endMillis = System.currentTimeMillis();\n+    LOGGER.info(\"Finished task: {} with configs: {}. Total time: {}ms\", taskType, configs, (endMillis - startMillis));\n+    List<SegmentConversionResult> results = new ArrayList<>();\n+    for (File file : outputSegmentsDir.listFiles()) {\n+      String outputSegmentName = file.getName();\n+      results.add(new SegmentConversionResult.Builder().setFile(file).setSegmentName(outputSegmentName)\n+          .setTableNameWithType(tableNameWithType).build());\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Construct a {@link RecordTransformerConfig} for time column transformation\n+   */\n+  private RecordTransformerConfig getRecordTransformerConfigForTime(String timeColumnTransformFunction,\n+      String timeColumn) {\n+    Map<String, String> transformationsMap = new HashMap<>();\n+    transformationsMap.put(timeColumn, timeColumnTransformFunction);\n+    return new RecordTransformerConfig.Builder().setTransformFunctionsMap(transformationsMap).build();\n+  }\n+\n+  /**\n+   * Construct a {@link RecordFilterConfig} by setting a filter function on the time column, for extracting data between window start/end\n+   */\n+  private RecordFilterConfig getRecordFilterConfigForWindow(long windowStartMs, long windowEndMs,\n+      DateTimeFieldSpec dateTimeFieldSpec, String timeColumn) {\n+    String filterFunction;\n+    DateTimeFormatSpec dateTimeFormatSpec = new DateTimeFormatSpec(dateTimeFieldSpec.getFormat());\n+    TimeUnit timeUnit = dateTimeFormatSpec.getColumnUnit();\n+    DateTimeFieldSpec.TimeFormat timeFormat = dateTimeFormatSpec.getTimeFormat();\n+    if (timeUnit.equals(TimeUnit.MILLISECONDS) && timeFormat.equals(DateTimeFieldSpec.TimeFormat.EPOCH)) {\n+      // If time column is in EPOCH millis, use windowStart and windowEnd directly to filter\n+      filterFunction = getFilterFunctionLong(windowStartMs, windowEndMs, timeColumn);\n+    } else {\n+      // Convert windowStart and windowEnd to time format of the data\n+      if (dateTimeFormatSpec.getTimeFormat().equals(DateTimeFieldSpec.TimeFormat.EPOCH)) {\n+        long windowStart = dateTimeFormatSpec.fromMillisToFormat(windowStartMs, Long.class);\n+        long windowEnd = dateTimeFormatSpec.fromMillisToFormat(windowEndMs, Long.class);\n+        filterFunction = getFilterFunctionLong(windowStart, windowEnd, timeColumn);\n+      } else {\n+        String windowStart = dateTimeFormatSpec.fromMillisToFormat(windowStartMs, String.class);\n+        String windowEnd = dateTimeFormatSpec.fromMillisToFormat(windowEndMs, String.class);\n+        if (dateTimeFieldSpec.getDataType().isNumeric()) {\n+          filterFunction = getFilterFunctionLong(Long.parseLong(windowStart), Long.parseLong(windowEnd), timeColumn);\n+        } else {\n+          filterFunction = getFilterFunctionString(windowStart, windowEnd, timeColumn);\n+        }\n+      }\n+    }\n+    return new RecordFilterConfig.Builder().setRecordFilterType(RecordFilterFactory.RecordFilterType.FILTER_FUNCTION)\n+        .setFilterFunction(filterFunction).build();\n+  }\n+\n+  /**\n+   * Construct a {@link PartitionerConfig} using {@link org.apache.pinot.spi.config.table.SegmentPartitionConfig} from the table config\n+   */\n+  private PartitionerConfig getPartitionerConfig(Map<String, ColumnPartitionConfig> columnPartitionMap,\n+      String tableNameWithType, Set<String> schemaColumns) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e29fdda136d4fe982f502ffe4aa4ff7b448dfe43"}, "originalPosition": 217}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c695ab2f06fe3af13daf17a3e3e36699bd474b89", "author": {"user": {"login": "npawar", "name": "Neha Pawar"}}, "url": "https://github.com/apache/pinot/commit/c695ab2f06fe3af13daf17a3e3e36699bd474b89", "committedDate": "2020-09-30T17:50:25Z", "message": "Remove line"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 97, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}