{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExOTM1Njc0", "number": 6208, "title": "Add StrictReplicaGroupInstanceSelector", "bodyText": "Description\nRecently we have introduced some features which require all the segments from the same partition to be processed by the same server. For example, upsert (#4261) feature requires all the segments for a partition loaded on a single server before starting serving queries to ensure result correctness. The Strict Replica-Group Routing is designed to meet this requirement.\nThis PR is the routing side change of the Strict Replica-Group Routing, which is handled in the StrictReplicaGroupInstanceSelector class.\nThe new algorithm relies on the ideal state of the table, so this PR added the ideal state to the routing interfaces.", "createdAt": "2020-10-29T00:34:22Z", "url": "https://github.com/apache/pinot/pull/6208", "merged": true, "mergeCommit": {"oid": "413b7cb294a59628a2233c6c593295f817c33455"}, "closed": true, "closedAt": "2020-11-01T09:54:01Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXLW45gFqTUxOTI3MzU1NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdYK-MYABqjM5NDQ4OTg0OTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MjczNTU1", "url": "https://github.com/apache/pinot/pull/6208#pullrequestreview-519273555", "createdAt": "2020-10-29T01:45:02Z", "commit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMTo0NTowMlrOHqECyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNToyOToxNVrOHqLJJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg2ODQ4OA==", "bodyText": "noinspection -> No inspection", "url": "https://github.com/apache/pinot/pull/6208#discussion_r513868488", "createdAt": "2020-10-29T01:45:02Z", "author": {"login": "yupeng9"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -284,6 +278,7 @@ private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {\n     if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.IS_SHUTDOWN_IN_PROGRESS))) {\n       return false;\n     }\n+    //noinspection RedundantIfStatement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg3MDAwMA==", "bodyText": "onlineSegments can be derived from idealState ?", "url": "https://github.com/apache/pinot/pull/6208#discussion_r513870000", "createdAt": "2020-10-29T01:48:59Z", "author": {"login": "yupeng9"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/BaseInstanceSelector.java", "diffHunk": "@@ -126,47 +128,28 @@ public void onInstancesChange(Set<String> enabledInstances, List<String> changed\n    * {@inheritDoc}\n    *\n    * <p>Updates the cached maps ({@code segmentToOnlineInstancesMap}, {@code segmentToOfflineInstancesMap} and\n-   * {@code instanceToSegmentsMap}) based on the given ExternalView and re-calculates\n-   * {@code segmentToEnabledInstancesMap} and {@code unavailableSegments} based on the cached states.\n+   * {@code instanceToSegmentsMap}) and re-calculates {@code segmentToEnabledInstancesMap} and\n+   * {@code unavailableSegments} based on the cached states.\n    */\n   @Override\n-  public void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {\n-    Map<String, Map<String, String>> segmentAssignment = externalView.getRecord().getMapFields();\n-    int numSegments = segmentAssignment.size();\n-    _segmentToOnlineInstancesMap = new HashMap<>(HashUtil.getHashMapCapacity(numSegments));\n-    _segmentToOfflineInstancesMap = new HashMap<>(HashUtil.getHashMapCapacity(numSegments));\n+  public void onExternalViewChange(ExternalView externalView, IdealState idealState, Set<String> onlineSegments) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDgwNA==", "bodyText": "high-level comment, since this is to calculate the map based on the coarse-grained unit (i.e. replica group) instead of the segment, have you considered mapping the online segments to the replica groups first, and then use the groups for selection?", "url": "https://github.com/apache/pinot/pull/6208#discussion_r513984804", "createdAt": "2020-10-29T05:29:15Z", "author": {"login": "yupeng9"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.IdealState;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.SegmentStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for strict replica-group routing strategy.\n+ *\n+ * <pre>\n+ * The strict replica-group routing strategy always routes the query to the instances within the same replica-group.\n+ * (Note that the replica-group information is derived from the ideal state of the table, where the instances are sorted\n+ * alphabetically in the instance state map, so the replica-groups in the instance selector might not match the\n+ * replica-groups in the instance partitions.) The instances in a replica-group should have all the online segments\n+ * (segments with ONLINE/CONSUMING instances in the ideal state and selected by the pre-selector) available\n+ * (ONLINE/CONSUMING in the external view) in order to serve queries. If any segment is unavailable in the\n+ * replica-group, we mark the whole replica-group down and not serve queries with this replica-group.\n+ *\n+ * The selection algorithm is the same as {@link ReplicaGroupInstanceSelector}, and will always evenly distribute the\n+ * traffic to all replica-groups that have all online segments available.\n+ *\n+ * The algorithm relies on the mirror segment assignment from replica-group segment assignment strategy. With mirror\n+ * segment assignment, any server in one replica-group will always have a corresponding server in other replica-groups\n+ * that have the same segments assigned. For example, if S1 is a server in replica-group 1, and it has mirror server\n+ * S2 in replica-group 2 and S3 in replica-group 3. All segments assigned to S1 will also be assigned to S2 and S3. In\n+ * stable scenario (external view matches ideal state), all segments assigned to S1 will have the same enabled instances\n+ * of [S1, S2, S3] sorted (in alphabetical order). If we always pick the same index of enabled instances for all\n+ * segments, only one of S1, S2, S3 will be picked, and all the segments are processed by the same server. In\n+ * transitioning/error scenario (external view does not match ideal state), if a segment is down on S1, we mark all\n+ * segments with the same assignment ([S1, S2, S3]) down on S1 to ensure that we always route the segments to the same\n+ * replica-group.\n+ * </pre>\n+ */\n+public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSelector {\n+\n+  public StrictReplicaGroupInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    super(tableNameWithType, brokerMetrics);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * <pre>\n+   * The maps are calculated in the following steps to meet the strict replica-group guarantee:\n+   *   1. Create a map from online segment to set of instances hosting the segment based on the ideal state\n+   *   2. Gather the online and offline instances for each online segment from the external view\n+   *   3. Compare the instances from the ideal state and the external view and gather the unavailable instances for each\n+   *      set of instances\n+   *   4. Exclude the unavailable instances from the online instances map\n+   * </pre>\n+   */\n+  @Override\n+  void updateSegmentMaps(ExternalView externalView, IdealState idealState, Set<String> onlineSegments,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTk0MDcz", "url": "https://github.com/apache/pinot/pull/6208#pullrequestreview-520194073", "createdAt": "2020-10-30T00:13:36Z", "commit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTEyNjAz", "url": "https://github.com/apache/pinot/pull/6208#pullrequestreview-521112603", "createdAt": "2020-10-31T04:47:06Z", "commit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwNDo0NzowN1rOHrk52Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwNDo0NzowN1rOHrk52Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1NTQ0OQ==", "bodyText": "(1) Where do you utilize the fact instanceStateMap is a tree map? and why?\n(2) The ExternalView interface has the value type as a generic map. What happens if EV changes its implementation. Will it break the current impl?", "url": "https://github.com/apache/pinot/pull/6208#discussion_r515455449", "createdAt": "2020-10-31T04:47:07Z", "author": {"login": "chenboat"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.IdealState;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.SegmentStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for strict replica-group routing strategy.\n+ *\n+ * <pre>\n+ * The strict replica-group routing strategy always routes the query to the instances within the same replica-group.\n+ * (Note that the replica-group information is derived from the ideal state of the table, where the instances are sorted\n+ * alphabetically in the instance state map, so the replica-groups in the instance selector might not match the\n+ * replica-groups in the instance partitions.) The instances in a replica-group should have all the online segments\n+ * (segments with ONLINE/CONSUMING instances in the ideal state and selected by the pre-selector) available\n+ * (ONLINE/CONSUMING in the external view) in order to serve queries. If any segment is unavailable in the\n+ * replica-group, we mark the whole replica-group down and not serve queries with this replica-group.\n+ *\n+ * The selection algorithm is the same as {@link ReplicaGroupInstanceSelector}, and will always evenly distribute the\n+ * traffic to all replica-groups that have all online segments available.\n+ *\n+ * The algorithm relies on the mirror segment assignment from replica-group segment assignment strategy. With mirror\n+ * segment assignment, any server in one replica-group will always have a corresponding server in other replica-groups\n+ * that have the same segments assigned. For example, if S1 is a server in replica-group 1, and it has mirror server\n+ * S2 in replica-group 2 and S3 in replica-group 3. All segments assigned to S1 will also be assigned to S2 and S3. In\n+ * stable scenario (external view matches ideal state), all segments assigned to S1 will have the same enabled instances\n+ * of [S1, S2, S3] sorted (in alphabetical order). If we always pick the same index of enabled instances for all\n+ * segments, only one of S1, S2, S3 will be picked, and all the segments are processed by the same server. In\n+ * transitioning/error scenario (external view does not match ideal state), if a segment is down on S1, we mark all\n+ * segments with the same assignment ([S1, S2, S3]) down on S1 to ensure that we always route the segments to the same\n+ * replica-group.\n+ * </pre>\n+ */\n+public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSelector {\n+\n+  public StrictReplicaGroupInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    super(tableNameWithType, brokerMetrics);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * <pre>\n+   * The maps are calculated in the following steps to meet the strict replica-group guarantee:\n+   *   1. Create a map from online segment to set of instances hosting the segment based on the ideal state\n+   *   2. Gather the online and offline instances for each online segment from the external view\n+   *   3. Compare the instances from the ideal state and the external view and gather the unavailable instances for each\n+   *      set of instances\n+   *   4. Exclude the unavailable instances from the online instances map\n+   * </pre>\n+   */\n+  @Override\n+  void updateSegmentMaps(ExternalView externalView, IdealState idealState, Set<String> onlineSegments,\n+      Map<String, List<String>> segmentToOnlineInstancesMap, Map<String, List<String>> segmentToOfflineInstancesMap,\n+      Map<String, List<String>> instanceToSegmentsMap) {\n+    // Iterate over the ideal state to fill up 'idealStateSegmentToInstancesMap' which is a map from segment to set of\n+    // instances hosting the segment in the ideal state\n+    int segmentMapCapacity = HashUtil.getHashMapCapacity(onlineSegments.size());\n+    Map<String, Set<String>> idealStateSegmentToInstancesMap = new HashMap<>(segmentMapCapacity);\n+    for (Map.Entry<String, Map<String, String>> entry : idealState.getRecord().getMapFields().entrySet()) {\n+      String segment = entry.getKey();\n+      // Only track online segments\n+      if (!onlineSegments.contains(segment)) {\n+        continue;\n+      }\n+      idealStateSegmentToInstancesMap.put(segment, entry.getValue().keySet());\n+    }\n+\n+    // Iterate over the external view to fill up 'tempSegmentToOnlineInstancesMap' and 'segmentToOfflineInstancesMap'.\n+    // 'tempSegmentToOnlineInstancesMap' is a temporary map from segment to set of instances that are in the ideal state\n+    // and also ONLINE/CONSUMING in the external view. This map does not have the strict replica-group guarantee, and\n+    // will be used to calculate the final 'segmentToOnlineInstancesMap'.\n+    Map<String, Set<String>> tempSegmentToOnlineInstancesMap = new HashMap<>(segmentMapCapacity);\n+    for (Map.Entry<String, Map<String, String>> entry : externalView.getRecord().getMapFields().entrySet()) {\n+      String segment = entry.getKey();\n+      Set<String> instancesInIdealState = idealStateSegmentToInstancesMap.get(segment);\n+      // Only track online segments\n+      if (instancesInIdealState == null) {\n+        continue;\n+      }\n+      // NOTE: Instances will be sorted here because 'instanceStateMap' is a TreeMap.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTg4OTUy", "url": "https://github.com/apache/pinot/pull/6208#pullrequestreview-521188952", "createdAt": "2020-11-01T03:13:32Z", "commit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwMzoxMzozMlrOHrr1MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwMzoxMzozMlrOHrr1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU2ODk0NQ==", "bodyText": "There is a need to introduce a new abstraction to simplify this class \u2014 note that the new abstraction can not be replicaGroup as it is now. We are talking about segment to replica group mapping. It should greatly simplify the codes in this class. At it current form, it looks correct to me but it is way too complex and hard to understand. We should refactor it in the next iteration.", "url": "https://github.com/apache/pinot/pull/6208#discussion_r515568945", "createdAt": "2020-11-01T03:13:32Z", "author": {"login": "chenboat"}, "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.IdealState;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.SegmentStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for strict replica-group routing strategy.\n+ *\n+ * <pre>\n+ * The strict replica-group routing strategy always routes the query to the instances within the same replica-group.\n+ * (Note that the replica-group information is derived from the ideal state of the table, where the instances are sorted\n+ * alphabetically in the instance state map, so the replica-groups in the instance selector might not match the\n+ * replica-groups in the instance partitions.) The instances in a replica-group should have all the online segments\n+ * (segments with ONLINE/CONSUMING instances in the ideal state and selected by the pre-selector) available\n+ * (ONLINE/CONSUMING in the external view) in order to serve queries. If any segment is unavailable in the\n+ * replica-group, we mark the whole replica-group down and not serve queries with this replica-group.\n+ *\n+ * The selection algorithm is the same as {@link ReplicaGroupInstanceSelector}, and will always evenly distribute the\n+ * traffic to all replica-groups that have all online segments available.\n+ *\n+ * The algorithm relies on the mirror segment assignment from replica-group segment assignment strategy. With mirror\n+ * segment assignment, any server in one replica-group will always have a corresponding server in other replica-groups\n+ * that have the same segments assigned. For example, if S1 is a server in replica-group 1, and it has mirror server\n+ * S2 in replica-group 2 and S3 in replica-group 3. All segments assigned to S1 will also be assigned to S2 and S3. In\n+ * stable scenario (external view matches ideal state), all segments assigned to S1 will have the same enabled instances\n+ * of [S1, S2, S3] sorted (in alphabetical order). If we always pick the same index of enabled instances for all\n+ * segments, only one of S1, S2, S3 will be picked, and all the segments are processed by the same server. In\n+ * transitioning/error scenario (external view does not match ideal state), if a segment is down on S1, we mark all\n+ * segments with the same assignment ([S1, S2, S3]) down on S1 to ensure that we always route the segments to the same\n+ * replica-group.\n+ * </pre>\n+ */\n+public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSelector {\n+\n+  public StrictReplicaGroupInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    super(tableNameWithType, brokerMetrics);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * <pre>\n+   * The maps are calculated in the following steps to meet the strict replica-group guarantee:\n+   *   1. Create a map from online segment to set of instances hosting the segment based on the ideal state\n+   *   2. Gather the online and offline instances for each online segment from the external view\n+   *   3. Compare the instances from the ideal state and the external view and gather the unavailable instances for each\n+   *      set of instances\n+   *   4. Exclude the unavailable instances from the online instances map\n+   * </pre>\n+   */\n+  @Override\n+  void updateSegmentMaps(ExternalView externalView, IdealState idealState, Set<String> onlineSegments,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae8394f1781d4bc2e7194e4a6f093fe0629cefb4", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/ae8394f1781d4bc2e7194e4a6f093fe0629cefb4", "committedDate": "2020-11-01T05:26:39Z", "message": "Add StrictReplicaGroupInstanceSelector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06f959d11cc3544634beb7cc0d661bc3327fd627", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/06f959d11cc3544634beb7cc0d661bc3327fd627", "committedDate": "2020-10-29T00:26:46Z", "message": "Add StrictReplicaGroupInstanceSelector"}, "afterCommit": {"oid": "3635880a5ab7ca04bdbb126690e6ba8d524809cb", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/3635880a5ab7ca04bdbb126690e6ba8d524809cb", "committedDate": "2020-11-01T05:26:39Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTk3NTM5", "url": "https://github.com/apache/pinot/pull/6208#pullrequestreview-521197539", "createdAt": "2020-11-01T06:52:28Z", "commit": {"oid": "3635880a5ab7ca04bdbb126690e6ba8d524809cb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e64f1964dcc3c77cbe6c2b55bc43ffada7d48f4f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/e64f1964dcc3c77cbe6c2b55bc43ffada7d48f4f", "committedDate": "2020-11-01T07:37:51Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3635880a5ab7ca04bdbb126690e6ba8d524809cb", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/3635880a5ab7ca04bdbb126690e6ba8d524809cb", "committedDate": "2020-11-01T05:26:39Z", "message": "Address comments"}, "afterCommit": {"oid": "e64f1964dcc3c77cbe6c2b55bc43ffada7d48f4f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/e64f1964dcc3c77cbe6c2b55bc43ffada7d48f4f", "committedDate": "2020-11-01T07:37:51Z", "message": "Address comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1661, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}