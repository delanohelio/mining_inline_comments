{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NTEyOTIy", "number": 5019, "title": "Make output schema to match selection list for aggregation groupbys", "bodyText": "Query results schema should match select list.\nValidate that non-aggregate expression in select list must be in group by expressions.\nE.g.\n\nselect group_id , count(*), sum(rsvp_count),count(rsvp_count), sum(rsvp_count),ADD(group_id,1)  from meetupRsvp group by  group_id , ADD(group_id,1)   limit 10\n\nResults is\n{\n    \"resultTable\": {\n        \"dataSchema\": {\n            \"columnDataTypes\": [\"LONG\", \"LONG\", \"DOUBLE\", \"LONG\", \"DOUBLE\", \"DOUBLE\"],\n            \"columnNames\": [\"group_id\", \"count(*)\", \"sum(rsvp_count)\", \"count(*)\", \"sum(rsvp_count)\", \"add(group_id,'1')\"]\n        },\n        \"rows\": [\n            [263790, 2, 2.0, 2, 2.0, 263791.0],\n            [15915612, 1, 1.0, 1, 1.0, 1.5915613E7],\n            [1516787, 1, 1.0, 1, 1.0, 1516788.0],\n            [31461301, 1, 1.0, 1, 1.0, 3.1461302E7],\n            [3315552, 2, 2.0, 2, 2.0, 3315553.0],\n            [19068870, 1, 1.0, 1, 1.0, 1.9068871E7],\n            [252197, 1, 1.0, 1, 1.0, 252198.0],\n            [32449323, 1, 1.0, 1, 1.0, 3.2449324E7],\n            [31525187, 1, 1.0, 1, 1.0, 3.1525188E7],\n            [18402988, 1, 1.0, 1, 1.0, 1.8402989E7]\n        ]\n    },\n    \"exceptions\": [],\n    \"numServersQueried\": 1,\n    \"numServersResponded\": 1,\n    \"numSegmentsQueried\": 1,\n    \"numSegmentsProcessed\": 1,\n    \"numSegmentsMatched\": 1,\n    \"numConsumingSegmentsQueried\": 1,\n    \"numDocsScanned\": 163,\n    \"numEntriesScannedInFilter\": 0,\n    \"numEntriesScannedPostFilter\": 326,\n    \"numGroupsLimitReached\": true,\n    \"totalDocs\": 163,\n    \"timeUsedMs\": 18,\n    \"segmentStatistics\": [],\n    \"traceInfo\": {},\n    \"minConsumingFreshnessTimeMs\": 1580132510553\n}", "createdAt": "2020-01-27T14:12:15Z", "url": "https://github.com/apache/pinot/pull/5019", "merged": true, "mergeCommit": {"oid": "daf02ac82dce2aed403fd1a3ab1796621ba0b185"}, "closed": true, "closedAt": "2020-01-27T23:35:40Z", "author": {"login": "xiangfu0"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-dW86gH2gAyMzY3NTEyOTIyOjNhM2Q3MGNhNzhhYTcwMGE3YWY1ZWQwYTE3N2RiZDg3YzAzMDExZWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-jXVgAFqTM0ODk3NjcxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/3a3d70ca78aa700a7af5ed0a177dbd87c03011ed", "committedDate": "2020-01-27T14:10:33Z", "message": "Make output schema to match selection list for aggregation groupbys"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njk1Mzgx", "url": "https://github.com/apache/pinot/pull/5019#pullrequestreview-348695381", "createdAt": "2020-01-27T14:20:12Z", "commit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4OTE3NDgw", "url": "https://github.com/apache/pinot/pull/5019#pullrequestreview-348917480", "createdAt": "2020-01-27T19:28:55Z", "commit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToyODo1NlrOFiOtUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToyODo1NlrOFiOtUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNjg4MA==", "bodyText": "When will this if block be needed? These will always be in the group by clause, and hence be handled by 269 right?", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371436880", "createdAt": "2020-01-27T19:28:56Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {\n+            finalValues[i] = null;\n+          } else {\n+            finalValues[i] = values[finalSchemaMapIdx[i]];\n+          }\n+        }\n+        rows.add(finalValues);\n+      } else {\n+        rows.add(values);\n+      }\n       numRows++;\n     }\n \n     DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n+    if (_sqlSelectionList != null) {\n+      int columnSize = _sqlSelectionList.size();\n+      String[] columns = new String[columnSize];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n+      for (int i = 0; i < columnSize; i++) {\n+        if (finalSchemaMapIdx[i] == -1) {\n+          columns[i] = RequestUtils.prettyPrint(_sqlSelectionList.get(i));\n+          columnDataTypes[i] = DataSchema.ColumnDataType.STRING;\n+        } else {\n+          columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n+          columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        }\n+      }\n+      finalDataSchema = new DataSchema(columns, columnDataTypes);\n+    }\n     brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n   }\n \n+  /**\n+   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n+   * then aggregation functions.\n+   * @param dataSchema\n+   *\n+   * @return a mapping from final schema idx to corresponding idx in data table schema.\n+   */\n+  private int[] getFinalSchemaMapIdx(DataSchema dataSchema) {\n+    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n+    int nextAggregationIdx = _numGroupBy;\n+    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n+      finalSchemaMapIdx[i] = getExpressionMapIdx(dataSchema, _sqlSelectionList.get(i), nextAggregationIdx);\n+      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n+        nextAggregationIdx++;\n+      }\n+    }\n+    return finalSchemaMapIdx;\n+  }\n+\n+  private int getExpressionMapIdx(DataSchema dataSchema, Expression expression, int nextAggregationIdx) {\n+    // Check if expression matches groupBy list.\n+    int idxFromGroupByList = getGroupByIdx(_groupByList, expression);\n+    if (idxFromGroupByList != -1) {\n+      return idxFromGroupByList;\n+    }\n+    // Handle all functions\n+    if (expression.getFunctionCall() != null) {\n+      // handle AS\n+      if (expression.getFunctionCall().getOperator().equalsIgnoreCase(\"AS\")) {\n+        return getExpressionMapIdx(dataSchema, expression.getFunctionCall().getOperands().get(0), nextAggregationIdx);\n+      }\n+      // Return next aggregation idx.\n+      return nextAggregationIdx;\n+    }\n+    // Handle identifier, which is a column.\n+    if (expression.getIdentifier() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4OTE5Mzg5", "url": "https://github.com/apache/pinot/pull/5019#pullrequestreview-348919389", "createdAt": "2020-01-27T19:31:57Z", "commit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOTozMTo1OFrOFiOzqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOTozMTo1OFrOFiOzqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzODUwNA==", "bodyText": "this group by list will be scanned for every single expression in the selection. Do you think it's worth constructing a map upfront groupByExpr -> index , within getFinalSchemaIdx method?", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371438504", "createdAt": "2020-01-27T19:31:58Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {\n+            finalValues[i] = null;\n+          } else {\n+            finalValues[i] = values[finalSchemaMapIdx[i]];\n+          }\n+        }\n+        rows.add(finalValues);\n+      } else {\n+        rows.add(values);\n+      }\n       numRows++;\n     }\n \n     DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n+    if (_sqlSelectionList != null) {\n+      int columnSize = _sqlSelectionList.size();\n+      String[] columns = new String[columnSize];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n+      for (int i = 0; i < columnSize; i++) {\n+        if (finalSchemaMapIdx[i] == -1) {\n+          columns[i] = RequestUtils.prettyPrint(_sqlSelectionList.get(i));\n+          columnDataTypes[i] = DataSchema.ColumnDataType.STRING;\n+        } else {\n+          columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n+          columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        }\n+      }\n+      finalDataSchema = new DataSchema(columns, columnDataTypes);\n+    }\n     brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n   }\n \n+  /**\n+   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n+   * then aggregation functions.\n+   * @param dataSchema\n+   *\n+   * @return a mapping from final schema idx to corresponding idx in data table schema.\n+   */\n+  private int[] getFinalSchemaMapIdx(DataSchema dataSchema) {\n+    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n+    int nextAggregationIdx = _numGroupBy;\n+    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n+      finalSchemaMapIdx[i] = getExpressionMapIdx(dataSchema, _sqlSelectionList.get(i), nextAggregationIdx);\n+      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n+        nextAggregationIdx++;\n+      }\n+    }\n+    return finalSchemaMapIdx;\n+  }\n+\n+  private int getExpressionMapIdx(DataSchema dataSchema, Expression expression, int nextAggregationIdx) {\n+    // Check if expression matches groupBy list.\n+    int idxFromGroupByList = getGroupByIdx(_groupByList, expression);\n+    if (idxFromGroupByList != -1) {\n+      return idxFromGroupByList;\n+    }\n+    // Handle all functions\n+    if (expression.getFunctionCall() != null) {\n+      // handle AS\n+      if (expression.getFunctionCall().getOperator().equalsIgnoreCase(\"AS\")) {\n+        return getExpressionMapIdx(dataSchema, expression.getFunctionCall().getOperands().get(0), nextAggregationIdx);\n+      }\n+      // Return next aggregation idx.\n+      return nextAggregationIdx;\n+    }\n+    // Handle identifier, which is a column.\n+    if (expression.getIdentifier() != null) {\n+      String columnName = expression.getIdentifier().getName();\n+      for (int i = 0; i < dataSchema.size(); i++) {\n+        if (columnName.equalsIgnoreCase(dataSchema.getColumnName(i))) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  /**\n+   * Trying to match an expression based on given groupByList.\n+   *\n+   * @param groupByList\n+   * @param expression\n+   * @return matched idx from groupByList\n+   */\n+  private int getGroupByIdx(List<Expression> groupByList, Expression expression) {\n+    for (int i = 0; i < groupByList.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4OTIwOTY4", "url": "https://github.com/apache/pinot/pull/5019#pullrequestreview-348920968", "createdAt": "2020-01-27T19:34:34Z", "commit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOTozNDozNFrOFiO4tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOTozNDozNFrOFiO4tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzOTc5OA==", "bodyText": "should this ever happen? the validation during parsing should prevent this right?", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371439798", "createdAt": "2020-01-27T19:34:34Z", "author": {"login": "npawar"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c513258eb669782ba001beeb133488bdb9157c9", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/2c513258eb669782ba001beeb133488bdb9157c9", "committedDate": "2020-01-27T20:23:27Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b0e19d71bcfec5d3f905800431a0bc7b3fd2374c", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/b0e19d71bcfec5d3f905800431a0bc7b3fd2374c", "committedDate": "2020-01-27T20:23:11Z", "message": "address comments"}, "afterCommit": {"oid": "2c513258eb669782ba001beeb133488bdb9157c9", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/apache/pinot/commit/2c513258eb669782ba001beeb133488bdb9157c9", "committedDate": "2020-01-27T20:23:27Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4OTc2NzE4", "url": "https://github.com/apache/pinot/pull/5019#pullrequestreview-348976718", "createdAt": "2020-01-27T21:10:24Z", "commit": {"oid": "2c513258eb669782ba001beeb133488bdb9157c9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1546, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}