{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0ODk3Njc5", "number": 5832, "title": "Added set-diff operators and changed distinctCountThetaSketch syntax", "bodyText": "#5377  Description\nCurrently, the DISTINCTCOUNTTHETASKETCH aggregation function does not support SET_DIFF operations. This pull-request addresses this gap.\nHowever, this commit does introduce a backwards-incompatible change. We are suggesting to change the syntax a bit to the following:\nSELECT DISTINCTCOUNTTHETASKETCH(col, 'nominalEntries=4096', 'predicate1', 'predicate2', 'SET_DIFF($1, $2)')\n  FROM table\n  WHERE predicate1 OR predicate2;\nWe are introducing 3 \"merging functions\" into the Pinot aggregation function:\n\nSET_UNION\nSET_INTERSECT\nSET_DIFF\n\nUpgrade Notes\nDoes this PR prevent a zero down-time upgrade? (Assume upgrade order: Controller, Broker, Server, Minion)\n\n Yes (Please label as backward-incompat, and complete the section below on Release Notes)\n\nDoes this PR fix a zero-downtime upgrade introduced earlier?\n\n Yes (Please label this as backward-incompat, and complete the section below on Release Notes)\n\nDoes this PR otherwise need attention when creating release notes? Things to consider:\n\nNew configuration options\nDeprecation of configurations\nSignature changes to public methods/interfaces\nNew plugins added or old plugins removed\n\n\n Yes (Please label this PR as release-notes and complete the section on Release Notes)\n\nRelease Notes\nThis patch introduces a new syntax to the recently introduced DISTINCTCOUNTTHETASKETCH aggregation function. The syntax will also introduce the new SET_DIFF functionality between 2 theta sketches. The syntax will be as follows:\nSELECT DISTINCTCOUNTTHETASKETCH(col, 'nominalEntries=4096', 'predicate1', 'predicate2', 'SET_DIFF($1, $2)')\n  FROM table\n  WHERE predicate1 OR predicate2;\nPlease note that the SET_DIFF operation is NOT associative. The ordering of operation matters for this operation. A NOT B is not the same thing as B NOT A.\nDocumentation\nIf you have introduced a new feature or configuration, please add it to the documentation as well.\nSee https://docs.pinot.apache.org/developers/developers-and-contributors/update-document", "createdAt": "2020-08-08T00:09:02Z", "url": "https://github.com/apache/pinot/pull/5832", "merged": true, "mergeCommit": {"oid": "1c754f8744122bda61e2310e5df36101a02574bb"}, "closed": true, "closedAt": "2020-08-11T18:52:55Z", "author": {"login": "bkuang88"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8t8p3gFqTQ2MzY5NTk4Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc96sy0gFqTQ2NTMwMTY2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjk1OTg3", "url": "https://github.com/apache/pinot/pull/5832#pullrequestreview-463695987", "createdAt": "2020-08-08T00:14:15Z", "commit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDoxNDoxNVrOG9r2jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozMjoyOFrOG9sBSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNDc5Ng==", "bodyText": "The comment says 4 arguments, but it only lists three of them?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467334796", "createdAt": "2020-08-08T00:14:15Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -78,9 +102,9 @@ public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> argum\n       throws SqlParseException {\n     int numArguments = arguments.size();\n \n-    // NOTE: This function expects at least 3 arguments: theta-sketch column, parameters, post-aggregation expression.\n-    Preconditions.checkArgument(numArguments >= 3,\n-        \"DistinctCountThetaSketch expects at least three arguments (theta-sketch column, parameters, post-aggregation expression), got: \",\n+    // NOTE: This function expects at least 4 arguments: theta-sketch column, parameters, post-aggregation expression.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA==", "bodyText": "We should still keep the auto-deriving of predicates. Granted, we won't be able to use $ notation in that case though. What do you think?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467335138", "createdAt": "2020-08-08T00:16:17Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -108,35 +136,24 @@ public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> argum\n     Preconditions.checkArgument(paramsExpression.getType() == ExpressionContext.Type.LITERAL,\n         \"Last argument of DistinctCountThetaSketch must be literal (post-aggregation expression)\");\n     _postAggregationExpression = QueryContextConverterUtils\n-        .getFilter(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n+        .getExpression(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n \n     // Initialize the predicate map\n     _predicateInfoMap = new HashMap<>();\n-    if (numArguments > 3) {\n-      // Predicates are explicitly specified\n-      for (int i = 2; i < numArguments - 1; i++) {\n-        ExpressionContext predicateExpression = arguments.get(i);\n-        Preconditions.checkArgument(predicateExpression.getType() == ExpressionContext.Type.LITERAL,\n-            \"Third to second last argument of DistinctCountThetaSketch must be literal (predicate expression)\");\n-        Predicate predicate = getPredicate(predicateExpression.getLiteral());\n-        _inputExpressions.add(predicate.getLhs());\n-        _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-      }\n-    } else {\n-      // Auto-derive predicates from the post-aggregation expression\n-      Stack<FilterContext> stack = new Stack<>();\n-      stack.push(_postAggregationExpression);\n-      while (!stack.isEmpty()) {\n-        FilterContext filter = stack.pop();\n-        if (filter.getType() == FilterContext.Type.PREDICATE) {\n-          Predicate predicate = filter.getPredicate();\n-          _inputExpressions.add(predicate.getLhs());\n-          _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-        } else {\n-          stack.addAll(filter.getChildren());\n-        }\n-      }\n+\n+    // Predicates are explicitly specified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTgyOQ==", "bodyText": "Perhaps pre-substitition in the constructor would be better? For example, if the same $k arg is repeated multiple times, we might avoid the use of matcher using a temporary alias map?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467335829", "createdAt": "2020-08-08T00:20:48Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,\n+      final List<Predicate> expressions,\n+      final Map<Predicate, Sketch> sketchMap) {\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Literal not supported in post-aggregation function\");\n+    }\n+\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      final Predicate exp =\n+          expressions.get(extractSubstitutionPosition(postAggregationExpression.getLiteral()) - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNjA1Mw==", "bodyText": "Include the string representation of function?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467336053", "createdAt": "2020-08-08T00:22:22Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,\n+      final List<Predicate> expressions,\n+      final Map<Predicate, Sketch> sketchMap) {\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Literal not supported in post-aggregation function\");\n+    }\n+\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      final Predicate exp =\n+          expressions.get(extractSubstitutionPosition(postAggregationExpression.getLiteral()) - 1);\n+      return sketchMap.get(exp);\n+    }\n+\n+    // shouldn't throw exception because of the validation in the constructor\n+    final MergeFunction func =\n+        MergeFunction.valueOf(postAggregationExpression.getFunction().getFunctionName().toUpperCase());\n+\n+    // handle functions recursively\n+    switch(func) {\n+      case SET_UNION:\n+        final Union union = _setOperationBuilder.buildUnion();\n+        for (final ExpressionContext exp : postAggregationExpression.getFunction().getArguments()) {\n+          union.update(evalPostAggregationExpression(exp, expressions, sketchMap));\n         }\n         return union.getResult();\n-      case PREDICATE:\n-        return sketchMap.get(postAggregationExpression.getPredicate());\n+      case SET_INTERSECT:\n+        final Intersection intersection = _setOperationBuilder.buildIntersection();\n+        for (final ExpressionContext exp : postAggregationExpression.getFunction().getArguments()) {\n+          intersection.update(evalPostAggregationExpression(exp, expressions, sketchMap));\n+        }\n+        return intersection.getResult();\n+      case SET_DIFF:\n+        final List<ExpressionContext> args = postAggregationExpression.getFunction().getArguments();\n+        final AnotB diff = _setOperationBuilder.buildANotB();\n+        final Sketch a = evalPostAggregationExpression(args.get(0), expressions, sketchMap);\n+        final Sketch b = evalPostAggregationExpression(args.get(1), expressions, sketchMap);\n+        diff.update(a, b);\n+        return diff.getResult();\n       default:\n-        throw new IllegalStateException();\n+        throw new IllegalStateException(\"Invalid post-aggregation function.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNjQxMA==", "bodyText": "We tend to avoid stream apis in query execution as they tend to have performance overhead.", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467336410", "createdAt": "2020-08-08T00:24:31Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *\n+   * For example, if the post aggregation function is:\n+   * INTERSECT($1, $2, $3)\n+   *\n+   * But there are only 2 arguments passed into the aggregation function, throw an error\n+   * @param context The parsed function context that's a tree structure\n+   * @param numPredicates Max number of predicates available to be substituted\n+   */\n+  private static void validatePostAggregationExpression(final ExpressionContext context, final int numPredicates) {\n+    if (context.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Invalid post-aggregation function expression syntax.\");\n+    }\n+\n+    if (context.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      int id = extractSubstitutionPosition(context.getIdentifier());\n+      if (id <= 0)\n+        throw new IllegalArgumentException(\"Argument substitution starts at $1\");\n+      if (id > numPredicates)\n+        throw new IllegalArgumentException(\"Argument substitution exceeded number of predicates\");\n+      // if none of the invalid conditions are met above, exit out early\n+      return;\n+    }\n+\n+    if (!MergeFunction.isValid(context.getFunction().getFunctionName())) {\n+      final String allowed =\n+          Arrays.stream(MergeFunction.values())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNjQ0NQ==", "bodyText": "+1", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467336445", "createdAt": "2020-08-08T00:24:43Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *\n+   * For example, if the post aggregation function is:\n+   * INTERSECT($1, $2, $3)\n+   *\n+   * But there are only 2 arguments passed into the aggregation function, throw an error\n+   * @param context The parsed function context that's a tree structure\n+   * @param numPredicates Max number of predicates available to be substituted\n+   */\n+  private static void validatePostAggregationExpression(final ExpressionContext context, final int numPredicates) {\n+    if (context.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Invalid post-aggregation function expression syntax.\");\n+    }\n+\n+    if (context.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      int id = extractSubstitutionPosition(context.getIdentifier());\n+      if (id <= 0)\n+        throw new IllegalArgumentException(\"Argument substitution starts at $1\");\n+      if (id > numPredicates)\n+        throw new IllegalArgumentException(\"Argument substitution exceeded number of predicates\");\n+      // if none of the invalid conditions are met above, exit out early\n+      return;\n+    }\n+\n+    if (!MergeFunction.isValid(context.getFunction().getFunctionName())) {\n+      final String allowed =\n+          Arrays.stream(MergeFunction.values())\n+              .map(MergeFunction::name)\n+              .collect(Collectors.joining(\",\"));\n+      throw new IllegalArgumentException(\n+          String.format(\"Invalid Theta Sketch aggregation function. Allowed: [%s]\", allowed));\n+    }\n+\n+    switch (MergeFunction.valueOf(context.getFunction().getFunctionName().toUpperCase())) {\n+      case SET_DIFF:\n+        // set diff can only have 2 arguments\n+        if (context.getFunction().getArguments().size() != 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzU0Nw==", "bodyText": "Isn't the fourth argument postAggregationExpression? If so, it should look more like a set operation, as opposed to \"$1\"?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467337547", "createdAt": "2020-08-08T00:32:28Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/test/java/org/apache/pinot/queries/DistinctCountThetaSketchTest.java", "diffHunk": "@@ -117,60 +121,77 @@ public void testGroupBySql() {\n     testThetaSketches(true, true);\n   }\n \n+  @Test(expectedExceptions = BadQueryRequestException.class, dataProvider = \"badQueries\")\n+  public void testInvalidNoPredicates(final String query) {\n+    getBrokerResponseForSqlQuery(query);\n+  }\n+\n+  @DataProvider(name = \"badQueries\")\n+  public Object[][] badQueries() {\n+    return new Object[][] {\n+        // need at least 4 arguments in agg func\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', '$0') from testTable\"},\n+        // substitution arguments should start at $1\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', '$0') from testTable\"},\n+        // substituting variable has numeric value higher than the number of predicates provided\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', '$5') from testTable\"},\n+        // SET_DIFF requires exactly 2 arguments\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', 'SET_DIFF($1)') from testTable\"},\n+        // invalid merging function\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', 'asdf') from testTable\"}\n+    };\n+  }\n+\n   private void testThetaSketches(boolean groupBy, boolean sql) {\n     String tsQuery, distinctQuery;\n     String thetaSketchParams = \"nominalEntries=1001\";\n \n     List<String> predicateStrings = Collections.singletonList(\"colA = 1\");\n+    String substitution = \"$1\";\n     String whereClause = Strings.join(predicateStrings, \" or \");\n-    tsQuery = buildQuery(whereClause, thetaSketchParams, predicateStrings, whereClause, groupBy, false);\n+    tsQuery = buildQuery(whereClause, thetaSketchParams, predicateStrings, substitution, groupBy, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNzAxMzE1", "url": "https://github.com/apache/pinot/pull/5832#pullrequestreview-463701315", "createdAt": "2020-08-08T00:47:01Z", "commit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDo0NzowMlrOG9sJHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQyMDoyMTowNlrOG91-4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTU1MQ==", "bodyText": "UNION, INTERSECT, DIFF for concise and simplicity?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467339551", "createdAt": "2020-08-08T00:47:02Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5ODkxNw==", "bodyText": "Let's not have method just for test in production class. In the test you should test different functions instead of the standardized one (e.g. Intersect($1, $2, $3), INTERSECT($1,$2,$3) etc.)", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467498917", "createdAt": "2020-08-08T19:57:11Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;\n+\n+    /** SET_INTERSECT($1, $2, $3) => \"SET_INTERSECT($1,$2,$3)\", useful for unit tests */\n+    public String apply(final String... args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5ODk4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final List<Predicate> _predicateInfoList;\n          \n          \n            \n              private final List<Predicate> _predicates;", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467498982", "createdAt": "2020-08-08T19:57:51Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;\n+\n+    /** SET_INTERSECT($1, $2, $3) => \"SET_INTERSECT($1,$2,$3)\", useful for unit tests */\n+    public String apply(final String... args) {\n+      final String delimited = String.join(\",\", args);\n+      return String.format(\"%s(%s)\", name(), delimited);\n+    }\n+\n+    public static boolean isValid(final String name) {\n+      return SET_UNION.name().equalsIgnoreCase(name)\n+          || SET_INTERSECT.name().equalsIgnoreCase(name)\n+          || SET_DIFF.name().equalsIgnoreCase(name);\n+    }\n+  }\n+\n+  private static final Pattern ARGUMENT_SUBSTITUTION = Pattern.compile(\"\\\\$(\\\\d+)\");\n+\n   private final ExpressionContext _thetaSketchColumn;\n   private final ThetaSketchParams _thetaSketchParams;\n   private final SetOperationBuilder _setOperationBuilder;\n   private final List<ExpressionContext> _inputExpressions;\n-  private final FilterContext _postAggregationExpression;\n+  private final ExpressionContext _postAggregationExpression;\n+  private final List<Predicate> _predicateInfoList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5OTAwMg==", "bodyText": "+1", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467499002", "createdAt": "2020-08-08T19:58:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -78,9 +102,9 @@ public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> argum\n       throws SqlParseException {\n     int numArguments = arguments.size();\n \n-    // NOTE: This function expects at least 3 arguments: theta-sketch column, parameters, post-aggregation expression.\n-    Preconditions.checkArgument(numArguments >= 3,\n-        \"DistinctCountThetaSketch expects at least three arguments (theta-sketch column, parameters, post-aggregation expression), got: \",\n+    // NOTE: This function expects at least 4 arguments: theta-sketch column, parameters, post-aggregation expression.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNDc5Ng=="}, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5OTE2MA==", "bodyText": "(Code convention) We don't use final within method argument or local variables. Same for other places", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467499160", "createdAt": "2020-08-08T20:00:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;\n+\n+    /** SET_INTERSECT($1, $2, $3) => \"SET_INTERSECT($1,$2,$3)\", useful for unit tests */\n+    public String apply(final String... args) {\n+      final String delimited = String.join(\",\", args);\n+      return String.format(\"%s(%s)\", name(), delimited);\n+    }\n+\n+    public static boolean isValid(final String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5OTk3Nw==", "bodyText": "I feel putting these functions as constant is more readable and easier to use:\npublic static final String UNION = \"UNION\";\nYou can directly switch on the expression.getFunction().getFunctionName().toUpperCase() and not need to worry about MergeFunction.valueOf() throws exception.", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467499977", "createdAt": "2020-08-08T20:10:31Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDAyNw==", "bodyText": "(Code convention) Remove final and reformat. Same for other methods", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500027", "createdAt": "2020-08-08T20:11:16Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDM1OA==", "bodyText": "(Code convention) Capitalize the first character of the comments. Same for other places", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500358", "createdAt": "2020-08-08T20:15:39Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -108,35 +136,24 @@ public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> argum\n     Preconditions.checkArgument(paramsExpression.getType() == ExpressionContext.Type.LITERAL,\n         \"Last argument of DistinctCountThetaSketch must be literal (post-aggregation expression)\");\n     _postAggregationExpression = QueryContextConverterUtils\n-        .getFilter(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n+        .getExpression(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n \n     // Initialize the predicate map\n     _predicateInfoMap = new HashMap<>();\n-    if (numArguments > 3) {\n-      // Predicates are explicitly specified\n-      for (int i = 2; i < numArguments - 1; i++) {\n-        ExpressionContext predicateExpression = arguments.get(i);\n-        Preconditions.checkArgument(predicateExpression.getType() == ExpressionContext.Type.LITERAL,\n-            \"Third to second last argument of DistinctCountThetaSketch must be literal (predicate expression)\");\n-        Predicate predicate = getPredicate(predicateExpression.getLiteral());\n-        _inputExpressions.add(predicate.getLhs());\n-        _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-      }\n-    } else {\n-      // Auto-derive predicates from the post-aggregation expression\n-      Stack<FilterContext> stack = new Stack<>();\n-      stack.push(_postAggregationExpression);\n-      while (!stack.isEmpty()) {\n-        FilterContext filter = stack.pop();\n-        if (filter.getType() == FilterContext.Type.PREDICATE) {\n-          Predicate predicate = filter.getPredicate();\n-          _inputExpressions.add(predicate.getLhs());\n-          _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-        } else {\n-          stack.addAll(filter.getChildren());\n-        }\n-      }\n+\n+    // Predicates are explicitly specified\n+    for (int i = 2; i < numArguments - 1; i++) {\n+      ExpressionContext predicateExpression = arguments.get(i);\n+      Preconditions.checkArgument(predicateExpression.getType() == ExpressionContext.Type.LITERAL,\n+          \"Third to second last argument of DistinctCountThetaSketch must be literal (predicate expression)\");\n+      Predicate predicate = getPredicate(predicateExpression.getLiteral());\n+      _inputExpressions.add(predicate.getLhs());\n+      _predicateInfoList.add(predicate);\n+      _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n     }\n+\n+    // first expression is the nominal entries parameter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDQ1NQ==", "bodyText": "Also validate the arguments", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500455", "createdAt": "2020-08-08T20:16:48Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *\n+   * For example, if the post aggregation function is:\n+   * INTERSECT($1, $2, $3)\n+   *\n+   * But there are only 2 arguments passed into the aggregation function, throw an error\n+   * @param context The parsed function context that's a tree structure\n+   * @param numPredicates Max number of predicates available to be substituted\n+   */\n+  private static void validatePostAggregationExpression(final ExpressionContext context, final int numPredicates) {\n+    if (context.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Invalid post-aggregation function expression syntax.\");\n+    }\n+\n+    if (context.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      int id = extractSubstitutionPosition(context.getIdentifier());\n+      if (id <= 0)\n+        throw new IllegalArgumentException(\"Argument substitution starts at $1\");\n+      if (id > numPredicates)\n+        throw new IllegalArgumentException(\"Argument substitution exceeded number of predicates\");\n+      // if none of the invalid conditions are met above, exit out early\n+      return;\n+    }\n+\n+    if (!MergeFunction.isValid(context.getFunction().getFunctionName())) {\n+      final String allowed =\n+          Arrays.stream(MergeFunction.values())\n+              .map(MergeFunction::name)\n+              .collect(Collectors.joining(\",\"));\n+      throw new IllegalArgumentException(\n+          String.format(\"Invalid Theta Sketch aggregation function. Allowed: [%s]\", allowed));\n+    }\n+\n+    switch (MergeFunction.valueOf(context.getFunction().getFunctionName().toUpperCase())) {\n+      case SET_DIFF:\n+        // set diff can only have 2 arguments\n+        if (context.getFunction().getArguments().size() != 2) {\n+          throw new IllegalArgumentException(\"SET_DIFF function can only have 2 arguments.\");\n+        }\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDUxNA==", "bodyText": "Also validate that there are 2 arguments for DIFF", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500514", "createdAt": "2020-08-08T20:17:32Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDcwNA==", "bodyText": "Check it has more than one argument?\nPrevent inefficient function such as UNION() or UNION($1)", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500704", "createdAt": "2020-08-08T20:20:09Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *\n+   * For example, if the post aggregation function is:\n+   * INTERSECT($1, $2, $3)\n+   *\n+   * But there are only 2 arguments passed into the aggregation function, throw an error\n+   * @param context The parsed function context that's a tree structure\n+   * @param numPredicates Max number of predicates available to be substituted\n+   */\n+  private static void validatePostAggregationExpression(final ExpressionContext context, final int numPredicates) {\n+    if (context.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Invalid post-aggregation function expression syntax.\");\n+    }\n+\n+    if (context.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      int id = extractSubstitutionPosition(context.getIdentifier());\n+      if (id <= 0)\n+        throw new IllegalArgumentException(\"Argument substitution starts at $1\");\n+      if (id > numPredicates)\n+        throw new IllegalArgumentException(\"Argument substitution exceeded number of predicates\");\n+      // if none of the invalid conditions are met above, exit out early\n+      return;\n+    }\n+\n+    if (!MergeFunction.isValid(context.getFunction().getFunctionName())) {\n+      final String allowed =\n+          Arrays.stream(MergeFunction.values())\n+              .map(MergeFunction::name)\n+              .collect(Collectors.joining(\",\"));\n+      throw new IllegalArgumentException(\n+          String.format(\"Invalid Theta Sketch aggregation function. Allowed: [%s]\", allowed));\n+    }\n+\n+    switch (MergeFunction.valueOf(context.getFunction().getFunctionName().toUpperCase())) {\n+      case SET_DIFF:\n+        // set diff can only have 2 arguments\n+        if (context.getFunction().getArguments().size() != 2) {\n+          throw new IllegalArgumentException(\"SET_DIFF function can only have 2 arguments.\");\n+        }\n+        break;\n+      case SET_UNION:\n+      case SET_INTERSECT:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDc3MQ==", "bodyText": "No need to pass in this argument. Directly use member variable _predicates", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500771", "createdAt": "2020-08-08T20:21:06Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,\n+      final List<Predicate> expressions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzODQwOTg3", "url": "https://github.com/apache/pinot/pull/5832#pullrequestreview-463840987", "createdAt": "2020-08-09T03:47:36Z", "commit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwMzo0NzozNlrOG934nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwMzo0NzozNlrOG934nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMTkzMw==", "bodyText": "Lets make sure we call out in the documentation that the order matters in case of SET_DIFF", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467531933", "createdAt": "2020-08-09T03:47:36Z", "author": {"login": "ManojRThakur"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,\n+      final List<Predicate> expressions,\n+      final Map<Predicate, Sketch> sketchMap) {\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Literal not supported in post-aggregation function\");\n+    }\n+\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      final Predicate exp =\n+          expressions.get(extractSubstitutionPosition(postAggregationExpression.getLiteral()) - 1);\n+      return sketchMap.get(exp);\n+    }\n+\n+    // shouldn't throw exception because of the validation in the constructor\n+    final MergeFunction func =\n+        MergeFunction.valueOf(postAggregationExpression.getFunction().getFunctionName().toUpperCase());\n+\n+    // handle functions recursively\n+    switch(func) {\n+      case SET_UNION:\n+        final Union union = _setOperationBuilder.buildUnion();\n+        for (final ExpressionContext exp : postAggregationExpression.getFunction().getArguments()) {\n+          union.update(evalPostAggregationExpression(exp, expressions, sketchMap));\n         }\n         return union.getResult();\n-      case PREDICATE:\n-        return sketchMap.get(postAggregationExpression.getPredicate());\n+      case SET_INTERSECT:\n+        final Intersection intersection = _setOperationBuilder.buildIntersection();\n+        for (final ExpressionContext exp : postAggregationExpression.getFunction().getArguments()) {\n+          intersection.update(evalPostAggregationExpression(exp, expressions, sketchMap));\n+        }\n+        return intersection.getResult();\n+      case SET_DIFF:\n+        final List<ExpressionContext> args = postAggregationExpression.getFunction().getArguments();\n+        final AnotB diff = _setOperationBuilder.buildANotB();\n+        final Sketch a = evalPostAggregationExpression(args.get(0), expressions, sketchMap);\n+        final Sketch b = evalPostAggregationExpression(args.get(1), expressions, sketchMap);\n+        diff.update(a, b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 187}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNzA1OTUy", "url": "https://github.com/apache/pinot/pull/5832#pullrequestreview-463705952", "createdAt": "2020-08-08T01:25:05Z", "commit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMToyNTowNVrOG9sb4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODowMjoyNVrOG-Zg8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDM1NA==", "bodyText": "I think this test wasn't testing any aggregations. It was just selecting a sketch without any aggregations, so I didn't touch it. Would you like me to get rid of this test then?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467344354", "createdAt": "2020-08-08T01:25:05Z", "author": {"login": "bkuang88"}, "path": "pinot-core/src/test/java/org/apache/pinot/queries/DistinctCountThetaSketchTest.java", "diffHunk": "@@ -117,60 +121,77 @@ public void testGroupBySql() {\n     testThetaSketches(true, true);\n   }\n \n+  @Test(expectedExceptions = BadQueryRequestException.class, dataProvider = \"badQueries\")\n+  public void testInvalidNoPredicates(final String query) {\n+    getBrokerResponseForSqlQuery(query);\n+  }\n+\n+  @DataProvider(name = \"badQueries\")\n+  public Object[][] badQueries() {\n+    return new Object[][] {\n+        // need at least 4 arguments in agg func\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', '$0') from testTable\"},\n+        // substitution arguments should start at $1\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', '$0') from testTable\"},\n+        // substituting variable has numeric value higher than the number of predicates provided\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', '$5') from testTable\"},\n+        // SET_DIFF requires exactly 2 arguments\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', 'SET_DIFF($1)') from testTable\"},\n+        // invalid merging function\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', 'asdf') from testTable\"}\n+    };\n+  }\n+\n   private void testThetaSketches(boolean groupBy, boolean sql) {\n     String tsQuery, distinctQuery;\n     String thetaSketchParams = \"nominalEntries=1001\";\n \n     List<String> predicateStrings = Collections.singletonList(\"colA = 1\");\n+    String substitution = \"$1\";\n     String whereClause = Strings.join(predicateStrings, \" or \");\n-    tsQuery = buildQuery(whereClause, thetaSketchParams, predicateStrings, whereClause, groupBy, false);\n+    tsQuery = buildQuery(whereClause, thetaSketchParams, predicateStrings, substitution, groupBy, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzU0Nw=="}, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNDEyMA==", "bodyText": "I think there are some SQL keywords in there. Do we want to mix real SQL keywords with theta sketch merging functions?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467534120", "createdAt": "2020-08-09T04:20:53Z", "author": {"login": "bkuang88"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTU1MQ=="}, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4MjkzMA==", "bodyText": "Wonder if that introduces more confusion than flexibility. Because we currently don't want to support complex predicates right? Wouldn't the users make more mistakes or be confused as to when they can use complex predicates and when they cannot?\nAnd if we do start to introduce complex queries in the future, will the syntax be \"UNION($1, $2)\" or \"$1 and $2\" or \"colA='a' or colB='b'\" or \"UNION(colA='a', colB='b')\"?\nGiven the vast possibilities out there, I'm wondering if it's better to just stick to a single syntax so that it doesn't cause confusion in the future in case we do want to modify the predicate complexities.\nWhat do you guys think?", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468082930", "createdAt": "2020-08-10T18:02:25Z", "author": {"login": "bkuang88"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -108,35 +136,24 @@ public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> argum\n     Preconditions.checkArgument(paramsExpression.getType() == ExpressionContext.Type.LITERAL,\n         \"Last argument of DistinctCountThetaSketch must be literal (post-aggregation expression)\");\n     _postAggregationExpression = QueryContextConverterUtils\n-        .getFilter(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n+        .getExpression(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n \n     // Initialize the predicate map\n     _predicateInfoMap = new HashMap<>();\n-    if (numArguments > 3) {\n-      // Predicates are explicitly specified\n-      for (int i = 2; i < numArguments - 1; i++) {\n-        ExpressionContext predicateExpression = arguments.get(i);\n-        Preconditions.checkArgument(predicateExpression.getType() == ExpressionContext.Type.LITERAL,\n-            \"Third to second last argument of DistinctCountThetaSketch must be literal (predicate expression)\");\n-        Predicate predicate = getPredicate(predicateExpression.getLiteral());\n-        _inputExpressions.add(predicate.getLhs());\n-        _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-      }\n-    } else {\n-      // Auto-derive predicates from the post-aggregation expression\n-      Stack<FilterContext> stack = new Stack<>();\n-      stack.push(_postAggregationExpression);\n-      while (!stack.isEmpty()) {\n-        FilterContext filter = stack.pop();\n-        if (filter.getType() == FilterContext.Type.PREDICATE) {\n-          Predicate predicate = filter.getPredicate();\n-          _inputExpressions.add(predicate.getLhs());\n-          _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-        } else {\n-          stack.addAll(filter.getChildren());\n-        }\n-      }\n+\n+    // Predicates are explicitly specified", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA=="}, "originalCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867"}, "originalPosition": 111}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "committedDate": "2020-08-08T00:03:13Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}, "afterCommit": {"oid": "c8fa12ead53abdf485dbf2c2f987b5c482df205d", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c8fa12ead53abdf485dbf2c2f987b5c482df205d", "committedDate": "2020-08-10T19:35:43Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8fa12ead53abdf485dbf2c2f987b5c482df205d", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c8fa12ead53abdf485dbf2c2f987b5c482df205d", "committedDate": "2020-08-10T19:35:43Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}, "afterCommit": {"oid": "9a29ae6d86512a5cc70981244ba80fdff2518527", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/9a29ae6d86512a5cc70981244ba80fdff2518527", "committedDate": "2020-08-10T20:22:16Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a29ae6d86512a5cc70981244ba80fdff2518527", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/9a29ae6d86512a5cc70981244ba80fdff2518527", "committedDate": "2020-08-10T20:22:16Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}, "afterCommit": {"oid": "c82534d188c462bc5a9196a3de87c60a202379ca", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c82534d188c462bc5a9196a3de87c60a202379ca", "committedDate": "2020-08-10T20:27:04Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c82534d188c462bc5a9196a3de87c60a202379ca", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c82534d188c462bc5a9196a3de87c60a202379ca", "committedDate": "2020-08-10T20:27:04Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}, "afterCommit": {"oid": "4c4d5c52dc7519b0affd5727e12c4366a2064773", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/4c4d5c52dc7519b0affd5727e12c4366a2064773", "committedDate": "2020-08-10T20:30:42Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c4d5c52dc7519b0affd5727e12c4366a2064773", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/4c4d5c52dc7519b0affd5727e12c4366a2064773", "committedDate": "2020-08-10T20:30:42Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}, "afterCommit": {"oid": "c8fa12ead53abdf485dbf2c2f987b5c482df205d", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c8fa12ead53abdf485dbf2c2f987b5c482df205d", "committedDate": "2020-08-10T19:35:43Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8fa12ead53abdf485dbf2c2f987b5c482df205d", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c8fa12ead53abdf485dbf2c2f987b5c482df205d", "committedDate": "2020-08-10T19:35:43Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}, "afterCommit": {"oid": "c78c568b92d15f2454d704d34f645fdd0bfccfce", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c78c568b92d15f2454d704d34f645fdd0bfccfce", "committedDate": "2020-08-10T20:42:02Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "427c41d48cd5daf197706e1975cf4eb16f2ad679", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/427c41d48cd5daf197706e1975cf4eb16f2ad679", "committedDate": "2020-08-11T17:52:25Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c78c568b92d15f2454d704d34f645fdd0bfccfce", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/c78c568b92d15f2454d704d34f645fdd0bfccfce", "committedDate": "2020-08-10T20:42:02Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly"}, "afterCommit": {"oid": "427c41d48cd5daf197706e1975cf4eb16f2ad679", "author": {"user": null}, "url": "https://github.com/apache/pinot/commit/427c41d48cd5daf197706e1975cf4eb16f2ad679", "committedDate": "2020-08-11T17:52:25Z", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzAxNjY1", "url": "https://github.com/apache/pinot/pull/5832#pullrequestreview-465301665", "createdAt": "2020-08-11T17:58:53Z", "commit": {"oid": "427c41d48cd5daf197706e1975cf4eb16f2ad679"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 149, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}