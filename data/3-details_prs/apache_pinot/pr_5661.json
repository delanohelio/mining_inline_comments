{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MDkwODY0", "number": 5661, "title": "Optimize selection order-by when not all selected expressions are ordered", "bodyText": "Description\nCurrently for selection order-by queries, we always read all output and order-by expressions and insert them into the priority queue. This is very inefficient because most values won't be preserved in the priority queue, especially in cases where most/all of the output expressions are not ordered (e.g. SELECT * FROM table ORDER BY col).\nTo resolve the inefficiency, this PR enhanced the SelectionOrderByOperator to only read order-by expressions and virtual document id column when not all output expressions are ordered. After getting the final top documents, it does a second round scan to read the non-order-by output expressions to construct the final result.\nMinor optimization:\nFor selection LIMIT 0 query, skip constructing DocIdSetPlanNode and FilterPlanNode and the corresponding operators.\nFor select * from baseballStats order by teamID limit 10 on quickstart:\n\nBefore:\n\nnumEntriesScannedPostFilter: 2447225 (97889 (numDocsScanned) * 25 columns)\ntimeUsedMs: 55ms\n\n\nAfter:\n\nnumEntriesScannedPostFilter: 196018 (97889 (numDocsScanned) * 2 (teamID & $docId) + 10 * 24 non-order-by columns)\ntimeUsedMs: 15ms", "createdAt": "2020-07-07T01:44:21Z", "url": "https://github.com/apache/pinot/pull/5661", "merged": true, "mergeCommit": {"oid": "2ec7dee1597021742f68f0ae8b279f7560e55894"}, "closed": true, "closedAt": "2020-07-08T14:30:21Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcydSm4AFqTQ0MzUzNTk0MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyzHpCABqjM1MjM0MTgzNjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNTM1OTQw", "url": "https://github.com/apache/pinot/pull/5661#pullrequestreview-443535940", "createdAt": "2020-07-07T03:23:20Z", "commit": {"oid": "b76a63b21899d1099651484edf07e44047f5baaa"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMzoyMzoyMFrOGtt2OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMzoyOTo0M1rOGtt7_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDI2NQ==", "bodyText": "not sure if this a valid check. what if the expressions are functions?", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450590265", "createdAt": "2020-07-07T03:23:20Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +167,134 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n-    TransformBlock transformBlock;\n-    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    if (numExpressions == numOrderByExpressions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76a63b21899d1099651484edf07e44047f5baaa"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDM2Nw==", "bodyText": "can we extract the if and else into separate methods for readability", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450590367", "createdAt": "2020-07-07T03:23:50Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +167,134 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n-    TransformBlock transformBlock;\n-    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    if (numExpressions == numOrderByExpressions) {\n+      // All selected expressions are ordered\n+\n       BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n+      TransformBlock transformBlock;\n+      while ((transformBlock = _transformOperator.nextBlock()) != null) {\n+        for (int i = 0; i < numExpressions; i++) {\n+          ExpressionContext expression = _expressions.get(i);\n+          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+        }\n+        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+        int numDocsFetched = transformBlock.getNumDocs();\n+        _numDocsScanned += numDocsFetched;\n+        for (int i = 0; i < numDocsFetched; i++) {\n+          SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n+        }\n+      }\n+      _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n+\n+      String[] columnNames = new String[numExpressions];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n-        ExpressionContext expression = _expressions.get(i);\n-        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+        columnNames[i] = _expressions.get(i).toString();\n+        TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+        columnDataTypes[i] = DataSchema.ColumnDataType\n+            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n       }\n-      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      return new IntermediateResultsBlock(new DataSchema(columnNames, columnDataTypes), _rows);\n+    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76a63b21899d1099651484edf07e44047f5baaa"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MTc0Mw==", "bodyText": "can we refer to them as output expressions and orderBy expressions?\nthe two cases output expressions == orderby expressions\norderby expression is small part of output expressions", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450591743", "createdAt": "2020-07-07T03:29:43Z", "author": {"login": "kishoreg"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -20,72 +20,96 @@\n \n import java.util.ArrayList;\n import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.PriorityQueue;\n+import java.util.Set;\n+import org.apache.pinot.common.utils.CommonConstants.Segment.BuiltInVirtualColumn;\n import org.apache.pinot.common.utils.DataSchema;\n import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.common.RowBasedBlockValueFetcher;\n import org.apache.pinot.core.indexsegment.IndexSegment;\n import org.apache.pinot.core.operator.BaseOperator;\n import org.apache.pinot.core.operator.ExecutionStatistics;\n+import org.apache.pinot.core.operator.ProjectionOperator;\n+import org.apache.pinot.core.operator.blocks.DocIdSetBlock;\n import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n import org.apache.pinot.core.operator.blocks.TransformBlock;\n import org.apache.pinot.core.operator.transform.TransformOperator;\n import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n import org.apache.pinot.core.query.request.context.QueryContext;\n import org.apache.pinot.core.query.selection.SelectionOperatorUtils;\n import org.apache.pinot.spi.data.FieldSpec.DataType;\n import org.apache.pinot.spi.utils.ByteArray;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n+/**\n+ * Operator for selection order-by queries.\n+ * <p>The operator uses a priority queue to sort the rows and return the top rows based on the order-by expressions.\n+ * <p>It is optimized to fetch only the values needed for the ordering purpose and the final result:\n+ * <ul>\n+ *   <li>\n+ *     When all the selected expressions are ordered, the operator fetches all the expressions and insert them into the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76a63b21899d1099651484edf07e44047f5baaa"}, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b76a63b21899d1099651484edf07e44047f5baaa", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/b76a63b21899d1099651484edf07e44047f5baaa", "committedDate": "2020-07-07T01:34:33Z", "message": "Optimize selection order-by when not all selected expressions are ordered"}, "afterCommit": {"oid": "44f30443a1d45fa61b6d371278da4ef1027a6341", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/44f30443a1d45fa61b6d371278da4ef1027a6341", "committedDate": "2020-07-07T22:20:11Z", "message": "Optimize selection order-by when not all selected expressions are ordered"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MzgwMzEy", "url": "https://github.com/apache/pinot/pull/5661#pullrequestreview-444380312", "createdAt": "2020-07-08T03:02:00Z", "commit": {"oid": "44f30443a1d45fa61b6d371278da4ef1027a6341"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0Mzk3OTgw", "url": "https://github.com/apache/pinot/pull/5661#pullrequestreview-444397980", "createdAt": "2020-07-08T04:05:49Z", "commit": {"oid": "44f30443a1d45fa61b6d371278da4ef1027a6341"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNDowNTo0OVrOGuXWkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNDoxMjo1MVrOGuXc5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MDI5MQ==", "bodyText": "Nit for readability: either add a variable, or a comment to indicate row[numOrderByExpressions] has the docId.", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451270291", "createdAt": "2020-07-08T04:05:49Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +168,145 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n+    if (_expressions.size() == _orderByExpressions.size()) {\n+      return computeAllOrdered();\n+    } else {\n+      return computePartiallyOrdered();\n+    }\n+  }\n+\n+  /**\n+   * Helper method to compute the result when all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computeAllOrdered() {\n+    int numExpressions = _expressions.size();\n+\n+    // Fetch all the expressions and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n     TransformBlock transformBlock;\n     while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n-      BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n         ExpressionContext expression = _expressions.get(i);\n         blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n       RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-\n       int numDocsFetched = transformBlock.getNumDocs();\n       _numDocsScanned += numDocsFetched;\n       for (int i = 0; i < numDocsFetched; i++) {\n         SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n       }\n     }\n+    _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n \n-    return new IntermediateResultsBlock(_dataSchema, _rows);\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n+  }\n+\n+  /**\n+   * Helper method to compute the result when not all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computePartiallyOrdered() {\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    // Fetch the order-by expressions and docIds and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numOrderByExpressions + 1];\n+    TransformBlock transformBlock;\n+    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n+      for (int i = 0; i < numOrderByExpressions; i++) {\n+        ExpressionContext expression = _orderByExpressions.get(i).getExpression();\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+      }\n+      blockValSets[numOrderByExpressions] = transformBlock.getBlockValueSet(BuiltInVirtualColumn.DOCID);\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      _numDocsScanned += numDocsFetched;\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        // NOTE: We pre-allocate the complete row so that we can fill up the non-order-by output expression values later\n+        //       without creating extra rows or re-constructing the priority queue. We can change the values in-place\n+        //       because the comparator only compare the values for the order-by expressions.\n+        Object[] row = new Object[numExpressions];\n+        blockValueFetcher.getRow(i, row, 0);\n+        SelectionOperatorUtils.addToPriorityQueue(row, _rows, _numRowsToKeep);\n+      }\n+    }\n+\n+    // Copy the rows (shallow copy so that any modification will also be reflected to the priority queue) into a list,\n+    // and store the document ids into a bitmap\n+    int numRows = _rows.size();\n+    List<Object[]> rowList = new ArrayList<>(numRows);\n+    MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n+    for (Object[] row : _rows) {\n+      rowList.add(row);\n+      docIds.add((int) row[numOrderByExpressions]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f30443a1d45fa61b6d371278da4ef1027a6341"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTkwOQ==", "bodyText": "Not required for this PR, but does it help if we completely defer the fetching of non-orderby expressions until combine phase? I think that might actually improve further quite a bit? We might need to have a segmentId+docId as a virtual column.", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451271909", "createdAt": "2020-07-08T04:12:51Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +168,145 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n+    if (_expressions.size() == _orderByExpressions.size()) {\n+      return computeAllOrdered();\n+    } else {\n+      return computePartiallyOrdered();\n+    }\n+  }\n+\n+  /**\n+   * Helper method to compute the result when all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computeAllOrdered() {\n+    int numExpressions = _expressions.size();\n+\n+    // Fetch all the expressions and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n     TransformBlock transformBlock;\n     while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n-      BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n         ExpressionContext expression = _expressions.get(i);\n         blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n       RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-\n       int numDocsFetched = transformBlock.getNumDocs();\n       _numDocsScanned += numDocsFetched;\n       for (int i = 0; i < numDocsFetched; i++) {\n         SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n       }\n     }\n+    _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n \n-    return new IntermediateResultsBlock(_dataSchema, _rows);\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n+  }\n+\n+  /**\n+   * Helper method to compute the result when not all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computePartiallyOrdered() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f30443a1d45fa61b6d371278da4ef1027a6341"}, "originalPosition": 186}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e0c32b1605764aec30ea609d079e04c4456f7c5", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/2e0c32b1605764aec30ea609d079e04c4456f7c5", "committedDate": "2020-07-08T04:38:37Z", "message": "Optimize selection order-by when not all selected expressions are ordered"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "committedDate": "2020-07-08T04:55:29Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44f30443a1d45fa61b6d371278da4ef1027a6341", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/44f30443a1d45fa61b6d371278da4ef1027a6341", "committedDate": "2020-07-07T22:20:11Z", "message": "Optimize selection order-by when not all selected expressions are ordered"}, "afterCommit": {"oid": "9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "committedDate": "2020-07-08T04:55:29Z", "message": "Address comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 775, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}