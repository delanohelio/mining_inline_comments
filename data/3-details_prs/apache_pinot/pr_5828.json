{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0NTM2NzA2", "number": 5828, "title": "Improving retention manager to handle segment lineage clean-up", "bodyText": "Added the logic to handle segment lineage clean-up in the\nretention manager.\nAdded the unit test", "createdAt": "2020-08-07T10:51:15Z", "url": "https://github.com/apache/pinot/pull/5828", "merged": true, "mergeCommit": {"oid": "3785aa7952bfadacd014c48e221cd74716df54f2"}, "closed": true, "closedAt": "2020-08-11T01:32:07Z", "author": {"login": "snleee"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8iLcygH2gAyNDY0NTM2NzA2OmI4ZmJlZDMzOTMzOWEwNGVjYjQ3YjQ5ZmFiYzdmZTllM2ZjNzdhNDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9sMMKAFqTQ2NDY4MjU3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "committedDate": "2020-08-07T10:50:49Z", "message": "Improving retention manager to handle segment lineage clean-up\n\n1. Added the logic to handle segment lineage clean-up in the\n   retention manager.\n2. Added the unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDgxNTky", "url": "https://github.com/apache/pinot/pull/5828#pullrequestreview-463481592", "createdAt": "2020-08-07T17:26:30Z", "commit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoyNjozMFrOG9h-_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo0NzozNVrOG9imsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3MzExNg==", "bodyText": "Don't log this as this can flood the log for large cluster", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467173116", "createdAt": "2020-08-07T17:26:30Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NDM1Nw==", "bodyText": "Remove the null check which is redundant", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467174357", "createdAt": "2020-08-07T17:29:02Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);\n+          }\n+        }\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper\n+            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String.format(\"Failed to clean up the segment lineage. (tableName = %s)\", tableNameWithType);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+    LOGGER.info(\"Segment lineage metadata clean-up is successfully processed for table: {}\", tableNameWithType);\n+  }\n+\n+  /**\n+   * Compute the segments that can be safely deleted based on the segment lineage.\n+   *\n+   * 1. The original segments can be deleted once the merged segments are successfully uploaded.\n+   * 2. If the segmentReplacement operation fails in the middle, there can be a case where partial segments are\n+   *    uploaded to the table. We should periodically clean up those zombie segments.\n+   */\n+  private List<String> computeSegmentsToDeleteFromSegmentLineage(SegmentLineage segmentLineage) {\n+    if (segmentLineage != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MDk5OA==", "bodyText": "Don't use Assert, use Preconditions instead", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467180998", "createdAt": "2020-08-07T17:42:57Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU2NA==", "bodyText": "This won't give you the up-to-date segment list because we delay the deletion of segment ZK metadata", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467181564", "createdAt": "2020-08-07T17:44:08Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA==", "bodyText": "Can we directly remove the lineage entry here? Why do we need to wait for all merged segments also being removed?", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467182434", "createdAt": "2020-08-07T17:45:54Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);\n+          }\n+        }\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper\n+            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String.format(\"Failed to clean up the segment lineage. (tableName = %s)\", tableNameWithType);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+    LOGGER.info(\"Segment lineage metadata clean-up is successfully processed for table: {}\", tableNameWithType);\n+  }\n+\n+  /**\n+   * Compute the segments that can be safely deleted based on the segment lineage.\n+   *\n+   * 1. The original segments can be deleted once the merged segments are successfully uploaded.\n+   * 2. If the segmentReplacement operation fails in the middle, there can be a case where partial segments are\n+   *    uploaded to the table. We should periodically clean up those zombie segments.\n+   */\n+  private List<String> computeSegmentsToDeleteFromSegmentLineage(SegmentLineage segmentLineage) {\n+    if (segmentLineage != null) {\n+      List<String> segmentsToDelete = new ArrayList<>();\n+      for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+          segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4Mjk3Mg==", "bodyText": "The lineage deletion can be handled along with the segment deletion", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467182972", "createdAt": "2020-08-07T17:46:53Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU2NA=="}, "originalCommit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MzI4Mw==", "bodyText": "This part is wrong. This will remove the real in-progress lineage", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467183283", "createdAt": "2020-08-07T17:47:35Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40"}, "originalPosition": 96}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "efa876fdb1ac6a0312027394fa4a989ded374da6", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/efa876fdb1ac6a0312027394fa4a989ded374da6", "committedDate": "2020-08-08T03:33:39Z", "message": "Addressing comments"}, "afterCommit": {"oid": "92635d800638f2a807919c912bffefc3d94d7686", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/92635d800638f2a807919c912bffefc3d94d7686", "committedDate": "2020-08-08T03:41:53Z", "message": "Addressing comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92635d800638f2a807919c912bffefc3d94d7686", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/92635d800638f2a807919c912bffefc3d94d7686", "committedDate": "2020-08-08T03:41:53Z", "message": "Addressing comments"}, "afterCommit": {"oid": "9a35e7ae53dcefd59cf2c2d3a14074b06d918802", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/9a35e7ae53dcefd59cf2c2d3a14074b06d918802", "committedDate": "2020-08-08T03:43:20Z", "message": "Addressing comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a35e7ae53dcefd59cf2c2d3a14074b06d918802", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/9a35e7ae53dcefd59cf2c2d3a14074b06d918802", "committedDate": "2020-08-08T03:43:20Z", "message": "Addressing comments"}, "afterCommit": {"oid": "2a5b3d491ad5201f1460d0272d92c65f74717904", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/2a5b3d491ad5201f1460d0272d92c65f74717904", "committedDate": "2020-08-10T07:49:57Z", "message": "Addressing comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2a5b3d491ad5201f1460d0272d92c65f74717904", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/2a5b3d491ad5201f1460d0272d92c65f74717904", "committedDate": "2020-08-10T07:49:57Z", "message": "Addressing comments"}, "afterCommit": {"oid": "8bf18a75012e905f379a3a292099ad6333591af1", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/8bf18a75012e905f379a3a292099ad6333591af1", "committedDate": "2020-08-10T07:55:04Z", "message": "Addressing comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDQyMTU3", "url": "https://github.com/apache/pinot/pull/5828#pullrequestreview-464442157", "createdAt": "2020-08-10T17:45:05Z", "commit": {"oid": "8bf18a75012e905f379a3a292099ad6333591af1"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzo0NTowNVrOG-Y5BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNzo1MzozMlrOG-ZMcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3MjcwOQ==", "bodyText": "We can simplify the logic as following, same for IN_PROGRESS\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n          \n          \n            \n            \n          \n          \n            \n                        // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n          \n          \n            \n                        // are all removed from the table.\n          \n          \n            \n                        if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n          \n          \n            \n                            .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n          \n          \n            \n                          segmentLineage.deleteLineageEntry(lineageEntryId);\n          \n          \n            \n                        }\n          \n          \n            \n                        Set<String> sourceSegments = new HashSet<>(lineageEntry.getSegmentsFrom());\n          \n          \n            \n                        sourceSegments.retainAll(segmentsForTable);\n          \n          \n            \n                        if (sourceSegments.isEmpty()) {\n          \n          \n            \n                          segmentLineage.deleteLineageEntry(lineageEntryId);\n          \n          \n            \n                        } else {\n          \n          \n            \n                          segmentsToDelete.addAll(sourceSegments);\n          \n          \n            \n                        }", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468072709", "createdAt": "2020-08-10T17:45:05Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,63 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the segment replacement failed in\n+        //    the middle\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+        List<String> segmentsToDelete = new ArrayList<>();\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n+            // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf18a75012e905f379a3a292099ad6333591af1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3NzY4Mw==", "bodyText": "We might want to delete segments after successfully writing back the lineage, or the segment might be deleted without updating the lineage", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468077683", "createdAt": "2020-08-10T17:53:32Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,63 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the segment replacement failed in\n+        //    the middle\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+        List<String> segmentsToDelete = new ArrayList<>();\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n+            // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // If the lineage state is 'IN_PROGRESS', we need to clean up the zombie lineage entry and its segments\n+            if (lineageEntry.getTimestamp() < System.currentTimeMillis() - LINEAGE_ENTRY_CLEANUP_RETENTION_IN_MILLIS) {\n+              segmentsToDelete.addAll(lineageEntry.getSegmentsTo());\n+\n+              // The lineage entry with 'IN_PROGRESS' state can only be safely removed when segmentTo are all removed\n+              // from the table. Deleting lineage will allow the task scheduler to re-schedule the source segments to\n+              // be merged again.\n+              if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+                segmentLineage.deleteLineageEntry(lineageEntryId);\n+              }\n+            }\n+          }\n+        }\n+\n+        // Delete segments based on the segment lineage\n+        _pinotHelixResourceManager.deleteSegments(tableNameWithType, segmentsToDelete);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf18a75012e905f379a3a292099ad6333591af1"}, "originalPosition": 107}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8bf18a75012e905f379a3a292099ad6333591af1", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/8bf18a75012e905f379a3a292099ad6333591af1", "committedDate": "2020-08-10T07:55:04Z", "message": "Addressing comments"}, "afterCommit": {"oid": "7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "committedDate": "2020-08-10T21:38:21Z", "message": "Addressing comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "committedDate": "2020-08-10T21:38:58Z", "message": "Addressing comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "committedDate": "2020-08-10T21:38:21Z", "message": "Addressing comments"}, "afterCommit": {"oid": "3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "author": {"user": {"login": "snleee", "name": "Seunghyun Lee"}}, "url": "https://github.com/apache/pinot/commit/3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "committedDate": "2020-08-10T21:38:58Z", "message": "Addressing comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjgyNTc3", "url": "https://github.com/apache/pinot/pull/5828#pullrequestreview-464682577", "createdAt": "2020-08-11T01:04:36Z", "commit": {"oid": "3a637b9271a2177f6e70c80cf64b5f6c95e36de1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 144, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}