{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNjU1MTY1", "number": 6212, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNTowOToxN1rOEzpkMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNToyNTo1NFrOEzp6aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTkzODQzOnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNTowOToxN1rOHrBD6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNTowOToxN1rOHrBD6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg2ODIwMQ==", "bodyText": "is meet -> is met", "url": "https://github.com/apache/pinot/pull/6212#discussion_r514868201", "createdAt": "2020-10-30T05:09:17Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTk2Mzg3OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNToxNzoyNlrOHrBVFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyNToxNFrOHrbU9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3MjU5OQ==", "bodyText": "nit: you can split this into two methods, one for enableStrictReplicaGroup  and the other for not.\nusually, function polymorphism shall return the same type and this one returns a different type from the other.", "url": "https://github.com/apache/pinot/pull/6212#discussion_r514872599", "createdAt": "2020-10-30T05:17:26Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.\n+   */\n+  @VisibleForTesting\n+  static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5ODU0OQ==", "bodyText": "Split the method and also change the name of the single segment assignment method", "url": "https://github.com/apache/pinot/pull/6212#discussion_r515298549", "createdAt": "2020-10-30T18:25:14Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.\n+   */\n+  @VisibleForTesting\n+  static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3MjU5OQ=="}, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTk4NDM5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNToyMjo1OFrOHrBjAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDoxOToxOVrOHre05Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3NjE2MA==", "bodyText": "hmm, does the greedy algorithm always work? Is it possible the iteration order of currentAssignment.entrySet matters?", "url": "https://github.com/apache/pinot/pull/6212#discussion_r514876160", "createdAt": "2020-10-30T05:22:58Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.\n+   */\n+  @VisibleForTesting\n+  static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n+      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas, boolean enableStrictReplicaGroup) {\n     Map<String, Map<String, String>> nextAssignment = new TreeMap<>();\n-\n-    for (Map.Entry<String, Map<String, String>> entry : currentAssignment.entrySet()) {\n-      String segmentName = entry.getKey();\n-      nextAssignment.put(segmentName,\n-          getNextInstanceStateMap(entry.getValue(), targetAssignment.get(segmentName), minAvailableReplicas));\n+    if (enableStrictReplicaGroup) {\n+      Map<Set<String>, Set<String>> availableInstancesMap = new HashMap<>();\n+      for (Map.Entry<String, Map<String, String>> entry : currentAssignment.entrySet()) {\n+        String segmentName = entry.getKey();\n+        Map<String, String> currentInstanceStateMap = entry.getValue();\n+        Map<String, String> targetInstanceStateMap = targetAssignment.get(segmentName);\n+        SingleSegmentAssignment assignment =\n+            getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, minAvailableReplicas);\n+        Set<String> assignedInstances = assignment._instanceStateMap.keySet();\n+        Set<String> availableInstances = assignment._availableInstances;\n+        Set<String> currentAvailableInstances = availableInstancesMap.get(assignedInstances);\n+        if (currentAvailableInstances == null) {\n+          // First segment assigned to these instances, use the new assignment and update the available instances\n+          nextAssignment.put(segmentName, assignment._instanceStateMap);\n+          availableInstancesMap.put(assignedInstances, availableInstances);\n+        } else {\n+          // There are other segments assigned to the same instances, check the available instances to see if adding the\n+          // new assignment can still hold the minimum available replicas requirement\n+          availableInstances.retainAll(currentAvailableInstances);\n+          if (availableInstances.size() >= minAvailableReplicas) {\n+            // New assignment can be added\n+            nextAssignment.put(segmentName, assignment._instanceStateMap);\n+            availableInstancesMap.put(assignedInstances, availableInstances);\n+          } else {\n+            // New assignment cannot be added, use the current instance state map", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI4ODgwMA==", "bodyText": "It always work. The first segment and all the segments that have the same assignment with the first segment will always be added. We are getting closer to the target assignment in each iteration. In most cases, it is the same number of iterations as the non-strict replica-group one because the collision is rear.", "url": "https://github.com/apache/pinot/pull/6212#discussion_r515288800", "createdAt": "2020-10-30T18:05:59Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.\n+   */\n+  @VisibleForTesting\n+  static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n+      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas, boolean enableStrictReplicaGroup) {\n     Map<String, Map<String, String>> nextAssignment = new TreeMap<>();\n-\n-    for (Map.Entry<String, Map<String, String>> entry : currentAssignment.entrySet()) {\n-      String segmentName = entry.getKey();\n-      nextAssignment.put(segmentName,\n-          getNextInstanceStateMap(entry.getValue(), targetAssignment.get(segmentName), minAvailableReplicas));\n+    if (enableStrictReplicaGroup) {\n+      Map<Set<String>, Set<String>> availableInstancesMap = new HashMap<>();\n+      for (Map.Entry<String, Map<String, String>> entry : currentAssignment.entrySet()) {\n+        String segmentName = entry.getKey();\n+        Map<String, String> currentInstanceStateMap = entry.getValue();\n+        Map<String, String> targetInstanceStateMap = targetAssignment.get(segmentName);\n+        SingleSegmentAssignment assignment =\n+            getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, minAvailableReplicas);\n+        Set<String> assignedInstances = assignment._instanceStateMap.keySet();\n+        Set<String> availableInstances = assignment._availableInstances;\n+        Set<String> currentAvailableInstances = availableInstancesMap.get(assignedInstances);\n+        if (currentAvailableInstances == null) {\n+          // First segment assigned to these instances, use the new assignment and update the available instances\n+          nextAssignment.put(segmentName, assignment._instanceStateMap);\n+          availableInstancesMap.put(assignedInstances, availableInstances);\n+        } else {\n+          // There are other segments assigned to the same instances, check the available instances to see if adding the\n+          // new assignment can still hold the minimum available replicas requirement\n+          availableInstances.retainAll(currentAvailableInstances);\n+          if (availableInstances.size() >= minAvailableReplicas) {\n+            // New assignment can be added\n+            nextAssignment.put(segmentName, assignment._instanceStateMap);\n+            availableInstancesMap.put(assignedInstances, availableInstances);\n+          } else {\n+            // New assignment cannot be added, use the current instance state map", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3NjE2MA=="}, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NTg3Nw==", "bodyText": "Got it.", "url": "https://github.com/apache/pinot/pull/6212#discussion_r515355877", "createdAt": "2020-10-30T20:19:19Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.\n+   */\n+  @VisibleForTesting\n+  static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n+      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas, boolean enableStrictReplicaGroup) {\n     Map<String, Map<String, String>> nextAssignment = new TreeMap<>();\n-\n-    for (Map.Entry<String, Map<String, String>> entry : currentAssignment.entrySet()) {\n-      String segmentName = entry.getKey();\n-      nextAssignment.put(segmentName,\n-          getNextInstanceStateMap(entry.getValue(), targetAssignment.get(segmentName), minAvailableReplicas));\n+    if (enableStrictReplicaGroup) {\n+      Map<Set<String>, Set<String>> availableInstancesMap = new HashMap<>();\n+      for (Map.Entry<String, Map<String, String>> entry : currentAssignment.entrySet()) {\n+        String segmentName = entry.getKey();\n+        Map<String, String> currentInstanceStateMap = entry.getValue();\n+        Map<String, String> targetInstanceStateMap = targetAssignment.get(segmentName);\n+        SingleSegmentAssignment assignment =\n+            getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, minAvailableReplicas);\n+        Set<String> assignedInstances = assignment._instanceStateMap.keySet();\n+        Set<String> availableInstances = assignment._availableInstances;\n+        Set<String> currentAvailableInstances = availableInstancesMap.get(assignedInstances);\n+        if (currentAvailableInstances == null) {\n+          // First segment assigned to these instances, use the new assignment and update the available instances\n+          nextAssignment.put(segmentName, assignment._instanceStateMap);\n+          availableInstancesMap.put(assignedInstances, availableInstances);\n+        } else {\n+          // There are other segments assigned to the same instances, check the available instances to see if adding the\n+          // new assignment can still hold the minimum available replicas requirement\n+          availableInstances.retainAll(currentAvailableInstances);\n+          if (availableInstances.size() >= minAvailableReplicas) {\n+            // New assignment can be added\n+            nextAssignment.put(segmentName, assignment._instanceStateMap);\n+            availableInstancesMap.put(assignedInstances, availableInstances);\n+          } else {\n+            // New assignment cannot be added, use the current instance state map", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3NjE2MA=="}, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTk5NTI5OnYy", "diffSide": "RIGHT", "path": "pinot-controller/src/test/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNToyNTo1NFrOHrBqjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxMjo0MlrOHra8Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3ODA5Mg==", "bodyText": "can you also add a test that no strict replica-group assignment available but best-effort replicas-group assignment is possible.", "url": "https://github.com/apache/pinot/pull/6212#discussion_r514878092", "createdAt": "2020-10-30T05:25:54Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/test/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancerTest.java", "diffHunk": "@@ -123,72 +134,232 @@ public void testTwoMinAvailableReplicas() {\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\", \"host4\"), ONLINE);\n     Map<String, String> targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\", \"host5\"), ONLINE);\n-    Map<String, String> nextInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(nextInstanceStateMap, targetInstanceStateMap);\n+    TableRebalancer.SingleSegmentAssignment assignment =\n+        TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host3\")));\n \n     // With 2 common instances, next assignment should be the same as target assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host5\", \"host6\"), ONLINE);\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(nextInstanceStateMap, targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n \n     // With 1 common instance, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host5\", \"host6\", \"host7\"), ONLINE);\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n     // [host1, host2, host5, host6]\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host5\", \"host6\")));\n \n     // Without common instance, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\", \"host8\"), ONLINE);\n     // [host1, host2, host5, host6]\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\")));\n \n     // With increasing number of replicas, next assignment should have 1 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\", \"host8\", \"host9\"), ONLINE);\n     // [host1, host2, host5, host6, host7]\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\", \"host7\")));\n \n     // With decreasing number of replicas, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\"), ONLINE);\n     // [host1, host2, host5]\n-    Map<String, String> firstRoundInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, firstRoundInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should have 2 common instances with first round assignment\n     // [host1, host5, host6]\n-    Map<String, String> secondRoundInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(firstRoundInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(firstRoundInstanceStateMap, secondRoundInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host5\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(secondRoundInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\")));\n   }\n \n-  private int getNumCommonInstances(Map<String, String> currentInstanceStateMap,\n-      Map<String, String> nextInstanceStateMap) {\n-    int numCommonInstances = 0;\n-    for (String instanceId : currentInstanceStateMap.keySet()) {\n-      if (nextInstanceStateMap.containsKey(instanceId)) {\n-        numCommonInstances++;\n-      }\n-    }\n-    return numCommonInstances;\n+  @Test\n+  public void testStrictReplicaGroup() {\n+    // Current assignment:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> currentAssignment = new TreeMap<>();\n+    currentAssignment\n+        .put(\"segment1\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment2\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host3\", \"host4\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment3\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment4\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host3\", \"host4\"), ONLINE));\n+\n+    // Target assignment:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host5\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host5\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> targetAssignment = new TreeMap<>();\n+    targetAssignment\n+        .put(\"segment1\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host4\", \"host6\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment2\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host4\", \"host5\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment3\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host4\", \"host6\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment4\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host4\", \"host5\"), ONLINE));\n+\n+    // Next assignment with 2 minimum available replicas without strict replica-group:\n+    // (This assignment will move \"segment1\" and \"segment3\" from \"host3\" to \"host4\", and move \"segment2\" and \"segment4\"\n+    // from \"host3\" to \"host1\". \"host1\" and \"host4\" might be unavailable for strict replica-group routing, which breaks\n+    // the minimum available replicas requirement.)\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> nextAssignment =\n+        TableRebalancer.getNextAssignment(currentAssignment, targetAssignment, 2, false);\n+    assertEquals(nextAssignment.get(\"segment1\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment2\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment3\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment4\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+\n+    // Next assignment with 2 minimum available replicas with strict replica-group:\n+    // (This assignment will only move \"segment1\" and \"segment3\" from \"host3\" to \"host4\". Only \"host4\" can be\n+    // unavailable for strict replica-group routing during the rebalance, which meets the minimum available replicas\n+    // requirement.)\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    nextAssignment = TableRebalancer.getNextAssignment(currentAssignment, targetAssignment, 2, true);\n+    assertEquals(nextAssignment.get(\"segment1\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment2\").keySet(), new TreeSet<>(Arrays.asList(\"host2\", \"host3\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment3\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment4\").keySet(), new TreeSet<>(Arrays.asList(\"host2\", \"host3\", \"host4\")));\n+\n+    // Next assignment with 2 minimum available replicas with strict replica-group:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5MjIyNg==", "bodyText": "Added", "url": "https://github.com/apache/pinot/pull/6212#discussion_r515292226", "createdAt": "2020-10-30T18:12:42Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-controller/src/test/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancerTest.java", "diffHunk": "@@ -123,72 +134,232 @@ public void testTwoMinAvailableReplicas() {\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\", \"host4\"), ONLINE);\n     Map<String, String> targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\", \"host5\"), ONLINE);\n-    Map<String, String> nextInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(nextInstanceStateMap, targetInstanceStateMap);\n+    TableRebalancer.SingleSegmentAssignment assignment =\n+        TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host3\")));\n \n     // With 2 common instances, next assignment should be the same as target assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host5\", \"host6\"), ONLINE);\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(nextInstanceStateMap, targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n \n     // With 1 common instance, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host5\", \"host6\", \"host7\"), ONLINE);\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n     // [host1, host2, host5, host6]\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host5\", \"host6\")));\n \n     // Without common instance, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\", \"host8\"), ONLINE);\n     // [host1, host2, host5, host6]\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\")));\n \n     // With increasing number of replicas, next assignment should have 1 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\", \"host8\", \"host9\"), ONLINE);\n     // [host1, host2, host5, host6, host7]\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\", \"host7\")));\n \n     // With decreasing number of replicas, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\"), ONLINE);\n     // [host1, host2, host5]\n-    Map<String, String> firstRoundInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, firstRoundInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should have 2 common instances with first round assignment\n     // [host1, host5, host6]\n-    Map<String, String> secondRoundInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(firstRoundInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(firstRoundInstanceStateMap, secondRoundInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host5\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(secondRoundInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\")));\n   }\n \n-  private int getNumCommonInstances(Map<String, String> currentInstanceStateMap,\n-      Map<String, String> nextInstanceStateMap) {\n-    int numCommonInstances = 0;\n-    for (String instanceId : currentInstanceStateMap.keySet()) {\n-      if (nextInstanceStateMap.containsKey(instanceId)) {\n-        numCommonInstances++;\n-      }\n-    }\n-    return numCommonInstances;\n+  @Test\n+  public void testStrictReplicaGroup() {\n+    // Current assignment:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> currentAssignment = new TreeMap<>();\n+    currentAssignment\n+        .put(\"segment1\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment2\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host3\", \"host4\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment3\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment4\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host3\", \"host4\"), ONLINE));\n+\n+    // Target assignment:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host5\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host5\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> targetAssignment = new TreeMap<>();\n+    targetAssignment\n+        .put(\"segment1\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host4\", \"host6\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment2\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host4\", \"host5\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment3\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host4\", \"host6\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment4\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host4\", \"host5\"), ONLINE));\n+\n+    // Next assignment with 2 minimum available replicas without strict replica-group:\n+    // (This assignment will move \"segment1\" and \"segment3\" from \"host3\" to \"host4\", and move \"segment2\" and \"segment4\"\n+    // from \"host3\" to \"host1\". \"host1\" and \"host4\" might be unavailable for strict replica-group routing, which breaks\n+    // the minimum available replicas requirement.)\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> nextAssignment =\n+        TableRebalancer.getNextAssignment(currentAssignment, targetAssignment, 2, false);\n+    assertEquals(nextAssignment.get(\"segment1\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment2\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment3\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment4\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+\n+    // Next assignment with 2 minimum available replicas with strict replica-group:\n+    // (This assignment will only move \"segment1\" and \"segment3\" from \"host3\" to \"host4\". Only \"host4\" can be\n+    // unavailable for strict replica-group routing during the rebalance, which meets the minimum available replicas\n+    // requirement.)\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    nextAssignment = TableRebalancer.getNextAssignment(currentAssignment, targetAssignment, 2, true);\n+    assertEquals(nextAssignment.get(\"segment1\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment2\").keySet(), new TreeSet<>(Arrays.asList(\"host2\", \"host3\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment3\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment4\").keySet(), new TreeSet<>(Arrays.asList(\"host2\", \"host3\", \"host4\")));\n+\n+    // Next assignment with 2 minimum available replicas with strict replica-group:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3ODA5Mg=="}, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 376}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3810, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}