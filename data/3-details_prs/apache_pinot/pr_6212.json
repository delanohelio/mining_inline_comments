{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNjU1MTY1", "number": 6212, "title": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables", "bodyText": "Description\nOn top of #6208, this PR enhances the TableRebalancer to support the no-downtime rebalance for strict replica-group routing, which still hold the minimum available replicas requirement.\nSee Strict Replica-Group Routing for the algorithm.", "createdAt": "2020-10-29T23:55:21Z", "url": "https://github.com/apache/pinot/pull/6212", "merged": true, "mergeCommit": {"oid": "e0f15aab71cda8fce3f06d2f53a4c7e7a4f3c523"}, "closed": true, "closedAt": "2020-11-02T06:34:35Z", "author": {"login": "Jackie-Jiang"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXf4PlgFqTUyMDM4MDA2Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdYbxrbgFqTUyMTMwOTI2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzgwMDYy", "url": "https://github.com/apache/pinot/pull/6212#pullrequestreview-520380062", "createdAt": "2020-10-30T05:09:17Z", "commit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNTowOToxN1rOHrBD6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNToyNTo1NFrOHrBqjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg2ODIwMQ==", "bodyText": "is meet -> is met", "url": "https://github.com/apache/pinot/pull/6212#discussion_r514868201", "createdAt": "2020-10-30T05:09:17Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3MjU5OQ==", "bodyText": "nit: you can split this into two methods, one for enableStrictReplicaGroup  and the other for not.\nusually, function polymorphism shall return the same type and this one returns a different type from the other.", "url": "https://github.com/apache/pinot/pull/6212#discussion_r514872599", "createdAt": "2020-10-30T05:17:26Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.\n+   */\n+  @VisibleForTesting\n+  static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3NjE2MA==", "bodyText": "hmm, does the greedy algorithm always work? Is it possible the iteration order of currentAssignment.entrySet matters?", "url": "https://github.com/apache/pinot/pull/6212#discussion_r514876160", "createdAt": "2020-10-30T05:22:58Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -546,22 +554,61 @@ static boolean isExternalViewConverged(String tableNameWithType,\n     return true;\n   }\n \n-  private static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n-      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas) {\n+  /**\n+   * Returns the next assignment for the table based on the current assignment and the target assignment with regards to\n+   * the minimum available replicas requirement. For strict replica-group mode, track the available instances for all\n+   * the segments with the same instances in the next assignment, and ensure the minimum available replicas requirement\n+   * is meet. If adding the assignment for a segment breaks the requirement, use the current assignment for the segment.\n+   */\n+  @VisibleForTesting\n+  static Map<String, Map<String, String>> getNextAssignment(Map<String, Map<String, String>> currentAssignment,\n+      Map<String, Map<String, String>> targetAssignment, int minAvailableReplicas, boolean enableStrictReplicaGroup) {\n     Map<String, Map<String, String>> nextAssignment = new TreeMap<>();\n-\n-    for (Map.Entry<String, Map<String, String>> entry : currentAssignment.entrySet()) {\n-      String segmentName = entry.getKey();\n-      nextAssignment.put(segmentName,\n-          getNextInstanceStateMap(entry.getValue(), targetAssignment.get(segmentName), minAvailableReplicas));\n+    if (enableStrictReplicaGroup) {\n+      Map<Set<String>, Set<String>> availableInstancesMap = new HashMap<>();\n+      for (Map.Entry<String, Map<String, String>> entry : currentAssignment.entrySet()) {\n+        String segmentName = entry.getKey();\n+        Map<String, String> currentInstanceStateMap = entry.getValue();\n+        Map<String, String> targetInstanceStateMap = targetAssignment.get(segmentName);\n+        SingleSegmentAssignment assignment =\n+            getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, minAvailableReplicas);\n+        Set<String> assignedInstances = assignment._instanceStateMap.keySet();\n+        Set<String> availableInstances = assignment._availableInstances;\n+        Set<String> currentAvailableInstances = availableInstancesMap.get(assignedInstances);\n+        if (currentAvailableInstances == null) {\n+          // First segment assigned to these instances, use the new assignment and update the available instances\n+          nextAssignment.put(segmentName, assignment._instanceStateMap);\n+          availableInstancesMap.put(assignedInstances, availableInstances);\n+        } else {\n+          // There are other segments assigned to the same instances, check the available instances to see if adding the\n+          // new assignment can still hold the minimum available replicas requirement\n+          availableInstances.retainAll(currentAvailableInstances);\n+          if (availableInstances.size() >= minAvailableReplicas) {\n+            // New assignment can be added\n+            nextAssignment.put(segmentName, assignment._instanceStateMap);\n+            availableInstancesMap.put(assignedInstances, availableInstances);\n+          } else {\n+            // New assignment cannot be added, use the current instance state map", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3ODA5Mg==", "bodyText": "can you also add a test that no strict replica-group assignment available but best-effort replicas-group assignment is possible.", "url": "https://github.com/apache/pinot/pull/6212#discussion_r514878092", "createdAt": "2020-10-30T05:25:54Z", "author": {"login": "yupeng9"}, "path": "pinot-controller/src/test/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancerTest.java", "diffHunk": "@@ -123,72 +134,232 @@ public void testTwoMinAvailableReplicas() {\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\", \"host4\"), ONLINE);\n     Map<String, String> targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\", \"host5\"), ONLINE);\n-    Map<String, String> nextInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(nextInstanceStateMap, targetInstanceStateMap);\n+    TableRebalancer.SingleSegmentAssignment assignment =\n+        TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host3\")));\n \n     // With 2 common instances, next assignment should be the same as target assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host5\", \"host6\"), ONLINE);\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(nextInstanceStateMap, targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n \n     // With 1 common instance, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host5\", \"host6\", \"host7\"), ONLINE);\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n     // [host1, host2, host5, host6]\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host5\", \"host6\")));\n \n     // Without common instance, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\", \"host8\"), ONLINE);\n     // [host1, host2, host5, host6]\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\")));\n \n     // With increasing number of replicas, next assignment should have 1 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\", \"host8\", \"host9\"), ONLINE);\n     // [host1, host2, host5, host6, host7]\n-    nextInstanceStateMap = TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, nextInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(nextInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\", \"host7\")));\n \n     // With decreasing number of replicas, next assignment should have 2 common instances with current assignment\n     targetInstanceStateMap =\n         SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host5\", \"host6\", \"host7\"), ONLINE);\n     // [host1, host2, host5]\n-    Map<String, String> firstRoundInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(currentInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(currentInstanceStateMap, firstRoundInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(currentInstanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host2\")));\n     // Next round should have 2 common instances with first round assignment\n     // [host1, host5, host6]\n-    Map<String, String> secondRoundInstanceStateMap =\n-        TableRebalancer.getNextInstanceStateMap(firstRoundInstanceStateMap, targetInstanceStateMap, 2);\n-    assertEquals(getNumCommonInstances(firstRoundInstanceStateMap, secondRoundInstanceStateMap), 2);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host1\", \"host5\")));\n     // Next round should make the assignment the same as target assignment\n-    assertEquals(TableRebalancer.getNextInstanceStateMap(secondRoundInstanceStateMap, targetInstanceStateMap, 2),\n-        targetInstanceStateMap);\n+    assignment = TableRebalancer.getNextAssignment(assignment._instanceStateMap, targetInstanceStateMap, 2);\n+    assertEquals(assignment._instanceStateMap, targetInstanceStateMap);\n+    assertEquals(assignment._availableInstances, new TreeSet<>(Arrays.asList(\"host5\", \"host6\")));\n   }\n \n-  private int getNumCommonInstances(Map<String, String> currentInstanceStateMap,\n-      Map<String, String> nextInstanceStateMap) {\n-    int numCommonInstances = 0;\n-    for (String instanceId : currentInstanceStateMap.keySet()) {\n-      if (nextInstanceStateMap.containsKey(instanceId)) {\n-        numCommonInstances++;\n-      }\n-    }\n-    return numCommonInstances;\n+  @Test\n+  public void testStrictReplicaGroup() {\n+    // Current assignment:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> currentAssignment = new TreeMap<>();\n+    currentAssignment\n+        .put(\"segment1\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment2\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host3\", \"host4\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment3\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host2\", \"host3\"), ONLINE));\n+    currentAssignment\n+        .put(\"segment4\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host3\", \"host4\"), ONLINE));\n+\n+    // Target assignment:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host5\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host5\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> targetAssignment = new TreeMap<>();\n+    targetAssignment\n+        .put(\"segment1\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host4\", \"host6\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment2\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host4\", \"host5\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment3\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host2\", \"host4\", \"host6\"), ONLINE));\n+    targetAssignment\n+        .put(\"segment4\", SegmentAssignmentUtils.getInstanceStateMap(Arrays.asList(\"host1\", \"host4\", \"host5\"), ONLINE));\n+\n+    // Next assignment with 2 minimum available replicas without strict replica-group:\n+    // (This assignment will move \"segment1\" and \"segment3\" from \"host3\" to \"host4\", and move \"segment2\" and \"segment4\"\n+    // from \"host3\" to \"host1\". \"host1\" and \"host4\" might be unavailable for strict replica-group routing, which breaks\n+    // the minimum available replicas requirement.)\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    Map<String, Map<String, String>> nextAssignment =\n+        TableRebalancer.getNextAssignment(currentAssignment, targetAssignment, 2, false);\n+    assertEquals(nextAssignment.get(\"segment1\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment2\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment3\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment4\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+\n+    // Next assignment with 2 minimum available replicas with strict replica-group:\n+    // (This assignment will only move \"segment1\" and \"segment3\" from \"host3\" to \"host4\". Only \"host4\" can be\n+    // unavailable for strict replica-group routing during the rebalance, which meets the minimum available replicas\n+    // requirement.)\n+    // {\n+    //   \"segment1\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host3\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }\n+    nextAssignment = TableRebalancer.getNextAssignment(currentAssignment, targetAssignment, 2, true);\n+    assertEquals(nextAssignment.get(\"segment1\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment2\").keySet(), new TreeSet<>(Arrays.asList(\"host2\", \"host3\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment3\").keySet(), new TreeSet<>(Arrays.asList(\"host1\", \"host2\", \"host4\")));\n+    assertEquals(nextAssignment.get(\"segment4\").keySet(), new TreeSet<>(Arrays.asList(\"host2\", \"host3\", \"host4\")));\n+\n+    // Next assignment with 2 minimum available replicas with strict replica-group:\n+    // {\n+    //   \"segment1\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment2\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   },\n+    //   \"segment3\": {\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\",\n+    //     \"host6\": \"ONLINE\"\n+    //   },\n+    //   \"segment4\": {\n+    //     \"host1\": \"ONLINE\",\n+    //     \"host2\": \"ONLINE\",\n+    //     \"host4\": \"ONLINE\"\n+    //   }\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c"}, "originalPosition": 376}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6781f57e93204632ff33eabbe5da36c6daacac1c", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/6781f57e93204632ff33eabbe5da36c6daacac1c", "committedDate": "2020-10-29T23:51:15Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}, "afterCommit": {"oid": "498ffed31c69d37dace5ce156aa8d0db4e22f67a", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/498ffed31c69d37dace5ce156aa8d0db4e22f67a", "committedDate": "2020-10-30T18:25:46Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDExMTQ0", "url": "https://github.com/apache/pinot/pull/6212#pullrequestreview-521011144", "createdAt": "2020-10-30T20:27:25Z", "commit": {"oid": "498ffed31c69d37dace5ce156aa8d0db4e22f67a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "498ffed31c69d37dace5ce156aa8d0db4e22f67a", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/498ffed31c69d37dace5ce156aa8d0db4e22f67a", "committedDate": "2020-10-30T18:25:46Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}, "afterCommit": {"oid": "421bbad1888e361d1c129222eabf7ae713e1bc8f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/421bbad1888e361d1c129222eabf7ae713e1bc8f", "committedDate": "2020-11-01T05:33:13Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "421bbad1888e361d1c129222eabf7ae713e1bc8f", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/421bbad1888e361d1c129222eabf7ae713e1bc8f", "committedDate": "2020-11-01T05:33:13Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}, "afterCommit": {"oid": "5ea9a3e05a6b1b353756d62657e2d4fedeacd899", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/5ea9a3e05a6b1b353756d62657e2d4fedeacd899", "committedDate": "2020-11-01T08:54:46Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ea9a3e05a6b1b353756d62657e2d4fedeacd899", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/5ea9a3e05a6b1b353756d62657e2d4fedeacd899", "committedDate": "2020-11-01T08:54:46Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}, "afterCommit": {"oid": "044d083f5cca81edd39b40d175d4e106c09c99f8", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/044d083f5cca81edd39b40d175d4e106c09c99f8", "committedDate": "2020-11-01T18:44:30Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dbfac84376f101a867c2261dc8f6b4b94ab13c7", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/4dbfac84376f101a867c2261dc8f6b4b94ab13c7", "committedDate": "2020-11-01T19:05:41Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "044d083f5cca81edd39b40d175d4e106c09c99f8", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/044d083f5cca81edd39b40d175d4e106c09c99f8", "committedDate": "2020-11-01T18:44:30Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}, "afterCommit": {"oid": "4dbfac84376f101a867c2261dc8f6b4b94ab13c7", "author": {"user": {"login": "Jackie-Jiang", "name": "Xiaotian (Jackie) Jiang"}}, "url": "https://github.com/apache/pinot/commit/4dbfac84376f101a867c2261dc8f6b4b94ab13c7", "committedDate": "2020-11-01T19:05:41Z", "message": "Enhance TableRebalancer to support no-downtime rebalance for strict replica-group routing tables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMzA5MjYy", "url": "https://github.com/apache/pinot/pull/6212#pullrequestreview-521309262", "createdAt": "2020-11-02T03:13:07Z", "commit": {"oid": "4dbfac84376f101a867c2261dc8f6b4b94ab13c7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1675, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}