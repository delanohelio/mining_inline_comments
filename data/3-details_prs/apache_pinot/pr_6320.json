{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyODMwMjA3", "number": 6320, "title": "More efficient use of RoaringBitmap in OnHeapBitmapInvertedIndexCreator and OffHeapBitmapInvertedIndexCreator", "bodyText": "Description\nThis PR uses some more efficient APIs from RoaringBitmap.\n\nRoaringBitmapWriter is optimised for writing row ids into the bitmap sequentially. This class has a few options to control memory usage, but I've used its defaults.\nA RoaringBitmap can be serialized to a ByteBuffer, which is generally a lot faster than a DataOutput. However, this requires mapping a file outside of the control of PinotByteBuffer. The buffer also has to be big endian for backward compatibility with DataOutput.\n\nI haven't run any benchmarks on this and am judging this on having used (and created) the same APIs for a similar problem. I tried to run the pinot-perf benchmarks but ran into errors with missing files. I would appreciate some help validating the benefits this change brings.\nUpgrade Notes\nDoes this PR prevent a zero down-time upgrade? (Assume upgrade order: Controller, Broker, Server, Minion)\n\n[No]\n\nDoes this PR fix a zero-downtime upgrade introduced earlier?\n\n[ No]\n\nDoes this PR otherwise need attention when creating release notes?\n\n[ No]", "createdAt": "2020-12-04T22:43:34Z", "url": "https://github.com/apache/pinot/pull/6320", "merged": true, "mergeCommit": {"oid": "fe2a63ca6d21015cbb09500f00d98a702338d488"}, "closed": true, "closedAt": "2020-12-08T05:03:46Z", "author": {"login": "richardstartin"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdjBGwQAFqTU0NTM3NTg2OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdj9Fi3gH2gAyNTMyODMwMjA3OjcyNWUyMTg4ZGU4MzFmNTNiYjFmNjUzNjRmMjkzMjBkZjIxNDJmY2U=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1Mzc1ODY4", "url": "https://github.com/apache/pinot/pull/6320#pullrequestreview-545375868", "createdAt": "2020-12-05T00:21:52Z", "commit": {"oid": "0a7af3663939e5d8a9cad3ca81e532631ad523bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDoyMTo1MlrOH_mzjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDoyMTo1MlrOH_mzjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1ODEyNg==", "bodyText": "This is a new allocation, but it's offset against the 16KB in stream buffers no longer allocated, and is a lot smaller than the bitmaps being materialised here anyway. This pattern where bitmaps are allocated just to obtain their serialized bytes could probably be supported by roaringbitmap without actually creating the intermediate bitmaps without much complication.", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536458126", "createdAt": "2020-12-05T00:21:52Z", "author": {"login": "richardstartin"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,49 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      MutableRoaringBitmap[] bitmaps = new MutableRoaringBitmap[_cardinality];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a7af3663939e5d8a9cad3ca81e532631ad523bc"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NDEyNTAz", "url": "https://github.com/apache/pinot/pull/6320#pullrequestreview-545412503", "createdAt": "2020-12-05T05:20:05Z", "commit": {"oid": "0a7af3663939e5d8a9cad3ca81e532631ad523bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNToyMDowNVrOH_qaEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNToyMDowNVrOH_qaEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNzEzOA==", "bodyText": "I am assuming the choice of LITTLE_ENDIAN comes from the fact that index generation (typically happening on x86 machines) will not require byte swap when writing the index?\nWhen we load the index, we specifically use BIG_ENDIAN byte order because throughout the index generation code we use BIG_ENDIAN. This works with overhead of byte swap for both read and write.\nI am confused how is this change expected to work today for the reader? The reader will load the file specifying the order as BIG_ENDIAN. This means every read operation will swap the bytes on x86. However, with this change index file is generated in LE format which doesn't require any swapping. So swapping bytes during inverted index read will result in incorrect data imo. I am surprised that tests are passing.\nSee the code in index buffer loader. This code doesn't know index file was written in LE format.\n// Backward-compatible: index file is always big-endian\n    PinotDataBuffer buffer;\n    if (readMode == ReadMode.heap) {\n      buffer = PinotDataBuffer.loadFile(indexFile, fromFilePos, size, ByteOrder.BIG_ENDIAN, context);\n    } else {\n      buffer = PinotDataBuffer.mapFile(indexFile, true, fromFilePos, size, ByteOrder.BIG_ENDIAN, context);\n    }", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536517138", "createdAt": "2020-12-05T05:20:05Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,68 +19,85 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmapWriter;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<MutableRoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.bufferWriter().get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size\n+    int size = (_bitmapWriters.length + 1) * Integer.BYTES;\n+    for (RoaringBitmapWriter<MutableRoaringBitmap> writer : _bitmapWriters) {\n+      size += writer.get().serializedSizeInBytes();\n+      // Check for int overflow\n+      Preconditions.checkState(size > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n+    }\n+    ByteBuffer buffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size).order(LITTLE_ENDIAN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a7af3663939e5d8a9cad3ca81e532631ad523bc"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NDE0MTIy", "url": "https://github.com/apache/pinot/pull/6320#pullrequestreview-545414122", "createdAt": "2020-12-05T05:49:34Z", "commit": {"oid": "0a7af3663939e5d8a9cad3ca81e532631ad523bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNTo0OTozNFrOH_qqOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNTo0OTozNFrOH_qqOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyMTI3NA==", "bodyText": "Where exactly is the potential benefit coming from?", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536521274", "createdAt": "2020-12-05T05:49:34Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,49 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a7af3663939e5d8a9cad3ca81e532631ad523bc"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjQ3MjY4", "url": "https://github.com/apache/pinot/pull/6320#pullrequestreview-545647268", "createdAt": "2020-12-05T20:24:40Z", "commit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMDoyNDo0MFrOIAA9Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMDo0OTo1OVrOIABMDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NjYwMg==", "bodyText": "(nit) same for other places\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (null != offsetBuffer) {\n          \n          \n            \n                    if (offsetBuffer != null) {", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536886602", "createdAt": "2020-12-05T20:24:40Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      RoaringBitmap[] bitmaps = new RoaringBitmap[_cardinality];\n+      RoaringBitmapWriter<RoaringBitmap> writer = RoaringBitmapWriter.writer()\n+              .initialCapacity(((_nextDocId - 1) >>> 16) / _cardinality).get();\n       int startIndex = 0;\n       for (int dictId = 0; dictId < _cardinality; dictId++) {\n-        MutableRoaringBitmap bitmap = new MutableRoaringBitmap();\n         int endIndex = getInt(_invertedIndexLengthBuffer, dictId);\n         for (int i = startIndex; i < endIndex; i++) {\n-          bitmap.add(getInt(_invertedIndexValueBuffer, i));\n+          writer.add(getInt(_invertedIndexValueBuffer, i));\n         }\n-        startIndex = endIndex;\n-\n-        // Write offset and bitmap into file\n-        bitmapOffset += bitmap.serializedSizeInBytes();\n+        bitmaps[dictId] = writer.get();\n+        writer.reset();\n+        int serializedSize = bitmaps[dictId].serializedSizeInBytes();\n+        bitmapOffset += serializedSize;\n         // Check for int overflow\n         Preconditions.checkState(bitmapOffset > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n-        offsetDataStream.writeInt(bitmapOffset);\n-        bitmap.serialize(bitmapDataStream);\n+        // write offset into file\n+        offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+        startIndex = endIndex;\n+      }\n+      // we know how long the file should be now, so can map it\n+      bitmapBuffer = channel.map(FileChannel.MapMode.READ_WRITE, startOfBitmaps, bitmapOffset - startOfBitmaps);\n+      for (RoaringBitmap bitmap : bitmaps) {\n+        bitmap.serialize(bitmapBuffer);\n       }\n     } catch (Exception e) {\n       FileUtils.deleteQuietly(_invertedIndexFile);\n       throw e;\n+    } finally {\n+      if (CleanerUtil.UNMAP_SUPPORTED) {\n+        CleanerUtil.BufferCleaner cleaner = CleanerUtil.getCleaner();\n+        if (null != offsetBuffer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzI2OA==", "bodyText": "The offset buffer does not have to be LE, as all the values are written as BE", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536887268", "createdAt": "2020-12-05T20:29:23Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzMzNw==", "bodyText": "Don't use static import in production class", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536887337", "createdAt": "2020-12-05T20:29:46Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,18 +19,25 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n+\n import java.io.Closeable;\n-import java.io.DataOutputStream;\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.util.CleanerUtil;\n import org.apache.pinot.spi.data.FieldSpec;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapWriter;\n+\n+import static java.lang.Integer.reverseBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzM5MA==", "bodyText": "(nit) we don't usually use final for local variable", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536887390", "createdAt": "2020-12-05T20:30:11Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzYyNQ==", "bodyText": "Do RoaringBitmap and MutableRoaringBitmap serialize to the same bytes?", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536887625", "createdAt": "2020-12-05T20:31:41Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      RoaringBitmap[] bitmaps = new RoaringBitmap[_cardinality];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4OTM3OA==", "bodyText": "For off-heap creator, we don't want to keep all bitmaps on heap. We should try to create and serialize the bitmaps one by one. Not sure about the cost if we map a buffer per bitmap", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536889378", "createdAt": "2020-12-05T20:43:13Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      RoaringBitmap[] bitmaps = new RoaringBitmap[_cardinality];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzYyNQ=="}, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4OTgyOQ==", "bodyText": "Why do you need to divide it with _cardinality? Though this should be .expectedRange(0, _nextDocId)?", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536889829", "createdAt": "2020-12-05T20:46:25Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      RoaringBitmap[] bitmaps = new RoaringBitmap[_cardinality];\n+      RoaringBitmapWriter<RoaringBitmap> writer = RoaringBitmapWriter.writer()\n+              .initialCapacity(((_nextDocId - 1) >>> 16) / _cardinality).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MDMwNw==", "bodyText": "Do you need to flush() before getUnderlying()? Or just use get() to retrieve the bitmap?", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536890307", "createdAt": "2020-12-05T20:49:27Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,68 +19,85 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmapWriter;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<MutableRoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.bufferWriter().get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size\n+    int size = (_bitmapWriters.length + 1) * Integer.BYTES;\n+    for (RoaringBitmapWriter<MutableRoaringBitmap> writer : _bitmapWriters) {\n+      size += writer.get().serializedSizeInBytes();\n+      // Check for int overflow\n+      Preconditions.checkState(size > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n+    }\n+    ByteBuffer buffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size).order(LITTLE_ENDIAN);\n       // Write bitmap offsets\n-      int bitmapOffset = (_bitmaps.length + 1) * Integer.BYTES;\n-      out.writeInt(bitmapOffset);\n-      for (MutableRoaringBitmap bitmap : _bitmaps) {\n-        bitmapOffset += bitmap.serializedSizeInBytes();\n-        // Check for int overflow\n-        Preconditions.checkState(bitmapOffset > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n-        out.writeInt(bitmapOffset);\n+      int bitmapOffset = (_bitmapWriters.length + 1) * Integer.BYTES;\n+      buffer.putInt(Integer.reverseBytes(bitmapOffset));\n+      for (RoaringBitmapWriter<MutableRoaringBitmap> writer : _bitmapWriters) {\n+        bitmapOffset += writer.getUnderlying().serializedSizeInBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MDM4MQ==", "bodyText": "Maybe keeping 2 buffers similar to the off-heap one?", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536890381", "createdAt": "2020-12-05T20:49:59Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,68 +19,85 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmapWriter;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<MutableRoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.bufferWriter().get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size\n+    int size = (_bitmapWriters.length + 1) * Integer.BYTES;\n+    for (RoaringBitmapWriter<MutableRoaringBitmap> writer : _bitmapWriters) {\n+      size += writer.get().serializedSizeInBytes();\n+      // Check for int overflow\n+      Preconditions.checkState(size > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n+    }\n+    ByteBuffer buffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size).order(LITTLE_ENDIAN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60861bc25110b94011091332a70a5e955e38405b"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NzQ4MzAy", "url": "https://github.com/apache/pinot/pull/6320#pullrequestreview-545748302", "createdAt": "2020-12-06T21:13:17Z", "commit": {"oid": "e3ec220081689a08ff4da20f1f5c2ff5e269882c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQyMToxMzoxN1rOIAPfDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQyMToxMzoxN1rOIAPfDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyNDYyMQ==", "bodyText": "Maybe we can use the same way as the off-heap creator to preallocate a huge buffer then truncate to save the calculation of the serialized size (we calculate that twice for each bitmap)?", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537124621", "createdAt": "2020-12-06T21:13:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,68 +19,96 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapWriter;\n \n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<RoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.writer().get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size\n+    int startOfBitmaps = (_bitmapWriters.length + 1) * Integer.BYTES;\n+    int size = 0;\n+    for (RoaringBitmapWriter<RoaringBitmap> writer : _bitmapWriters) {\n+      size += writer.get().serializedSizeInBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ec220081689a08ff4da20f1f5c2ff5e269882c"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDg2NzQy", "url": "https://github.com/apache/pinot/pull/6320#pullrequestreview-546486742", "createdAt": "2020-12-07T19:55:39Z", "commit": {"oid": "92d995341f68f8c7dbc103efc3897b548dae7c2e"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NTozOVrOIA4EEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDowMjoyOFrOIA4VMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTQ1Nw==", "bodyText": "Please reformat this file to fix the indentation (should be 2 spaces) for this file", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537789457", "createdAt": "2020-12-07T19:55:39Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-perf/src/main/java/org/apache/pinot/perf/BenchmarkOffheapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.perf;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.segment.creator.impl.inv.OffHeapBitmapInvertedIndexCreator;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.ChainedOptionsBuilder;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+@State(Scope.Benchmark)\n+public class BenchmarkOffheapBitmapInvertedIndexCreator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d995341f68f8c7dbc103efc3897b548dae7c2e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5Mzg0MA==", "bodyText": "I see your point. We won't create bitmap inverted index if the values are sorted (we have another RLE format), so in most cases, the docIds will spread over all the arrays. But for high cardinality case where each bitmap only contain very few values, pre-allocation might end up allocating too many arrays. So agree with letting it grow automatically.", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537793840", "createdAt": "2020-12-07T20:02:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +184,45 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, startOfBitmaps)\n+              .order(ByteOrder.BIG_ENDIAN);\n+      offsetBuffer.putInt(startOfBitmaps);\n+      bitmapBuffer = channel.map(FileChannel.MapMode.READ_WRITE, startOfBitmaps, Integer.MAX_VALUE - startOfBitmaps)\n+              .order(ByteOrder.LITTLE_ENDIAN);\n+      RoaringBitmapWriter<RoaringBitmap> writer = RoaringBitmapWriter.writer().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d995341f68f8c7dbc103efc3897b548dae7c2e"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTM5MjQ2", "url": "https://github.com/apache/pinot/pull/6320#pullrequestreview-546539246", "createdAt": "2020-12-07T21:10:49Z", "commit": {"oid": "72e9d8dc61a3d3b6e04b601afa1b6c6e8b1ff302"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToxMDo0OVrOIA63Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToxMDo0OVrOIA63Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgzNTI5MQ==", "bodyText": "this comment is now misleading, will remove it", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537835291", "createdAt": "2020-12-07T21:10:49Z", "author": {"login": "richardstartin"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -18,69 +18,85 @@\n  */\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n-import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapWriter;\n \n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<RoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.writer().runCompress(false).get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e9d8dc61a3d3b6e04b601afa1b6c6e8b1ff302"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "725e2188de831f53bb1f65364f29320df2142fce", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/apache/pinot/commit/725e2188de831f53bb1f65364f29320df2142fce", "committedDate": "2020-12-07T22:14:51Z", "message": "use RoaringBitmapWriter and direct to ByteBuffer serialization in BitmapInvertedIndexCreators"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1589, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}