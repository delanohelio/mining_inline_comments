{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNzc5ODUy", "number": 8676, "title": "Add getItem(int index) to DataView #8652", "bodyText": "Part of #8652", "createdAt": "2020-07-01T15:35:32Z", "url": "https://github.com/vaadin/flow/pull/8676", "merged": true, "mergeCommit": {"oid": "40049327d54cf5aa8c9da54f0fb688495f69f3bb"}, "closed": true, "closedAt": "2020-07-05T19:23:13Z", "author": {"login": "mshabarov"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwszIRgFqTQ0MTAxMzc3Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyBuIHgFqTQ0MjcwMDQ0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMDEzNzc3", "url": "https://github.com/vaadin/flow/pull/8676#pullrequestreview-441013777", "createdAt": "2020-07-01T16:13:50Z", "commit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNjoxMzo1MFrOGrsjAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNjoyNToxM1rOGrs9yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3MTgwOQ==", "bodyText": "The intention was that it works the same way regardless of anything, defined or undefined size.\nSo this should use the data communicator to get the item and the data communicator gets the item from active range or makes a fetch query.", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r448471809", "createdAt": "2020-07-01T16:13:50Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractLazyDataView.java", "diffHunk": "@@ -37,28 +37,46 @@\n      * Creates a new instance and verifies the passed data provider is\n      * compatible with this data view implementation.\n      *\n-     * @param dataCommunicator\n-     *            the data communicator of the component\n-     * @param component\n-     *            the component\n+     * @param dataCommunicator the data communicator of the component\n+     * @param component        the component\n      */\n     public AbstractLazyDataView(DataCommunicator<T> dataCommunicator,\n-            Component component) {\n+                                Component component) {\n         super(dataCommunicator::getDataProvider, component);\n         this.dataCommunicator = dataCommunicator;\n     }\n \n     /**\n      * Returns the data communicator for the component and checks that the data\n      * provider is of the correct type.\n-     * \n+     *\n      * @return the data communicator\n      */\n     protected DataCommunicator<T> getDataCommunicator() {\n         verifyDataProviderType(dataCommunicator.getDataProvider().getClass());\n         return dataCommunicator;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T getItem(int index) {\n+        DataCommunicator<T> verifiedDataCommunicator = getDataCommunicator();\n+        if (verifiedDataCommunicator.isDefinedSize()) {\n+            final int itemCount = this.dataCommunicator.getDataSize();\n+            validateItemIndex(index, itemCount);\n+            Optional<T> optionalItem =\n+                    verifiedDataCommunicator.getDataProvider()\n+                            .fetch(this.dataCommunicator.buildQuery(index, 1))\n+                            .findFirst();\n+            return optionalItem.orElseThrow(() ->\n+                    new IllegalStateException(String.format(\n+                            \"Item with an index %d is expected to be fetched\" +\n+                                    \" from backend, but not found\", index)));\n+        } else {\n+            return verifiedDataCommunicator.getActiveItemOnIndex(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3MjU2NQ==", "bodyText": "This logic IMO  belongs to the data communicator, not here.", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r448472565", "createdAt": "2020-07-01T16:15:02Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractLazyDataView.java", "diffHunk": "@@ -37,28 +37,46 @@\n      * Creates a new instance and verifies the passed data provider is\n      * compatible with this data view implementation.\n      *\n-     * @param dataCommunicator\n-     *            the data communicator of the component\n-     * @param component\n-     *            the component\n+     * @param dataCommunicator the data communicator of the component\n+     * @param component        the component\n      */\n     public AbstractLazyDataView(DataCommunicator<T> dataCommunicator,\n-            Component component) {\n+                                Component component) {\n         super(dataCommunicator::getDataProvider, component);\n         this.dataCommunicator = dataCommunicator;\n     }\n \n     /**\n      * Returns the data communicator for the component and checks that the data\n      * provider is of the correct type.\n-     * \n+     *\n      * @return the data communicator\n      */\n     protected DataCommunicator<T> getDataCommunicator() {\n         verifyDataProviderType(dataCommunicator.getDataProvider().getClass());\n         return dataCommunicator;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T getItem(int index) {\n+        DataCommunicator<T> verifiedDataCommunicator = getDataCommunicator();\n+        if (verifiedDataCommunicator.isDefinedSize()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NDMzNQ==", "bodyText": "This would mean that the item is not given when the component has not fetched any items.\nWould be weird that the same code fails first but later on works.", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r448474335", "createdAt": "2020-07-01T16:17:54Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -325,6 +325,10 @@ public boolean isItemActive(T item) {\n      * @return the item\n      */\n     public T getActiveItemOnIndex(int index) {\n+        if (activeKeyOrder.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NDYzMA==", "bodyText": "We can hide this method, not expose it anymore", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r448474630", "createdAt": "2020-07-01T16:18:26Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -325,6 +325,10 @@ public boolean isItemActive(T item) {\n      * @return the item\n      */\n     public T getActiveItemOnIndex(int index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NDkzMw==", "bodyText": "Just expose getItemOnIndex which works consistently", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r448474933", "createdAt": "2020-07-01T16:18:58Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -325,6 +325,10 @@ public boolean isItemActive(T item) {\n      * @return the item\n      */\n     public T getActiveItemOnIndex(int index) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NDYzMA=="}, "originalCommit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NjU4MA==", "bodyText": "Please emphasize the \"filtered and sorted data set\"", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r448476580", "createdAt": "2020-07-01T16:21:33Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataView.java", "diffHunk": "@@ -28,12 +28,22 @@\n  * Base view interface for getting information on current data set of a\n  * Component.\n  *\n- * @param <T>\n- *            data type\n+ * @param <T> data type\n  * @since\n  */\n public interface DataView<T> extends Serializable {\n \n+    /**\n+     * Gets the item at the given index from the data available to the\n+     * component. Data is filtered and sorted the same way as in the component.\n+     *\n+     * @param index item index number\n+     * @return item on index\n+     * @throws IndexOutOfBoundsException requested index is outside of the\n+     *                                   available data set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3ODA2Mw==", "bodyText": "Missing test that sorting and filtering is applied?", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r448478063", "createdAt": "2020-07-01T16:24:13Z", "author": {"login": "pleku"}, "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/AbstractLazyDataViewTest.java", "diffHunk": "@@ -251,6 +256,138 @@ public void getItems_withUndefinedSize() {\n                 items.count());\n     }\n \n+    @Test\n+    public void getItem_withDefinedSizeAndCorrectIndex() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndNegativeIndex() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index -1 is outside of the accepted range '0 - 2'\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        dataView.getItem(-1);\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndEmptyDataset() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Requested index 0 on empty data.\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.empty();\n+        }, query -> 0), null);\n+\n+        dataView.getItem(0);\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndIndexOutsideOfRange() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index 3 is outside of the accepted range '0 - 2'\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(3));\n+    }\n+\n+    @Test\n+    public void getItem_withUndefinedSizeAndCorrectIndex() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> -1), null);\n+\n+        dataCommunicator.setRowCountEstimate(5);\n+        fakeClientCommunication();\n+\n+        Assert.assertEquals(\"Wrong item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+        Assert.assertEquals(\"Wrong item on index 2\", \"baz\",\n+                dataView.getItem(2));\n+    }\n+\n+    @Test\n+    public void getItem_withUndefinedSizeAndNegativeIndex() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index -1 is outside of the active range of the \" +\n+                        \"component '0 - 2'\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> -1), null);\n+\n+        dataCommunicator.setRowCountEstimate(1);\n+        fakeClientCommunication();\n+\n+        dataView.getItem(-1);\n+    }\n+\n+    @Test\n+    public void getItem_withUndefinedSizeAndEmptyDataset() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\"Requested index 0 on empty data.\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.empty();\n+        }, query -> -1), null);\n+\n+        dataCommunicator.setRowCountEstimate(2);\n+        fakeClientCommunication();\n+\n+        dataView.getItem(0);\n+    }\n+\n+    @Test\n+    public void getItem_withUndefinedSizeAndIndexOutsideOfRange() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index 3 is outside of the active range of the \" +\n+                        \"component '0 - 2'\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> -1), null);\n+\n+        dataCommunicator.setRowCountEstimate(3);\n+        fakeClientCommunication();\n+\n+        dataView.getItem(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3ODY2Ng==", "bodyText": "Missing tests for sorting and filtering", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r448478666", "createdAt": "2020-07-01T16:25:13Z", "author": {"login": "pleku"}, "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/AbstractListDataViewTest.java", "diffHunk": "@@ -741,6 +713,34 @@ public void updateItem_itemNotPresent_itemNotRefreshed() {\n                 .refreshItem(updatedItem);\n     }\n \n+    @Test\n+    public void getItem_correctIndex_itemFound() {\n+        Assert.assertEquals(\"Wrong item returned for index\", \"first\",\n+                dataView.getItem(0));\n+    }\n+\n+    @Test\n+    public void getItem_negativeIndex_throwsException() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index -1 is outside of the accepted range '0 - 2'\");\n+        dataView.getItem(-1);\n+    }\n+\n+    @Test\n+    public void getItem_emptyDataSet_throwsException() {\n+        dataProvider = DataProvider.ofItems();\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\"Requested index 0 on empty data.\");\n+        dataView.getItem(0);\n+    }\n+\n+    @Test\n+    public void getItem_indexOutsideOfSize_throwsException() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        dataView.getItem(items.size());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c48e25b555315c0ca4da6fea123d9b165e36d2"}, "originalPosition": 65}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "385b0c7e3d65ded94aa942e21639bf01061bf294", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/385b0c7e3d65ded94aa942e21639bf01061bf294", "committedDate": "2020-07-02T13:54:15Z", "message": "Rework getItem, filtering and sorting tests added"}, "afterCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd", "committedDate": "2020-07-02T14:20:52Z", "message": "Rework getItem, filtering and sorting tests added"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTM0NTcw", "url": "https://github.com/vaadin/flow/pull/8676#pullrequestreview-441934570", "createdAt": "2020-07-02T18:33:48Z", "commit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODozMzo0OVrOGsZBAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxOTozMjozNlrOGsapSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMDM4NQ==", "bodyText": "I think this intentionally on multiple lines, so you'd should revert this and use\n//@formatter:on ...", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449200385", "createdAt": "2020-07-02T18:33:49Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -173,9 +173,7 @@ public boolean contains(T item) {\n     @Override\n     public AbstractListDataView<T> updateItem(T item) {\n         Objects.requireNonNull(item, NULL_ITEM_ERROR_MESSAGE);\n-        getItems()\n-                .filter(i -> equals(item, i))\n-                .findFirst()\n+        getItems().filter(i -> equals(item, i)).findFirst()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMDYzMA==", "bodyText": "I think this intentionally on multiple lines, so you'd should revert this and use\n//@formatter:on ...", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449200630", "createdAt": "2020-07-02T18:34:23Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -186,10 +184,8 @@ public boolean contains(T item) {\n         if (!items.isEmpty()) {\n             final ListDataProvider<T> dataProvider = getDataProvider();\n             Collection<T> backendItems = dataProvider.getItems();\n-            items.stream()\n-                    .filter(this::contains)\n-                    .forEach(item ->\n-                            removeItemIfPresent(item, dataProvider));\n+            items.stream().filter(this::contains)\n+                    .forEach(item -> removeItemIfPresent(item, dataProvider));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMDc2MA==", "bodyText": "I think this intentionally on multiple lines, so you'd should revert this and use\n//@formatter:on ...", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449200760", "createdAt": "2020-07-02T18:34:36Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -281,8 +276,7 @@ private int getItemIndex(T item) {\n         Objects.requireNonNull(item, NULL_ITEM_ERROR_MESSAGE);\n         AtomicInteger index = new AtomicInteger(-1);\n         if (!getItems().peek(t -> index.incrementAndGet())\n-                .filter(t -> equals(item, t))\n-                .findFirst().isPresent()) {\n+                .filter(t -> equals(item, t)).findFirst().isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMjU3NA==", "bodyText": "NIT: \"the index of the item to get\" is IMO the better wording to use here, why change it ?", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449202574", "createdAt": "2020-07-02T18:38:40Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -316,22 +316,38 @@ public boolean isItemActive(T item) {\n     }\n \n     /**\n-     * Returns the active item at the given index or throws a\n-     * {@link IndexOutOfBoundsException} in case the item is not active at the\n-     * moment.\n-     * \n+     * Gets the item at the given index from the data available to the\n+     * component. Data is filtered and sorted the same way as in the component.\n+     * <p>\n+     * Call to the backend is triggered if the item for a requested index is\n+     * not present in the cached active items.\n+     *\n      * @param index\n-     *            the index of the item to get\n-     * @return the item\n+     *            item index number", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMDkxNg==", "bodyText": "For unknown size, getItemCount() returns either 0 (initially) or the current estimate.\nWhy is not intentionally working if I ask for the item that is current estimate + 1?\nWhy is not intentionally working if I ask for the first item before the data communicator has fetched any items?\nIt should be my problem if my backend cannot handle the query for outside the range, or then when I return null then this just returns null.\nI would presume that\n\nif exact size is used and I request outside the current size, I get the exception because we know this\nif unknown size is used, the query is done even if it is outside of the current estimate - what this method returns cannot depend on the active range or the estimate at that moment or whether or not the data provider has loaded any items yet, as the flush occurs later during the roundtrip.", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449210916", "createdAt": "2020-07-02T18:56:40Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -316,22 +316,38 @@ public boolean isItemActive(T item) {\n     }\n \n     /**\n-     * Returns the active item at the given index or throws a\n-     * {@link IndexOutOfBoundsException} in case the item is not active at the\n-     * moment.\n-     * \n+     * Gets the item at the given index from the data available to the\n+     * component. Data is filtered and sorted the same way as in the component.\n+     * <p>\n+     * Call to the backend is triggered if the item for a requested index is\n+     * not present in the cached active items.\n+     *\n      * @param index\n-     *            the index of the item to get\n-     * @return the item\n+     *            item index number\n+     * @return item on index\n+     * @throws IndexOutOfBoundsException\n+     *             requested index is outside of the filtered and sorted data\n+     *             set or the data set is empty\n      */\n-    public T getActiveItemOnIndex(int index) {\n+    @SuppressWarnings(\"unchecked\")\n+    public T getItem(int index) {\n         int activeDataEnd = activeStart + activeKeyOrder.size() - 1;\n         if (index < activeStart || index > activeDataEnd) {\n-            throw new IndexOutOfBoundsException(String.format(\n-                    \"Given index %d is outside of the active range of the component '%d - %d'\",\n-                    index, activeStart, activeDataEnd));\n+            int dataSize = getItemCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMzkwMA==", "bodyText": "I think a stream that just provides an object that can be validated against the correct index could be used instead of an empty string", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449213900", "createdAt": "2020-07-02T19:03:06Z", "author": {"login": "pleku"}, "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/AbstractLazyDataViewTest.java", "diffHunk": "@@ -267,6 +273,277 @@ public void getItems_withUndefinedSize() {\n                 items.count());\n     }\n \n+    @Test\n+    public void getItem_withDefinedSizeAndCorrectIndex() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+\n+        // Request the item within the active range\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(\n+                query -> Stream.generate(String::new).skip(query.getOffset())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxOTc1MA==", "bodyText": "So now when unknown size is used and nothing is yet fetched as flush occurs later, I get an exception for any item.\nAs a user I would not like this, and the error doesn't give me any indication why the data is not yet fetchable.\nI think we should just make it always work and educate the users with javadocs on getItem in LazyDataView to understand that \"Calling this method with an index that is not currently active in the component will cause a query to the backend, so do not call this method carelessly. Use `UI::beforeClientResponse to access items that will be fetched later on.\"", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449219750", "createdAt": "2020-07-02T19:15:39Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -316,22 +316,38 @@ public boolean isItemActive(T item) {\n     }\n \n     /**\n-     * Returns the active item at the given index or throws a\n-     * {@link IndexOutOfBoundsException} in case the item is not active at the\n-     * moment.\n-     * \n+     * Gets the item at the given index from the data available to the\n+     * component. Data is filtered and sorted the same way as in the component.\n+     * <p>\n+     * Call to the backend is triggered if the item for a requested index is\n+     * not present in the cached active items.\n+     *\n      * @param index\n-     *            the index of the item to get\n-     * @return the item\n+     *            item index number\n+     * @return item on index\n+     * @throws IndexOutOfBoundsException\n+     *             requested index is outside of the filtered and sorted data\n+     *             set or the data set is empty\n      */\n-    public T getActiveItemOnIndex(int index) {\n+    @SuppressWarnings(\"unchecked\")\n+    public T getItem(int index) {\n         int activeDataEnd = activeStart + activeKeyOrder.size() - 1;\n         if (index < activeStart || index > activeDataEnd) {\n-            throw new IndexOutOfBoundsException(String.format(\n-                    \"Given index %d is outside of the active range of the component '%d - %d'\",\n-                    index, activeStart, activeDataEnd));\n+            int dataSize = getItemCount();\n+            if (dataSize == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyMzA0Nw==", "bodyText": "The fakeClientCommunication() call above will increase the estimate to 60+200 because the requested range 0,50 is less than one page from the estimate.\nYou need to test with items that are\n\navailable in the backend\nnot within the current size estimate\n(this will not work currently but it should, like I explained in the DC comments)", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449223047", "createdAt": "2020-07-02T19:23:04Z", "author": {"login": "pleku"}, "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/AbstractLazyDataViewTest.java", "diffHunk": "@@ -267,6 +273,277 @@ public void getItems_withUndefinedSize() {\n                 items.count());\n     }\n \n+    @Test\n+    public void getItem_withDefinedSizeAndCorrectIndex() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+\n+        // Request the item within the active range\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(\n+                query -> Stream.generate(String::new).skip(query.getOffset())\n+                        .limit(query.getLimit()),\n+                query -> 300), null);\n+\n+        fakeClientCommunication();\n+\n+        // Request an item outside the active range\n+        Assert.assertNotNull(dataView.getItem(260));\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndNegativeIndex() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index -1 is outside of the accepted range '0 - 2'\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+\n+        dataView.getItem(-1);\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndEmptyDataset() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\"Requested index 0 on empty data.\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.empty();\n+        }, query -> 0), null);\n+\n+        fakeClientCommunication();\n+\n+        dataView.getItem(0);\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndIndexOutsideOfRange() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index 3 is outside of the accepted range '0 - 2'\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(3));\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndFiltering() {\n+        final String initialFilter = \"bar\";\n+        final String newFilter = \"foo\";\n+\n+        dataCommunicator.setRequestedRange(0, 50);\n+        SerializableConsumer<String> newFilterProvider = dataCommunicator\n+                .setDataProvider(DataProvider.fromFilteringCallbacks(query -> {\n+                    query.getOffset();\n+                    query.getLimit();\n+                    return Stream.of(\"foo\", \"bar\", \"baz\").filter(\n+                            item -> item.equals(query.getFilter().get()));\n+                }, query -> 1), initialFilter);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", initialFilter,\n+                dataView.getItem(0));\n+\n+        newFilterProvider.accept(newFilter);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", newFilter,\n+                dataView.getItem(0));\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndSorting() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            Stream<String> stream = Stream.of(\"foo\", \"bar\", \"baz\");\n+            if (query.getInMemorySorting() != null) {\n+                stream = stream.sorted(query.getInMemorySorting());\n+            }\n+            return stream;\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+\n+        dataCommunicator.setInMemorySorting(String::compareTo);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", \"bar\",\n+                dataView.getItem(0));\n+    }\n+\n+    @Test\n+    public void getItem_withUndefinedSizeAndCorrectIndex() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> -1), null);\n+\n+        dataCommunicator.setItemCountEstimate(5);\n+        fakeClientCommunication();\n+\n+        // Request the item within the active range\n+        Assert.assertEquals(\"Wrong item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+        Assert.assertEquals(\"Wrong item on index 2\", \"baz\",\n+                dataView.getItem(2));\n+\n+        // Request the item outside the active range\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            if (query.getOffset() > 70) {\n+                return Stream.empty();\n+            } else {\n+                return Stream.generate(String::new).skip(query.getOffset())\n+                        .limit(Math.min(query.getOffset() + query.getLimit(),\n+                                70));\n+            }\n+        }, query -> -1), null);\n+\n+        final int itemCountEstimate = 60;\n+        dataCommunicator.setItemCountEstimate(itemCountEstimate);\n+\n+        fakeClientCommunication();\n+        Assert.assertNotNull(dataView.getItem(49));\n+        Assert.assertNotNull(dataView.getItem(59));\n+        Assert.assertNotNull(dataView.getItem(69));\n+        Assert.assertNull(dataView.getItem(79));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyMzkzNQ==", "bodyText": "I don't like the newFilter = \"foo\" since the result from that is the same as no filter used at all when using getItem(0) so a regression in applying the filter not working would not be caught", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449223935", "createdAt": "2020-07-02T19:25:17Z", "author": {"login": "pleku"}, "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/AbstractLazyDataViewTest.java", "diffHunk": "@@ -267,6 +273,277 @@ public void getItems_withUndefinedSize() {\n                 items.count());\n     }\n \n+    @Test\n+    public void getItem_withDefinedSizeAndCorrectIndex() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+\n+        // Request the item within the active range\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(\n+                query -> Stream.generate(String::new).skip(query.getOffset())\n+                        .limit(query.getLimit()),\n+                query -> 300), null);\n+\n+        fakeClientCommunication();\n+\n+        // Request an item outside the active range\n+        Assert.assertNotNull(dataView.getItem(260));\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndNegativeIndex() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index -1 is outside of the accepted range '0 - 2'\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+\n+        dataView.getItem(-1);\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndEmptyDataset() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\"Requested index 0 on empty data.\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.empty();\n+        }, query -> 0), null);\n+\n+        fakeClientCommunication();\n+\n+        dataView.getItem(0);\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndIndexOutsideOfRange() {\n+        exceptionRule.expect(IndexOutOfBoundsException.class);\n+        exceptionRule.expectMessage(\n+                \"Given index 3 is outside of the accepted range '0 - 2'\");\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(3));\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndFiltering() {\n+        final String initialFilter = \"bar\";\n+        final String newFilter = \"foo\";\n+\n+        dataCommunicator.setRequestedRange(0, 50);\n+        SerializableConsumer<String> newFilterProvider = dataCommunicator\n+                .setDataProvider(DataProvider.fromFilteringCallbacks(query -> {\n+                    query.getOffset();\n+                    query.getLimit();\n+                    return Stream.of(\"foo\", \"bar\", \"baz\").filter(\n+                            item -> item.equals(query.getFilter().get()));\n+                }, query -> 1), initialFilter);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", initialFilter,\n+                dataView.getItem(0));\n+\n+        newFilterProvider.accept(newFilter);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", newFilter,\n+                dataView.getItem(0));\n+    }\n+\n+    @Test\n+    public void getItem_withDefinedSizeAndSorting() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            Stream<String> stream = Stream.of(\"foo\", \"bar\", \"baz\");\n+            if (query.getInMemorySorting() != null) {\n+                stream = stream.sorted(query.getInMemorySorting());\n+            }\n+            return stream;\n+        }, query -> 3), null);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+\n+        dataCommunicator.setInMemorySorting(String::compareTo);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", \"bar\",\n+                dataView.getItem(0));\n+    }\n+\n+    @Test\n+    public void getItem_withUndefinedSizeAndCorrectIndex() {\n+        dataCommunicator.setRequestedRange(0, 50);\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            query.getOffset();\n+            query.getLimit();\n+            return Stream.of(\"foo\", \"bar\", \"baz\");\n+        }, query -> -1), null);\n+\n+        dataCommunicator.setItemCountEstimate(5);\n+        fakeClientCommunication();\n+\n+        // Request the item within the active range\n+        Assert.assertEquals(\"Wrong item on index 0\", \"foo\",\n+                dataView.getItem(0));\n+        Assert.assertEquals(\"Wrong item on index 2\", \"baz\",\n+                dataView.getItem(2));\n+\n+        // Request the item outside the active range\n+        dataCommunicator.setDataProvider(DataProvider.fromCallbacks(query -> {\n+            if (query.getOffset() > 70) {\n+                return Stream.empty();\n+            } else {\n+                return Stream.generate(String::new).skip(query.getOffset())\n+                        .limit(Math.min(query.getOffset() + query.getLimit(),\n+                                70));\n+            }\n+        }, query -> -1), null);\n+\n+        final int itemCountEstimate = 60;\n+        dataCommunicator.setItemCountEstimate(itemCountEstimate);\n+\n+        fakeClientCommunication();\n+        Assert.assertNotNull(dataView.getItem(49));\n+        Assert.assertNotNull(dataView.getItem(59));\n+        Assert.assertNotNull(dataView.getItem(69));\n+        Assert.assertNull(dataView.getItem(79));\n+    }\n+\n+    @Test\n+    public void getItem_withUndefinedSizeAndFiltering() {\n+        final String initialFilter = \"bar\";\n+        final String newFilter = \"foo\";\n+\n+        dataCommunicator.setRequestedRange(0, 50);\n+        SerializableConsumer<String> newFilterProvider = dataCommunicator\n+                .setDataProvider(DataProvider.fromFilteringCallbacks(query -> {\n+                    query.getOffset();\n+                    query.getLimit();\n+                    return Stream.of(\"foo\", \"bar\", \"baz\").filter(\n+                            item -> item.equals(query.getFilter().get()));\n+                }, query -> -1), initialFilter);\n+\n+        dataCommunicator.setItemCountEstimate(5);\n+\n+        fakeClientCommunication();\n+        Assert.assertEquals(\"Invalid item on index 0\", initialFilter,\n+                dataView.getItem(0));\n+\n+        newFilterProvider.accept(newFilter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNjQ4Mg==", "bodyText": "I think these active item tests are a bit weird now - and probably as the AbstractLazyDataView just delegates to the DataCommunicator for getItem calls, maybe all the tests for that should just be here ...\nAt least the ones here need to get the name updated, and if the majority of the class is tested through another class, then maybe drop a comment here that \"getItem is tested from ...\"", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449226482", "createdAt": "2020-07-02T19:31:06Z", "author": {"login": "pleku"}, "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/DataCommunicatorTest.java", "diffHunk": "@@ -534,19 +534,19 @@ public void getActiveItemOnIndex_activeRangeChanges_itemsReturned() {\n         dataCommunicator.setRequestedRange(0, 50);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNzA4Mg==", "bodyText": "There is no throwing verified here so the name is incorrect ?", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449227082", "createdAt": "2020-07-02T19:32:36Z", "author": {"login": "pleku"}, "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/DataCommunicatorTest.java", "diffHunk": "@@ -577,15 +577,15 @@ public void isItemActive_newItems() {\n                 dataCommunicator.isItemActive(new Item(100)));\n     }\n \n-    @Test(expected = IndexOutOfBoundsException.class)\n-    public void getActiveItemOnIndex_outsizeActiveRange_throws() {\n+    @Test\n+    public void getItem_outsizeActiveRange_throws() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589d3da1d5fd1eb5dd4c52564220a800e7e7f0bd"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzg0ODE0", "url": "https://github.com/vaadin/flow/pull/8676#pullrequestreview-442384814", "createdAt": "2020-07-03T12:38:15Z", "commit": {"oid": "5858b86b41b20b7e2a0308158612179ac7068c70"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjozODoxNVrOGsvFIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjozODoxNVrOGsvFIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2MTg4OQ==", "bodyText": "Since this variable is used only once, why isn't it inlined ? The name even matches the getter so it doesn't help readability", "url": "https://github.com/vaadin/flow/pull/8676#discussion_r449561889", "createdAt": "2020-07-03T12:38:15Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -323,30 +323,54 @@ public boolean isItemActive(T item) {\n      * not present in the cached active items.\n      *\n      * @param index\n-     *            item index number\n+     *            the index of the item to get\n      * @return item on index\n      * @throws IndexOutOfBoundsException\n      *             requested index is outside of the filtered and sorted data\n-     *             set or the data set is empty\n+     *             set\n      */\n     @SuppressWarnings(\"unchecked\")\n     public T getItem(int index) {\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index must be non-negative\");\n+        }\n         int activeDataEnd = activeStart + activeKeyOrder.size() - 1;\n-        if (index < activeStart || index > activeDataEnd) {\n-            int dataSize = getItemCount();\n-            if (dataSize == 0) {\n-                throw new IndexOutOfBoundsException(String\n-                        .format(\"Requested index %d on empty data.\", index));\n-            }\n-            if (index < 0 || index >= dataSize) {\n-                throw new IndexOutOfBoundsException(String.format(\n-                        \"Given index %d is outside of the accepted range '0 - %d'\",\n-                        index, dataSize - 1));\n+        /*\n+         * Check if the item on a requested index is already in the cache of\n+         * active items. No matter is this currently a defined or undefined\n+         * mode\n+         */\n+        if (index >= activeStart && index <= activeDataEnd) {\n+            return getKeyMapper().get(activeKeyOrder.get(index - activeStart));\n+        } else {\n+            final int itemCount = getItemCount();\n+            final boolean definedSize = isDefinedSize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5858b86b41b20b7e2a0308158612179ac7068c70"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "910bf10d4aab54e0b251cf956ebb5ac129c74e75", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/910bf10d4aab54e0b251cf956ebb5ac129c74e75", "committedDate": "2020-07-03T14:17:35Z", "message": "Add getItem(int index) to DataView #8652"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d02f54f1fb6e741a9d26b5d48783fad9cc54adbb", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/d02f54f1fb6e741a9d26b5d48783fad9cc54adbb", "committedDate": "2020-07-03T14:19:11Z", "message": "Rework getItem, filtering and sorting tests added"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c6b74c7ef69271fce4f33db368540f6b6da9061", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/5c6b74c7ef69271fce4f33db368540f6b6da9061", "committedDate": "2020-07-03T14:19:11Z", "message": "Get item from outside estimation case, rework the unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f09636b751534b967f0153d9ca18d80571951a2", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/5f09636b751534b967f0153d9ca18d80571951a2", "committedDate": "2020-07-03T14:19:11Z", "message": "Remove unnecessary variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab3252765d16a79cf52e216f2beb46c8ae479219", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/ab3252765d16a79cf52e216f2beb46c8ae479219", "committedDate": "2020-07-03T14:22:46Z", "message": "Rebase and remove unnecessary import"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e166f740e70519332353329a04d4de0869a73178", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/e166f740e70519332353329a04d4de0869a73178", "committedDate": "2020-07-03T13:03:33Z", "message": "Remove unnecessary variable"}, "afterCommit": {"oid": "ab3252765d16a79cf52e216f2beb46c8ae479219", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/ab3252765d16a79cf52e216f2beb46c8ae479219", "committedDate": "2020-07-03T14:22:46Z", "message": "Rebase and remove unnecessary import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNzAwNDQy", "url": "https://github.com/vaadin/flow/pull/8676#pullrequestreview-442700442", "createdAt": "2020-07-05T19:22:35Z", "commit": {"oid": "ab3252765d16a79cf52e216f2beb46c8ae479219"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 267, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}