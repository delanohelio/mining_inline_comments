{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwNzY1OTgz", "number": 9155, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMDoxMzo0MlrOEsLz-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozOVrOEwLpvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzY2MzI5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/AppShellRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMDoxMzo0MlrOHfXXNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMDoxMzo0MlrOHfXXNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY1MDY3OA==", "bodyText": "Do not forget to remove this deprecated code someday.", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r502650678", "createdAt": "2020-10-09T20:13:42Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/AppShellRegistry.java", "diffHunk": "@@ -163,12 +161,16 @@ public boolean isShell(Class<?> clz) {\n     }\n \n     /**\n-     * Return the text content of the title tag in the application shell.\n-     *\n-     * @return title;\n+     * @return {code null};\n+     * \n+     * @deprecated this method does not work, to get the application shell title, \n+     * use {code UI.getCurrent().getInternals().getAppShellTitle()} instead.\n      */\n+    @Deprecated\n     public String getTitle() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "923c38e0ca6f13cc1859bf632e9a6598716f3024"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTU3OTk0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozNlrOHllRpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozNlrOHllRpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MDA4Nw==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r509170087", "createdAt": "2020-10-21T10:33:36Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",\n+                                createContentRangeHeader(start, end,\n+                                        connection.getContentLengthLong()))\n+                        .getBytes());\n+\n+                if (position > start) {\n+                    // out-of-sequence range -> open new stream to the file\n+                    // alternative: use single stream with mark / reset\n+                    closeStream(connection.getInputStream());\n+                    connection = resourceURL.openConnection();\n+                    dataStream = connection.getInputStream();\n+                    position = 0L;\n+                }\n+                long skipped = dataStream.skip(start - position);\n+                assert(skipped == start - position);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+                position = end + 1;\n+            }\n+        } finally {\n+            closeStream(dataStream);\n+        }\n+        outputStream.write(String.format(\"\\r\\n--%s\", partBoundary).getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTU4MDAxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozN1rOHllRrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozN1rOHllRrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MDA5NA==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL) \n Found reliance on default encoding in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL): String.getBytes()", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r509170094", "createdAt": "2020-10-21T10:33:37Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTU4MDA3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozOFrOHllRug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozOFrOHllRug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MDEwNg==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r509170106", "createdAt": "2020-10-21T10:33:38Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTU4MDEzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozOVrOHllRxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMzozOVrOHllRxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MDExNg==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r509170116", "createdAt": "2020-10-21T10:33:39Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3142, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}