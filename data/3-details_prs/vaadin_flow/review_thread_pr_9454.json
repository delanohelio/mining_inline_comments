{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0NjM1NDgx", "number": 9454, "reviewThreads": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo0OVrOE7jU6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyOFrOE7jV9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjMyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/scanner/FrontendDependencies.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo0OVrOH3QzMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo0OVrOH3QzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwODk3OA==", "bodyText": "Refactor this code to not nest more than 3 if/for/while/switch/try statements.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527708978", "createdAt": "2020-11-20T14:00:49Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/scanner/FrontendDependencies.java", "diffHunk": "@@ -326,15 +326,24 @@ private void computeApplicationTheme() throws ClassNotFoundException,\n             // we have a proper theme or no-theme for the app\n             ThemeData themeData = themes.iterator().next();\n             if (!themeData.isNotheme()) {\n-                variant = themeData.getVariant();\n                 String themeClass = themeData.getThemeClass();\n-                if (themeClass == null) {\n-                    themeClass = LUMO;\n+                if (!themeData.getThemeName().isEmpty() && themeClass != null) {\n+                    throw new IllegalStateException(\n+                        \"Theme name and theme class can not both be specified. \"\n+                            + \"Theme name uses Lumo and can not be used in combination with custom theme class.\");\n+                }\n+                variant = themeData.getVariant();\n+                if (themeClass != null) {\n+                    theme = getFinder().loadClass(themeClass);\n+                } else {\n+                    theme = getDefaultTheme();\n+                    if (theme == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjQxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/DeferredServletContextInitializers.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1MFrOH3QzPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1MFrOH3QzPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwODk5MA==", "bodyText": "This call to \"add()\" may be a performance hot spot if the collection is large.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527708990", "createdAt": "2020-11-20T14:00:50Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/DeferredServletContextInitializers.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.server.VaadinContext;\n+\n+/**\n+ * Internal collection of initializers which may not be executed immediately but\n+ * requires a {@link Lookup} instance which will be set in the\n+ * {@link VaadinContext} ({@link ServletContext}) only when\n+ * {@link LookupInitializer} completed.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+class DeferredServletContextInitializers {\n+\n+    /**\n+     * A callback which will be called to run\n+     * {@link ServletContainerInitializer} logic once a {@link ServletContext}\n+     * is initialized with {@link Lookup}.\n+     * \n+     * @author Vaadin Ltd\n+     * @since\n+     *\n+     */\n+    interface Initializer {\n+        /**\n+         * Runs {@link ServletContainerInitializer} logic with the provided\n+         * {@code context}.\n+         * \n+         * @param context\n+         *            a ServletContext for the initializer\n+         * @throws ServletException\n+         *             thrown if the initializer throws an exception\n+         */\n+        void init(ServletContext context) throws ServletException;\n+    }\n+\n+    private final List<Initializer> initializers = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * Adds deferred initializer.\n+     * \n+     * @param initializer\n+     *            an initializer\n+     */\n+    void addInitializer(Initializer initializer) {\n+        initializers.add(initializer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjQ4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1MVrOH3QzTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1MVrOH3QzTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTAwNQ==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709005", "createdAt": "2020-11-20T14:00:51Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and is explicitly made non-overridable because it\n+     * provides the way to override everything.\n+     */\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and should not be available as public because\n+     * {@link LookupInitializer} will find it in the classpath and it will be\n+     * always used instead custom {@link ResourceProvider} implementation.\n+     */\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {\n+            initializers = vaadinContext\n+                    .getAttribute(DeferredServletContextInitializers.class);\n+            vaadinContext\n+                    .removeAttribute(DeferredServletContextInitializers.class);\n+        }\n+\n+        if (initializers != null) {\n+            initializers.runInitializers(servletContext);\n+        }\n+    }\n+\n+    @Override\n+    public boolean requiresLookup() {\n+        return false;\n+    }\n+\n+    private void initStandardLookup(Set<Class<?>> classSet,\n+            ServletContext servletContext) {\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+\n+        Map<Class<?>, Collection<Object>> services = new HashMap<>();\n+\n+        collectResourceProviders(classSet, services);\n+        collectSubclasses(InstantiatorFactory.class, classSet, services);\n+        collectSubclasses(DeprecatedPolymerPublishedEventHandler.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjUzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1MlrOH3QzVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1MlrOH3QzVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTAxNQ==", "bodyText": "Reduce the number of conditional operators (5) used in the expression (maximum allowed 3).", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709015", "createdAt": "2020-11-20T14:00:52Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and is explicitly made non-overridable because it\n+     * provides the way to override everything.\n+     */\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and should not be available as public because\n+     * {@link LookupInitializer} will find it in the classpath and it will be\n+     * always used instead custom {@link ResourceProvider} implementation.\n+     */\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {\n+            initializers = vaadinContext\n+                    .getAttribute(DeferredServletContextInitializers.class);\n+            vaadinContext\n+                    .removeAttribute(DeferredServletContextInitializers.class);\n+        }\n+\n+        if (initializers != null) {\n+            initializers.runInitializers(servletContext);\n+        }\n+    }\n+\n+    @Override\n+    public boolean requiresLookup() {\n+        return false;\n+    }\n+\n+    private void initStandardLookup(Set<Class<?>> classSet,\n+            ServletContext servletContext) {\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+\n+        Map<Class<?>, Collection<Object>> services = new HashMap<>();\n+\n+        collectResourceProviders(classSet, services);\n+        collectSubclasses(InstantiatorFactory.class, classSet, services);\n+        collectSubclasses(DeprecatedPolymerPublishedEventHandler.class,\n+                classSet, services);\n+\n+        LookupImpl lookup = new LookupImpl(services);\n+        vaadinContext.setAttribute(Lookup.class, lookup);\n+    }\n+\n+    private void collectSubclasses(Class<?> clazz, Set<Class<?>> classSet,\n+            Map<Class<?>, Collection<Object>> services) {\n+        services.put(clazz,\n+                filterSubClasses(clazz, classSet).stream()\n+                        .map(ReflectTools::createInstance)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    private void collectResourceProviders(Set<Class<?>> classSet,\n+            Map<Class<?>, Collection<Object>> services) {\n+        Set<Class<?>> providers = filterResourceProviders(classSet);\n+        if (providers.isEmpty()) {\n+            services.put(ResourceProvider.class,\n+                    Collections.singletonList(new ResourceProviderImpl()));\n+        } else if (providers.size() > 1) {\n+            throw new IllegalStateException(\n+                    SEVERAL_IMPLS + ResourceProvider.class.getSimpleName() + SPI\n+                            + classSet + ONE_IMPL_REQUIRED);\n+        } else {\n+            Class<?> clazz = providers.iterator().next();\n+            services.put(ResourceProvider.class, Collections\n+                    .singletonList(ReflectTools.createInstance(clazz)));\n+        }\n+    }\n+\n+    private Set<Class<?>> filterResourceProviders(Set<Class<?>> classes) {\n+        return classes == null ? Collections.emptySet()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjYyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1M1rOH3QzZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1M1rOH3QzZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTAyOQ==", "bodyText": "\"servletContext\" is a method parameter, and should not be used for synchronization.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709029", "createdAt": "2020-11-20T14:00:53Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and is explicitly made non-overridable because it\n+     * provides the way to override everything.\n+     */\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and should not be available as public because\n+     * {@link LookupInitializer} will find it in the classpath and it will be\n+     * always used instead custom {@link ResourceProvider} implementation.\n+     */\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjY1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1M1rOH3Qzag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1M1rOH3Qzag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTAzNA==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709034", "createdAt": "2020-11-20T14:00:53Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjcyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1NFrOH3QzdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1NFrOH3QzdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA0NA==", "bodyText": "Replace the synchronized class \"Hashtable\" by an unsynchronized one such as \"HashMap\".", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709044", "createdAt": "2020-11-20T14:00:54Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjc1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1NVrOH3Qzeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1NVrOH3Qzeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA1MA==", "bodyText": "Add a \"try/catch\" block for \"openStream\".", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709050", "createdAt": "2020-11-20T14:00:55Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjc4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1NlrOH3QzgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1NlrOH3QzgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA1Ng==", "bodyText": "Add a \"try/catch\" block for \"copy\". \n Add a \"try/catch\" block for \"getOutputStream\".", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709056", "createdAt": "2020-11-20T14:00:56Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjgyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1N1rOH3QzhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1N1rOH3QzhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA2MQ==", "bodyText": "Reduce the total number of break and continue statements in this loop to use at most one.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709061", "createdAt": "2020-11-20T14:00:57Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/client/*\");\n+        servletClientRegistration.compareAndSet(null,\n+                clientBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(clientBundle,\n+                                \"/META-INF/resources/VAADIN/static/client\"),\n+                        properties));\n+    }\n+\n+    private void unregisterClientResource(Bundle clientBundle) {\n+        ServiceRegistration<Servlet> registration = servletClientRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == clientBundle.getBundleId()) {\n+            registration.unregister();\n+            servletClientRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private boolean isPushModule(Bundle bundle) {\n+        return \"com.vaadin.flow.push\".equals(bundle.getSymbolicName());\n+    }\n+\n+    private boolean isClientModule(Bundle bundle) {\n+        return \"com.vaadin.flow.client\".equals(bundle.getSymbolicName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void scanContextInitializers() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        scanClasses(flowServerBundle, map, this::handleFlowServerClassError);\n+        Collection<Class<?>> classes = map.get(flowServerBundle.getBundleId());\n+\n+        Predicate<Class<?>> isInterface = Class::isInterface;\n+\n+        Collection<Class<? extends ServletContainerInitializer>> initializers = classes\n+                .stream()\n+                .filter(ServletContainerInitializer.class::isAssignableFrom)\n+                .filter(isInterface.negate())\n+                .map(clazz -> (Class<? extends ServletContainerInitializer>) clazz)\n+                .collect(Collectors.toList());\n+        OSGiAccess.getInstance().setServletContainerInitializers(initializers);\n+    }\n+\n+    private void scanActivatedBundle(Bundle bundle) {\n+        if (!isActive(bundle) || !isVaadinExtender(bundle)) {\n+            return;\n+        }\n+        if (OSGiAccess.getInstance().hasInitializers()) {\n+            Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+            scanClasses(bundle, map, this::handleBundleClassError);\n+            OSGiAccess.getInstance().addScannedClasses(map);\n+        } else {\n+            executor.execute(() -> scanActivatedBundle(bundle));\n+        }\n+    }\n+\n+    private void scanActiveBundles() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        Stream.of(flowServerBundle.getBundleContext().getBundles())\n+                .filter(this::isActive).filter(this::isVaadinExtender)\n+                .forEach(activeBundle -> scanClasses(activeBundle, map,\n+                        this::handleBundleClassError));\n+        OSGiAccess.getInstance().addScannedClasses(map);\n+    }\n+\n+    private boolean isActive(Bundle bundle) {\n+        return (bundle.getState() & Bundle.ACTIVE) > 0;\n+    }\n+\n+    private boolean isVaadinExtender(Bundle bundle) {\n+        return !flowServerBundle.equals(bundle) && Boolean.TRUE.toString()\n+                .equals(bundle.getHeaders().get(\"Vaadin-OSGi-Extender\"));\n+    }\n+\n+    private void handleFlowServerClassError(String className,\n+            Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .trace(\"Couldn't load class '{}'\", className, throwable);\n+    }\n+\n+    private void handleBundleClassError(String className, Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .warn(\"Couldn't load class '{}'\", className, throwable);\n+    }\n+\n+    private void scanClasses(Bundle bundle, Map<Long, Collection<Class<?>>> map,\n+            BiConsumer<String, Throwable> throwableHandler) {\n+        BundleWiring wiring = bundle.adapt(BundleWiring.class);\n+\n+        // get all .class resources of this bundle\n+        Collection<String> classes = wiring.listResources(\"/\", \"*.class\",\n+                /*\n+                 * Two options: recursive to visit all resources including\n+                 * sub-directories, and limit resources only to the current\n+                 * wiring (bundle) avoiding possibly returned classes from\n+                 * dependencies\n+                 */\n+                BundleWiring.LISTRESOURCES_RECURSE\n+                        | BundleWiring.LISTRESOURCES_LOCAL);\n+\n+        Collection<Class<?>> bundleClasses = new ArrayList<>();\n+\n+        for (String clazz : classes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjkwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1OFrOH3Qzlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1OFrOH3Qzlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA3OA==", "bodyText": "Replace the synchronized class \"Hashtable\" by an unsynchronized one such as \"HashMap\".", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709078", "createdAt": "2020-11-20T14:00:58Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMjk1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1OVrOH3Qznw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMDo1OVrOH3Qznw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA4Nw==", "bodyText": "Do not forget to remove this deprecated code someday.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709087", "createdAt": "2020-11-20T14:00:59Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "diffHunk": "@@ -151,13 +155,13 @@\n     /**\n      * Default folder for copying front-end resources present in the classpath\n      * jars.\n-     * @deprecated This is deprecated due to a typo.\n-     *             Use DEFAULT_FLOW_RESOURCES_FOLDER instead.\n+     * \n+     * @deprecated This is deprecated due to a typo. Use\n+     *             DEFAULT_FLOW_RESOURCES_FOLDER instead.\n      * @see #DEFAULT_FLOW_RESOURCES_FOLDER\n      */\n     @Deprecated\n-    public static final String DEAULT_FLOW_RESOURCES_FOLDER =\n-            DEFAULT_FLOW_RESOURCES_FOLDER;\n+    public static final String DEAULT_FLOW_RESOURCES_FOLDER = DEFAULT_FLOW_RESOURCES_FOLDER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzAzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowMFrOH3QzqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowMFrOH3QzqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA5Nw==", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709097", "createdAt": "2020-11-20T14:01:00Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),\n+                        data.getParentLayouts()), caught != null);\n+            }\n+            handleCaughtException(caught);\n+        }\n+\n+        private void setRoutes(List<RouteData> routes) {\n+            Exception caught = null;\n+            for (RouteData data : routes) {\n+                caught = modifyRoute(() -> setRoute(data.getUrl(),\n+                        data.getNavigationTarget(), data.getParentLayouts()),\n+                        caught != null);\n+                for (RouteAliasData alias : data.getRouteAliases()) {\n+                    caught = modifyRoute(() -> setRoute(alias.getUrl(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzExOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowMVrOH3Qzsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowMVrOH3Qzsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTEwNw==", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709107", "createdAt": "2020-11-20T14:01:01Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzE4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowMVrOH3QzvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowMVrOH3QzvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTExNw==", "bodyText": "This call to \"add()\" may be a performance hot spot if the collection is large.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709117", "createdAt": "2020-11-20T14:01:01Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzI1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowM1rOH3Qzxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowM1rOH3Qzxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTEyNw==", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709127", "createdAt": "2020-11-20T14:01:03Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),\n+                        data.getParentLayouts()), caught != null);\n+            }\n+            handleCaughtException(caught);\n+        }\n+\n+        private void setRoutes(List<RouteData> routes) {\n+            Exception caught = null;\n+            for (RouteData data : routes) {\n+                caught = modifyRoute(() -> setRoute(data.getUrl(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzM3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowNFrOH3Qz1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowNFrOH3Qz1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE0Mw==", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709143", "createdAt": "2020-11-20T14:01:04Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzUxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowNVrOH3Qz5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowNVrOH3Qz5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE1OQ==", "bodyText": "Rename \"instantiator\" which hides the field declared at line 191.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709159", "createdAt": "2020-11-20T14:01:05Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,33 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzU0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowNlrOH3Qz8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowNlrOH3Qz8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE2OA==", "bodyText": "Remove this use of \"init\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709168", "createdAt": "2020-11-20T14:01:06Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,33 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                // if the existing instantiator is converted to new API then\n+                // let's respect its deprecated method\n+                if (instantiator != null && instantiator.init(this)) {\n+                    instantiators.add(instantiator);\n+                }\n+            }\n+        }\n+\n+        if (instantiators == null) {\n+            instantiators = new ArrayList<>();\n+        }\n+\n+        // the code to support previous way of loading instantiators\n+        StreamSupport\n                 .stream(ServiceLoader.load(Instantiator.class, getClassLoader())\n                         .spliterator(), false)\n                 .filter(iterator -> iterator.init(this))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzYwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowN1rOH3Qz-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowN1rOH3Qz-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE3OA==", "bodyText": "Remove this use of \"init\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709178", "createdAt": "2020-11-20T14:01:07Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,33 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                // if the existing instantiator is converted to new API then\n+                // let's respect its deprecated method\n+                if (instantiator != null && instantiator.init(this)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzYzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowOFrOH3Q0Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowOFrOH3Q0Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE4Ng==", "bodyText": "Reduce this lambda expression number of lines from 37 to at most 20.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709186", "createdAt": "2020-11-20T14:01:08Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzY2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowOVrOH3Q0Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTowOVrOH3Q0Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE5MA==", "bodyText": "This block of commented-out lines of code should be removed.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709190", "createdAt": "2020-11-20T14:01:09Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzc5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxMFrOH3Q0Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxMFrOH3Q0Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTIxMA==", "bodyText": "Replace this lambda with a method reference.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709210", "createdAt": "2020-11-20T14:01:10Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n+\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {\n+                if (vaadinContext.getAttribute(Lookup.class) == null) {\n+                    DeferredServletContextInitializers initializers = vaadinContext\n+                            .getAttribute(\n+                                    DeferredServletContextInitializers.class,\n+                                    () -> new DeferredServletContextInitializers());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzg0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxMVrOH3Q0IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxMVrOH3Q0IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTIxNg==", "bodyText": "Replace this lambda with a method reference.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709216", "createdAt": "2020-11-20T14:01:11Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n+\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {\n+                if (vaadinContext.getAttribute(Lookup.class) == null) {\n+                    DeferredServletContextInitializers initializers = vaadinContext\n+                            .getAttribute(\n+                                    DeferredServletContextInitializers.class,\n+                                    () -> new DeferredServletContextInitializers());\n+                    initializers.addInitializer(\n+                            ctx -> deferredInitializer.init(ctx));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwMzkxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxMVrOH3Q0Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxMVrOH3Q0Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTIyNw==", "bodyText": "\"context\" is a method parameter, and should not be used for synchronization.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709227", "createdAt": "2020-11-20T14:01:11Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n+\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDAyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxMlrOH3Q0Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxMlrOH3Q0Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI0Mw==", "bodyText": "Either log or rethrow this exception. \n Catch Exception instead of Throwable.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709243", "createdAt": "2020-11-20T14:01:12Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return an OSGi temporary servlet context\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\n+                    \"Couldn't run servlet context initializer \"\n+                            + initializer.getClass(),\n+                    e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Set<Class<?>> filterClasses(HandlesTypes typesAnnotation) {\n+        Set<Class<?>> result = new HashSet<>();\n+        if (typesAnnotation == null) {\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes));\n+        } else {\n+            Class<?>[] requestedTypes = typesAnnotation.value();\n+\n+            Predicate<Class<?>> isAnnotation = Class::isAnnotation;\n+\n+            List<Class<? extends Annotation>> annotations = Stream\n+                    .of(requestedTypes).filter(isAnnotation)\n+                    .map(clazz -> (Class<? extends Annotation>) clazz)\n+                    .collect(Collectors.toList());\n+\n+            List<Class<?>> superTypes = Stream.of(requestedTypes)\n+                    .filter(isAnnotation.negate()).collect(Collectors.toList());\n+\n+            Predicate<Class<?>> hasType = clazz -> annotations.stream()\n+                    .anyMatch(annotation -> AnnotationReader\n+                            .getAnnotationFor(clazz, annotation).isPresent())\n+                    || superTypes.stream()\n+                            .anyMatch(superType -> GenericTypeReflector\n+                                    .isSuperType(HasErrorParameter.class,\n+                                            clazz));\n+\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes\n+                    .stream().filter(hasType).collect(Collectors.toList())));\n+\n+        }\n+        return result;\n+    }\n+\n+    private ServletContext createOSGiServletContext() {\n+        Builder<OSGiServletContext> builder = new ByteBuddy()\n+                .subclass(OSGiServletContext.class);\n+\n+        Class<? extends OSGiServletContext> osgiServletContextClass = builder\n+                .make().load(OSGiServletContext.class.getClassLoader(),\n+                        ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        OSGiServletContext osgiContext = ReflectTools.createProxyInstance(\n+                osgiServletContextClass, ServletContext.class);\n+\n+        new VaadinServletContext(osgiContext).setAttribute(Lookup.class,\n+                new OsgiLookupImpl());\n+\n+        return osgiContext;\n+    }\n+\n+    private static final class LazyOSGiDetector {\n+        private static final boolean IS_IN_OSGI = isInOSGi();\n+\n+        private static boolean isInOSGi() {\n+            try {\n+                Class<?> clazz = Class\n+                        .forName(\"org.osgi.framework.FrameworkUtil\");\n+\n+                Method method = clazz.getDeclaredMethod(\"getBundle\",\n+                        Class.class);\n+\n+                // even though the FrameworkUtil class is in the classpath it\n+                // may be there not because of OSGi container but plain WAR with\n+                // jar which contains the class\n+                if (method.invoke(null, OSGiAccess.class) == null) {\n+                    return false;\n+                }\n+                UsageStatistics.markAsUsed(\"flow/osgi\", getOSGiVersion());\n+\n+                return true;\n+            } catch (ClassNotFoundException | NoSuchMethodException\n+                    | SecurityException | IllegalAccessException\n+                    | IllegalArgumentException\n+                    | InvocationTargetException exception) {\n+                if (LoggerFactory.getLogger(OSGiAccess.class)\n+                        .isTraceEnabled()) {\n+                    LoggerFactory.getLogger(OSGiAccess.class)\n+                            .trace(\"Exception in OSGi container check \"\n+                                    + \"(which most likely means that this is not OSGi container)\",\n+                                    exception);\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /**\n+         * Tries to detect the version of the OSGi framework used.\n+         *\n+         * @return the used OSGi version or {@code null} if not able to detect\n+         *         it\n+         */\n+        private static String getOSGiVersion() {\n+            try {\n+                Bundle osgiBundle = org.osgi.framework.FrameworkUtil\n+                        .getBundle(Bundle.class);\n+                return osgiBundle.getVersion().toString();\n+            } catch (Throwable throwable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDA2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxM1rOH3Q0Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxM1rOH3Q0Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI0Nw==", "bodyText": "Add a private constructor to hide the implicit public one.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709247", "createdAt": "2020-11-20T14:01:13Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return an OSGi temporary servlet context\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\n+                    \"Couldn't run servlet context initializer \"\n+                            + initializer.getClass(),\n+                    e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Set<Class<?>> filterClasses(HandlesTypes typesAnnotation) {\n+        Set<Class<?>> result = new HashSet<>();\n+        if (typesAnnotation == null) {\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes));\n+        } else {\n+            Class<?>[] requestedTypes = typesAnnotation.value();\n+\n+            Predicate<Class<?>> isAnnotation = Class::isAnnotation;\n+\n+            List<Class<? extends Annotation>> annotations = Stream\n+                    .of(requestedTypes).filter(isAnnotation)\n+                    .map(clazz -> (Class<? extends Annotation>) clazz)\n+                    .collect(Collectors.toList());\n+\n+            List<Class<?>> superTypes = Stream.of(requestedTypes)\n+                    .filter(isAnnotation.negate()).collect(Collectors.toList());\n+\n+            Predicate<Class<?>> hasType = clazz -> annotations.stream()\n+                    .anyMatch(annotation -> AnnotationReader\n+                            .getAnnotationFor(clazz, annotation).isPresent())\n+                    || superTypes.stream()\n+                            .anyMatch(superType -> GenericTypeReflector\n+                                    .isSuperType(HasErrorParameter.class,\n+                                            clazz));\n+\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes\n+                    .stream().filter(hasType).collect(Collectors.toList())));\n+\n+        }\n+        return result;\n+    }\n+\n+    private ServletContext createOSGiServletContext() {\n+        Builder<OSGiServletContext> builder = new ByteBuddy()\n+                .subclass(OSGiServletContext.class);\n+\n+        Class<? extends OSGiServletContext> osgiServletContextClass = builder\n+                .make().load(OSGiServletContext.class.getClassLoader(),\n+                        ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        OSGiServletContext osgiContext = ReflectTools.createProxyInstance(\n+                osgiServletContextClass, ServletContext.class);\n+\n+        new VaadinServletContext(osgiContext).setAttribute(Lookup.class,\n+                new OsgiLookupImpl());\n+\n+        return osgiContext;\n+    }\n+\n+    private static final class LazyOSGiDetector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 356}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDEwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxNFrOH3Q0RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxNFrOH3Q0RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI1Mg==", "bodyText": "Define and throw a dedicated exception instead of using a generic one.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709252", "createdAt": "2020-11-20T14:01:14Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return an OSGi temporary servlet context\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDE1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/di/Instantiator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxNVrOH3Q0TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxNVrOH3Q0TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI2MQ==", "bodyText": "Do not forget to remove this deprecated code someday.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709261", "createdAt": "2020-11-20T14:01:15Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/di/Instantiator.java", "diffHunk": "@@ -63,7 +63,12 @@\n      * @return <code>true</code> if this instance should be considered as a\n      *         candidate for usage for the provided service; <code>false</code>\n      *         to opt-out from the selection process\n+     * @deprecated The {@link Instantiator} instance should be created by an\n+     *             {@link InstantiatorFactory} which should just return\n+     *             {@code null} if the provided {@code service} can't be handled\n+     *             by it\n      */\n+    @Deprecated\n     boolean init(VaadinService service);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDIxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/webcomponent/OSGiWebComponentConfigurationRegistryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxNlrOH3Q0Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxNlrOH3Q0Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI3MA==", "bodyText": "Remove this use of \"Thread.sleep()\".", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709270", "createdAt": "2020-11-20T14:01:16Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/webcomponent/OSGiWebComponentConfigurationRegistryTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.vaadin.flow.server.webcomponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.startup.EnableOSGiRunner;\n+\n+import net.jcip.annotations.NotThreadSafe;\n+\n+@NotThreadSafe\n+@RunWith(EnableOSGiRunner.class)\n+public class OSGiWebComponentConfigurationRegistryTest\n+        extends WebComponentConfigurationRegistryTest {\n+\n+    @Override\n+    protected WebComponentConfigurationRegistry createRegistry() {\n+        return new OSGiWebComponentConfigurationRegistry();\n+    }\n+\n+    @Test\n+    @Override\n+    public void assertRegistryIsSingleton() {\n+        Assert.assertSame(\n+                \"OSGiWebComponentConfigurationRegistry instance should be singleton\",\n+                registry,\n+                OSGiWebComponentConfigurationRegistry.getInstance(context));\n+    }\n+\n+    @After\n+    public void cleanUpOSGi() {\n+        OSGiAccess.getInstance().getOsgiServletContext().removeAttribute(\n+                WebComponentConfigurationRegistry.class.getName());\n+    }\n+\n+    @Override\n+    @Test\n+    public void assertWebComponentRegistry() {\n+        Assert.assertEquals(\n+                OSGiWebComponentConfigurationRegistry.class.getName(),\n+                registry.getClass().getName());\n+    }\n+\n+    @Override\n+    public void setConfigurationsTwice_onlyFirstSetIsAccepted() {\n+        // OSGi accepts setting the web components multiple times.\n+        // NO-OP\n+    }\n+\n+    @Override\n+    public void setConfigurations_getConfigurationsCallDoesNotChangeSetProtection() {\n+        // OSGi accepts setting the web components multiple times.\n+        // NO-OP\n+    }\n+\n+    @Test\n+    public void setBuildersTwice_allSetsAcceptedLastSetValid() {\n+        Assert.assertFalse(\"Registry should have no configurations\",\n+                registry.hasConfigurations());\n+\n+        Assert.assertTrue(\n+                \"Registry should have accepted the \" + \"WebComponentExporters\",\n+                registry.setConfigurations(\n+                        createConfigurations(MyComponentExporter.class)));\n+\n+        Assert.assertTrue(\n+                \"OSGi registry should have accept the second set of \"\n+                        + \"WebComponentExporters.\",\n+                registry.setConfigurations(\n+                        createConfigurations(UserBoxExporter.class)));\n+\n+        Assert.assertEquals(\"Registry should contain only one builder\", 1,\n+                registry.getConfigurations().size());\n+\n+        Assert.assertEquals(\"Builder should be linked to UserBox.class\",\n+                UserBox.class, registry.getConfiguration(\"user-box\").get()\n+                        .getComponentClass());\n+\n+        Assert.assertTrue(\"Registry should have configurations\",\n+                registry.hasConfigurations());\n+    }\n+\n+    @Override\n+    public void setSameRouteValueFromDifferentThreads_ConcurrencyTest()\n+            throws InterruptedException, ExecutionException {\n+        final int THREADS = 10;\n+\n+        ExecutorService executorService = Executors.newFixedThreadPool(THREADS);\n+\n+        List<Callable<AtomicBoolean>> callables = IntStream.range(0, THREADS)\n+                .mapToObj(i -> {\n+                    Callable<AtomicBoolean> callable = () -> {\n+                        // Add random sleep for better possibility to run at\n+                        // same time\n+                        Thread.sleep(new Random().nextInt(200));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDI4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxN1rOH3Q0Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxN1rOH3Q0Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI3OQ==", "bodyText": "Immediately return this expression instead of assigning it to the temporary variable \"resourceProvider\".", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709279", "createdAt": "2020-11-20T14:01:17Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,52 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = getResourceProvider(context);\n+            String clientEngine = getClientEngine(resourceProvider);\n+            boolean resolveNow = !productionMode || clientEngine == null;\n             if (resolveNow\n-                    && ClientResourcesUtils.getResource(\"/META-INF/resources/\"\n+                    && resourceProvider.getClientResource(\"/META-INF/resources/\"\n                             + CLIENT_ENGINE_NOCACHE_FILE) != null) {\n                 return context.getUriResolver().resolveVaadinUri(\n                         \"context://\" + CLIENT_ENGINE_NOCACHE_FILE);\n             }\n \n-            if (getClientEngine() == null) {\n+            if (clientEngine == null) {\n                 throw new BootstrapException(\n                         \"Client engine file name has not been resolved during initialization\");\n             }\n             return context.getUriResolver()\n-                    .resolveVaadinUri(\"context://\" + getClientEngine());\n+                    .resolveVaadinUri(\"context://\" + clientEngine);\n+        }\n+\n+        private ResourceProvider getResourceProvider(BootstrapContext context) {\n+            ResourceProvider resourceProvider = context.getSession()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDM0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxOFrOH3Q0aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxOFrOH3Q0aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI4OA==", "bodyText": "Do not forget to remove this deprecated code someday.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709288", "createdAt": "2020-11-20T14:01:18Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Service for injecting the polymer event handler when the module is available.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ * @deprecated Polymer template support is deprecated - we recommend you to use\n+ *             {@code LitTemplate} instead. Read more details from <a href=\n+ *             \"https://vaadin.com/blog/future-of-html-templates-in-vaadin\">the\n+ *             Vaadin blog.</a>\n+ */\n+@Deprecated\n+public interface DeprecatedPolymerPublishedEventHandler extends Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDQwOnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxOVrOH3Q0cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToxOVrOH3Q0cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI5Nw==", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709297", "createdAt": "2020-11-20T14:01:19Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container. *\n+ * \n+ * @since\n+ */\n+// This is OSGi specific annotation for the class which may be used without\n+// OSGi. But RetentionPolicy.CLASS used for the annotation makes it safe to use\n+// in runtime because JVM doesn't see it.\n+@org.osgi.service.component.annotations.Component(immediate = true)\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *            Component to be validated\n+     * @param argValue\n+     *            received value\n+     * @param convertedType\n+     *            target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDQ0OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyMFrOH3Q0eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyMFrOH3Q0eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTMwNg==", "bodyText": "Remove this use of \"ModelType\"; it is deprecated. \n Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709306", "createdAt": "2020-11-20T14:01:20Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container. *\n+ * \n+ * @since\n+ */\n+// This is OSGi specific annotation for the class which may be used without\n+// OSGi. But RetentionPolicy.CLASS used for the annotation makes it safe to use\n+// in runtime because JVM doesn't see it.\n+@org.osgi.service.component.annotations.Component(immediate = true)\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *            Component to be validated\n+     * @param argValue\n+     *            received value\n+     * @param convertedType\n+     *            target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)\n+                        .isSupportedClass(convertedType)\n+                && ((JsonObject) argValue).hasKey(\"nodeId\");\n+    }\n+\n+    /**\n+     * Get the template model object and type.\n+     *\n+     * @param template\n+     *            polymer template to get model from\n+     * @param argValue\n+     *            argument value\n+     * @param convertedType\n+     *            value type\n+     * @return the provided model value\n+     * @throws IllegalStateException\n+     *             if the component is not attached to the UI\n+     */\n+    @Override\n+    public Object getTemplateItem(Component template, JsonObject argValue,\n+            Type convertedType) {\n+        final Optional<UI> ui = template.getUI();\n+        if (ui.isPresent()) {\n+            StateNode node = ui.get().getInternals().getStateTree()\n+                    .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+\n+            ModelType propertyType = ((PolymerTemplate<?>) template)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDUxOnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyMVrOH3Q0hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyMVrOH3Q0hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTMxNw==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709317", "createdAt": "2020-11-20T14:01:21Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container. *\n+ * \n+ * @since\n+ */\n+// This is OSGi specific annotation for the class which may be used without\n+// OSGi. But RetentionPolicy.CLASS used for the annotation makes it safe to use\n+// in runtime because JVM doesn't see it.\n+@org.osgi.service.component.annotations.Component(immediate = true)\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDYwOnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyMlrOH3Q0kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyMlrOH3Q0kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTMzMA==", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709330", "createdAt": "2020-11-20T14:01:22Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container. *\n+ * \n+ * @since\n+ */\n+// This is OSGi specific annotation for the class which may be used without\n+// OSGi. But RetentionPolicy.CLASS used for the annotation makes it safe to use\n+// in runtime because JVM doesn't see it.\n+@org.osgi.service.component.annotations.Component(immediate = true)\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *            Component to be validated\n+     * @param argValue\n+     *            received value\n+     * @param convertedType\n+     *            target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDY2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/HandlerHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyM1rOH3Q0mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyM1rOH3Q0mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTMzOQ==", "bodyText": "Define and throw a dedicated exception instead of using a generic one.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709339", "createdAt": "2020-11-20T14:01:23Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/HandlerHelper.java", "diffHunk": "@@ -176,4 +189,26 @@ public static String getCancelingRelativePath(String pathToCancel) {\n         return sb.toString();\n     }\n \n+    /**\n+     * Checks if the given URL path contains the directory change instruction\n+     * (dot-dot), taking into account possible double encoding in hexadecimal\n+     * format, which can be injected maliciously.\n+     *\n+     * @param path\n+     *            the URL path to be verified.\n+     * @return {@code true}, if the given path has a directory change\n+     *         instruction, {@code false} otherwise.\n+     */\n+    public static boolean isPathUnsafe(String path) {\n+        // Check that the path does not have '/../', '\\..\\', %5C..%5C,\n+        // %2F..%2F, nor '/..', '\\..', %5C.., %2F..\n+        try {\n+            path = URLDecoder.decode(path, StandardCharsets.UTF_8.name());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(\"An error occurred during decoding URL.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDcxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyNFrOH3Q0ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyNFrOH3Q0ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM0Nw==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709347", "createdAt": "2020-11-20T14:01:24Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                if (!ui.isPresent()) {\n+                    throw new IllegalStateException(\n+                            \"Rpc handler may not be called for a detached component\");\n+                }\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDc4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyNVrOH3Q0qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyNVrOH3Q0qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM1NQ==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709355", "createdAt": "2020-11-20T14:01:25Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                if (!ui.isPresent()) {\n+                    throw new IllegalStateException(\n+                            \"Rpc handler may not be called for a detached component\");\n+                }\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context\n+                        .getAttribute(Lookup.class)\n+                        .lookup(DeprecatedPolymerPublishedEventHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDgzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyNlrOH3Q0sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyNlrOH3Q0sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM2MQ==", "bodyText": "A \"NullPointerException\" could be thrown; \"instance\" is nullable here.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709361", "createdAt": "2020-11-20T14:01:26Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -180,14 +182,16 @@ private static void invokeMethod(Component instance, Method method,\n                 Serializable returnValue = (Serializable) invokeMethod(instance,\n                         method, args);\n \n-                instance.getElement().executeJs(\"this.$server['\"\n+                instance.getElement()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDg2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyN1rOH3Q0tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyN1rOH3Q0tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM2Ng==", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709366", "createdAt": "2020-11-20T14:01:27Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -107,13 +110,12 @@ public String getRpcType() {\n             PolymerServerEventHandlers eventHandlers = node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNDkyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyN1rOH3Q0vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyN1rOH3Q0vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM3NQ==", "bodyText": "A \"NullPointerException\" could be thrown; \"instance\" is nullable here.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709375", "createdAt": "2020-11-20T14:01:27Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -180,14 +182,16 @@ private static void invokeMethod(Component instance, Method method,\n                 Serializable returnValue = (Serializable) invokeMethod(instance,\n                         method, args);\n \n-                instance.getElement().executeJs(\"this.$server['\"\n+                instance.getElement()\n+                        .executeJs(\"this.$server['\"\n                                 + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n-                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n-                        returnValue);\n+                                + \"']($0, true, $1)\",\n+                                Integer.valueOf(promiseId), returnValue);\n             } catch (RuntimeException e) {\n-                instance.getElement().executeJs(\"this.$server['\"\n-                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n-                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+                instance.getElement()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODgwNTAwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyOFrOH3Q0yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMToyOFrOH3Q0yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM4NQ==", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709385", "createdAt": "2020-11-20T14:01:28Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -107,13 +110,12 @@ public String getRpcType() {\n             PolymerServerEventHandlers eventHandlers = node\n                     .getFeature(PolymerServerEventHandlers.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2808, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}