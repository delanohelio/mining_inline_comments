{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxMTAzMDM1", "number": 8874, "title": "Filter type support in Data View interfaces", "bodyText": "Part of https://github.com/vaadin/vaadin-combo-box-flow/issues/355\n\nHasDataView and HasLazyDataView now contains F filter generic type in their declarations.\nAbstractDataView requires a query supplier instead of just creating a Query with no filter and sorting. Components implies to provide such a query populated with their internal filter or sorting. Basically it delegates to DataCommunicator::buildQuery. For Select and CheckBoxGroup it will be new Query() like previously, because those components do not have them.\nsetItems(InMemoryDataProvider) is now supplemented with a filter converter, because it's impossible to just delegate it to generic setItems because of filter type in declaration. Old setItems(InMemoryDataProvider) methods proposed to be removed.\n\nGrid vaadin/vaadin-grid-flow#1100\nComboBox vaadin/vaadin-combo-box-flow#380\nSelect TBD\nCheckBoxGroup TBD", "createdAt": "2020-08-20T17:21:49Z", "url": "https://github.com/vaadin/flow/pull/8874", "merged": true, "mergeCommit": {"oid": "91c7e183cc0d9be3a6e7879f1d555b7635782521"}, "closed": true, "closedAt": "2020-08-24T07:32:46Z", "author": {"login": "mshabarov"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAzYEagH2gAyNDcxMTAzMDM1OjE1MzQzNjllMzIyNjE3ZWI5MTg5Njg2NTgzNGM2NDM4ODUxOTdmM2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdB9f54gFqTQ3MzE4MjgzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1534369e322617eb91896865834c643885197f3e", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/1534369e322617eb91896865834c643885197f3e", "committedDate": "2020-08-20T17:08:41Z", "message": "Filter type support in Data View interfaces"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMjA1NzY0", "url": "https://github.com/vaadin/flow/pull/8874#pullrequestreview-472205764", "createdAt": "2020-08-21T06:30:11Z", "commit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNjozMDoxMVrOHEdMiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNzozMTo1MFrOHEfcQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzNDY5Ng==", "bodyText": "\"...into a predicate applied to the data provider\"", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474434696", "createdAt": "2020-08-21T06:30:11Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/HasDataView.java", "diffHunk": "@@ -30,35 +35,89 @@\n  *            DataView type\n  * @since\n  */\n-public interface HasDataView<T, V extends DataView<T>> extends Serializable {\n+public interface HasDataView<T, F, V extends DataView<T>> extends Serializable {\n \n     /**\n      * Set a generic data provider for the component to use and returns the base\n      * {@link DataView} that provides API to get information on the items.\n      * <p>\n-     * This method should be used only when the data provider type\n-     * is not either {@link ListDataProvider} or {@link BackEndDataProvider}.\n+     * This method should be used only when the data provider type is not either\n+     * {@link ListDataProvider} or {@link BackEndDataProvider}.\n      *\n      * @param dataProvider\n-     *            DataProvider instance to use\n+     *            DataProvider instance to use, not <code>null</code>\n      * @return DataView providing information on the data\n      */\n-    V setItems(DataProvider<T, ?> dataProvider);\n+    V setItems(DataProvider<T, F> dataProvider);\n \n     /**\n-     * Sets an in-memory data provider for the component to use.\n+     * Sets an in-memory data provider for the component to use, taking into\n+     * account both in-memory filtering from data provider and component\n+     * specific internal filter.\n+     * <p>\n+     * Component's filter is transformed into a predicate through the given\n+     * filter combiner. Example of filter combiner which produces the\n+     * Person's name predicate:\n+     * {@code (String nameFilter) -> person -> person.getName().equalsIgnoreCase\n+     * (nameFilter);}\n      * <p>\n      * Note! Using a {@link ListDataProvider} instead of a\n      * {@link InMemoryDataProvider} is recommended to get access to\n      * {@link ListDataView} API by using\n      * {@link HasListDataView#setItems(ListDataProvider)}.\n      *\n      * @param dataProvider\n-     *            InMemoryDataProvider to use\n+     *            InMemoryDataProvider to use, not <code>null</code>\n+     * @param filterConverter a function which converts a component's\n+     *                        internal filter into a predicate to be\n+     *                        applied to the all items of data provider", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzNzk3NA==", "bodyText": "I don't know if the filtering here is that important, since the setItems(DataProvider) neither mentions anything about it.\nMaybe it would be OK to clarify in a later sentence that if the component has inbuilt filtering, then it the other method with filter converter should be used instead.", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474437974", "createdAt": "2020-08-21T06:39:09Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/HasDataView.java", "diffHunk": "@@ -30,35 +35,89 @@\n  *            DataView type\n  * @since\n  */\n-public interface HasDataView<T, V extends DataView<T>> extends Serializable {\n+public interface HasDataView<T, F, V extends DataView<T>> extends Serializable {\n \n     /**\n      * Set a generic data provider for the component to use and returns the base\n      * {@link DataView} that provides API to get information on the items.\n      * <p>\n-     * This method should be used only when the data provider type\n-     * is not either {@link ListDataProvider} or {@link BackEndDataProvider}.\n+     * This method should be used only when the data provider type is not either\n+     * {@link ListDataProvider} or {@link BackEndDataProvider}.\n      *\n      * @param dataProvider\n-     *            DataProvider instance to use\n+     *            DataProvider instance to use, not <code>null</code>\n      * @return DataView providing information on the data\n      */\n-    V setItems(DataProvider<T, ?> dataProvider);\n+    V setItems(DataProvider<T, F> dataProvider);\n \n     /**\n-     * Sets an in-memory data provider for the component to use.\n+     * Sets an in-memory data provider for the component to use, taking into\n+     * account both in-memory filtering from data provider and component\n+     * specific internal filter.\n+     * <p>\n+     * Component's filter is transformed into a predicate through the given\n+     * filter combiner. Example of filter combiner which produces the\n+     * Person's name predicate:\n+     * {@code (String nameFilter) -> person -> person.getName().equalsIgnoreCase\n+     * (nameFilter);}\n      * <p>\n      * Note! Using a {@link ListDataProvider} instead of a\n      * {@link InMemoryDataProvider} is recommended to get access to\n      * {@link ListDataView} API by using\n      * {@link HasListDataView#setItems(ListDataProvider)}.\n      *\n      * @param dataProvider\n-     *            InMemoryDataProvider to use\n+     *            InMemoryDataProvider to use, not <code>null</code>\n+     * @param filterConverter a function which converts a component's\n+     *                        internal filter into a predicate to be\n+     *                        applied to the all items of data provider\n      * @return DataView providing information on the data\n+     *\n+     * @see #setItems(InMemoryDataProvider)\n+     */\n+    default V setItems(InMemoryDataProvider<T> dataProvider,\n+            SerializableFunction<F, SerializablePredicate<T>> filterConverter) {\n+        Objects.requireNonNull(filterConverter,\n+                \"FilterConverter cannot be null\");\n+        DataProvider<T, F> convertedDataProvider = dataProvider\n+                .withConvertedFilter(filter -> Optional\n+                        .ofNullable(dataProvider.getFilter())\n+                        .orElse(item -> true)\n+                        .and(item -> filterConverter.apply(filter).test(item)));\n+        return setItems(convertedDataProvider);\n+    }\n+\n+    /**\n+     * Sets an in-memory data provider for the component to use, taking into\n+     * account only in-memory filtering from data provider.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzOTExOQ==", "bodyText": "Since ComboBox is still the only component with inbuilt filtering, it might be OK even still to just force the components to implement this method always (not have default implementation at all) and then make CB throw in the implementation, and point to the method with the filter converter instead, which would only be in CB.\nI cannot say at the moment which is better or worse option.", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474439119", "createdAt": "2020-08-21T06:42:27Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/HasDataView.java", "diffHunk": "@@ -30,35 +35,89 @@\n  *            DataView type\n  * @since\n  */\n-public interface HasDataView<T, V extends DataView<T>> extends Serializable {\n+public interface HasDataView<T, F, V extends DataView<T>> extends Serializable {\n \n     /**\n      * Set a generic data provider for the component to use and returns the base\n      * {@link DataView} that provides API to get information on the items.\n      * <p>\n-     * This method should be used only when the data provider type\n-     * is not either {@link ListDataProvider} or {@link BackEndDataProvider}.\n+     * This method should be used only when the data provider type is not either\n+     * {@link ListDataProvider} or {@link BackEndDataProvider}.\n      *\n      * @param dataProvider\n-     *            DataProvider instance to use\n+     *            DataProvider instance to use, not <code>null</code>\n      * @return DataView providing information on the data\n      */\n-    V setItems(DataProvider<T, ?> dataProvider);\n+    V setItems(DataProvider<T, F> dataProvider);\n \n     /**\n-     * Sets an in-memory data provider for the component to use.\n+     * Sets an in-memory data provider for the component to use, taking into\n+     * account both in-memory filtering from data provider and component\n+     * specific internal filter.\n+     * <p>\n+     * Component's filter is transformed into a predicate through the given\n+     * filter combiner. Example of filter combiner which produces the\n+     * Person's name predicate:\n+     * {@code (String nameFilter) -> person -> person.getName().equalsIgnoreCase\n+     * (nameFilter);}\n      * <p>\n      * Note! Using a {@link ListDataProvider} instead of a\n      * {@link InMemoryDataProvider} is recommended to get access to\n      * {@link ListDataView} API by using\n      * {@link HasListDataView#setItems(ListDataProvider)}.\n      *\n      * @param dataProvider\n-     *            InMemoryDataProvider to use\n+     *            InMemoryDataProvider to use, not <code>null</code>\n+     * @param filterConverter a function which converts a component's\n+     *                        internal filter into a predicate to be\n+     *                        applied to the all items of data provider\n      * @return DataView providing information on the data\n+     *\n+     * @see #setItems(InMemoryDataProvider)\n+     */\n+    default V setItems(InMemoryDataProvider<T> dataProvider,\n+            SerializableFunction<F, SerializablePredicate<T>> filterConverter) {\n+        Objects.requireNonNull(filterConverter,\n+                \"FilterConverter cannot be null\");\n+        DataProvider<T, F> convertedDataProvider = dataProvider\n+                .withConvertedFilter(filter -> Optional\n+                        .ofNullable(dataProvider.getFilter())\n+                        .orElse(item -> true)\n+                        .and(item -> filterConverter.apply(filter).test(item)));\n+        return setItems(convertedDataProvider);\n+    }\n+\n+    /**\n+     * Sets an in-memory data provider for the component to use, taking into\n+     * account only in-memory filtering from data provider.\n+     * <p>\n+     * This methods ignores the component specific filter, even if it's included\n+     * into the query object. If you want to take it into account, please use\n+     * {@link #setItems(InMemoryDataProvider, SerializableFunction)}.\n+     * <p>\n+     * Note! Using a {@link ListDataProvider} instead of a\n+     * {@link InMemoryDataProvider} is recommended to get access to\n+     * {@link ListDataView} API by using\n+     * {@link HasListDataView#setItems(ListDataProvider)}.\n+     *\n+     * @param dataProvider\n+     *            InMemoryDataProvider to use, not <code>null</code>\n+     * @return DataView providing information on the data\n+     *\n+     * @see #setItems(InMemoryDataProvider, SerializableFunction)\n      */\n+    // TODO: probably we should just remove this methods, because it has a\n+    //  significant drawback: it ignores the component's filter quietly, even\n+    //  though it described in javadoc, so the developer can easily make a\n+    //  mistake here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzOTE0MQ==", "bodyText": "Would be better to start why one should use this method instead of explaining how it works:\n\"Sets an in-memory data provider to use with a component that has internal filtering, like {@code ComboBox}. For components without inbuilt filtering use ...... instead.\"", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474439141", "createdAt": "2020-08-21T06:42:30Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/HasDataView.java", "diffHunk": "@@ -30,35 +35,89 @@\n  *            DataView type\n  * @since\n  */\n-public interface HasDataView<T, V extends DataView<T>> extends Serializable {\n+public interface HasDataView<T, F, V extends DataView<T>> extends Serializable {\n \n     /**\n      * Set a generic data provider for the component to use and returns the base\n      * {@link DataView} that provides API to get information on the items.\n      * <p>\n-     * This method should be used only when the data provider type\n-     * is not either {@link ListDataProvider} or {@link BackEndDataProvider}.\n+     * This method should be used only when the data provider type is not either\n+     * {@link ListDataProvider} or {@link BackEndDataProvider}.\n      *\n      * @param dataProvider\n-     *            DataProvider instance to use\n+     *            DataProvider instance to use, not <code>null</code>\n      * @return DataView providing information on the data\n      */\n-    V setItems(DataProvider<T, ?> dataProvider);\n+    V setItems(DataProvider<T, F> dataProvider);\n \n     /**\n-     * Sets an in-memory data provider for the component to use.\n+     * Sets an in-memory data provider for the component to use, taking into\n+     * account both in-memory filtering from data provider and component\n+     * specific internal filter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzOTkzMw==", "bodyText": "Since filter is basically optional, I would maybe mention that one last as \"...and an optional filter\"", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474439933", "createdAt": "2020-08-21T06:44:42Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/HasLazyDataView.java", "diffHunk": "@@ -45,12 +48,11 @@\n      *\n      * @param fetchCallback\n      *            function that returns a stream of items from the backend based\n-     *            on the offset and limit provided by the query object\n+     *            on the filter, offset and limit provided by the query object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2NjY1OA==", "bodyText": "I would move filter to be last since it is not valid for components which don't provide a filter.\nMaybe even better to leave it out completely (keep it as it was) and add\n\"Usage example without component provided filter:\"", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474466658", "createdAt": "2020-08-21T07:26:16Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/HasLazyDataView.java", "diffHunk": "@@ -24,19 +24,22 @@\n  *\n  * @param <T>\n  *            item type\n+ * @param <F>\n+ *            filter type\n  * @param <V>\n  *            DataView type\n  * @since\n  */\n-public interface HasLazyDataView<T, V extends LazyDataView<T>>\n+public interface HasLazyDataView<T, F, V extends LazyDataView<T>>\n         extends Serializable {\n \n     /**\n      * Supply items lazily with a callback from a backend. The component will\n      * automatically fetch more items and adjust its size until the backend runs\n      * out of items. Usage example:\n      * <p>\n-     * {@code component.setItems(query -> orderService.getOrders(query.getOffset(), query.getLimit());}\n+     * {@code component.setItems(query -> orderService.getOrders(\n+     *                  query.getFilter, query.getOffset(), query.getLimit());}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2Nzg0OQ==", "bodyText": "Again, maybe for simplicity the filter could be kept out of this and then another comment could follow the example stating that \"If the component supports filtering, it can be fetched with query.getFilter().\"", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474467849", "createdAt": "2020-08-21T07:27:47Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/HasLazyDataView.java", "diffHunk": "@@ -68,14 +70,15 @@ default V setItems(\n \n     /**\n      * Supply items lazily with callbacks: the first one fetches the items based\n-     * on offset and limit, the second provides the exact count of items in the\n-     * backend. Use this in case getting the count is cheap and the user\n+     * on filter, offset and limit, the second provides the exact count of items\n+     * in the backend. Use this in case getting the count is cheap and the user\n      * benefits from the component showing immediately the exact size. Usage\n      * example:\n      * <p>\n      * {@code component.setItems(\n-     *                    query -> orderService.getOrders(query.getOffset, query.getLimit()),\n-     *                    query -> orderService.getSize());}\n+     *                    query -> orderService.getOrders(query.getFilter,\n+     *                              query.getOffset, query.getLimit()),\n+     *                    query -> orderService.getSize(query.getFilter));}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2ODA2Mg==", "bodyText": "Missing () x 2", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474468062", "createdAt": "2020-08-21T07:28:04Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/HasLazyDataView.java", "diffHunk": "@@ -68,14 +70,15 @@ default V setItems(\n \n     /**\n      * Supply items lazily with callbacks: the first one fetches the items based\n-     * on offset and limit, the second provides the exact count of items in the\n-     * backend. Use this in case getting the count is cheap and the user\n+     * on filter, offset and limit, the second provides the exact count of items\n+     * in the backend. Use this in case getting the count is cheap and the user\n      * benefits from the component showing immediately the exact size. Usage\n      * example:\n      * <p>\n      * {@code component.setItems(\n-     *                    query -> orderService.getOrders(query.getOffset, query.getLimit()),\n-     *                    query -> orderService.getSize());}\n+     *                    query -> orderService.getOrders(query.getFilter,\n+     *                              query.getOffset, query.getLimit()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3MTQ5MA==", "bodyText": "Why is this needed as a property instead of just keeping the buildQuery method abstract ? Is it going to change on the fly ?", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474471490", "createdAt": "2020-08-21T07:31:50Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractDataView.java", "diffHunk": "@@ -37,6 +38,7 @@\n     protected static final String NULL_IDENTIFIER_ERROR_MESSAGE = \"Identity provider should not return null\";\n \n     protected SerializableSupplier<? extends DataProvider<T, ?>> dataProviderSupplier;\n+    protected SerializableBiFunction<Integer, Integer, Query<T, ?>> querySupplier;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1534369e322617eb91896865834c643885197f3e"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22a8cb0f337f6a483685d5b4744edaeea0064225", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/22a8cb0f337f6a483685d5b4744edaeea0064225", "committedDate": "2020-08-21T11:26:57Z", "message": "Remove default implementations from HasDataView and move query supplier to combobox"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNDU0MjI5", "url": "https://github.com/vaadin/flow/pull/8874#pullrequestreview-472454229", "createdAt": "2020-08-21T12:41:03Z", "commit": {"oid": "22a8cb0f337f6a483685d5b4744edaeea0064225"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMjo0MTowM1rOHEroeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMjo0MTowM1rOHEroeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3MTIyNA==", "bodyText": "Just noting here that both Grid and ComboBox need to have the getItems() method overridden for DataView and ListDataView due to sorting (grid) and filtering (cb). LazyDataView is safe because it uses data communicator", "url": "https://github.com/vaadin/flow/pull/8874#discussion_r474671224", "createdAt": "2020-08-21T12:41:03Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -61,9 +61,8 @@\n      */\n     public AbstractListDataView(\n             SerializableSupplier<? extends DataProvider<T, ?>> dataProviderSupplier,\n-            SerializableBiFunction<Integer, Integer, Query<T, ?>> querySupplier,\n             Component component) {\n-        super(dataProviderSupplier, querySupplier, component);\n+        super(dataProviderSupplier, component);\n     }\n \n     @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22a8cb0f337f6a483685d5b4744edaeea0064225"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bf7cc118f30fd9c32ca516b5b8b6ab9e31becca", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/9bf7cc118f30fd9c32ca516b5b8b6ab9e31becca", "committedDate": "2020-08-21T14:07:42Z", "message": "Move setItemCountCallback to Grid and ComboBox"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78f444f0767c388e8d378794e9e4c28c0d8e751f", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/78f444f0767c388e8d378794e9e4c28c0d8e751f", "committedDate": "2020-08-21T14:32:52Z", "message": "Remove Unused import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMTgyODM5", "url": "https://github.com/vaadin/flow/pull/8874#pullrequestreview-473182839", "createdAt": "2020-08-24T07:30:13Z", "commit": {"oid": "78f444f0767c388e8d378794e9e4c28c0d8e751f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 97, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}