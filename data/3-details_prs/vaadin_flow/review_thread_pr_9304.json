{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NzU2MTI1", "number": 9304, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0NToxMFrOE1JW7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDo0MTo1NFrOE1Kv7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTYzMzExOnYy", "diffSide": "RIGHT", "path": "flow-client/src/test/frontend/OfflineTests.ts", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0NToxMFrOHtQXwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDo1Nzo0MlrOHtTG0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjE5NA==", "bodyText": "Typo (deferrecCall), should be deferrableCall or omitted", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517216194", "createdAt": "2020-11-04T09:45:10Z", "author": {"login": "joheriks"}, "path": "flow-client/src/test/frontend/OfflineTests.ts", "diffHunk": "@@ -0,0 +1,532 @@\n+/* tslint:disable: no-unused-expression */\n+const { describe, it, beforeEach, afterEach, after } = intern.getPlugin('interface.bdd');\n+const { expect } = intern.getPlugin('chai');\n+const { fetchMock } = intern.getPlugin('fetchMock');\n+const { sinon } = intern.getPlugin('sinon');\n+\n+import {\n+  ConnectClient,\n+} from \"../../main/resources/META-INF/resources/frontend/Connect\";\n+\n+import { openDB } from \"idb\";\n+import { DeferredCallSubmitter, OfflineHelper } from \"../../main/resources/META-INF/resources/frontend/Offline\";\n+\n+const VAADIN_DEFERRED_CALL_QUEUE_DB_NAME = 'vaadin-deferred-call-queue';\n+const VAADIN_DEFERRED_CALL_STORE_NAME = 'deferredCalls';\n+\n+// `connectClient.call` adds the host and context to the endpoint request.\n+// we need to add this origin when configuring fetch-mock\n+const base = window.location.origin;\n+const offline = new OfflineHelper();\n+describe(\"Offline\", () => {\n+  beforeEach(() => localStorage.clear());\n+\n+  after(() => {\n+    // @ts-ignore\n+    delete window.Vaadin;\n+  });\n+\n+  describe(\"Defer Request\", () => {\n+    let client: ConnectClient;\n+\n+    beforeEach(() => {\n+      client = new ConnectClient();\n+    });\n+\n+    afterEach(() => {\n+      sinon.restore();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"Should return a DeferrableResult that retains request meta when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\").callsFake((deferredCall: any) => {\n+        if (!deferredCall.id) {\n+          deferredCall.id = 100;\n+        }\n+        return { isDeferred: true, deferredCall };\n+      });\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.true;\n+      expect(result.deferredCall?.endpoint).to.equal('FooEndpoint');\n+      expect(result.deferredCall?.method).to.equal('fooMethod');\n+      expect(result.deferredCall?.params?.fooData).to.equal('foo');\n+    })\n+\n+    it(\"Should cache the endpoint call when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+      const cachedRequest = await db.get(VAADIN_DEFERRED_CALL_STORE_NAME, result.deferredCall?.id as number);\n+\n+      expect(cachedRequest.endpoint).to.equal('FooEndpoint');\n+      expect(cachedRequest.method).to.equal('fooMethod');\n+      expect(cachedRequest.params?.fooData).to.equal('foo');\n+\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+    })\n+\n+    it(\"Should not invoke the client.call method when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.false;\n+    })\n+\n+    it(\"Should invoke the client.call method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.true;\n+    })\n+\n+    it(\"Should not invoke the client.storeDeferredCall method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      const storeDeferredCallMock = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(storeDeferredCallMock.called).to.be.false;\n+    })\n+\n+    it(\"should return false when checking the isDefered prooperty of the return value of invoking deferRequest method online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.false;\n+    })\n+\n+    it(\"should return undefined when checking the endpointRequest prooperty of the return value of invoking deferRequest method offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const returnValue = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(returnValue.deferredCall).to.be.undefined;\n+    })\n+\n+    it(\"should defer endpoint call when server is not reachable even though browser is online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const storeDeferredCall = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      fetchMock.post(\n+        base + '/connect/FooEndpoint/fooMethod',\n+        Promise.reject(new TypeError('Failed to fetch'))\n+      )\n+  \n+      await client.deferrableCall('FooEndpoint', 'fooMethod');\n+  \n+      expect(storeDeferredCall.called).to.be.true;\n+    })\n+  \n+    it(\"should NOT defer endpoint call when server return error\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      const body = 'Unexpected error';\n+      const errorResponse = new Response(\n+        body,\n+        {\n+          status: 500,\n+          statusText: 'Internal Server Error'\n+        }\n+      );\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', errorResponse);\n+  \n+      try {\n+        await client.deferrableCall('FooEndpoint', 'fooMethod');\n+      } catch (error) {\n+        expect(error).to.be.instanceOf(Error)\n+          .and.have.property('message').that.has.string('Unexpected error');\n+      }\n+    })\n+  });\n+\n+  describe(\"submit deferred calls\", () => {\n+    let client: ConnectClient;\n+    let requestCallStub: any;\n+\n+    function fakeRequestCallFails() {\n+      requestCallStub.callsFake(() => {\n+        throw new Error();\n+      });\n+    }\n+\n+    async function insertARequest(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      for (let i = 0; i < numberOfRequests; i++) {\n+        await db.put(VAADIN_DEFERRED_CALL_STORE_NAME, { endpoint: 'FooEndpoint', method: 'fooMethod', params: { fooData: 'foo' } });\n+      }\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    async function verifyNumberOfRequsetsInTheQueue(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    beforeEach(async () => {\n+      client = new ConnectClient();\n+      requestCallStub = sinon.stub(client, 'requestCall').callsFake(async () => {\n+        await new Promise(resolve => setTimeout(resolve, 10))\n+      });\n+    });\n+\n+    afterEach(async () => {\n+      const db = await (offline as any).openOrCreateDB();\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"should check and submit the cached requests when receiving online event\", () => {\n+      const submitMethod = sinon.stub(ConnectClient.prototype, \"submitDeferredCalls\");\n+      client = new ConnectClient();\n+      self.dispatchEvent(new Event('online'));\n+      expect(submitMethod.called).to.be.true;\n+      submitMethod.restore();\n+    })\n+\n+    it(\"should submit the cached request when receiving online event\", async () => {\n+      await insertARequest(3);\n+\n+      await client.submitDeferredCalls();\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    })\n+\n+    it(\"should keep the request if submission fails\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should reject if submission fails', async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      }\n+\n+      expect(errors?.length).to.equal(1);\n+    });\n+\n+    it(\"should be able to resubmit cached request that was failed to submit\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await client.submitDeferredCalls();\n+\n+        await verifyNumberOfRequsetsInTheQueue(0);\n+      }\n+    });\n+\n+    it(\"should only submit once when receiving multiple online events\", async () => {\n+      await insertARequest();\n+\n+      await Promise.all([\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls()\n+      ])\n+\n+      expect(requestCallStub.calledOnce).to.be.true;\n+    })\n+\n+    it(\"should only submit once when receiving multiple online events after a failed submission\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await Promise.all([\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls()\n+        ])\n+\n+        expect(requestCallStub.calledOnce).to.be.true;\n+      }\n+    });\n+\n+    it('should invoke middleware with isDeferred context', async () => {\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', { fooData: 'foo' });\n+\n+      requestCallStub.restore();\n+\n+      const spyMiddleware = sinon.spy(async (context: any, next?: any) => {\n+        expect(context.endpoint).to.equal('FooEndpoint');\n+        expect(context.method).to.equal('fooMethod');\n+        expect(context.params).to.deep.equal({ fooData: 'foo' });\n+        expect(context.request).to.be.instanceOf(Request);\n+        expect(context.isDeferred).to.be.true;\n+        return next(context);\n+      });\n+      client.middlewares = [spyMiddleware];\n+\n+      try {\n+        await insertARequest();\n+\n+        expect(spyMiddleware.called).to.be.false;\n+\n+        await client.submitDeferredCalls();\n+\n+        expect(spyMiddleware.called).to.be.true;\n+      } finally {\n+        fetchMock.restore();\n+      }\n+    });\n+\n+    it('should invoke deferredCallHandler', async () => {\n+      await insertARequest();\n+\n+      const onDeferredCallStub = sinon.stub().resolves();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      await client.submitDeferredCalls();\n+\n+      expect(onDeferredCallStub.callCount).to.equal(1);\n+      const [call] = onDeferredCallStub.getCall(0).args;\n+      expect(call.deferredCall.endpoint).to.equal('FooEndpoint');\n+      expect(call.deferredCall.method).to.equal('fooMethod');\n+      expect(call.deferredCall.params).to.deep.equal({ fooData: 'foo' });\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    });\n+\n+    it('should reject if onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      } finally {\n+        expect(errors?.length).to.equal(1);\n+      }\n+    });\n+\n+    it('should keep request in the queue when onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };;\n+  \n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch(_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should set submitting status to false for all the request in the queue', async () => {\n+      try {\n+        await insertARequest(2);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        verifyNumberOfRequsetsInTheQueue(2)\n+        const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+        let cursor = await db.transaction(VAADIN_DEFERRED_CALL_STORE_NAME).store.openCursor();\n+        while (cursor) {\n+          expect(cursor.value.submitting).to.be.false;\n+          cursor = await cursor.continue();\n+        }\n+        await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+        db.close;\n+      }\n+    });\n+\n+    it('should submit all the endpoint calls in the queue even errors are encountered when submitting some calls', async () => {\n+      try {\n+        await insertARequest(3);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        expect(requestCallStub.callCount).to.equal(3);\n+        verifyNumberOfRequsetsInTheQueue(3)\n+      }\n+    });\n+\n+    describe('deferred call handler', () => {\n+      it('should be able to show a notification when a deferred call submission succeeds', async () => {\n+        const notifyOnSucess = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+            notifyOnSucess();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnSucess.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should be able to show a notification when deferred call submission fails', async () => {\n+        const notifyOnFailure = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              notifyOnFailure();\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails()\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnFailure.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should remove a succeeded endpoint call from the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint in the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } catch (_) {\n+          // expected\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(1);\n+        }\n+      });\n+\n+      it('should remove a failed endpoint call from the queue when user catches the error without calling deferrecCall.keepInTheQueue()', async () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 490}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2MTAxMQ==", "bodyText": "done", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517261011", "createdAt": "2020-11-04T10:57:42Z", "author": {"login": "haijian-vaadin"}, "path": "flow-client/src/test/frontend/OfflineTests.ts", "diffHunk": "@@ -0,0 +1,532 @@\n+/* tslint:disable: no-unused-expression */\n+const { describe, it, beforeEach, afterEach, after } = intern.getPlugin('interface.bdd');\n+const { expect } = intern.getPlugin('chai');\n+const { fetchMock } = intern.getPlugin('fetchMock');\n+const { sinon } = intern.getPlugin('sinon');\n+\n+import {\n+  ConnectClient,\n+} from \"../../main/resources/META-INF/resources/frontend/Connect\";\n+\n+import { openDB } from \"idb\";\n+import { DeferredCallSubmitter, OfflineHelper } from \"../../main/resources/META-INF/resources/frontend/Offline\";\n+\n+const VAADIN_DEFERRED_CALL_QUEUE_DB_NAME = 'vaadin-deferred-call-queue';\n+const VAADIN_DEFERRED_CALL_STORE_NAME = 'deferredCalls';\n+\n+// `connectClient.call` adds the host and context to the endpoint request.\n+// we need to add this origin when configuring fetch-mock\n+const base = window.location.origin;\n+const offline = new OfflineHelper();\n+describe(\"Offline\", () => {\n+  beforeEach(() => localStorage.clear());\n+\n+  after(() => {\n+    // @ts-ignore\n+    delete window.Vaadin;\n+  });\n+\n+  describe(\"Defer Request\", () => {\n+    let client: ConnectClient;\n+\n+    beforeEach(() => {\n+      client = new ConnectClient();\n+    });\n+\n+    afterEach(() => {\n+      sinon.restore();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"Should return a DeferrableResult that retains request meta when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\").callsFake((deferredCall: any) => {\n+        if (!deferredCall.id) {\n+          deferredCall.id = 100;\n+        }\n+        return { isDeferred: true, deferredCall };\n+      });\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.true;\n+      expect(result.deferredCall?.endpoint).to.equal('FooEndpoint');\n+      expect(result.deferredCall?.method).to.equal('fooMethod');\n+      expect(result.deferredCall?.params?.fooData).to.equal('foo');\n+    })\n+\n+    it(\"Should cache the endpoint call when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+      const cachedRequest = await db.get(VAADIN_DEFERRED_CALL_STORE_NAME, result.deferredCall?.id as number);\n+\n+      expect(cachedRequest.endpoint).to.equal('FooEndpoint');\n+      expect(cachedRequest.method).to.equal('fooMethod');\n+      expect(cachedRequest.params?.fooData).to.equal('foo');\n+\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+    })\n+\n+    it(\"Should not invoke the client.call method when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.false;\n+    })\n+\n+    it(\"Should invoke the client.call method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.true;\n+    })\n+\n+    it(\"Should not invoke the client.storeDeferredCall method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      const storeDeferredCallMock = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(storeDeferredCallMock.called).to.be.false;\n+    })\n+\n+    it(\"should return false when checking the isDefered prooperty of the return value of invoking deferRequest method online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.false;\n+    })\n+\n+    it(\"should return undefined when checking the endpointRequest prooperty of the return value of invoking deferRequest method offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const returnValue = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(returnValue.deferredCall).to.be.undefined;\n+    })\n+\n+    it(\"should defer endpoint call when server is not reachable even though browser is online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const storeDeferredCall = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      fetchMock.post(\n+        base + '/connect/FooEndpoint/fooMethod',\n+        Promise.reject(new TypeError('Failed to fetch'))\n+      )\n+  \n+      await client.deferrableCall('FooEndpoint', 'fooMethod');\n+  \n+      expect(storeDeferredCall.called).to.be.true;\n+    })\n+  \n+    it(\"should NOT defer endpoint call when server return error\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      const body = 'Unexpected error';\n+      const errorResponse = new Response(\n+        body,\n+        {\n+          status: 500,\n+          statusText: 'Internal Server Error'\n+        }\n+      );\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', errorResponse);\n+  \n+      try {\n+        await client.deferrableCall('FooEndpoint', 'fooMethod');\n+      } catch (error) {\n+        expect(error).to.be.instanceOf(Error)\n+          .and.have.property('message').that.has.string('Unexpected error');\n+      }\n+    })\n+  });\n+\n+  describe(\"submit deferred calls\", () => {\n+    let client: ConnectClient;\n+    let requestCallStub: any;\n+\n+    function fakeRequestCallFails() {\n+      requestCallStub.callsFake(() => {\n+        throw new Error();\n+      });\n+    }\n+\n+    async function insertARequest(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      for (let i = 0; i < numberOfRequests; i++) {\n+        await db.put(VAADIN_DEFERRED_CALL_STORE_NAME, { endpoint: 'FooEndpoint', method: 'fooMethod', params: { fooData: 'foo' } });\n+      }\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    async function verifyNumberOfRequsetsInTheQueue(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    beforeEach(async () => {\n+      client = new ConnectClient();\n+      requestCallStub = sinon.stub(client, 'requestCall').callsFake(async () => {\n+        await new Promise(resolve => setTimeout(resolve, 10))\n+      });\n+    });\n+\n+    afterEach(async () => {\n+      const db = await (offline as any).openOrCreateDB();\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"should check and submit the cached requests when receiving online event\", () => {\n+      const submitMethod = sinon.stub(ConnectClient.prototype, \"submitDeferredCalls\");\n+      client = new ConnectClient();\n+      self.dispatchEvent(new Event('online'));\n+      expect(submitMethod.called).to.be.true;\n+      submitMethod.restore();\n+    })\n+\n+    it(\"should submit the cached request when receiving online event\", async () => {\n+      await insertARequest(3);\n+\n+      await client.submitDeferredCalls();\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    })\n+\n+    it(\"should keep the request if submission fails\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should reject if submission fails', async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      }\n+\n+      expect(errors?.length).to.equal(1);\n+    });\n+\n+    it(\"should be able to resubmit cached request that was failed to submit\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await client.submitDeferredCalls();\n+\n+        await verifyNumberOfRequsetsInTheQueue(0);\n+      }\n+    });\n+\n+    it(\"should only submit once when receiving multiple online events\", async () => {\n+      await insertARequest();\n+\n+      await Promise.all([\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls()\n+      ])\n+\n+      expect(requestCallStub.calledOnce).to.be.true;\n+    })\n+\n+    it(\"should only submit once when receiving multiple online events after a failed submission\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await Promise.all([\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls()\n+        ])\n+\n+        expect(requestCallStub.calledOnce).to.be.true;\n+      }\n+    });\n+\n+    it('should invoke middleware with isDeferred context', async () => {\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', { fooData: 'foo' });\n+\n+      requestCallStub.restore();\n+\n+      const spyMiddleware = sinon.spy(async (context: any, next?: any) => {\n+        expect(context.endpoint).to.equal('FooEndpoint');\n+        expect(context.method).to.equal('fooMethod');\n+        expect(context.params).to.deep.equal({ fooData: 'foo' });\n+        expect(context.request).to.be.instanceOf(Request);\n+        expect(context.isDeferred).to.be.true;\n+        return next(context);\n+      });\n+      client.middlewares = [spyMiddleware];\n+\n+      try {\n+        await insertARequest();\n+\n+        expect(spyMiddleware.called).to.be.false;\n+\n+        await client.submitDeferredCalls();\n+\n+        expect(spyMiddleware.called).to.be.true;\n+      } finally {\n+        fetchMock.restore();\n+      }\n+    });\n+\n+    it('should invoke deferredCallHandler', async () => {\n+      await insertARequest();\n+\n+      const onDeferredCallStub = sinon.stub().resolves();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      await client.submitDeferredCalls();\n+\n+      expect(onDeferredCallStub.callCount).to.equal(1);\n+      const [call] = onDeferredCallStub.getCall(0).args;\n+      expect(call.deferredCall.endpoint).to.equal('FooEndpoint');\n+      expect(call.deferredCall.method).to.equal('fooMethod');\n+      expect(call.deferredCall.params).to.deep.equal({ fooData: 'foo' });\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    });\n+\n+    it('should reject if onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      } finally {\n+        expect(errors?.length).to.equal(1);\n+      }\n+    });\n+\n+    it('should keep request in the queue when onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };;\n+  \n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch(_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should set submitting status to false for all the request in the queue', async () => {\n+      try {\n+        await insertARequest(2);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        verifyNumberOfRequsetsInTheQueue(2)\n+        const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+        let cursor = await db.transaction(VAADIN_DEFERRED_CALL_STORE_NAME).store.openCursor();\n+        while (cursor) {\n+          expect(cursor.value.submitting).to.be.false;\n+          cursor = await cursor.continue();\n+        }\n+        await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+        db.close;\n+      }\n+    });\n+\n+    it('should submit all the endpoint calls in the queue even errors are encountered when submitting some calls', async () => {\n+      try {\n+        await insertARequest(3);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        expect(requestCallStub.callCount).to.equal(3);\n+        verifyNumberOfRequsetsInTheQueue(3)\n+      }\n+    });\n+\n+    describe('deferred call handler', () => {\n+      it('should be able to show a notification when a deferred call submission succeeds', async () => {\n+        const notifyOnSucess = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+            notifyOnSucess();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnSucess.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should be able to show a notification when deferred call submission fails', async () => {\n+        const notifyOnFailure = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              notifyOnFailure();\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails()\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnFailure.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should remove a succeeded endpoint call from the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint in the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } catch (_) {\n+          // expected\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(1);\n+        }\n+      });\n+\n+      it('should remove a failed endpoint call from the queue when user catches the error without calling deferrecCall.keepInTheQueue()', async () => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjE5NA=="}, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 490}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTYzMzYzOnYy", "diffSide": "RIGHT", "path": "flow-client/src/test/frontend/OfflineTests.ts", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0NToxN1rOHtQYCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDo1Nzo0OFrOHtTHDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjI2Nw==", "bodyText": "Typo (deferrecCall), should be deferrableCall or omitted.", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517216267", "createdAt": "2020-11-04T09:45:17Z", "author": {"login": "joheriks"}, "path": "flow-client/src/test/frontend/OfflineTests.ts", "diffHunk": "@@ -0,0 +1,532 @@\n+/* tslint:disable: no-unused-expression */\n+const { describe, it, beforeEach, afterEach, after } = intern.getPlugin('interface.bdd');\n+const { expect } = intern.getPlugin('chai');\n+const { fetchMock } = intern.getPlugin('fetchMock');\n+const { sinon } = intern.getPlugin('sinon');\n+\n+import {\n+  ConnectClient,\n+} from \"../../main/resources/META-INF/resources/frontend/Connect\";\n+\n+import { openDB } from \"idb\";\n+import { DeferredCallSubmitter, OfflineHelper } from \"../../main/resources/META-INF/resources/frontend/Offline\";\n+\n+const VAADIN_DEFERRED_CALL_QUEUE_DB_NAME = 'vaadin-deferred-call-queue';\n+const VAADIN_DEFERRED_CALL_STORE_NAME = 'deferredCalls';\n+\n+// `connectClient.call` adds the host and context to the endpoint request.\n+// we need to add this origin when configuring fetch-mock\n+const base = window.location.origin;\n+const offline = new OfflineHelper();\n+describe(\"Offline\", () => {\n+  beforeEach(() => localStorage.clear());\n+\n+  after(() => {\n+    // @ts-ignore\n+    delete window.Vaadin;\n+  });\n+\n+  describe(\"Defer Request\", () => {\n+    let client: ConnectClient;\n+\n+    beforeEach(() => {\n+      client = new ConnectClient();\n+    });\n+\n+    afterEach(() => {\n+      sinon.restore();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"Should return a DeferrableResult that retains request meta when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\").callsFake((deferredCall: any) => {\n+        if (!deferredCall.id) {\n+          deferredCall.id = 100;\n+        }\n+        return { isDeferred: true, deferredCall };\n+      });\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.true;\n+      expect(result.deferredCall?.endpoint).to.equal('FooEndpoint');\n+      expect(result.deferredCall?.method).to.equal('fooMethod');\n+      expect(result.deferredCall?.params?.fooData).to.equal('foo');\n+    })\n+\n+    it(\"Should cache the endpoint call when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+      const cachedRequest = await db.get(VAADIN_DEFERRED_CALL_STORE_NAME, result.deferredCall?.id as number);\n+\n+      expect(cachedRequest.endpoint).to.equal('FooEndpoint');\n+      expect(cachedRequest.method).to.equal('fooMethod');\n+      expect(cachedRequest.params?.fooData).to.equal('foo');\n+\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+    })\n+\n+    it(\"Should not invoke the client.call method when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.false;\n+    })\n+\n+    it(\"Should invoke the client.call method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.true;\n+    })\n+\n+    it(\"Should not invoke the client.storeDeferredCall method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      const storeDeferredCallMock = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(storeDeferredCallMock.called).to.be.false;\n+    })\n+\n+    it(\"should return false when checking the isDefered prooperty of the return value of invoking deferRequest method online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.false;\n+    })\n+\n+    it(\"should return undefined when checking the endpointRequest prooperty of the return value of invoking deferRequest method offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const returnValue = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(returnValue.deferredCall).to.be.undefined;\n+    })\n+\n+    it(\"should defer endpoint call when server is not reachable even though browser is online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const storeDeferredCall = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      fetchMock.post(\n+        base + '/connect/FooEndpoint/fooMethod',\n+        Promise.reject(new TypeError('Failed to fetch'))\n+      )\n+  \n+      await client.deferrableCall('FooEndpoint', 'fooMethod');\n+  \n+      expect(storeDeferredCall.called).to.be.true;\n+    })\n+  \n+    it(\"should NOT defer endpoint call when server return error\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      const body = 'Unexpected error';\n+      const errorResponse = new Response(\n+        body,\n+        {\n+          status: 500,\n+          statusText: 'Internal Server Error'\n+        }\n+      );\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', errorResponse);\n+  \n+      try {\n+        await client.deferrableCall('FooEndpoint', 'fooMethod');\n+      } catch (error) {\n+        expect(error).to.be.instanceOf(Error)\n+          .and.have.property('message').that.has.string('Unexpected error');\n+      }\n+    })\n+  });\n+\n+  describe(\"submit deferred calls\", () => {\n+    let client: ConnectClient;\n+    let requestCallStub: any;\n+\n+    function fakeRequestCallFails() {\n+      requestCallStub.callsFake(() => {\n+        throw new Error();\n+      });\n+    }\n+\n+    async function insertARequest(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      for (let i = 0; i < numberOfRequests; i++) {\n+        await db.put(VAADIN_DEFERRED_CALL_STORE_NAME, { endpoint: 'FooEndpoint', method: 'fooMethod', params: { fooData: 'foo' } });\n+      }\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    async function verifyNumberOfRequsetsInTheQueue(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    beforeEach(async () => {\n+      client = new ConnectClient();\n+      requestCallStub = sinon.stub(client, 'requestCall').callsFake(async () => {\n+        await new Promise(resolve => setTimeout(resolve, 10))\n+      });\n+    });\n+\n+    afterEach(async () => {\n+      const db = await (offline as any).openOrCreateDB();\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"should check and submit the cached requests when receiving online event\", () => {\n+      const submitMethod = sinon.stub(ConnectClient.prototype, \"submitDeferredCalls\");\n+      client = new ConnectClient();\n+      self.dispatchEvent(new Event('online'));\n+      expect(submitMethod.called).to.be.true;\n+      submitMethod.restore();\n+    })\n+\n+    it(\"should submit the cached request when receiving online event\", async () => {\n+      await insertARequest(3);\n+\n+      await client.submitDeferredCalls();\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    })\n+\n+    it(\"should keep the request if submission fails\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should reject if submission fails', async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      }\n+\n+      expect(errors?.length).to.equal(1);\n+    });\n+\n+    it(\"should be able to resubmit cached request that was failed to submit\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await client.submitDeferredCalls();\n+\n+        await verifyNumberOfRequsetsInTheQueue(0);\n+      }\n+    });\n+\n+    it(\"should only submit once when receiving multiple online events\", async () => {\n+      await insertARequest();\n+\n+      await Promise.all([\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls()\n+      ])\n+\n+      expect(requestCallStub.calledOnce).to.be.true;\n+    })\n+\n+    it(\"should only submit once when receiving multiple online events after a failed submission\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await Promise.all([\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls()\n+        ])\n+\n+        expect(requestCallStub.calledOnce).to.be.true;\n+      }\n+    });\n+\n+    it('should invoke middleware with isDeferred context', async () => {\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', { fooData: 'foo' });\n+\n+      requestCallStub.restore();\n+\n+      const spyMiddleware = sinon.spy(async (context: any, next?: any) => {\n+        expect(context.endpoint).to.equal('FooEndpoint');\n+        expect(context.method).to.equal('fooMethod');\n+        expect(context.params).to.deep.equal({ fooData: 'foo' });\n+        expect(context.request).to.be.instanceOf(Request);\n+        expect(context.isDeferred).to.be.true;\n+        return next(context);\n+      });\n+      client.middlewares = [spyMiddleware];\n+\n+      try {\n+        await insertARequest();\n+\n+        expect(spyMiddleware.called).to.be.false;\n+\n+        await client.submitDeferredCalls();\n+\n+        expect(spyMiddleware.called).to.be.true;\n+      } finally {\n+        fetchMock.restore();\n+      }\n+    });\n+\n+    it('should invoke deferredCallHandler', async () => {\n+      await insertARequest();\n+\n+      const onDeferredCallStub = sinon.stub().resolves();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      await client.submitDeferredCalls();\n+\n+      expect(onDeferredCallStub.callCount).to.equal(1);\n+      const [call] = onDeferredCallStub.getCall(0).args;\n+      expect(call.deferredCall.endpoint).to.equal('FooEndpoint');\n+      expect(call.deferredCall.method).to.equal('fooMethod');\n+      expect(call.deferredCall.params).to.deep.equal({ fooData: 'foo' });\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    });\n+\n+    it('should reject if onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      } finally {\n+        expect(errors?.length).to.equal(1);\n+      }\n+    });\n+\n+    it('should keep request in the queue when onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };;\n+  \n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch(_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should set submitting status to false for all the request in the queue', async () => {\n+      try {\n+        await insertARequest(2);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        verifyNumberOfRequsetsInTheQueue(2)\n+        const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+        let cursor = await db.transaction(VAADIN_DEFERRED_CALL_STORE_NAME).store.openCursor();\n+        while (cursor) {\n+          expect(cursor.value.submitting).to.be.false;\n+          cursor = await cursor.continue();\n+        }\n+        await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+        db.close;\n+      }\n+    });\n+\n+    it('should submit all the endpoint calls in the queue even errors are encountered when submitting some calls', async () => {\n+      try {\n+        await insertARequest(3);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        expect(requestCallStub.callCount).to.equal(3);\n+        verifyNumberOfRequsetsInTheQueue(3)\n+      }\n+    });\n+\n+    describe('deferred call handler', () => {\n+      it('should be able to show a notification when a deferred call submission succeeds', async () => {\n+        const notifyOnSucess = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+            notifyOnSucess();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnSucess.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should be able to show a notification when deferred call submission fails', async () => {\n+        const notifyOnFailure = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              notifyOnFailure();\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails()\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnFailure.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should remove a succeeded endpoint call from the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint in the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } catch (_) {\n+          // expected\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(1);\n+        }\n+      });\n+\n+      it('should remove a failed endpoint call from the queue when user catches the error without calling deferrecCall.keepInTheQueue()', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              // swallow the error\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint call in the queue when user catches the error and calls deferrecCall.keepInTheQueue()', async () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 510}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2MTA3MA==", "bodyText": "done", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517261070", "createdAt": "2020-11-04T10:57:48Z", "author": {"login": "haijian-vaadin"}, "path": "flow-client/src/test/frontend/OfflineTests.ts", "diffHunk": "@@ -0,0 +1,532 @@\n+/* tslint:disable: no-unused-expression */\n+const { describe, it, beforeEach, afterEach, after } = intern.getPlugin('interface.bdd');\n+const { expect } = intern.getPlugin('chai');\n+const { fetchMock } = intern.getPlugin('fetchMock');\n+const { sinon } = intern.getPlugin('sinon');\n+\n+import {\n+  ConnectClient,\n+} from \"../../main/resources/META-INF/resources/frontend/Connect\";\n+\n+import { openDB } from \"idb\";\n+import { DeferredCallSubmitter, OfflineHelper } from \"../../main/resources/META-INF/resources/frontend/Offline\";\n+\n+const VAADIN_DEFERRED_CALL_QUEUE_DB_NAME = 'vaadin-deferred-call-queue';\n+const VAADIN_DEFERRED_CALL_STORE_NAME = 'deferredCalls';\n+\n+// `connectClient.call` adds the host and context to the endpoint request.\n+// we need to add this origin when configuring fetch-mock\n+const base = window.location.origin;\n+const offline = new OfflineHelper();\n+describe(\"Offline\", () => {\n+  beforeEach(() => localStorage.clear());\n+\n+  after(() => {\n+    // @ts-ignore\n+    delete window.Vaadin;\n+  });\n+\n+  describe(\"Defer Request\", () => {\n+    let client: ConnectClient;\n+\n+    beforeEach(() => {\n+      client = new ConnectClient();\n+    });\n+\n+    afterEach(() => {\n+      sinon.restore();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"Should return a DeferrableResult that retains request meta when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\").callsFake((deferredCall: any) => {\n+        if (!deferredCall.id) {\n+          deferredCall.id = 100;\n+        }\n+        return { isDeferred: true, deferredCall };\n+      });\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.true;\n+      expect(result.deferredCall?.endpoint).to.equal('FooEndpoint');\n+      expect(result.deferredCall?.method).to.equal('fooMethod');\n+      expect(result.deferredCall?.params?.fooData).to.equal('foo');\n+    })\n+\n+    it(\"Should cache the endpoint call when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+      const cachedRequest = await db.get(VAADIN_DEFERRED_CALL_STORE_NAME, result.deferredCall?.id as number);\n+\n+      expect(cachedRequest.endpoint).to.equal('FooEndpoint');\n+      expect(cachedRequest.method).to.equal('fooMethod');\n+      expect(cachedRequest.params?.fooData).to.equal('foo');\n+\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+    })\n+\n+    it(\"Should not invoke the client.call method when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.false;\n+    })\n+\n+    it(\"Should invoke the client.call method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.true;\n+    })\n+\n+    it(\"Should not invoke the client.storeDeferredCall method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      const storeDeferredCallMock = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(storeDeferredCallMock.called).to.be.false;\n+    })\n+\n+    it(\"should return false when checking the isDefered prooperty of the return value of invoking deferRequest method online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.false;\n+    })\n+\n+    it(\"should return undefined when checking the endpointRequest prooperty of the return value of invoking deferRequest method offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const returnValue = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(returnValue.deferredCall).to.be.undefined;\n+    })\n+\n+    it(\"should defer endpoint call when server is not reachable even though browser is online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const storeDeferredCall = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      fetchMock.post(\n+        base + '/connect/FooEndpoint/fooMethod',\n+        Promise.reject(new TypeError('Failed to fetch'))\n+      )\n+  \n+      await client.deferrableCall('FooEndpoint', 'fooMethod');\n+  \n+      expect(storeDeferredCall.called).to.be.true;\n+    })\n+  \n+    it(\"should NOT defer endpoint call when server return error\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      const body = 'Unexpected error';\n+      const errorResponse = new Response(\n+        body,\n+        {\n+          status: 500,\n+          statusText: 'Internal Server Error'\n+        }\n+      );\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', errorResponse);\n+  \n+      try {\n+        await client.deferrableCall('FooEndpoint', 'fooMethod');\n+      } catch (error) {\n+        expect(error).to.be.instanceOf(Error)\n+          .and.have.property('message').that.has.string('Unexpected error');\n+      }\n+    })\n+  });\n+\n+  describe(\"submit deferred calls\", () => {\n+    let client: ConnectClient;\n+    let requestCallStub: any;\n+\n+    function fakeRequestCallFails() {\n+      requestCallStub.callsFake(() => {\n+        throw new Error();\n+      });\n+    }\n+\n+    async function insertARequest(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      for (let i = 0; i < numberOfRequests; i++) {\n+        await db.put(VAADIN_DEFERRED_CALL_STORE_NAME, { endpoint: 'FooEndpoint', method: 'fooMethod', params: { fooData: 'foo' } });\n+      }\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    async function verifyNumberOfRequsetsInTheQueue(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    beforeEach(async () => {\n+      client = new ConnectClient();\n+      requestCallStub = sinon.stub(client, 'requestCall').callsFake(async () => {\n+        await new Promise(resolve => setTimeout(resolve, 10))\n+      });\n+    });\n+\n+    afterEach(async () => {\n+      const db = await (offline as any).openOrCreateDB();\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"should check and submit the cached requests when receiving online event\", () => {\n+      const submitMethod = sinon.stub(ConnectClient.prototype, \"submitDeferredCalls\");\n+      client = new ConnectClient();\n+      self.dispatchEvent(new Event('online'));\n+      expect(submitMethod.called).to.be.true;\n+      submitMethod.restore();\n+    })\n+\n+    it(\"should submit the cached request when receiving online event\", async () => {\n+      await insertARequest(3);\n+\n+      await client.submitDeferredCalls();\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    })\n+\n+    it(\"should keep the request if submission fails\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should reject if submission fails', async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      }\n+\n+      expect(errors?.length).to.equal(1);\n+    });\n+\n+    it(\"should be able to resubmit cached request that was failed to submit\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await client.submitDeferredCalls();\n+\n+        await verifyNumberOfRequsetsInTheQueue(0);\n+      }\n+    });\n+\n+    it(\"should only submit once when receiving multiple online events\", async () => {\n+      await insertARequest();\n+\n+      await Promise.all([\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls()\n+      ])\n+\n+      expect(requestCallStub.calledOnce).to.be.true;\n+    })\n+\n+    it(\"should only submit once when receiving multiple online events after a failed submission\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await Promise.all([\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls()\n+        ])\n+\n+        expect(requestCallStub.calledOnce).to.be.true;\n+      }\n+    });\n+\n+    it('should invoke middleware with isDeferred context', async () => {\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', { fooData: 'foo' });\n+\n+      requestCallStub.restore();\n+\n+      const spyMiddleware = sinon.spy(async (context: any, next?: any) => {\n+        expect(context.endpoint).to.equal('FooEndpoint');\n+        expect(context.method).to.equal('fooMethod');\n+        expect(context.params).to.deep.equal({ fooData: 'foo' });\n+        expect(context.request).to.be.instanceOf(Request);\n+        expect(context.isDeferred).to.be.true;\n+        return next(context);\n+      });\n+      client.middlewares = [spyMiddleware];\n+\n+      try {\n+        await insertARequest();\n+\n+        expect(spyMiddleware.called).to.be.false;\n+\n+        await client.submitDeferredCalls();\n+\n+        expect(spyMiddleware.called).to.be.true;\n+      } finally {\n+        fetchMock.restore();\n+      }\n+    });\n+\n+    it('should invoke deferredCallHandler', async () => {\n+      await insertARequest();\n+\n+      const onDeferredCallStub = sinon.stub().resolves();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      await client.submitDeferredCalls();\n+\n+      expect(onDeferredCallStub.callCount).to.equal(1);\n+      const [call] = onDeferredCallStub.getCall(0).args;\n+      expect(call.deferredCall.endpoint).to.equal('FooEndpoint');\n+      expect(call.deferredCall.method).to.equal('fooMethod');\n+      expect(call.deferredCall.params).to.deep.equal({ fooData: 'foo' });\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    });\n+\n+    it('should reject if onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      } finally {\n+        expect(errors?.length).to.equal(1);\n+      }\n+    });\n+\n+    it('should keep request in the queue when onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };;\n+  \n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch(_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should set submitting status to false for all the request in the queue', async () => {\n+      try {\n+        await insertARequest(2);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        verifyNumberOfRequsetsInTheQueue(2)\n+        const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+        let cursor = await db.transaction(VAADIN_DEFERRED_CALL_STORE_NAME).store.openCursor();\n+        while (cursor) {\n+          expect(cursor.value.submitting).to.be.false;\n+          cursor = await cursor.continue();\n+        }\n+        await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+        db.close;\n+      }\n+    });\n+\n+    it('should submit all the endpoint calls in the queue even errors are encountered when submitting some calls', async () => {\n+      try {\n+        await insertARequest(3);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        expect(requestCallStub.callCount).to.equal(3);\n+        verifyNumberOfRequsetsInTheQueue(3)\n+      }\n+    });\n+\n+    describe('deferred call handler', () => {\n+      it('should be able to show a notification when a deferred call submission succeeds', async () => {\n+        const notifyOnSucess = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+            notifyOnSucess();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnSucess.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should be able to show a notification when deferred call submission fails', async () => {\n+        const notifyOnFailure = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              notifyOnFailure();\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails()\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnFailure.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should remove a succeeded endpoint call from the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint in the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } catch (_) {\n+          // expected\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(1);\n+        }\n+      });\n+\n+      it('should remove a failed endpoint call from the queue when user catches the error without calling deferrecCall.keepInTheQueue()', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              // swallow the error\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint call in the queue when user catches the error and calls deferrecCall.keepInTheQueue()', async () => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjI2Nw=="}, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 510}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTc4OTUyOnYy", "diffSide": "RIGHT", "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDoyMzo0M1rOHtR2Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDoyMzo0M1rOHtR2Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0MDM4Ng==", "bodyText": "Extreanous The at end of docstring.", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517240386", "createdAt": "2020-11-04T10:23:43Z", "author": {"login": "joheriks"}, "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "diffHunk": "@@ -182,16 +174,12 @@ export interface ConnectClientOptions {\n   middlewares?: Middleware[];\n \n   /**\n-   * The `onDeferredCall` property value\n+   * The `deferredCallSubmissionHandler` property valueThe", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTg2MDk0OnYy", "diffSide": "RIGHT", "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDo0MTo1NFrOHtSiJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDo1ODoxMFrOHtTHwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI1MTYyMg==", "bodyText": "The name seems longish, how about deferredCallHandler?", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517251622", "createdAt": "2020-11-04T10:41:54Z", "author": {"login": "joheriks"}, "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "diffHunk": "@@ -182,16 +174,12 @@ export interface ConnectClientOptions {\n   middlewares?: Middleware[];\n \n   /**\n-   * The `onDeferredCall` property value\n+   * The `deferredCallSubmissionHandler` property valueThe\n    */\n-  onDeferredCall?: OnDeferredCallCallback\n+  deferredCallSubmissionHandler?: DeferredCallSubmissionHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2MTI0OA==", "bodyText": "renamed", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517261248", "createdAt": "2020-11-04T10:58:10Z", "author": {"login": "haijian-vaadin"}, "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "diffHunk": "@@ -182,16 +174,12 @@ export interface ConnectClientOptions {\n   middlewares?: Middleware[];\n \n   /**\n-   * The `onDeferredCall` property value\n+   * The `deferredCallSubmissionHandler` property valueThe\n    */\n-  onDeferredCall?: OnDeferredCallCallback\n+  deferredCallSubmissionHandler?: DeferredCallSubmissionHandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI1MTYyMg=="}, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2978, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}