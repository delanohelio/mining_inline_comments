{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyNzc4MDI4", "number": 8988, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo1Njo1OFrOEiiGGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzowMTowM1rOEiiLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQ1NjU2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo1Njo1OFrOHQdvDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo1Njo1OFrOHQdvDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjQ0NA==", "bodyText": "Typo, should be \"Initialize\"", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487026444", "createdAt": "2020-09-11T12:56:58Z", "author": {"login": "joheriks"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQ2NDQ4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo1OToxN1rOHQd0KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoyMToxN1rOHQlapg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNzc1Mg==", "bodyText": "Is element parameter needed? Seems it could be omitted as this is always called with argument this.element.", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487027752", "createdAt": "2020-09-11T12:59:17Z", "author": {"login": "joheriks"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MjI5NA==", "bodyText": "Good point.", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487152294", "createdAt": "2020-09-11T16:21:17Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNzc1Mg=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQ3MDI4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzowMTowM1rOHQd37g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNzoyMzoyN1rOHRG91g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA==", "bodyText": "I got an NPE here when using the attribute-without-value syntax in my template. For example autofocus:\n<vaadin-text-field id=\"textField\" autofocus></vaadin-text-field>\nAlso, how about about ${...} in the attribute? For example:\n<vaadin-text-field id=\"textField\" label=\"${this.dynamicLabel}\"></vaadin-text-field>\nShould it then also not be read to the server side?", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487028718", "createdAt": "2020-09-11T13:01:03Z", "author": {"login": "joheriks"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NTM2Nw==", "bodyText": "label=\"${this.dynamicLabel}\" should not be read as it's dynamic.\nBut now again : how may I detect a dynamic values ?\nIs label=\"foo ${this.dynamicLabel}\" a correct declaration ?\nIs check for ${ presence good enough ?\nI considered only bindings as dynamic value and missed that .", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487155367", "createdAt": "2020-09-11T16:27:04Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NjU0NA==", "bodyText": "There is an IT test for hidden attribute .\nSo stacktrace is required.", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487156544", "createdAt": "2020-09-11T16:29:11Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUyOTEwOA==", "bodyText": "Probably attributes should only be parsed to server if they're string, int, float, etc. literals. So value containing ${ would need to be excluded.\nWith the following template in my app (./src/polymer.js):\nclass PolymerComponent extends PolymerElement {\n  static get template() {\n    return html`\n        <vaadin-text-field id=\"textField\" autofocus></vaadin-text-field>\n    `;\n  }\n}\ncustomElements.define('polymer-component', PolymerComponent);\nJava:\n@Tag(\"polymer-component\")\n@JsModule(\"./src/polymer.js\")\npublic class PolymerComponent extends PolymerTemplate<PolymerComponent.PolymerModel> {\n    public interface PolymerModel extends TemplateModel {\n    }\n\n    @Id\n    private TextField textField;\n\n    public PolymerComponent() {\n        System.out.println(textField.isAutofocus());\n    }\n}\nI got the following exception when adding the component to MainView:\njava.lang.IllegalArgumentException: Unable to create an instance of 'org.vaadin.example.MainView'. The constructor threw an exception.\n\tat com.vaadin.flow.internal.ReflectTools.createProxyInstance(ReflectTools.java:512)\n\tat com.vaadin.flow.internal.ReflectTools.createInstance(ReflectTools.java:449)\n\tat com.vaadin.flow.di.DefaultInstantiator.create(DefaultInstantiator.java:137)\n\tat com.vaadin.flow.di.DefaultInstantiator.getOrCreate(DefaultInstantiator.java:66)\n\tat com.vaadin.flow.di.Instantiator.createRouteTarget(Instantiator.java:190)\n\tat com.vaadin.flow.router.internal.AbstractNavigationStateRenderer.lambda$getRouteTarget$1(AbstractNavigationStateRenderer.java:133)\n\tat java.base/java.util.Optional.orElseGet(Optional.java:362)\n\tat com.vaadin.flow.router.internal.AbstractNavigationStateRenderer.getRouteTarget(AbstractNavigationStateRenderer.java:132)\n\tat com.vaadin.flow.router.internal.AbstractNavigationStateRenderer.sendBeforeEnterEventAndPopulateChain(AbstractNavigationStateRenderer.java:485)\n\tat com.vaadin.flow.router.internal.AbstractNavigationStateRenderer.createChainIfEmptyAndExecuteBeforeEnterNavigation(AbstractNavigationStateRenderer.java:466)\n\tat com.vaadin.flow.router.internal.AbstractNavigationStateRenderer.handle(AbstractNavigationStateRenderer.java:204)\n\tat com.vaadin.flow.component.internal.JavaScriptNavigationStateRenderer.handle(JavaScriptNavigationStateRenderer.java:75)\n\tat com.vaadin.flow.component.internal.JavaScriptBootstrapUI.handleNavigation(JavaScriptBootstrapUI.java:289)\n\tat com.vaadin.flow.component.internal.JavaScriptBootstrapUI.renderViewForRoute(JavaScriptBootstrapUI.java:253)\n\tat com.vaadin.flow.component.internal.JavaScriptBootstrapUI.connectClient(JavaScriptBootstrapUI.java:127)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:564)\n\tat com.vaadin.flow.server.communication.rpc.PublishedServerEventHandlerRpcHandler.invokeMethod(PublishedServerEventHandlerRpcHandler.java:200)\n\tat com.vaadin.flow.server.communication.rpc.PublishedServerEventHandlerRpcHandler.invokeMethod(PublishedServerEventHandlerRpcHandler.java:177)\n\tat com.vaadin.flow.server.communication.rpc.PublishedServerEventHandlerRpcHandler.invokeMethod(PublishedServerEventHandlerRpcHandler.java:137)\n\tat com.vaadin.flow.server.communication.rpc.PublishedServerEventHandlerRpcHandler.handleNode(PublishedServerEventHandlerRpcHandler.java:125)\n\tat com.vaadin.flow.server.communication.rpc.AbstractRpcInvocationHandler.handle(AbstractRpcInvocationHandler.java:64)\n\tat com.vaadin.flow.server.communication.ServerRpcHandler.handleInvocationData(ServerRpcHandler.java:409)\n\tat com.vaadin.flow.server.communication.ServerRpcHandler.lambda$handleInvocations$1(ServerRpcHandler.java:390)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat com.vaadin.flow.server.communication.ServerRpcHandler.handleInvocations(ServerRpcHandler.java:390)\n\tat com.vaadin.flow.server.communication.ServerRpcHandler.handleRpc(ServerRpcHandler.java:317)\n\tat com.vaadin.flow.server.communication.UidlRequestHandler.synchronizedHandleRequest(UidlRequestHandler.java:114)\n\tat com.vaadin.flow.server.SynchronizedRequestHandler.handleRequest(SynchronizedRequestHandler.java:40)\n\tat com.vaadin.flow.server.VaadinService.handleRequest(VaadinService.java:1539)\n\tat com.vaadin.flow.server.VaadinServlet.service(VaadinServlet.java:238)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:790)\n\tat org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:763)\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1631)\n\tat org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:226)\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1618)\n\tat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:549)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\n\tat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:602)\n\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:235)\n\tat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1610)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)\n\tat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1363)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)\n\tat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:489)\n\tat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1580)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)\n\tat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1278)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\n\tat org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:221)\n\tat org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)\n\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)\n\tat org.eclipse.jetty.server.Server.handle(Server.java:500)\n\tat org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:383)\n\tat org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:547)\n\tat org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:375)\n\tat org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:273)\n\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)\n\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)\n\tat org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)\n\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)\n\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)\n\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)\n\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)\n\tat org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:375)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:806)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:938)\n\tat java.base/java.lang.Thread.run(Thread.java:832)\nCaused by: java.lang.reflect.InvocationTargetException\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:500)\n\tat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:481)\n\tat com.vaadin.flow.internal.ReflectTools.createProxyInstance(ReflectTools.java:481)\n\t... 70 more\nCaused by: java.lang.NullPointerException\n\tat com.vaadin.flow.component.polymertemplate.InjectablePolymerElementInitializer.isStaticAttribute(InjectablePolymerElementInitializer.java:62)\n\tat com.vaadin.flow.component.template.internal.AbstractInjectableElementInitializer.initialize(AbstractInjectableElementInitializer.java:82)\n\tat com.vaadin.flow.component.template.internal.AbstractInjectableElementInitializer.lambda$accept$0(AbstractInjectableElementInitializer.java:56)\n\tat java.base/java.util.HashMap.forEach(HashMap.java:1425)\n\tat com.vaadin.flow.component.template.internal.AbstractInjectableElementInitializer.accept(AbstractInjectableElementInitializer.java:56)\n\tat com.vaadin.flow.component.polymertemplate.TemplateInitializer.lambda$null$2(TemplateInitializer.java:160)\n\tat com.vaadin.flow.component.polymertemplate.IdMapper.injectTemplateElement(IdMapper.java:161)\n\tat com.vaadin.flow.component.polymertemplate.IdMapper.attachExistingElementById(IdMapper.java:153)\n\tat com.vaadin.flow.component.polymertemplate.IdMapper.injectClientSideElement(IdMapper.java:105)\n\tat com.vaadin.flow.component.polymertemplate.IdMapper.mapComponentOrElement(IdMapper.java:76)\n\tat com.vaadin.flow.component.polymertemplate.TemplateInitializer.lambda$mapComponents$3(TemplateInitializer.java:157)\n\tat com.vaadin.flow.component.polymertemplate.TemplateDataAnalyzer$ParserData.lambda$forEachInjectedField$0(TemplateDataAnalyzer.java:145)\n\tat java.base/java.util.HashMap.forEach(HashMap.java:1425)\n\tat java.base/java.util.Collections$UnmodifiableMap.forEach(Collections.java:1521)\n\tat com.vaadin.flow.component.polymertemplate.TemplateDataAnalyzer$ParserData.forEachInjectedField(TemplateDataAnalyzer.java:144)\n\tat com.vaadin.flow.component.polymertemplate.TemplateInitializer.mapComponents(TemplateInitializer.java:156)\n\tat com.vaadin.flow.component.polymertemplate.TemplateInitializer.initChildElements(TemplateInitializer.java:101)\n\tat com.vaadin.flow.component.polymertemplate.PolymerTemplate.<init>(PolymerTemplate.java:90)\n\tat com.vaadin.flow.component.polymertemplate.PolymerTemplate.<init>(PolymerTemplate.java:103)\n\tat org.vaadin.example.PolymerComponent.<init>(PolymerComponent.java:19)\n\tat org.vaadin.example.MainView.<init>(MainView.java:17)\n\t... 76 more", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487529108", "createdAt": "2020-09-13T13:22:59Z", "author": {"login": "joheriks"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY2OTI2Mw==", "bodyText": "Values with ${ are excluded.\nWill check the exception, thanks.", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487669263", "createdAt": "2020-09-14T06:03:22Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3OTI5MQ==", "bodyText": "I'm not able to get any exception with the correct template:\nimport {PolymerElement} from '@polymer/polymer/polymer-element.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\nclass PolymerComponent extends PolymerElement {\n  static get template() {\n    return html`\n        <vaadin-text-field id=\"textField\" autofocus></vaadin-text-field>\n    `;\n  }\n  \n  static get is() {\n    return 'polymer-component';\n  }\n}\ncustomElements.define('polymer-component', PolymerComponent);\n\nThough textField.isAutofocus() returns false which is unexpected but this is a different issue.\nI will try to see what can be done with this.", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487679291", "createdAt": "2020-09-14T06:31:57Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4MTM3Mg==", "bodyText": "On the other hand , apparently the NPE is caused by the null  attribute value after Jsoup parsing which is never null for me.\nI may assume it's related to Jsoup version.\nBut anyway the fix should be easy: just check null  value.", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487681372", "createdAt": "2020-09-14T06:37:35Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4NDI3Mw==", "bodyText": "This template looks essentially the same as the one I posted above (I omitted the imports). I get the NPE also with this template I when I add the polymer component to a server-side component.", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487684273", "createdAt": "2020-09-14T06:44:44Z", "author": {"login": "joheriks"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcwMTk3NA==", "bodyText": "Both issues should be fixed now.", "url": "https://github.com/vaadin/flow/pull/8988#discussion_r487701974", "createdAt": "2020-09-14T07:23:27Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/InjectableElementInitializer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.regex.Pattern;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.dom.Element;\n+\n+/**\n+ * Initializer the template element with data.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+public class InjectableElementInitializer\n+        implements Consumer<Map<String, String>> {\n+\n+    private final Element element;\n+\n+    private final Class<? extends Component> templateClass;\n+\n+    private static final Map<String, ElementInitializationStrategy> INIT_STRATEGIES = createStategies();\n+    private static final IdentityHashMap<Pattern, ElementInitializationStrategy> PATTERN_STRATEGIES = createPatternStategies();\n+\n+    private static final ElementInitializationStrategy DEFAULT_STRATEGY = new PropertyInitializationStrategy();\n+\n+    /**\n+     * Creates an initializer for the {@code element}.\n+     * \n+     * @param element\n+     *            element to initialize\n+     * @param templateClass\n+     *            the class of the template component\n+     */\n+    public InjectableElementInitializer(Element element,\n+            Class<? extends Component> templateClass) {\n+        this.element = element;\n+        this.templateClass = templateClass;\n+    }\n+\n+    @Override\n+    public void accept(Map<String, String> templateAttributes) {\n+        templateAttributes\n+                .forEach((name, value) -> initialize(element, name, value));\n+    }\n+\n+    private void initialize(Element element, String name, String value) {\n+        if (name.endsWith(\"$\")) {\n+            // this is an attribute binding, ignore it since we don't support\n+            // bindings: the value is not an expression\n+            getLogger().debug(\n+                    \"Template {} contains an attribute {} in element {} which \"\n+                            + \"ends with $ and ignored by initialization since this is an attribute binding\",\n+                    templateClass.getSimpleName(), name, element.getTag());\n+            return;\n+        }\n+        if (value.contains(\"{{\") && value.contains(\"}}\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyODcxOA=="}, "originalCommit": {"oid": "49acd2e76b461dc49be5ae552c5ff900c0848aaa"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3246, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}