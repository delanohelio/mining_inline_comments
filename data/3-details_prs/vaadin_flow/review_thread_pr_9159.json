{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxNDAzNTE4", "number": 9159, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzowOVrOEsrNAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzoxM1rOEsrNKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjgwNjQyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzowOVrOHgDALw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzowOVrOHgDALw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2NTY3OQ==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9159#discussion_r503365679", "createdAt": "2020-10-12T15:17:09Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -152,31 +168,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n+            }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80bd93860222f3d0601b61834d3befb0be543591"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjgwNjY0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzoxMlrOHgDAUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzoxMlrOHgDAUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2NTcxNQ==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9159#discussion_r503365715", "createdAt": "2020-10-12T15:17:12Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -152,31 +168,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n+            }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",\n+                                createContentRangeHeader(start, end,\n+                                        connection.getContentLengthLong()))\n+                        .getBytes());\n+\n+                if (position > start) {\n+                    // out-of-sequence range -> open new stream to the file\n+                    // alternative: use single stream with mark / reset\n+                    closeStream(connection.getInputStream());\n+                    connection = resourceURL.openConnection();\n+                    dataStream = connection.getInputStream();\n+                    position = 0L;\n+                }\n+                long skipped = dataStream.skip(start - position);\n+                assert(skipped == start - position);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+                position = end + 1;\n             }\n+        } finally {\n+            closeStream(dataStream);\n+        }\n+        outputStream.write(String.format(\"\\r\\n--%s\", partBoundary).getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80bd93860222f3d0601b61834d3befb0be543591"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjgwNjc1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzoxM1rOHgDAYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzoxM1rOHgDAYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2NTczMQ==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL) \n Found reliance on default encoding in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL): String.getBytes()", "url": "https://github.com/vaadin/flow/pull/9159#discussion_r503365731", "createdAt": "2020-10-12T15:17:13Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -152,31 +168,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n+            }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80bd93860222f3d0601b61834d3befb0be543591"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjgwNjgzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzoxM1rOHgDAcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNToxNzoxM1rOHgDAcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2NTc0NQ==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9159#discussion_r503365745", "createdAt": "2020-10-12T15:17:13Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -152,31 +168,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n+            }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80bd93860222f3d0601b61834d3befb0be543591"}, "originalPosition": 207}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3145, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}