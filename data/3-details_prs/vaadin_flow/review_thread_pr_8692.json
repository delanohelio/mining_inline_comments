{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0NDU0NzIz", "number": 8692, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNjo0MzoxOVrOELjvbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNjo0MzoxOVrOELjvbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTU1Mzc0OnYy", "diffSide": "RIGHT", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNjo0MzoxOVrOGtKoig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNToyNDo1MVrOGtcGTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMzMyMg==", "bodyText": "Doesn't this break the connector behaviour? Have you tested the grid manually after these changes? I'm a bit worry about the fact that the connector send the requested range to the server, and then the server sends back the data corresponding to another request range (which is shifted by the server). Is that a some kind of optimisation to avoid redundant client-servers interactions?", "url": "https://github.com/vaadin/flow/pull/8692#discussion_r450013322", "createdAt": "2020-07-06T06:43:19Z", "author": {"login": "mshabarov"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -792,7 +797,20 @@ private void flush() {\n                 // the end has been reached\n                 assumedSize = requestedRange.getStart()\n                         + activation.getActiveKeys().size();\n-                skipSizeCheckUntilReset = true;\n+                skipCountIncreaseUntilReset = true;\n+                /*\n+                 * If the fetch query returned 0 items, it means that the user\n+                 * has scrolled past the end of the exact item count. Instead of\n+                 * returning 0 items to the client and letting it incrementally\n+                 * request for the previous pages, we'll cancel this flush and\n+                 * tweak the requested range and flush again.\n+                 */\n+                if (assumedSize != 0 && activation.getActiveKeys().size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8809535f52c83fc2ffeee35643eb00d241a982d9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1MDkyNQ==", "bodyText": "I've tested this case using the GridDemo (with appropriate itemCountEstimate and itemCountEstimateIncrease) and it works good. Withdraw my comment.", "url": "https://github.com/vaadin/flow/pull/8692#discussion_r450050925", "createdAt": "2020-07-06T08:04:43Z", "author": {"login": "mshabarov"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -792,7 +797,20 @@ private void flush() {\n                 // the end has been reached\n                 assumedSize = requestedRange.getStart()\n                         + activation.getActiveKeys().size();\n-                skipSizeCheckUntilReset = true;\n+                skipCountIncreaseUntilReset = true;\n+                /*\n+                 * If the fetch query returned 0 items, it means that the user\n+                 * has scrolled past the end of the exact item count. Instead of\n+                 * returning 0 items to the client and letting it incrementally\n+                 * request for the previous pages, we'll cancel this flush and\n+                 * tweak the requested range and flush again.\n+                 */\n+                if (assumedSize != 0 && activation.getActiveKeys().size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMzMyMg=="}, "originalCommit": {"oid": "8809535f52c83fc2ffeee35643eb00d241a982d9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5OTQ2OA==", "bodyText": "I did test it myself too as I was unsure how the web component would react - but it is simple and beautiful that it will just work - as it first gets the new size and it requests the new item range which is already available on the client.", "url": "https://github.com/vaadin/flow/pull/8692#discussion_r450299468", "createdAt": "2020-07-06T15:24:51Z", "author": {"login": "pleku"}, "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -792,7 +797,20 @@ private void flush() {\n                 // the end has been reached\n                 assumedSize = requestedRange.getStart()\n                         + activation.getActiveKeys().size();\n-                skipSizeCheckUntilReset = true;\n+                skipCountIncreaseUntilReset = true;\n+                /*\n+                 * If the fetch query returned 0 items, it means that the user\n+                 * has scrolled past the end of the exact item count. Instead of\n+                 * returning 0 items to the client and letting it incrementally\n+                 * request for the previous pages, we'll cancel this flush and\n+                 * tweak the requested range and flush again.\n+                 */\n+                if (assumedSize != 0 && activation.getActiveKeys().size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMzMyMg=="}, "originalCommit": {"oid": "8809535f52c83fc2ffeee35643eb00d241a982d9"}, "originalPosition": 103}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3357, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}