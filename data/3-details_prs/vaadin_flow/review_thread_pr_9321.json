{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1OTE5ODk4", "number": 9321, "reviewThreads": {"totalCount": 93, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1M1rOE1-hNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzozNTozN1rOE6BKoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0Mjk0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/DeferredServletContextInitializers.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1M1rOHujKOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1M1rOHujKOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjYwMw==", "bodyText": "This call to \"add()\" may be a performance hot spot if the collection is large.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572603", "createdAt": "2020-11-06T07:43:53Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/DeferredServletContextInitializers.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.server.VaadinContext;\n+\n+/**\n+ * Internal collection of initializers which may not be executed immediately but\n+ * requires a {@link Lookup} instance which will be set in the\n+ * {@link VaadinContext} ({@link ServletContext}) only when\n+ * {@link LookupInitializer} completed.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+class DeferredServletContextInitializers {\n+\n+    /**\n+     * A callback which will be called to run\n+     * {@link ServletContainerInitializer} logic once a {@link ServletContext}\n+     * is initialized with {@link Lookup}.\n+     * \n+     * @author Vaadin Ltd\n+     * @since\n+     *\n+     */\n+    interface Initializer {\n+        /**\n+         * Runs {@link ServletContainerInitializer} logic with the provided\n+         * {@code context}.\n+         * \n+         * @param context\n+         * @throws ServletException\n+         *             thrown if the initializer throws an exception\n+         */\n+        void init(ServletContext context) throws ServletException;\n+    }\n+\n+    private final List<Initializer> initializers = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * Adds deferred initializer\n+     * \n+     * @param initializer\n+     *            an initializer\n+     */\n+    void addInitializer(Initializer initializer) {\n+        initializers.add(initializer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzEyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1NlrOHujKVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1NlrOHujKVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjYzMA==", "bodyText": "\"servletContext\" is a method parameter, and should not be used for synchronization.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572630", "createdAt": "2020-11-06T07:43:56Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzE1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1N1rOHujKWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1N1rOHujKWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjYzNA==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572634", "createdAt": "2020-11-06T07:43:57Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {\n+            initializers = vaadinContext\n+                    .getAttribute(DeferredServletContextInitializers.class);\n+            vaadinContext\n+                    .removeAttribute(DeferredServletContextInitializers.class);\n+        }\n+\n+        if (initializers != null) {\n+            initializers.runInitializers(servletContext);\n+        }\n+    }\n+\n+    @Override\n+    public boolean requiresLookup() {\n+        return false;\n+    }\n+\n+    private void initStandardLookup(Set<Class<?>> classSet,\n+            ServletContext servletContext) {\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+\n+        Map<Class<?>, Collection<Object>> services = new HashMap<>();\n+\n+        collectResourceProviders(classSet, services);\n+        collectSubclasses(InstantiatorFactory.class, classSet, services);\n+        collectSubclasses(DeprecatedPolymerPublishedEventHandler.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzE5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1OFrOHujKXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1OFrOHujKXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjYzOA==", "bodyText": "Reduce the number of conditional operators (5) used in the expression (maximum allowed 3).", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572638", "createdAt": "2020-11-06T07:43:58Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {\n+            initializers = vaadinContext\n+                    .getAttribute(DeferredServletContextInitializers.class);\n+            vaadinContext\n+                    .removeAttribute(DeferredServletContextInitializers.class);\n+        }\n+\n+        if (initializers != null) {\n+            initializers.runInitializers(servletContext);\n+        }\n+    }\n+\n+    @Override\n+    public boolean requiresLookup() {\n+        return false;\n+    }\n+\n+    private void initStandardLookup(Set<Class<?>> classSet,\n+            ServletContext servletContext) {\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+\n+        Map<Class<?>, Collection<Object>> services = new HashMap<>();\n+\n+        collectResourceProviders(classSet, services);\n+        collectSubclasses(InstantiatorFactory.class, classSet, services);\n+        collectSubclasses(DeprecatedPolymerPublishedEventHandler.class,\n+                classSet, services);\n+\n+        LookupImpl lookup = new LookupImpl(services);\n+        vaadinContext.setAttribute(Lookup.class, lookup);\n+    }\n+\n+    private void collectSubclasses(Class<?> clazz, Set<Class<?>> classSet,\n+            Map<Class<?>, Collection<Object>> services) {\n+        services.put(clazz,\n+                filterSubClasses(clazz, classSet).stream()\n+                        .map(ReflectTools::createInstance)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    private void collectResourceProviders(Set<Class<?>> classSet,\n+            Map<Class<?>, Collection<Object>> services) {\n+        Set<Class<?>> providers = filterResourceProviders(classSet);\n+        if (providers.isEmpty()) {\n+            services.put(ResourceProvider.class,\n+                    Collections.singletonList(new ResourceProviderImpl()));\n+        } else if (providers.size() > 1) {\n+            throw new IllegalStateException(\n+                    SEVERAL_IMPLS + ResourceProvider.class.getSimpleName() + SPI\n+                            + classSet + ONE_IMPL_REQUIRED);\n+        } else {\n+            Class<?> clazz = providers.iterator().next();\n+            services.put(ResourceProvider.class, Collections\n+                    .singletonList(ReflectTools.createInstance(clazz)));\n+        }\n+    }\n+\n+    private Set<Class<?>> filterResourceProviders(Set<Class<?>> classes) {\n+        return classes == null ? Collections.emptySet()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzI2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1OVrOHujKZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1OVrOHujKZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY0Nw==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572647", "createdAt": "2020-11-06T07:43:59Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzI5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1OVrOHujKbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0Mzo1OVrOHujKbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY1Mg==", "bodyText": "Reduce the total number of break and continue statements in this loop to use at most one.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572652", "createdAt": "2020-11-06T07:43:59Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class PushResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+\n+        public PushResourceServlet(Bundle pushBundle) {\n+            bundle = pushBundle;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(\n+                    \"/META-INF/resources/VAADIN/static/push\" + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker.\n+     *\n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/push/*\");\n+        servletRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new PushResourceServlet(pushBundle), properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletRegistration.get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private boolean isPushModule(Bundle bundle) {\n+        return \"com.vaadin.flow.push\".equals(bundle.getSymbolicName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void scanContextInitializers() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        scanClasses(flowServerBundle, map, this::handleFlowServerClassError);\n+        Collection<Class<?>> classes = map.get(flowServerBundle.getBundleId());\n+\n+        Predicate<Class<?>> isInterface = Class::isInterface;\n+\n+        Collection<Class<? extends ServletContainerInitializer>> initializers = classes\n+                .stream()\n+                .filter(ServletContainerInitializer.class::isAssignableFrom)\n+                .filter(isInterface.negate())\n+                .map(clazz -> (Class<? extends ServletContainerInitializer>) clazz)\n+                .collect(Collectors.toList());\n+        OSGiAccess.getInstance().setServletContainerInitializers(initializers);\n+    }\n+\n+    private void scanActivatedBundle(Bundle bundle) {\n+        if (!isActive(bundle) || !isVaadinExtender(bundle)) {\n+            return;\n+        }\n+        if (OSGiAccess.getInstance().hasInitializers()) {\n+            Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+            scanClasses(bundle, map, this::handleBundleClassError);\n+            OSGiAccess.getInstance().addScannedClasses(map);\n+        } else {\n+            executor.execute(() -> scanActivatedBundle(bundle));\n+        }\n+    }\n+\n+    private void scanActiveBundles() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        Stream.of(flowServerBundle.getBundleContext().getBundles())\n+                .filter(this::isActive).filter(this::isVaadinExtender)\n+                .forEach(activeBundle -> scanClasses(activeBundle, map,\n+                        this::handleBundleClassError));\n+        OSGiAccess.getInstance().addScannedClasses(map);\n+    }\n+\n+    private boolean isActive(Bundle bundle) {\n+        return (bundle.getState() & Bundle.ACTIVE) > 0;\n+    }\n+\n+    private boolean isVaadinExtender(Bundle bundle) {\n+        return !flowServerBundle.equals(bundle) && Boolean.TRUE.toString()\n+                .equals(bundle.getHeaders().get(\"Vaadin-OSGi-Extender\"));\n+    }\n+\n+    private void handleFlowServerClassError(String className,\n+            Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .trace(\"Couldn't load class '{}'\", className, throwable);\n+    }\n+\n+    private void handleBundleClassError(String className, Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .warn(\"Couldn't load class '{}'\", className, throwable);\n+    }\n+\n+    private void scanClasses(Bundle bundle, Map<Long, Collection<Class<?>>> map,\n+            BiConsumer<String, Throwable> throwableHandler) {\n+        BundleWiring wiring = bundle.adapt(BundleWiring.class);\n+\n+        // get all .class resources of this bundle\n+        Collection<String> classes = wiring.listResources(\"/\", \"*.class\",\n+                BundleWiring.LISTRESOURCES_RECURSE);\n+\n+        Collection<Class<?>> bundleClasses = new ArrayList<>();\n+\n+        for (String clazz : classes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzMzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowMVrOHujKcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowMVrOHujKcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY1Ng==", "bodyText": "Add a \"try/catch\" block for \"openStream\".", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572656", "createdAt": "2020-11-06T07:44:01Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class PushResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+\n+        public PushResourceServlet(Bundle pushBundle) {\n+            bundle = pushBundle;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(\n+                    \"/META-INF/resources/VAADIN/static/push\" + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzM3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowMlrOHujKeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowMlrOHujKeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY2NQ==", "bodyText": "Replace the synchronized class \"Hashtable\" by an unsynchronized one such as \"HashMap\".", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572665", "createdAt": "2020-11-06T07:44:02Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class PushResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+\n+        public PushResourceServlet(Bundle pushBundle) {\n+            bundle = pushBundle;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(\n+                    \"/META-INF/resources/VAADIN/static/push\" + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker.\n+     *\n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzQxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowMlrOHujKfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowMlrOHujKfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY3MA==", "bodyText": "Add a \"try/catch\" block for \"copy\". \n Add a \"try/catch\" block for \"getOutputStream\".", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572670", "createdAt": "2020-11-06T07:44:02Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class PushResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+\n+        public PushResourceServlet(Bundle pushBundle) {\n+            bundle = pushBundle;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(\n+                    \"/META-INF/resources/VAADIN/static/push\" + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzQ2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowM1rOHujKhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowM1rOHujKhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY3Nw==", "bodyText": "Do not forget to remove this deprecated code someday.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572677", "createdAt": "2020-11-06T07:44:03Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "diffHunk": "@@ -135,13 +139,13 @@\n     /**\n      * Default folder for copying front-end resources present in the classpath\n      * jars.\n-     * @deprecated This is deprecated due to a typo.\n-     *             Use DEFAULT_FLOW_RESOURCES_FOLDER instead.\n+     * \n+     * @deprecated This is deprecated due to a typo. Use\n+     *             DEFAULT_FLOW_RESOURCES_FOLDER instead.\n      * @see #DEFAULT_FLOW_RESOURCES_FOLDER\n      */\n     @Deprecated\n-    public static final String DEAULT_FLOW_RESOURCES_FOLDER =\n-            DEFAULT_FLOW_RESOURCES_FOLDER;\n+    public static final String DEAULT_FLOW_RESOURCES_FOLDER = DEFAULT_FLOW_RESOURCES_FOLDER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzYwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowN1rOHujKnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDowN1rOHujKnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjcwMw==", "bodyText": "This call to \"add()\" may be a performance hot spot if the collection is large.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572703", "createdAt": "2020-11-06T07:44:07Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +63,127 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0MzkyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxMlrOHujKzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxMlrOHujKzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc1MA==", "bodyText": "Remove this use of \"init\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572750", "createdAt": "2020-11-06T07:44:12Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +410,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                if (instantiator != null && instantiator.init(this)) {\n+                    instantiators.add(instantiator);\n+                }\n+            }\n+        }\n+\n+        if (instantiators == null) {\n+            instantiators = new ArrayList<>();\n+        }\n+\n+        // the code to support previous way of loading instantiators\n+        StreamSupport\n                 .stream(ServiceLoader.load(Instantiator.class, getClassLoader())\n                         .spliterator(), false)\n                 .filter(iterator -> iterator.init(this))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0Mzk5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxM1rOHujK1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxM1rOHujK1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc1OA==", "bodyText": "Rename \"instantiator\" which hides the field declared at line 191.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572758", "createdAt": "2020-11-06T07:44:13Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +410,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDA2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxNFrOHujK3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxNFrOHujK3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc2Nw==", "bodyText": "Remove this use of \"init\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572767", "createdAt": "2020-11-06T07:44:14Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +410,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                if (instantiator != null && instantiator.init(this)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDEyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxNFrOHujK5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxNFrOHujK5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc3Mw==", "bodyText": "Reduce this lambda expression number of lines from 37 to at most 20.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572773", "createdAt": "2020-11-06T07:44:14Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDE3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxNVrOHujK7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxNVrOHujK7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc4MQ==", "bodyText": "This block of commented-out lines of code should be removed.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572781", "createdAt": "2020-11-06T07:44:15Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDIyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxNlrOHujK8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxNlrOHujK8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc4Nw==", "bodyText": "Replace this lambda with a method reference.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572787", "createdAt": "2020-11-06T07:44:16Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n+\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {\n+                if (vaadinContext.getAttribute(Lookup.class) == null) {\n+                    DeferredServletContextInitializers initializers = vaadinContext\n+                            .getAttribute(\n+                                    DeferredServletContextInitializers.class,\n+                                    () -> new DeferredServletContextInitializers());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDIzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxN1rOHujK9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxN1rOHujK9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc5MQ==", "bodyText": "Replace this lambda with a method reference.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572791", "createdAt": "2020-11-06T07:44:17Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n+\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {\n+                if (vaadinContext.getAttribute(Lookup.class) == null) {\n+                    DeferredServletContextInitializers initializers = vaadinContext\n+                            .getAttribute(\n+                                    DeferredServletContextInitializers.class,\n+                                    () -> new DeferredServletContextInitializers());\n+                    initializers.addInitializer(\n+                            ctx -> deferredInitializer.init(ctx));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDI2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxOFrOHujK-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxOFrOHujK-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc5NQ==", "bodyText": "\"context\" is a method parameter, and should not be used for synchronization.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572795", "createdAt": "2020-11-06T07:44:18Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n+\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDM1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxOVrOHujLBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxOVrOHujLBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgwNA==", "bodyText": "Either log or rethrow this exception. \n Catch Exception instead of Throwable.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572804", "createdAt": "2020-11-06T07:44:19Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\n+                    \"Couldn't run servlet context initializer \"\n+                            + initializer.getClass(),\n+                    e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Set<Class<?>> filterClasses(HandlesTypes typesAnnotation) {\n+        Set<Class<?>> result = new HashSet<>();\n+        if (typesAnnotation == null) {\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes));\n+        } else {\n+            Class<?>[] requestedTypes = typesAnnotation.value();\n+\n+            Predicate<Class<?>> isAnnotation = Class::isAnnotation;\n+\n+            List<Class<? extends Annotation>> annotations = Stream\n+                    .of(requestedTypes).filter(isAnnotation)\n+                    .map(clazz -> (Class<? extends Annotation>) clazz)\n+                    .collect(Collectors.toList());\n+\n+            List<Class<?>> superTypes = Stream.of(requestedTypes)\n+                    .filter(isAnnotation.negate()).collect(Collectors.toList());\n+\n+            Predicate<Class<?>> hasType = clazz -> annotations.stream()\n+                    .anyMatch(annotation -> AnnotationReader\n+                            .getAnnotationFor(clazz, annotation).isPresent())\n+                    || superTypes.stream()\n+                            .anyMatch(superType -> GenericTypeReflector\n+                                    .isSuperType(HasErrorParameter.class,\n+                                            clazz));\n+\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes\n+                    .stream().filter(hasType).collect(Collectors.toList())));\n+\n+        }\n+        return result;\n+    }\n+\n+    private ServletContext createOSGiServletContext() {\n+        Builder<OSGiServletContext> builder = new ByteBuddy()\n+                .subclass(OSGiServletContext.class);\n+\n+        Class<? extends OSGiServletContext> osgiServletContextClass = builder\n+                .make().load(OSGiServletContext.class.getClassLoader(),\n+                        ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        OSGiServletContext osgiContext = ReflectTools.createProxyInstance(\n+                osgiServletContextClass, ServletContext.class);\n+\n+        new VaadinServletContext(osgiContext).setAttribute(Lookup.class,\n+                new OsgiLookupImpl());\n+\n+        return osgiContext;\n+    }\n+\n+    private static final class LazyOSGiDetector {\n+        private static final boolean IS_IN_OSGI = isInOSGi();\n+\n+        private static boolean isInOSGi() {\n+            try {\n+                Class<?> clazz = Class\n+                        .forName(\"org.osgi.framework.FrameworkUtil\");\n+\n+                Method method = clazz.getDeclaredMethod(\"getBundle\",\n+                        Class.class);\n+\n+                // even though the FrameworkUtil class is in the classpath it\n+                // may be there not because of OSGi container but plain WAR with\n+                // jar which contains the class\n+                if (method.invoke(null, OSGiAccess.class) == null) {\n+                    return false;\n+                }\n+                UsageStatistics.markAsUsed(\"flow/osgi\", getOSGiVersion());\n+\n+                return true;\n+            } catch (ClassNotFoundException | NoSuchMethodException\n+                    | SecurityException | IllegalAccessException\n+                    | IllegalArgumentException\n+                    | InvocationTargetException exception) {\n+                if (LoggerFactory.getLogger(OSGiAccess.class)\n+                        .isTraceEnabled()) {\n+                    LoggerFactory.getLogger(OSGiAccess.class)\n+                            .trace(\"Exception in OSGi container check \"\n+                                    + \"(which most likely means that this is not OSGi container)\",\n+                                    exception);\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /**\n+         * Tries to detect the version of the OSGi framework used.\n+         *\n+         * @return the used OSGi version or {@code null} if not able to detect\n+         *         it\n+         */\n+        private static String getOSGiVersion() {\n+            try {\n+                Bundle osgiBundle = org.osgi.framework.FrameworkUtil\n+                        .getBundle(Bundle.class);\n+                return osgiBundle.getVersion().toString();\n+            } catch (Throwable throwable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDQyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxOVrOHujLEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoxOVrOHujLEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgxNw==", "bodyText": "Add a private constructor to hide the implicit public one.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572817", "createdAt": "2020-11-06T07:44:19Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\n+                    \"Couldn't run servlet context initializer \"\n+                            + initializer.getClass(),\n+                    e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Set<Class<?>> filterClasses(HandlesTypes typesAnnotation) {\n+        Set<Class<?>> result = new HashSet<>();\n+        if (typesAnnotation == null) {\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes));\n+        } else {\n+            Class<?>[] requestedTypes = typesAnnotation.value();\n+\n+            Predicate<Class<?>> isAnnotation = Class::isAnnotation;\n+\n+            List<Class<? extends Annotation>> annotations = Stream\n+                    .of(requestedTypes).filter(isAnnotation)\n+                    .map(clazz -> (Class<? extends Annotation>) clazz)\n+                    .collect(Collectors.toList());\n+\n+            List<Class<?>> superTypes = Stream.of(requestedTypes)\n+                    .filter(isAnnotation.negate()).collect(Collectors.toList());\n+\n+            Predicate<Class<?>> hasType = clazz -> annotations.stream()\n+                    .anyMatch(annotation -> AnnotationReader\n+                            .getAnnotationFor(clazz, annotation).isPresent())\n+                    || superTypes.stream()\n+                            .anyMatch(superType -> GenericTypeReflector\n+                                    .isSuperType(HasErrorParameter.class,\n+                                            clazz));\n+\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes\n+                    .stream().filter(hasType).collect(Collectors.toList())));\n+\n+        }\n+        return result;\n+    }\n+\n+    private ServletContext createOSGiServletContext() {\n+        Builder<OSGiServletContext> builder = new ByteBuddy()\n+                .subclass(OSGiServletContext.class);\n+\n+        Class<? extends OSGiServletContext> osgiServletContextClass = builder\n+                .make().load(OSGiServletContext.class.getClassLoader(),\n+                        ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        OSGiServletContext osgiContext = ReflectTools.createProxyInstance(\n+                osgiServletContextClass, ServletContext.class);\n+\n+        new VaadinServletContext(osgiContext).setAttribute(Lookup.class,\n+                new OsgiLookupImpl());\n+\n+        return osgiContext;\n+    }\n+\n+    private static final class LazyOSGiDetector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 356}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDQ1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyMFrOHujLGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyMFrOHujLGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgyNQ==", "bodyText": "Define and throw a dedicated exception instead of using a generic one.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572825", "createdAt": "2020-11-06T07:44:20Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDUwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/di/Instantiator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyMVrOHujLIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyMVrOHujLIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgzMw==", "bodyText": "Do not forget to remove this deprecated code someday.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572833", "createdAt": "2020-11-06T07:44:21Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/di/Instantiator.java", "diffHunk": "@@ -63,7 +63,12 @@\n      * @return <code>true</code> if this instance should be considered as a\n      *         candidate for usage for the provided service; <code>false</code>\n      *         to opt-out from the selection process\n+     * @deprecated The {@link Instantiator} instance should be created by an\n+     *             {@link InstantiatorFactory} which should just return\n+     *             {@code null} if the provided {@code service} can't be handled\n+     *             by it\n      */\n+    @Deprecated\n     boolean init(VaadinService service);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDUyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/webcomponent/OSGiWebComponentConfigurationRegistryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyMlrOHujLJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyMlrOHujLJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgzNg==", "bodyText": "Remove this use of \"Thread.sleep()\".", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572836", "createdAt": "2020-11-06T07:44:22Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/webcomponent/OSGiWebComponentConfigurationRegistryTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.vaadin.flow.server.webcomponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.startup.EnableOSGiRunner;\n+\n+import net.jcip.annotations.NotThreadSafe;\n+\n+@NotThreadSafe\n+@RunWith(EnableOSGiRunner.class)\n+public class OSGiWebComponentConfigurationRegistryTest\n+        extends WebComponentConfigurationRegistryTest {\n+\n+    @Override\n+    protected WebComponentConfigurationRegistry createRegistry() {\n+        return new OSGiWebComponentConfigurationRegistry();\n+    }\n+\n+    @Test\n+    @Override\n+    public void assertRegistryIsSingleton() {\n+        Assert.assertSame(\n+                \"OSGiWebComponentConfigurationRegistry instance should be singleton\",\n+                registry,\n+                OSGiWebComponentConfigurationRegistry.getInstance(context));\n+    }\n+\n+    @After\n+    public void cleanUpOSGi() {\n+        OSGiAccess.getInstance().getOsgiServletContext().removeAttribute(\n+                WebComponentConfigurationRegistry.class.getName());\n+    }\n+\n+    @Override\n+    @Test\n+    public void assertWebComponentRegistry() {\n+        Assert.assertEquals(\n+                OSGiWebComponentConfigurationRegistry.class.getName(),\n+                registry.getClass().getName());\n+    }\n+\n+    @Override\n+    public void setConfigurationsTwice_onlyFirstSetIsAccepted() {\n+        // OSGi accepts setting the web components multiple times.\n+        // NO-OP\n+    }\n+\n+    @Override\n+    public void setConfigurations_getConfigurationsCallDoesNotChangeSetProtection() {\n+        // OSGi accepts setting the web components multiple times.\n+        // NO-OP\n+    }\n+\n+    @Test\n+    public void setBuildersTwice_allSetsAcceptedLastSetValid() {\n+        Assert.assertFalse(\"Registry should have no configurations\",\n+                registry.hasConfigurations());\n+\n+        Assert.assertTrue(\n+                \"Registry should have accepted the \" + \"WebComponentExporters\",\n+                registry.setConfigurations(\n+                        createConfigurations(MyComponentExporter.class)));\n+\n+        Assert.assertTrue(\n+                \"OSGi registry should have accept the second set of \"\n+                        + \"WebComponentExporters.\",\n+                registry.setConfigurations(\n+                        createConfigurations(UserBoxExporter.class)));\n+\n+        Assert.assertEquals(\"Registry should contain only one builder\", 1,\n+                registry.getConfigurations().size());\n+\n+        Assert.assertEquals(\"Builder should be linked to UserBox.class\",\n+                UserBox.class, registry.getConfiguration(\"user-box\").get()\n+                        .getComponentClass());\n+\n+        Assert.assertTrue(\"Registry should have configurations\",\n+                registry.hasConfigurations());\n+    }\n+\n+    @Override\n+    public void setSameRouteValueFromDifferentThreads_ConcurrencyTest()\n+            throws InterruptedException, ExecutionException {\n+        final int THREADS = 10;\n+\n+        ExecutorService executorService = Executors.newFixedThreadPool(THREADS);\n+\n+        List<Callable<AtomicBoolean>> callables = IntStream.range(0, THREADS)\n+                .mapToObj(i -> {\n+                    Callable<AtomicBoolean> callable = () -> {\n+                        // Add random sleep for better possibility to run at\n+                        // same time\n+                        Thread.sleep(new Random().nextInt(200));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDYxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyNVrOHujLNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyNVrOHujLNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg1NQ==", "bodyText": "Do not forget to remove this deprecated code someday.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572855", "createdAt": "2020-11-06T07:44:25Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Handler published event handler service for polymer templates.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ * @deprecated Polymer template support is deprecated - we recommend you to use\n+ *             {@code LitTemplate} instead. Read more details from <a href=\n+ *             \"https://vaadin.com/blog/future-of-html-templates-in-vaadin\">the\n+ *             Vaadin blog.</a>\n+ */\n+@Deprecated\n+public interface DeprecatedPolymerPublishedEventHandler extends Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDcwOnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyNlrOHujLRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyNlrOHujLRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg3MQ==", "bodyText": "Remove this use of \"ModelType\"; it is deprecated. \n Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572871", "createdAt": "2020-11-06T07:44:26Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -33,56 +33,59 @@\n  *\n  * @since\n  */\n-public class PublishedEventRpcHandlerUtil implements Serializable {\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n \n     /**\n      * Validate that the given Component instance is a PolymerTemplate and that\n      * the value can be converted.\n      *\n      * @param instance\n-     *         Component to be validated\n+     *            Component to be validated\n      * @param argValue\n-     *         received value\n+     *            received value\n      * @param convertedType\n-     *         target type that value should be converted to\n+     *            target type that value should be converted to\n      * @return true if valid template model value\n      */\n-    public static boolean isTemplateModelValue(Component instance,\n-            JsonValue argValue, Class<?> convertedType) {\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n         return instance instanceof PolymerTemplate\n                 && argValue instanceof JsonObject\n                 && ((PolymerTemplate<?>) instance)\n-                .isSupportedClass(convertedType) && ((JsonObject) argValue)\n-                .hasKey(\"nodeId\");\n+                        .isSupportedClass(convertedType)\n+                && ((JsonObject) argValue).hasKey(\"nodeId\");\n     }\n \n     /**\n      * Get the template model object and type.\n      *\n      * @param template\n-     *         polymer template to get model from\n+     *            polymer template to get model from\n      * @param argValue\n-     *         argument value\n+     *            argument value\n      * @param convertedType\n-     *         value type\n+     *            value type\n      * @return the provided model value\n      * @throws IllegalStateException\n-     *         if the component is not attached to the UI\n-         */\n-        public static Object getTemplateItem(Component template,\n-                JsonObject argValue, Type convertedType) {\n-            final Optional<UI> ui = template.getUI();\n-            if (ui.isPresent()) {\n-                StateNode node = ui.get().getInternals().getStateTree()\n-                        .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+     *             if the component is not attached to the UI\n+     */\n+    @Override\n+    public Object getTemplateItem(Component template, JsonObject argValue,\n+            Type convertedType) {\n+        final Optional<UI> ui = template.getUI();\n+        if (ui.isPresent()) {\n+            StateNode node = ui.get().getInternals().getStateTree()\n+                    .getNodeById((int) argValue.getNumber(\"nodeId\"));\n \n-                ModelType propertyType = ((PolymerTemplate<?>) template)\n-                        .getModelType(convertedType);\n+            ModelType propertyType = ((PolymerTemplate<?>) template)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDc1OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyN1rOHujLTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyN1rOHujLTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg3Nw==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572877", "createdAt": "2020-11-06T07:44:27Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -33,56 +33,59 @@\n  *\n  * @since\n  */\n-public class PublishedEventRpcHandlerUtil implements Serializable {\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDc5OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyN1rOHujLUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyN1rOHujLUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg4MQ==", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572881", "createdAt": "2020-11-06T07:44:27Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -33,56 +33,59 @@\n  *\n  * @since\n  */\n-public class PublishedEventRpcHandlerUtil implements Serializable {\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n \n     /**\n      * Validate that the given Component instance is a PolymerTemplate and that\n      * the value can be converted.\n      *\n      * @param instance\n-     *         Component to be validated\n+     *            Component to be validated\n      * @param argValue\n-     *         received value\n+     *            received value\n      * @param convertedType\n-     *         target type that value should be converted to\n+     *            target type that value should be converted to\n      * @return true if valid template model value\n      */\n-    public static boolean isTemplateModelValue(Component instance,\n-            JsonValue argValue, Class<?> convertedType) {\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n         return instance instanceof PolymerTemplate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDg1OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyOFrOHujLWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDoyOFrOHujLWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg4OQ==", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572889", "createdAt": "2020-11-06T07:44:28Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -33,56 +33,59 @@\n  *\n  * @since\n  */\n-public class PublishedEventRpcHandlerUtil implements Serializable {\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n \n     /**\n      * Validate that the given Component instance is a PolymerTemplate and that\n      * the value can be converted.\n      *\n      * @param instance\n-     *         Component to be validated\n+     *            Component to be validated\n      * @param argValue\n-     *         received value\n+     *            received value\n      * @param convertedType\n-     *         target type that value should be converted to\n+     *            target type that value should be converted to\n      * @return true if valid template model value\n      */\n-    public static boolean isTemplateModelValue(Component instance,\n-            JsonValue argValue, Class<?> convertedType) {\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n         return instance instanceof PolymerTemplate\n                 && argValue instanceof JsonObject\n                 && ((PolymerTemplate<?>) instance)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDkyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozMFrOHujLYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozMFrOHujLYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg5OQ==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572899", "createdAt": "2020-11-06T07:44:30Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NDk3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozMVrOHujLbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozMVrOHujLbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjkwOA==", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572908", "createdAt": "2020-11-06T07:44:31Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context\n+                        .getAttribute(Lookup.class)\n+                        .lookup(DeprecatedPolymerPublishedEventHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NTA2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozM1rOHujLfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozM1rOHujLfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjkyNQ==", "bodyText": "A \"NullPointerException\" could be thrown; \"instance\" is nullable here.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572925", "createdAt": "2020-11-06T07:44:33Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -180,14 +182,16 @@ private static void invokeMethod(Component instance, Method method,\n                 Serializable returnValue = (Serializable) invokeMethod(instance,\n                         method, args);\n \n-                instance.getElement().executeJs(\"this.$server['\"\n+                instance.getElement()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NTE2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozNFrOHujLiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozNFrOHujLiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjkzNw==", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572937", "createdAt": "2020-11-06T07:44:34Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -107,13 +110,12 @@ public String getRpcType() {\n             PolymerServerEventHandlers eventHandlers = node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NTIzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozNFrOHujLkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozNFrOHujLkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjk0NA==", "bodyText": "A \"NullPointerException\" could be thrown; \"instance\" is nullable here.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572944", "createdAt": "2020-11-06T07:44:34Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -180,14 +182,16 @@ private static void invokeMethod(Component instance, Method method,\n                 Serializable returnValue = (Serializable) invokeMethod(instance,\n                         method, args);\n \n-                instance.getElement().executeJs(\"this.$server['\"\n+                instance.getElement()\n+                        .executeJs(\"this.$server['\"\n                                 + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n-                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n-                        returnValue);\n+                                + \"']($0, true, $1)\",\n+                                Integer.valueOf(promiseId), returnValue);\n             } catch (RuntimeException e) {\n-                instance.getElement().executeJs(\"this.$server['\"\n-                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n-                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+                instance.getElement()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDM0NTI1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozNVrOHujLkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo0NDozNVrOHujLkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjk0Ng==", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572946", "createdAt": "2020-11-06T07:44:35Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -107,13 +110,12 @@ public String getRpcType() {\n             PolymerServerEventHandlers eventHandlers = node\n                     .getFeature(PolymerServerEventHandlers.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTM1MzI3OnYy", "diffSide": "RIGHT", "path": "flow-lit-template/bnd.bnd", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjo0ODoxOFrOHuswcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNTo1NjowM1rOHvf4QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyOTg0Mw==", "bodyText": "I know that you use this in most bnd.bnd files. But not sure why -  its the default\n\nThe Import-Package header lists the packages that are required by the contained packages. The default for this header is *, resulting in importing all referred packages.\n\nfrom bnd docs", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518729843", "createdAt": "2020-11-06T12:48:18Z", "author": {"login": "stbischof"}, "path": "flow-lit-template/bnd.bnd", "diffHunk": "@@ -3,5 +3,6 @@ Bundle-Name: Vaadin Flow Lit Templates Support\n Bundle-Version: ${osgi.bundle.version}\n Bundle-RequiredExecutionEnvironment: JavaSE-1.8\n Bundle-License: http://www.apache.org/licenses/LICENSE-2.0\n+Import-Package: *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e641cf127642e7b07a8952231cffca4563ea3a69"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU2NzQyNQ==", "bodyText": "Thank you.\nDidn't know that this is the default.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r519567425", "createdAt": "2020-11-09T05:56:03Z", "author": {"login": "denis-anisimov"}, "path": "flow-lit-template/bnd.bnd", "diffHunk": "@@ -3,5 +3,6 @@ Bundle-Name: Vaadin Flow Lit Templates Support\n Bundle-Version: ${osgi.bundle.version}\n Bundle-RequiredExecutionEnvironment: JavaSE-1.8\n Bundle-License: http://www.apache.org/licenses/LICENSE-2.0\n+Import-Package: *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyOTg0Mw=="}, "originalCommit": {"oid": "e641cf127642e7b07a8952231cffca4563ea3a69"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTM2NjI5OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjo1MjoyOVrOHus4bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjowMjozNFrOHvf_ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMTg4NQ==", "bodyText": "i think the scope is compile.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518731885", "createdAt": "2020-11-06T12:52:29Z", "author": {"login": "stbischof"}, "path": "flow-polymer-template/pom.xml", "diffHunk": "@@ -90,6 +90,13 @@\n             <version>${osgi.core.version}</version>\n             <scope>provided</scope>\n         </dependency>\n+        \n+        <dependency>\n+            <groupId>org.osgi</groupId>\n+            <artifactId>osgi.cmpn</artifactId>\n+            <version>${osgi.compendium.version}</version>\n+            <scope>provided</scope>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e641cf127642e7b07a8952231cffca4563ea3a69"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU2OTI1OA==", "bodyText": "Not really.\nOr may be it would be better to set this dependency as optional....\nThe idea here is : this Jar should be used without any OSGi.\nAnd that's exactly the reason why I've introduced OSGiPolymerPublishedEventHandlerRegistration class instead of declaring PolymerPublishedEventRpcHandler directly as a service impl.\nIt allows to use PolymerPublishedEventRpcHandler as is so that it doesn't depend on OSGi at all (no any references to OSGi annotations).\nAnd OSGiPolymerPublishedEventHandlerRegistration  will be used only in OSGi, otherwise this class will be completely ignored.\nI think I prefer provided  vs optional.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r519569258", "createdAt": "2020-11-09T06:02:34Z", "author": {"login": "denis-anisimov"}, "path": "flow-polymer-template/pom.xml", "diffHunk": "@@ -90,6 +90,13 @@\n             <version>${osgi.core.version}</version>\n             <scope>provided</scope>\n         </dependency>\n+        \n+        <dependency>\n+            <groupId>org.osgi</groupId>\n+            <artifactId>osgi.cmpn</artifactId>\n+            <version>${osgi.compendium.version}</version>\n+            <scope>provided</scope>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMTg4NQ=="}, "originalCommit": {"oid": "e641cf127642e7b07a8952231cffca4563ea3a69"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTM3NTU5OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/OSGiPolymerPublishedEventHandlerRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjo1NToyN1rOHus99Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjowMzoxNlrOHvgAAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMzMwMQ==", "bodyText": "You could a BundleContext as Parameter in the method. The ServiceComponentRuntime will inject it.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518733301", "createdAt": "2020-11-06T12:55:27Z", "author": {"login": "stbischof"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/OSGiPolymerPublishedEventHandlerRegistration.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+\n+/**\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@Component(immediate = true)\n+public class OSGiPolymerPublishedEventHandlerRegistration {\n+\n+    private ServiceRegistration<DeprecatedPolymerPublishedEventHandler> registration;\n+\n+    @Activate\n+    void activate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e641cf127642e7b07a8952231cffca4563ea3a69"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU2OTQwOA==", "bodyText": "Thank you.\nI assumed that it should work this way but was too lazy to check that in the spec.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r519569408", "createdAt": "2020-11-09T06:03:16Z", "author": {"login": "denis-anisimov"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/OSGiPolymerPublishedEventHandlerRegistration.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+\n+/**\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@Component(immediate = true)\n+public class OSGiPolymerPublishedEventHandlerRegistration {\n+\n+    private ServiceRegistration<DeprecatedPolymerPublishedEventHandler> registration;\n+\n+    @Activate\n+    void activate() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMzMwMQ=="}, "originalCommit": {"oid": "e641cf127642e7b07a8952231cffca4563ea3a69"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzQwOTY2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwODoyMjowMFrOHvjYZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwODoyMjowMFrOHvjYZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYyNDgwNA==", "bodyText": "Replace the synchronized class \"Hashtable\" by an unsynchronized one such as \"HashMap\".", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r519624804", "createdAt": "2020-11-09T08:22:00Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker.\n+     *\n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e20bb7ec4f962ba4026afc170d4b2ca3603aa2c"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTgxMjYyOnYy", "diffSide": "RIGHT", "path": "flow-server/bnd.bnd", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0NDoxMVrOHv6Snw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNTo1NzozM1rOHwM5XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAwMDE1OQ==", "bodyText": "maybe just only  io.swagger.codegen an optional. oll the other are afaik theother io.swagger jars are osgi bundles", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r520000159", "createdAt": "2020-11-09T17:44:11Z", "author": {"login": "stbischof"}, "path": "flow-server/bnd.bnd", "diffHunk": "@@ -4,8 +4,9 @@ Bundle-Version: ${osgi.bundle.version}\n Bundle-RequiredExecutionEnvironment: JavaSE-1.8\n Bundle-License: http://www.apache.org/licenses/LICENSE-2.0\n Import-Package: org.atmosphere*;resolution:=optional;version='${atmosphere.runtime.version}',\\\n-    org.apache.http*;resolution:=optional;,\\\n-  *\n+    org.apache.http*;resolution:=optional;,com.github.javaparser*;resolution:=optional;,\\\n+    io.swagger*;resolution:=optional;,javax.annotation;version=1.3.2,\\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7e12e5ad7a8a2e1e115e4ec1af556e4b8ccc864"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwNDk4OA==", "bodyText": "Well, there are many packages.\nAnd the reason is semantical here: all io.swagger packages are used by vaadin-connect functionality which is\nexecuted either via Maven goal or via DevModeInitializer  which is explicitly excluded in OSGi.\nSo in the end : the whole Flow functionality which requires io.swagger  doesn't work in OSGi and there is just no sense to keep some dependencies non optional.\nAt some point all these deps will be excluded from flow-server  along with this functionality which is not supposed to work in OSGi at all.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r520304988", "createdAt": "2020-11-10T05:57:33Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/bnd.bnd", "diffHunk": "@@ -4,8 +4,9 @@ Bundle-Version: ${osgi.bundle.version}\n Bundle-RequiredExecutionEnvironment: JavaSE-1.8\n Bundle-License: http://www.apache.org/licenses/LICENSE-2.0\n Import-Package: org.atmosphere*;resolution:=optional;version='${atmosphere.runtime.version}',\\\n-    org.apache.http*;resolution:=optional;,\\\n-  *\n+    org.apache.http*;resolution:=optional;,com.github.javaparser*;resolution:=optional;,\\\n+    io.swagger*;resolution:=optional;,javax.annotation;version=1.3.2,\\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAwMDE1OQ=="}, "originalCommit": {"oid": "d7e12e5ad7a8a2e1e115e4ec1af556e4b8ccc864"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Mjg5NDU0OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/OSGiPolymerPublishedEventHandlerRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMTowMTo0N1rOHwXTMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMjowNjo0NFrOHwZjbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3NTQ0MQ==", "bodyText": "you could remove this class if you declare PolymerPublishedEventRpcHandler als component\n@Component(immidiate=true,service=PolymerPublishedEventRpcHandler.class)\npublic class PolymerPublishedEventRpcHandler", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r520475441", "createdAt": "2020-11-10T11:01:47Z", "author": {"login": "stbischof"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/OSGiPolymerPublishedEventHandlerRegistration.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+\n+/**\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@Component(immediate = true)\n+public class OSGiPolymerPublishedEventHandlerRegistration {\n+\n+    private ServiceRegistration<DeprecatedPolymerPublishedEventHandler> registration;\n+\n+    @Activate\n+    void activate(BundleContext context) {\n+        context.registerService(DeprecatedPolymerPublishedEventHandler.class,\n+                new PolymerPublishedEventRpcHandler(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bf7596fa66abe88daf7d1518a52d737ac52db0c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDUxMjM2Ng==", "bodyText": "Already explained here:\nhttps://github.com/vaadin/flow/pull/9321/files#r519569258", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r520512366", "createdAt": "2020-11-10T12:06:44Z", "author": {"login": "denis-anisimov"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/OSGiPolymerPublishedEventHandlerRegistration.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+\n+/**\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@Component(immediate = true)\n+public class OSGiPolymerPublishedEventHandlerRegistration {\n+\n+    private ServiceRegistration<DeprecatedPolymerPublishedEventHandler> registration;\n+\n+    @Activate\n+    void activate(BundleContext context) {\n+        context.registerService(DeprecatedPolymerPublishedEventHandler.class,\n+                new PolymerPublishedEventRpcHandler(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3NTQ0MQ=="}, "originalCommit": {"oid": "9bf7596fa66abe88daf7d1518a52d737ac52db0c"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzI5NDQyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzo1MTozN1rOHxCDHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzo1MTozN1rOHxCDHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3NTgzOQ==", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521175839", "createdAt": "2020-11-11T07:51:37Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),\n+                        data.getParentLayouts()), caught != null);\n+            }\n+            handleCaughtException(caught);\n+        }\n+\n+        private void setRoutes(List<RouteData> routes) {\n+            Exception caught = null;\n+            for (RouteData data : routes) {\n+                caught = modifyRoute(() -> setRoute(data.getUrl(),\n+                        data.getNavigationTarget(), data.getParentLayouts()),\n+                        caught != null);\n+                for (RouteAliasData alias : data.getRouteAliases()) {\n+                    caught = modifyRoute(() -> setRoute(alias.getUrl(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f28e07ae8836a66c82f85d5a70851f9ab43de8be"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzI5NDU0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzo1MTozOFrOHxCDLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzo1MTozOFrOHxCDLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3NTg1NA==", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521175854", "createdAt": "2020-11-11T07:51:38Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f28e07ae8836a66c82f85d5a70851f9ab43de8be"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzI5NDYwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzo1MTozOVrOHxCDNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzo1MTozOVrOHxCDNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3NTg2Mg==", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521175862", "createdAt": "2020-11-11T07:51:39Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),\n+                        data.getParentLayouts()), caught != null);\n+            }\n+            handleCaughtException(caught);\n+        }\n+\n+        private void setRoutes(List<RouteData> routes) {\n+            Exception caught = null;\n+            for (RouteData data : routes) {\n+                caught = modifyRoute(() -> setRoute(data.getUrl(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f28e07ae8836a66c82f85d5a70851f9ab43de8be"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzI5NDYxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzo1MTo0MFrOHxCDOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzo1MTo0MFrOHxCDOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3NTg2NA==", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521175864", "createdAt": "2020-11-11T07:51:40Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f28e07ae8836a66c82f85d5a70851f9ab43de8be"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzY4MzgxOnYy", "diffSide": "RIGHT", "path": "flow-lit-template/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTo0NTo1NVrOHxFxag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTo0NTo1NVrOHxFxag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIzNjg0Mg==", "bodyText": "clear since as it's wrong for lit-template", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521236842", "createdAt": "2020-11-11T09:45:55Z", "author": {"login": "caalador"}, "path": "flow-lit-template/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import org.mockito.Mockito;\n+\n+import com.vaadin.flow.di.Instantiator;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.function.DeploymentConfiguration;\n+import com.vaadin.flow.router.Router;\n+\n+/**\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f28e07ae8836a66c82f85d5a70851f9ab43de8be"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Nzc5NDkzOnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDoxNTo1NVrOHxG10w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDoxNTo1NVrOHxG10w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1NDM1NQ==", "bodyText": "Faulty since tag.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521254355", "createdAt": "2020-11-11T10:15:55Z", "author": {"login": "caalador"}, "path": "flow-polymer-template/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import org.mockito.Mockito;\n+\n+import com.vaadin.flow.di.Instantiator;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.function.DeploymentConfiguration;\n+import com.vaadin.flow.router.Router;\n+\n+/**\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2ODA1MzQyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTozMToxOFrOHxJUAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMTo0Mjo1OFrOHx3C0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5NDg0OQ==", "bodyText": "This should throw or return if ui is not present. now If the case is that we don't have an attached Component the next line will NPE.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521294849", "createdAt": "2020-11-11T11:31:18Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0NDExMw==", "bodyText": "This code is designed to work only with StateNode  which are attached to the StateTree: RPC may not be executed for a Node which is not in the tree.\nSo I would say assertion should be enough since it just checks that the assumption correct.\nException should be thrown on a user mistake. Our internal mistake (or incorrect assumption) should be checked with assertions.\nBut I don't see a reason to have a strong position here on my side.\nLet's make it throwing.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522044113", "createdAt": "2020-11-12T11:42:58Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5NDg0OQ=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2ODA3MDQ0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTozNzowMlrOHxJe4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTozNzowMlrOHxJe4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5NzYzNA==", "bodyText": "Non descriptive javadoc. This should name that it's a interface for injecting the polymer event handler when the module is available.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521297634", "createdAt": "2020-11-11T11:37:02Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Handler published event handler service for polymer templates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2ODE1MTE4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMjowMjowNFrOHxKP_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMjowMjowNFrOHxKP_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMxMDIwNw==", "bodyText": "Remove this call from a constructor to the overridable \"open\" method.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521310207", "createdAt": "2020-11-11T12:02:04Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating the bundle.\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker.\n+     * OSGi ServiceComponentRuntime injects the BundleContext because of the @Activate\n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+        open();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2ODM5MDUxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMzoxMDo0MVrOHxMgGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDowMjowMFrOHx8HXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA5Ng==", "bodyText": "Could we have this as a shorthand in BootstrapContext as getReourceProvider()", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521347096", "createdAt": "2020-11-11T13:10:41Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,47 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = context.getSession()\n+                    .getService().getContext().getAttribute(Lookup.class)\n+                    .lookup(ResourceProvider.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0NjQxMw==", "bodyText": "BootstrapContext is quite hidden internal class.\nAnd ResourceProvider is used only once in the code.\nSo any specific reason to declare a shorthand ?", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522046413", "createdAt": "2020-11-12T11:47:12Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,47 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = context.getSession()\n+                    .getService().getContext().getAttribute(Lookup.class)\n+                    .lookup(ResourceProvider.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA5Ng=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1MDQyOQ==", "bodyText": "Readability is the main issue.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522050429", "createdAt": "2020-11-12T11:54:24Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,47 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = context.getSession()\n+                    .getService().getContext().getAttribute(Lookup.class)\n+                    .lookup(ResourceProvider.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA5Ng=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNzE5OQ==", "bodyText": "Ah, you mean just private method.\nI thought public or protected  method for reuse.\nOK.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522127199", "createdAt": "2020-11-12T14:02:00Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,47 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = context.getSession()\n+                    .getService().getContext().getAttribute(Lookup.class)\n+                    .lookup(ResourceProvider.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA5Ng=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTU1OTQ2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNToxNDoxN1rOHxq1iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNToxNDoxN1rOHxq1iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0NDEwNQ==", "bodyText": "Please add javaDoc on the differences between the 2 context usages", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521844105", "createdAt": "2020-11-12T05:14:17Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTc0MjA3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjo0MTo0N1rOHxsedw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNTozNjoxNFrOHyc_1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<URL> resources;\n          \n          \n            \n                    if (classResources.isEmpty()) {\n          \n          \n            \n                        resources = contextResources;\n          \n          \n            \n                    } else if (contextResources.isEmpty()) {\n          \n          \n            \n                        resources = classResources;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        resources = new ArrayList<>(\n          \n          \n            \n                                classResources.size() + contextResources.size());\n          \n          \n            \n                        resources.addAll(classResources);\n          \n          \n            \n                        resources.addAll(contextResources);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    // Accept resource that doesn't contain\n          \n          \n            \n                    // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n          \n          \n            \n                    URL resource = resources.stream()\n          \n          \n            \n                            .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n          \n          \n            \n                            .findFirst().orElse(null);\n          \n          \n            \n                    Stream<URL> resourceStream = Stream.of(classResources, contextResources).flatMap(Collection::stream);\n          \n          \n            \n            \n          \n          \n            \n                    // Accept resource that doesn't contain\n          \n          \n            \n                    // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n          \n          \n            \n                    URL resource = resourceStream\n          \n          \n            \n                            .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n          \n          \n            \n                            .findFirst().orElse(null);", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521870967", "createdAt": "2020-11-12T06:41:47Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,\n+            VaadinContext context) throws IOException {\n         String tokenResource = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n-        List<URL> resources = Collections.list(DeploymentConfiguration.class\n-                .getClassLoader().getResources(tokenResource));\n+\n+        Lookup lookup = context.getAttribute(Lookup.class);\n+        ResourceProvider resourceProvider = lookup\n+                .lookup(ResourceProvider.class);\n+\n+        List<URL> classResources = resourceProvider\n+                .getApplicationResources(contextClass, tokenResource);\n+        List<URL> contextResources = resourceProvider\n+                .getApplicationResources(context, tokenResource);\n+\n+        List<URL> resources;\n+        if (classResources.isEmpty()) {\n+            resources = contextResources;\n+        } else if (contextResources.isEmpty()) {\n+            resources = classResources;\n+        } else {\n+            resources = new ArrayList<>(\n+                    classResources.size() + contextResources.size());\n+            resources.addAll(classResources);\n+            resources.addAll(contextResources);\n+        }\n+\n         // Accept resource that doesn't contain\n         // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n         URL resource = resources.stream()\n                 .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n                 .findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NTU4Nw==", "bodyText": "Doesn't work.\nBecause it fixes only URL resource = line.\nBut then below there is a check for resources.isEmpty() which may not be done with the same stream.\nIt might be this can be simplified but it's out of scope of this PR.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522055587", "createdAt": "2020-11-12T12:03:23Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,\n+            VaadinContext context) throws IOException {\n         String tokenResource = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n-        List<URL> resources = Collections.list(DeploymentConfiguration.class\n-                .getClassLoader().getResources(tokenResource));\n+\n+        Lookup lookup = context.getAttribute(Lookup.class);\n+        ResourceProvider resourceProvider = lookup\n+                .lookup(ResourceProvider.class);\n+\n+        List<URL> classResources = resourceProvider\n+                .getApplicationResources(contextClass, tokenResource);\n+        List<URL> contextResources = resourceProvider\n+                .getApplicationResources(context, tokenResource);\n+\n+        List<URL> resources;\n+        if (classResources.isEmpty()) {\n+            resources = contextResources;\n+        } else if (contextResources.isEmpty()) {\n+            resources = classResources;\n+        } else {\n+            resources = new ArrayList<>(\n+                    classResources.size() + contextResources.size());\n+            resources.addAll(classResources);\n+            resources.addAll(contextResources);\n+        }\n+\n         // Accept resource that doesn't contain\n         // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n         URL resource = resources.stream()\n                 .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n                 .findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2MDM4MA==", "bodyText": "But the stream of an empty list is a \"empty stream\" (e.g. no-op) so it makes streams of the 2 lists (that are never null) and gets the same end result as the if with the isEmpty checks and new list creation.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522060380", "createdAt": "2020-11-12T12:12:19Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,\n+            VaadinContext context) throws IOException {\n         String tokenResource = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n-        List<URL> resources = Collections.list(DeploymentConfiguration.class\n-                .getClassLoader().getResources(tokenResource));\n+\n+        Lookup lookup = context.getAttribute(Lookup.class);\n+        ResourceProvider resourceProvider = lookup\n+                .lookup(ResourceProvider.class);\n+\n+        List<URL> classResources = resourceProvider\n+                .getApplicationResources(contextClass, tokenResource);\n+        List<URL> contextResources = resourceProvider\n+                .getApplicationResources(context, tokenResource);\n+\n+        List<URL> resources;\n+        if (classResources.isEmpty()) {\n+            resources = contextResources;\n+        } else if (contextResources.isEmpty()) {\n+            resources = classResources;\n+        } else {\n+            resources = new ArrayList<>(\n+                    classResources.size() + contextResources.size());\n+            resources.addAll(classResources);\n+            resources.addAll(contextResources);\n+        }\n+\n         // Accept resource that doesn't contain\n         // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n         URL resource = resources.stream()\n                 .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n                 .findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMTU4OA==", "bodyText": "I think I don't understand you.\nOne stream instance may be used once. Stream is not interchangeable with List anyhow.\nresourceStream.filter.... closes the stream in the end.\nWhich means that isEmpty  or in fact stream.count() may not be called anymore: stream is closed.\nThat's why the list is used : it's possible to call isEmpty regardless of any other list operations.\nPlease provide the whole code snippet for the method instead of change for the snippet above if you still see how this can be imprioved.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522131588", "createdAt": "2020-11-12T14:08:16Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,\n+            VaadinContext context) throws IOException {\n         String tokenResource = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n-        List<URL> resources = Collections.list(DeploymentConfiguration.class\n-                .getClassLoader().getResources(tokenResource));\n+\n+        Lookup lookup = context.getAttribute(Lookup.class);\n+        ResourceProvider resourceProvider = lookup\n+                .lookup(ResourceProvider.class);\n+\n+        List<URL> classResources = resourceProvider\n+                .getApplicationResources(contextClass, tokenResource);\n+        List<URL> contextResources = resourceProvider\n+                .getApplicationResources(context, tokenResource);\n+\n+        List<URL> resources;\n+        if (classResources.isEmpty()) {\n+            resources = contextResources;\n+        } else if (contextResources.isEmpty()) {\n+            resources = classResources;\n+        } else {\n+            resources = new ArrayList<>(\n+                    classResources.size() + contextResources.size());\n+            resources.addAll(classResources);\n+            resources.addAll(contextResources);\n+        }\n+\n         // Accept resource that doesn't contain\n         // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n         URL resource = resources.stream()\n                 .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n                 .findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY1NjExNw==", "bodyText": "Right didn't see the reuse of the thing later on in the class. then I would just have it as\nCollection<URL> resources = Stream.of(classResources, contextResources).flatMap(Collection::stream).collect(Collectors.toList());", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522656117", "createdAt": "2020-11-13T05:15:48Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,\n+            VaadinContext context) throws IOException {\n         String tokenResource = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n-        List<URL> resources = Collections.list(DeploymentConfiguration.class\n-                .getClassLoader().getResources(tokenResource));\n+\n+        Lookup lookup = context.getAttribute(Lookup.class);\n+        ResourceProvider resourceProvider = lookup\n+                .lookup(ResourceProvider.class);\n+\n+        List<URL> classResources = resourceProvider\n+                .getApplicationResources(contextClass, tokenResource);\n+        List<URL> contextResources = resourceProvider\n+                .getApplicationResources(context, tokenResource);\n+\n+        List<URL> resources;\n+        if (classResources.isEmpty()) {\n+            resources = contextResources;\n+        } else if (contextResources.isEmpty()) {\n+            resources = classResources;\n+        } else {\n+            resources = new ArrayList<>(\n+                    classResources.size() + contextResources.size());\n+            resources.addAll(classResources);\n+            resources.addAll(contextResources);\n+        }\n+\n         // Accept resource that doesn't contain\n         // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n         URL resource = resources.stream()\n                 .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n                 .findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY2NTk0Mg==", "bodyText": "Done without flatMap.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522665942", "createdAt": "2020-11-13T05:36:14Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,\n+            VaadinContext context) throws IOException {\n         String tokenResource = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n-        List<URL> resources = Collections.list(DeploymentConfiguration.class\n-                .getClassLoader().getResources(tokenResource));\n+\n+        Lookup lookup = context.getAttribute(Lookup.class);\n+        ResourceProvider resourceProvider = lookup\n+                .lookup(ResourceProvider.class);\n+\n+        List<URL> classResources = resourceProvider\n+                .getApplicationResources(contextClass, tokenResource);\n+        List<URL> contextResources = resourceProvider\n+                .getApplicationResources(context, tokenResource);\n+\n+        List<URL> resources;\n+        if (classResources.isEmpty()) {\n+            resources = contextResources;\n+        } else if (contextResources.isEmpty()) {\n+            resources = classResources;\n+        } else {\n+            resources = new ArrayList<>(\n+                    classResources.size() + contextResources.size());\n+            resources.addAll(classResources);\n+            resources.addAll(contextResources);\n+        }\n+\n         // Accept resource that doesn't contain\n         // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n         URL resource = resources.stream()\n                 .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n                 .findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTc3NDI5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinServlet.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjo1NTozNFrOHxsw5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMjowNDoxN1rOHx3xfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NTY4NQ==", "bodyText": "Merge comments. These should be cleaned up.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521875685", "createdAt": "2020-11-12T06:55:34Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinServlet.java", "diffHunk": "@@ -429,8 +435,13 @@ private boolean ensureCookiesEnabled(VaadinServletRequest request,\n      *             if the application is denied access to the persistent data\n      *             store represented by the given URL.\n      *\n+     *             <<<<<<< HEAD =======\n+     * @deprecated As of 1.0. Will be removed in 3.0.\n+     *\n+     *             >>>>>>> 81a7e2d15a... Fix OSGi Lookup related issues", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NjA0Nw==", "bodyText": "Also should be removed as we are now in 6.0 and this should have been removed in 3.0 if going by the comment", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521876047", "createdAt": "2020-11-12T06:56:38Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinServlet.java", "diffHunk": "@@ -429,8 +435,13 @@ private boolean ensureCookiesEnabled(VaadinServletRequest request,\n      *             if the application is denied access to the persistent data\n      *             store represented by the given URL.\n      *\n+     *             <<<<<<< HEAD =======\n+     * @deprecated As of 1.0. Will be removed in 3.0.\n+     *\n+     *             >>>>>>> 81a7e2d15a... Fix OSGi Lookup related issues", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NTY4NQ=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NjA2MQ==", "bodyText": "Good point.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522056061", "createdAt": "2020-11-12T12:04:17Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinServlet.java", "diffHunk": "@@ -429,8 +435,13 @@ private boolean ensureCookiesEnabled(VaadinServletRequest request,\n      *             if the application is denied access to the persistent data\n      *             store represented by the given URL.\n      *\n+     *             <<<<<<< HEAD =======\n+     * @deprecated As of 1.0. Will be removed in 3.0.\n+     *\n+     *             >>>>>>> 81a7e2d15a... Fix OSGi Lookup related issues", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NTY4NQ=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTc4NzYyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNzowMToxM1rOHxs4pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNzowMToxM1rOHxs4pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NzY2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (handler != null) {\n          \n          \n            \n                                if (handler.isTemplateModelValue(instance, argValue,\n          \n          \n            \n                                        convertedType)) {\n          \n          \n            \n                                    return handler.getTemplateItem(instance,\n          \n          \n            \n                                            (JsonObject) argValue,\n          \n          \n            \n                                            method.getGenericParameterTypes()[index]);\n          \n          \n            \n                                }\n          \n          \n            \n                            }\n          \n          \n            \n                            if (handler != null && handler.isTemplateModelValue(instance, argValue,\n          \n          \n            \n                                    convertedType)) {\n          \n          \n            \n                                return handler.getTemplateItem(instance,\n          \n          \n            \n                                        (JsonObject) argValue,\n          \n          \n            \n                                        method.getGenericParameterTypes()[index]);\n          \n          \n            \n                            }", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521877668", "createdAt": "2020-11-12T07:01:13Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context\n+                        .getAttribute(Lookup.class)\n+                        .lookup(DeprecatedPolymerPublishedEventHandler.class);\n+                if (handler != null) {\n+                    if (handler.isTemplateModelValue(instance, argValue,\n+                            convertedType)) {\n+                        return handler.getTemplateItem(instance,\n+                                (JsonObject) argValue,\n+                                method.getGenericParameterTypes()[index]);\n+                    }\n                 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTc5NDQzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNzowNDoyMVrOHxs8vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNzowNDoyMVrOHxs8vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3ODcxOQ==", "bodyText": "Empty return statement", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521878719", "createdAt": "2020-11-12T07:04:21Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTgxNzczOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNzoxMzo0NFrOHxtKcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNzoxMzo0NFrOHxtKcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg4MjIyNA==", "bodyText": "As we have a null resource we should return; here", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521882224", "createdAt": "2020-11-12T07:13:44Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating the bundle.\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTgyMDgxOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNzoxNDo1NFrOHxtMQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNzoxNDo1NFrOHxtMQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg4MjY5MA==", "bodyText": "As we are marking it as not found here we should return;  here and not try to serve the (resourceDirPath + null)", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521882690", "createdAt": "2020-11-12T07:14:54Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating the bundle.\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MjA3OTYwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwODoyODo0OFrOHxvoXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTo1NTowOFrOH0lYxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg==", "bodyText": "Could we have the classes as their own package protected classes instead of internal?\nAt a minimum document if they are default implementations that may be overridden/changed.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521922652", "createdAt": "2020-11-12T08:28:48Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2NjM2OQ==", "bodyText": "Similar question has been already answered in the original review of this code for 2.5 branch.\nLookupImpl : I may extract this class to its own file. But why ?\nThis class is instantiated here directly and there is no any single reason to override it because overridden class won't be ever instantiated.\nImplementation is done private explicitly. And this obviously says that this may not be overriden /changed.\nJust because it's impossible.\nAnd that's the reason why it's done private and nested.\nThe code is self-explanatory .\nLookup is an entry point for \"everything\". It exactly allows to override any service (if it's done properly).\nAnd this is the only thing which may not be overridden: because it give the way to override other things.\nOther classes are made private for same reasons and e.g. ResourceProviderImpl may not be done public because otherwise it will be collected by the LookupInitializer and there will be no any way to override it.\nShortly : this functionality is explicitly made non-overridable because it gives the way to override everything.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522066369", "createdAt": "2020-11-12T12:23:20Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2ODM0Ng==", "bodyText": "So please add a javadoc with the information for both internal impl classes.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522068346", "createdAt": "2020-11-12T12:26:43Z", "author": {"login": "caalador"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMzIxNQ==", "bodyText": "Which kind of information?\nI don't understand . These are impl classes.\nThe contract (interfaces) are described in details in javadocs of interface.\nImpl classes just impl classes (one of impl).", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522133215", "createdAt": "2020-11-12T14:10:24Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAyNTA4Mg==", "bodyText": "Which kind of information?\n\nAnswer review questions in code.\n\nShortly : this functionality is explicitly made non-overridable because it gives the way to override everything.\n\nYes this is obvious to you as you've done this. It was not obvious for me or Mikael so we asked to document it.\nUnless you do that, it will not be obvious to anyone else outside this conversation either. So spending a little time on documenting the code with comments to save time in the future.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524025082", "createdAt": "2020-11-16T09:31:48Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwMDU1MQ==", "bodyText": "There is a reason why we are writing the code using Java.\nIt allows to write the code in typesafe way, clear contract and hide things which should not be exposed.\nAll these things may be done so that compiler may check this.\nWithout this JS may be used to write the code: it doesn't provide any safety.\nIt's possible to use 4 visibilities : public, protected , package local and private.\nIf something is defined as private then this is intentionally made non-extendable and intentionally hidden from everyone. And this is enforced by the compiler.\nLooks quite obvious. And the same obvious things are requested to be added as comment. That's why\nI really don't understand why.\nWe don't add any comment for a private field why it's private : it's obvious why it's private.\nHere the internal impl class implements interface which defines a contract and since it's private: it's an implementation details which explicitly is not exposed.\nSo it's absolutely obvious for me why the nested class is private and what it means.\nBut apparently I'm the only one for whom this is obvious.\nSo OK, let's add comment which nobody reads.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524900551", "createdAt": "2020-11-17T05:55:08Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MjEwNzExOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwODozNjowOVrOHxv5Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzo1MzowM1rOHx7tlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyNjkzOQ==", "bodyText": "Why don't we init it automatically anymore?", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521926939", "createdAt": "2020-11-12T08:36:09Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "diffHunk": "@@ -39,24 +37,41 @@\n \n     private Router router;\n \n+    private ResourceProvider resourceProvider;\n+\n+    private static class MockVaadinServlet extends VaadinServlet {\n+\n+        private final DeploymentConfiguration configuration;\n+\n+        private VaadinServletService service;\n+\n+        private MockVaadinServlet(DeploymentConfiguration configuration) {\n+            this.configuration = configuration;\n+        }\n+\n+        @Override\n+        protected DeploymentConfiguration createDeploymentConfiguration()\n+                throws ServletException {\n+            return configuration;\n+        }\n+\n+        @Override\n+        protected VaadinServletService createServletService(\n+                DeploymentConfiguration deploymentConfiguration)\n+                throws ServiceException {\n+            return service;\n+        }\n+\n+    }\n+\n     public MockVaadinServletService() {\n         this(new MockDeploymentConfiguration());\n     }\n \n     public MockVaadinServletService(\n             DeploymentConfiguration deploymentConfiguration) {\n-        this(new VaadinServlet(), deploymentConfiguration);\n-    }\n-\n-    public MockVaadinServletService(VaadinServlet servlet,\n-            DeploymentConfiguration deploymentConfiguration) {\n-        super(servlet, deploymentConfiguration);\n-\n-        try {\n-            servlet.init(new MockServletConfig());\n-        } catch (ServletException e) {\n-            throw new RuntimeException(e);\n-        }\n+        super(new MockVaadinServlet(deploymentConfiguration),\n+                deploymentConfiguration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyMDU5Nw==", "bodyText": "servlet.init is almost not needed in the tests.\nThat's why I've removed it.\nBut VaadinService::init is needed everywhere.\nSo yes, good point.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522120597", "createdAt": "2020-11-12T13:53:03Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "diffHunk": "@@ -39,24 +37,41 @@\n \n     private Router router;\n \n+    private ResourceProvider resourceProvider;\n+\n+    private static class MockVaadinServlet extends VaadinServlet {\n+\n+        private final DeploymentConfiguration configuration;\n+\n+        private VaadinServletService service;\n+\n+        private MockVaadinServlet(DeploymentConfiguration configuration) {\n+            this.configuration = configuration;\n+        }\n+\n+        @Override\n+        protected DeploymentConfiguration createDeploymentConfiguration()\n+                throws ServletException {\n+            return configuration;\n+        }\n+\n+        @Override\n+        protected VaadinServletService createServletService(\n+                DeploymentConfiguration deploymentConfiguration)\n+                throws ServiceException {\n+            return service;\n+        }\n+\n+    }\n+\n     public MockVaadinServletService() {\n         this(new MockDeploymentConfiguration());\n     }\n \n     public MockVaadinServletService(\n             DeploymentConfiguration deploymentConfiguration) {\n-        this(new VaadinServlet(), deploymentConfiguration);\n-    }\n-\n-    public MockVaadinServletService(VaadinServlet servlet,\n-            DeploymentConfiguration deploymentConfiguration) {\n-        super(servlet, deploymentConfiguration);\n-\n-        try {\n-            servlet.init(new MockServletConfig());\n-        } catch (ServletException e) {\n-            throw new RuntimeException(e);\n-        }\n+        super(new MockVaadinServlet(deploymentConfiguration),\n+                deploymentConfiguration);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyNjkzOQ=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MjE0MjM2OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/test/java/com/vaadin/flow/component/PolymerClassesSerializableTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwODo0NToxNlrOHxwOlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzo1NToyNlrOHx70sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzMjQzOA==", "bodyText": "Does this class exist by magic or ?", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521932438", "createdAt": "2020-11-12T08:45:16Z", "author": {"login": "pleku"}, "path": "flow-polymer-template/src/test/java/com/vaadin/flow/component/PolymerClassesSerializableTest.java", "diffHunk": "@@ -18,7 +18,8 @@\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.TemplateParser(\\\\$.*)?\",\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.InjectablePolymerElementInitializer\",\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.TemplateDataAnalyzer\",\n-                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.IdCollector\"),\n+                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.IdCollector\",\n+                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.rpc\\\\.OSGiPolymerPublishedEventHandlerRegistration\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyMjQxNg==", "bodyText": "This class has been removed at some point.\nSo now it's not needed.\nJust a leftover, thanks.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522122416", "createdAt": "2020-11-12T13:55:26Z", "author": {"login": "denis-anisimov"}, "path": "flow-polymer-template/src/test/java/com/vaadin/flow/component/PolymerClassesSerializableTest.java", "diffHunk": "@@ -18,7 +18,8 @@\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.TemplateParser(\\\\$.*)?\",\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.InjectablePolymerElementInitializer\",\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.TemplateDataAnalyzer\",\n-                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.IdCollector\"),\n+                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.IdCollector\",\n+                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.rpc\\\\.OSGiPolymerPublishedEventHandlerRegistration\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzMjQzOA=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MjE1ODMyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwODo0OToxNFrOHxwYUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMjozODowMVrOHx45tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzNDkyOA==", "bodyText": "Can't we just mock the URL and return a new ByteArrayInputStream(statsJson.getBytes()) for mockURL.openStream().\nIt would be better to not do file handling if not explicitly necessary.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521934928", "createdAt": "2020-11-12T08:49:14Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "diffHunk": "@@ -1379,21 +1386,26 @@ public void getBootstrapPage_removesExportScript() throws ServiceException {\n \n     @Test // #7158\n     public void getBootstrapPage_assetChunksIsAnARRAY_bootstrapParsesOk()\n-            throws ServiceException {\n+            throws ServiceException, IOException {\n \n         initUI(testUI);\n \n-        ClassLoader classLoader = Mockito.mock(ClassLoader.class);\n-        service.setClassLoader(classLoader);\n-\n         String statsJson = \"{\\n\" + \" \\\"errors\\\": [],\\n\" + \" \\\"warnings\\\": [],\\n\"\n                 + \" \\\"assetsByChunkName\\\": {\\n\" + \"  \\\"bundle\\\": [\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js\\\",\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js.map\\\"\\n\"\n                 + \"  ],\\n\" + \" }\" + \"}\";\n \n-        Mockito.when(classLoader.getResourceAsStream(Mockito.anyString()))\n-                .thenReturn(new ByteArrayInputStream(statsJson.getBytes()));\n+        File tmpFile = tmpDir.newFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2OTA0MQ==", "bodyText": "Can we mock final classes?\nI thought we can't.\nI will check.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522069041", "createdAt": "2020-11-12T12:28:02Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "diffHunk": "@@ -1379,21 +1386,26 @@ public void getBootstrapPage_removesExportScript() throws ServiceException {\n \n     @Test // #7158\n     public void getBootstrapPage_assetChunksIsAnARRAY_bootstrapParsesOk()\n-            throws ServiceException {\n+            throws ServiceException, IOException {\n \n         initUI(testUI);\n \n-        ClassLoader classLoader = Mockito.mock(ClassLoader.class);\n-        service.setClassLoader(classLoader);\n-\n         String statsJson = \"{\\n\" + \" \\\"errors\\\": [],\\n\" + \" \\\"warnings\\\": [],\\n\"\n                 + \" \\\"assetsByChunkName\\\": {\\n\" + \"  \\\"bundle\\\": [\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js\\\",\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js.map\\\"\\n\"\n                 + \"  ],\\n\" + \" }\" + \"}\";\n \n-        Mockito.when(classLoader.getResourceAsStream(Mockito.anyString()))\n-                .thenReturn(new ByteArrayInputStream(statsJson.getBytes()));\n+        File tmpFile = tmpDir.newFile();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzNDkyOA=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDY2NA==", "bodyText": "final class may not be mocked.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522070664", "createdAt": "2020-11-12T12:30:54Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "diffHunk": "@@ -1379,21 +1386,26 @@ public void getBootstrapPage_removesExportScript() throws ServiceException {\n \n     @Test // #7158\n     public void getBootstrapPage_assetChunksIsAnARRAY_bootstrapParsesOk()\n-            throws ServiceException {\n+            throws ServiceException, IOException {\n \n         initUI(testUI);\n \n-        ClassLoader classLoader = Mockito.mock(ClassLoader.class);\n-        service.setClassLoader(classLoader);\n-\n         String statsJson = \"{\\n\" + \" \\\"errors\\\": [],\\n\" + \" \\\"warnings\\\": [],\\n\"\n                 + \" \\\"assetsByChunkName\\\": {\\n\" + \"  \\\"bundle\\\": [\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js\\\",\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js.map\\\"\\n\"\n                 + \"  ],\\n\" + \" }\" + \"}\";\n \n-        Mockito.when(classLoader.getResourceAsStream(Mockito.anyString()))\n-                .thenReturn(new ByteArrayInputStream(statsJson.getBytes()));\n+        File tmpFile = tmpDir.newFile();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzNDkyOA=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NDU1MQ==", "bodyText": "Right so the other possibility would be to either have a WrapperUrl that is mocked or   mock(URLConnection.class);\ne.g. something like:\nfinal URLConnection mockUrlCon = mock(URLConnection.class);\n\nByteArrayInputStream is = new ByteArrayInputStream(\n        \"<myList></myList>\".getBytes(\"UTF-8\"));\ndoReturn(is).when(mockUrlCon).getInputStream();\n\nURLStreamHandler stubUrlHandler = new URLStreamHandler() {\n    @Override\n     protected URLConnection openConnection(URL u) throws IOException {\n        return mockUrlCon;\n     }            \n};\nURL url = new URL(\"foo\", \"bar\", 99, \"/foobar\", stubUrlHandler);\n\nWhich is in many ways worse... Lets go with the temp file.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522074551", "createdAt": "2020-11-12T12:38:01Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "diffHunk": "@@ -1379,21 +1386,26 @@ public void getBootstrapPage_removesExportScript() throws ServiceException {\n \n     @Test // #7158\n     public void getBootstrapPage_assetChunksIsAnARRAY_bootstrapParsesOk()\n-            throws ServiceException {\n+            throws ServiceException, IOException {\n \n         initUI(testUI);\n \n-        ClassLoader classLoader = Mockito.mock(ClassLoader.class);\n-        service.setClassLoader(classLoader);\n-\n         String statsJson = \"{\\n\" + \" \\\"errors\\\": [],\\n\" + \" \\\"warnings\\\": [],\\n\"\n                 + \" \\\"assetsByChunkName\\\": {\\n\" + \"  \\\"bundle\\\": [\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js\\\",\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js.map\\\"\\n\"\n                 + \"  ],\\n\" + \" }\" + \"}\";\n \n-        Mockito.when(classLoader.getResourceAsStream(Mockito.anyString()))\n-                .thenReturn(new ByteArrayInputStream(statsJson.getBytes()));\n+        File tmpFile = tmpDir.newFile();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzNDkyOA=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MjIyNzI3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwOTowNjozM1rOHxxCyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMjozMTowMVrOHx4qwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0NTgwMw==", "bodyText": "Is the temp file necesary? We could just mock the URL and return an expected path.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521945803", "createdAt": "2020-11-12T09:06:33Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java", "diffHunk": "@@ -464,6 +474,69 @@ public void createInitParameters_readDevModeProperties() throws Exception {\n                 .getProperty(InitParameters.REQUIRE_HOME_NODE_EXECUTABLE));\n     }\n \n+    @Test\n+    public void createInitParameters_readTokenFileFromContext()\n+            throws VaadinConfigurationException, IOException {\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        VaadinConfig config = Mockito.mock(VaadinConfig.class);\n+\n+        ResourceProvider resourceProvider = mockResourceProvider(config,\n+                context);\n+\n+        DeploymentConfigurationFactory.createInitParameters(\n+                DeploymentConfigurationFactoryTest.class, config);\n+\n+        Mockito.verify(resourceProvider).getApplicationResources(\n+                DeploymentConfigurationFactoryTest.class,\n+                VAADIN_SERVLET_RESOURCES + TOKEN_FILE);\n+        Mockito.verify(resourceProvider).getApplicationResources(context,\n+                VAADIN_SERVLET_RESOURCES + TOKEN_FILE);\n+    }\n+\n+    @Test\n+    public void createInitParameters_checkWebpackGeneratedFromContext()\n+            throws VaadinConfigurationException, IOException {\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        VaadinConfig config = Mockito.mock(VaadinConfig.class);\n+\n+        ResourceProvider resourceProvider = mockResourceProvider(config,\n+                context);\n+\n+        String path = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n+\n+        File tmpFile = temporaryFolder.newFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDcyMQ==", "bodyText": "final class may not be mocked.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522070721", "createdAt": "2020-11-12T12:31:01Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java", "diffHunk": "@@ -464,6 +474,69 @@ public void createInitParameters_readDevModeProperties() throws Exception {\n                 .getProperty(InitParameters.REQUIRE_HOME_NODE_EXECUTABLE));\n     }\n \n+    @Test\n+    public void createInitParameters_readTokenFileFromContext()\n+            throws VaadinConfigurationException, IOException {\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        VaadinConfig config = Mockito.mock(VaadinConfig.class);\n+\n+        ResourceProvider resourceProvider = mockResourceProvider(config,\n+                context);\n+\n+        DeploymentConfigurationFactory.createInitParameters(\n+                DeploymentConfigurationFactoryTest.class, config);\n+\n+        Mockito.verify(resourceProvider).getApplicationResources(\n+                DeploymentConfigurationFactoryTest.class,\n+                VAADIN_SERVLET_RESOURCES + TOKEN_FILE);\n+        Mockito.verify(resourceProvider).getApplicationResources(context,\n+                VAADIN_SERVLET_RESOURCES + TOKEN_FILE);\n+    }\n+\n+    @Test\n+    public void createInitParameters_checkWebpackGeneratedFromContext()\n+            throws VaadinConfigurationException, IOException {\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        VaadinConfig config = Mockito.mock(VaadinConfig.class);\n+\n+        ResourceProvider resourceProvider = mockResourceProvider(config,\n+                context);\n+\n+        String path = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n+\n+        File tmpFile = temporaryFolder.newFile();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0NTgwMw=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MjMxMTk4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwOToyNjowNlrOHxx1Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwOToyNjowNlrOHxx1Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk1ODcyMg==", "bodyText": "Drop un-used rule and imports", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521958722", "createdAt": "2020-11-12T09:26:06Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java", "diffHunk": "@@ -41,13 +51,14 @@\n import com.vaadin.flow.server.VaadinServletService;\n import com.vaadin.flow.server.VaadinSession;\n import com.vaadin.flow.server.webcomponent.WebComponentConfigurationRegistry;\n+import com.vaadin.flow.shared.ApplicationConstants;\n import com.vaadin.tests.util.MockDeploymentConfiguration;\n \n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.eq;\n-\n public class WebComponentBootstrapHandlerTest {\n \n+    @Rule\n+    public final TemporaryFolder tmpDir = new TemporaryFolder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MjMyNjU1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwOToyOTozNVrOHxx-Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMjozMToyMVrOHx4riw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk2MTA0Nw==", "bodyText": "This should also be mockable to not need to have the temporary file by returning a mock url that for openStream() returns the stream.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521961047", "createdAt": "2020-11-12T09:29:35Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "diffHunk": "@@ -264,31 +273,89 @@ public void commandToString_commandContainsBaseDir_baseDirIsReplaced() {\n                 wrappedCommand);\n     }\n \n-    private VaadinService setupStatsAssetMocks(String statsFile)\n+    @Test\n+    public void getStatsContent_getStatsFromClassPath_delegateToGetApplicationResource()\n             throws IOException {\n-        String stats = IOUtils.toString(FrontendUtilsTest.class.getClassLoader()\n-                .getResourceAsStream(statsFile), StandardCharsets.UTF_8);\n+        VaadinService service = Mockito.mock(VaadinService.class);\n \n-        return getServiceWithResource(\n-                new ByteArrayInputStream(stats.getBytes()));\n+        ResourceProvider provider = mockResourceProvider(service);\n+\n+        FrontendUtils.getStatsContent(service);\n+\n+        Mockito.verify(provider).getApplicationResource(service, \"foo\");\n     }\n \n-    private VaadinService getServiceWithResource(InputStream stats) {\n+    @Test\n+    public void getStatsAssetsByChunkName_getStatsFromClassPath_delegateToGetApplicationResource()\n+            throws IOException {\n         VaadinService service = Mockito.mock(VaadinService.class);\n-        ClassLoader classLoader = Mockito.mock(ClassLoader.class);\n-        DeploymentConfiguration deploymentConfiguration = Mockito\n+\n+        ResourceProvider provider = mockResourceProvider(service);\n+\n+        FrontendUtils.getStatsAssetsByChunkName(service);\n+\n+        Mockito.verify(provider).getApplicationResource(service, \"foo\");\n+    }\n+\n+    private ResourceProvider mockResourceProvider(VaadinService service) {\n+        DeploymentConfiguration config = Mockito\n                 .mock(DeploymentConfiguration.class);\n \n-        Mockito.when(service.getClassLoader()).thenReturn(classLoader);\n-        Mockito.when(service.getDeploymentConfiguration())\n-                .thenReturn(deploymentConfiguration);\n-        Mockito.when(deploymentConfiguration.getStringProperty(\n-                SERVLET_PARAMETER_STATISTICS_JSON,\n-                VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT))\n-                .thenReturn(VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT);\n-        Mockito.when(classLoader.getResourceAsStream(\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        Lookup lookup = Mockito.mock(Lookup.class);\n+        Mockito.when(context.getAttribute(Lookup.class)).thenReturn(lookup);\n+\n+        ResourceProvider provider = Mockito.mock(ResourceProvider.class);\n+        Mockito.when(lookup.lookup(ResourceProvider.class))\n+                .thenReturn(provider);\n+\n+        Mockito.when(service.getDeploymentConfiguration()).thenReturn(config);\n+        Mockito.when(service.getContext()).thenReturn(context);\n+\n+        Mockito.when(config.isProductionMode()).thenReturn(true);\n+\n+        Mockito.when(config.getStringProperty(SERVLET_PARAMETER_STATISTICS_JSON,\n                 VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT))\n-                .thenReturn(stats);\n+                .thenReturn(\"foo\");\n+        return provider;\n+    }\n+\n+    private VaadinService setupStatsAssetMocks(String statsFile)\n+            throws IOException, ServiceException {\n+        String stats = IOUtils.toString(FrontendUtilsTest.class.getClassLoader()\n+                .getResourceAsStream(statsFile), StandardCharsets.UTF_8);\n+\n+        return getServiceWithResource(stats);\n+    }\n+\n+    private VaadinService getServiceWithResource(String content)\n+            throws ServiceException, IOException {\n+        MockDeploymentConfiguration configuration = new MockDeploymentConfiguration();\n+        configuration.setProductionMode(true);\n+        VaadinService service = new MockVaadinServletService(configuration);\n+        service.init();\n+\n+        VaadinContext context = service.getContext();\n+\n+        Lookup lookup = Mockito.mock(Lookup.class);\n+        context.setAttribute(Lookup.class, lookup);\n+\n+        ResourceProvider provider = Mockito.mock(ResourceProvider.class);\n+\n+        Mockito.when(lookup.lookup(ResourceProvider.class))\n+                .thenReturn(provider);\n+\n+        if (content != null) {\n+            File tmpFile = tmpDir.newFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDkyMw==", "bodyText": "final class may not be mocked.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522070923", "createdAt": "2020-11-12T12:31:21Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "diffHunk": "@@ -264,31 +273,89 @@ public void commandToString_commandContainsBaseDir_baseDirIsReplaced() {\n                 wrappedCommand);\n     }\n \n-    private VaadinService setupStatsAssetMocks(String statsFile)\n+    @Test\n+    public void getStatsContent_getStatsFromClassPath_delegateToGetApplicationResource()\n             throws IOException {\n-        String stats = IOUtils.toString(FrontendUtilsTest.class.getClassLoader()\n-                .getResourceAsStream(statsFile), StandardCharsets.UTF_8);\n+        VaadinService service = Mockito.mock(VaadinService.class);\n \n-        return getServiceWithResource(\n-                new ByteArrayInputStream(stats.getBytes()));\n+        ResourceProvider provider = mockResourceProvider(service);\n+\n+        FrontendUtils.getStatsContent(service);\n+\n+        Mockito.verify(provider).getApplicationResource(service, \"foo\");\n     }\n \n-    private VaadinService getServiceWithResource(InputStream stats) {\n+    @Test\n+    public void getStatsAssetsByChunkName_getStatsFromClassPath_delegateToGetApplicationResource()\n+            throws IOException {\n         VaadinService service = Mockito.mock(VaadinService.class);\n-        ClassLoader classLoader = Mockito.mock(ClassLoader.class);\n-        DeploymentConfiguration deploymentConfiguration = Mockito\n+\n+        ResourceProvider provider = mockResourceProvider(service);\n+\n+        FrontendUtils.getStatsAssetsByChunkName(service);\n+\n+        Mockito.verify(provider).getApplicationResource(service, \"foo\");\n+    }\n+\n+    private ResourceProvider mockResourceProvider(VaadinService service) {\n+        DeploymentConfiguration config = Mockito\n                 .mock(DeploymentConfiguration.class);\n \n-        Mockito.when(service.getClassLoader()).thenReturn(classLoader);\n-        Mockito.when(service.getDeploymentConfiguration())\n-                .thenReturn(deploymentConfiguration);\n-        Mockito.when(deploymentConfiguration.getStringProperty(\n-                SERVLET_PARAMETER_STATISTICS_JSON,\n-                VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT))\n-                .thenReturn(VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT);\n-        Mockito.when(classLoader.getResourceAsStream(\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        Lookup lookup = Mockito.mock(Lookup.class);\n+        Mockito.when(context.getAttribute(Lookup.class)).thenReturn(lookup);\n+\n+        ResourceProvider provider = Mockito.mock(ResourceProvider.class);\n+        Mockito.when(lookup.lookup(ResourceProvider.class))\n+                .thenReturn(provider);\n+\n+        Mockito.when(service.getDeploymentConfiguration()).thenReturn(config);\n+        Mockito.when(service.getContext()).thenReturn(context);\n+\n+        Mockito.when(config.isProductionMode()).thenReturn(true);\n+\n+        Mockito.when(config.getStringProperty(SERVLET_PARAMETER_STATISTICS_JSON,\n                 VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT))\n-                .thenReturn(stats);\n+                .thenReturn(\"foo\");\n+        return provider;\n+    }\n+\n+    private VaadinService setupStatsAssetMocks(String statsFile)\n+            throws IOException, ServiceException {\n+        String stats = IOUtils.toString(FrontendUtilsTest.class.getClassLoader()\n+                .getResourceAsStream(statsFile), StandardCharsets.UTF_8);\n+\n+        return getServiceWithResource(stats);\n+    }\n+\n+    private VaadinService getServiceWithResource(String content)\n+            throws ServiceException, IOException {\n+        MockDeploymentConfiguration configuration = new MockDeploymentConfiguration();\n+        configuration.setProductionMode(true);\n+        VaadinService service = new MockVaadinServletService(configuration);\n+        service.init();\n+\n+        VaadinContext context = service.getContext();\n+\n+        Lookup lookup = Mockito.mock(Lookup.class);\n+        context.setAttribute(Lookup.class, lookup);\n+\n+        ResourceProvider provider = Mockito.mock(ResourceProvider.class);\n+\n+        Mockito.when(lookup.lookup(ResourceProvider.class))\n+                .thenReturn(provider);\n+\n+        if (content != null) {\n+            File tmpFile = tmpDir.newFile();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk2MTA0Nw=="}, "originalCommit": {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzA1ODU3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMjozOTozOVrOHx49cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzo1OToyMFrOHx7_VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NTUwNA==", "bodyText": "This is also broken, javax. should be at the top", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522075504", "createdAt": "2020-11-12T12:39:39Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -48,12 +47,18 @@\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n \n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.http.HttpServletResponse;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb8fd24b04e8294e95b16d5648f6652b75e35c15"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNTE0MA==", "bodyText": "I had no flow.importorder  imported in my Eclipse apparently.\nDone.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522125140", "createdAt": "2020-11-12T13:59:20Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -48,12 +47,18 @@\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n \n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.http.HttpServletResponse;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NTUwNA=="}, "originalCommit": {"oid": "cb8fd24b04e8294e95b16d5648f6652b75e35c15"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzA1OTA5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMjozOTo0OFrOHx49wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMjozOTo0OFrOHx49wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NTU4NQ==", "bodyText": "Your import ordering is broken ?\nStatic imports should be last https://sites.google.com/a/vaadin.com/fw-flow-team-s-wiki/contributing-code/code-style/e", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522075585", "createdAt": "2020-11-12T12:39:48Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -16,9 +16,7 @@\n \n package com.vaadin.flow.server;\n \n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.http.HttpServletResponse;\n+import static java.nio.charset.StandardCharsets.UTF_8;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb8fd24b04e8294e95b16d5648f6652b75e35c15"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjgxMzc2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowNDoyNVrOHydZug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowNDoyNVrOHydZug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MjU3MA==", "bodyText": "This still doesn't have the fixed imports after Pekkas comment", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522672570", "createdAt": "2020-11-13T06:04:25Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "diffHunk": "@@ -15,42 +15,47 @@\n  */\n package com.vaadin.flow.server;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f41e3c7c557b504243a21e480c50c046d5693ee5"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjgxOTA5OnYy", "diffSide": "LEFT", "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinSessionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowNzozMFrOHydcsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowNzozMFrOHydcsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MzMyOA==", "bodyText": "The private static class TestServlet can be removed as it's not used anymore.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673328", "createdAt": "2020-11-13T06:07:30Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinSessionTest.java", "diffHunk": "@@ -93,18 +88,15 @@ public Router getRouter() {\n                     return Mockito.mock(Router.class);\n                 }\n             };\n-            service.init();\n             return service;\n         }\n     }\n \n     @Before\n     public void setup() throws Exception {\n         httpSessionLock = new ReentrantLock();\n-        mockServletConfig = new MockServletConfig();\n-        mockServlet = new TestServlet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjgxOTg5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/StreamReceiverHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowODowNVrOHyddJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowODowNVrOHyddJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MzQ0Ng==", "bodyText": "Imports", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673446", "createdAt": "2020-11-13T06:08:05Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/StreamReceiverHandlerTest.java", "diffHunk": "@@ -1,11 +1,9 @@\n package com.vaadin.flow.server.communication;\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjgyMDQyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/StreamRequestHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowODoyN1rOHydddg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowODoyN1rOHydddg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MzUyNg==", "bodyText": "import position", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673526", "createdAt": "2020-11-13T06:08:27Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/StreamRequestHandlerTest.java", "diffHunk": "@@ -1,13 +1,14 @@\n package com.vaadin.flow.server.communication;\n \n-import javax.servlet.ServletConfig;\n+import static com.vaadin.flow.server.communication.StreamRequestHandler.DYN_RES_PREFIX;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjgyMTgyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowOToxNFrOHydeNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowOToxNFrOHydeNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MzcxOA==", "bodyText": "import position", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673718", "createdAt": "2020-11-13T06:09:14Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java", "diffHunk": "@@ -15,6 +15,12 @@\n  */\n package com.vaadin.flow.server.communication;\n \n+import static com.vaadin.flow.server.Constants.STATISTICS_JSON_DEFAULT;\n+import static com.vaadin.flow.server.Constants.VAADIN_SERVLET_RESOURCES;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjgyMjM4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowOToyOVrOHydefA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNjowOToyOVrOHydefA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3Mzc4OA==", "bodyText": "import position", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673788", "createdAt": "2020-11-13T06:09:29Z", "author": {"login": "caalador"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "diffHunk": "@@ -15,11 +15,16 @@\n  */\n package com.vaadin.flow.server.frontend;\n \n-import java.io.ByteArrayInputStream;\n+import static com.vaadin.flow.server.Constants.STATISTICS_JSON_DEFAULT;\n+import static com.vaadin.flow.server.Constants.VAADIN_SERVLET_RESOURCES;\n+import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_STATISTICS_JSON;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzMyOTc2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwODowMDowMVrOHyixgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwODowMDowMVrOHyixgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc2MDU3OA==", "bodyText": "Immediately return this expression instead of assigning it to the temporary variable \"resourceProvider\".", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522760578", "createdAt": "2020-11-13T08:00:01Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,52 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = getResourceProvider(context);\n+            String clientEngine = getClientEngine(resourceProvider);\n+            boolean resolveNow = !productionMode || clientEngine == null;\n             if (resolveNow\n-                    && ClientResourcesUtils.getResource(\"/META-INF/resources/\"\n+                    && resourceProvider.getClientResource(\"/META-INF/resources/\"\n                             + CLIENT_ENGINE_NOCACHE_FILE) != null) {\n                 return context.getUriResolver().resolveVaadinUri(\n                         \"context://\" + CLIENT_ENGINE_NOCACHE_FILE);\n             }\n \n-            if (getClientEngine() == null) {\n+            if (clientEngine == null) {\n                 throw new BootstrapException(\n                         \"Client engine file name has not been resolved during initialization\");\n             }\n             return context.getUriResolver()\n-                    .resolveVaadinUri(\"context://\" + getClientEngine());\n+                    .resolveVaadinUri(\"context://\" + clientEngine);\n+        }\n+\n+        private ResourceProvider getResourceProvider(BootstrapContext context) {\n+            ResourceProvider resourceProvider = context.getSession()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODI2MDk1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjowMjowN1rOHyrvyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTozOTozOVrOH0lGqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwNzU5Mg==", "bodyText": "Even though this code was in the 2.5 version too, I don't recall why is it calling init(this) as the instantiator is created by the factory and the method has been deprecated. Maybe a comment above? The init method javadoc gives the impression that it should be done by the factory", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522907592", "createdAt": "2020-11-13T12:02:07Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                if (instantiator != null && instantiator.init(this)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NTkxNQ==", "bodyText": "I hope you understand that it means my intention is failed: it should have been done for 2.5 and now this change should be back-ported after forwardporting. This is exactly what I've been trying to avoid.\nThis should be done by factory.\nBut the method exists. And if it's implemented we should use it I suppose.\nThough I'm not sure: and as result I consider the comment absolutely useless since both approaches makes sense and the code is written using one or another way.\nBut sure, let's add more comments which nobody reads.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524895915", "createdAt": "2020-11-17T05:39:39Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                if (instantiator != null && instantiator.init(this)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwNzU5Mg=="}, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODI2NzgwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjowNDozM1rOHyrz8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjowNDozM1rOHyrz8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwODY1OA==", "bodyText": "again and still, bad import formatting", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522908658", "createdAt": "2020-11-13T12:04:33Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "diffHunk": "@@ -15,6 +15,12 @@\n  */\n package com.vaadin.flow.server.frontend;\n \n+import static com.vaadin.flow.server.Constants.STATISTICS_JSON_DEFAULT;\n+import static com.vaadin.flow.server.Constants.VAADIN_MAPPING;\n+import static com.vaadin.flow.server.Constants.VAADIN_SERVLET_RESOURCES;\n+import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_STATISTICS_JSON;\n+import static java.lang.String.format;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODMzNjY3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjoyNzo0MFrOHysdFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTo0MToxNFrOH0lIgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxOTE5MA==", "bodyText": "Should the pathInfo be sanitized or is it done by the web container ? So that this doesn't expose a way to traverse contents outside of the static resources directory ? Could not see directly from javadocs if we can expect the container to handle that.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522919190", "createdAt": "2020-11-13T12:27:40Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NjM4NQ==", "bodyText": "And again this code has been already reviewed in 2.5.\nThis is done only for two bundles: flow-client  and flow-push.\nflow-push contains only two resources (and nothing else) and both of them should be exposed.\nflow-client contains client engine compiled files + ts files and map files. Do you see any reason why we should not allow to access any resource in this bundle ?\nDo you suggest add a check for the pathInfo to avoid navigation to parent folders ?\nI would not touch this for now because this should be rewritten via HTTP whiteboard resource registration which should take care about this in a separate PR.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524896385", "createdAt": "2020-11-17T05:41:14Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxOTE5MA=="}, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODM1MTgzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjozMjo0M1rOHysmIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTo0MTozM1rOH0lI1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMTUwNg==", "bodyText": "This is the same code as the below method, just total duplication", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522921506", "createdAt": "2020-11-13T12:32:43Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+        open();\n+    }\n+\n+    /**\n+     * OSGi ServiceComponentRuntime calls this method while unregister the\n+     * Service(e.g when stop/uninstall the bundle)\n+     */\n+    @Deactivate\n+    public void deactivate() {\n+        close();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/client/*\");\n+        servletClientRegistration.compareAndSet(null,\n+                clientBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(clientBundle,\n+                                \"/META-INF/resources/VAADIN/static/client\"),\n+                        properties));\n+    }\n+\n+    private void unregisterClientResource(Bundle clientBundle) {\n+        ServiceRegistration<Servlet> registration = servletClientRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == clientBundle.getBundleId()) {\n+            registration.unregister();\n+            servletClientRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private boolean isPushModule(Bundle bundle) {\n+        return \"com.vaadin.flow.push\".equals(bundle.getSymbolicName());\n+    }\n+\n+    private boolean isClientModule(Bundle bundle) {\n+        return \"com.vaadin.flow.client\".equals(bundle.getSymbolicName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void scanContextInitializers() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        scanClasses(flowServerBundle, map, this::handleFlowServerClassError);\n+        Collection<Class<?>> classes = map.get(flowServerBundle.getBundleId());\n+\n+        Predicate<Class<?>> isInterface = Class::isInterface;\n+\n+        Collection<Class<? extends ServletContainerInitializer>> initializers = classes\n+                .stream()\n+                .filter(ServletContainerInitializer.class::isAssignableFrom)\n+                .filter(isInterface.negate())\n+                .map(clazz -> (Class<? extends ServletContainerInitializer>) clazz)\n+                .collect(Collectors.toList());\n+        OSGiAccess.getInstance().setServletContainerInitializers(initializers);\n+    }\n+\n+    private void scanActivatedBundle(Bundle bundle) {\n+        if (!isActive(bundle) || !isVaadinExtender(bundle)) {\n+            return;\n+        }\n+        if (OSGiAccess.getInstance().hasInitializers()) {\n+            Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+            scanClasses(bundle, map, this::handleBundleClassError);\n+            OSGiAccess.getInstance().addScannedClasses(map);\n+        } else {\n+            executor.execute(() -> scanActivatedBundle(bundle));\n+        }\n+    }\n+\n+    private void scanActiveBundles() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        Stream.of(flowServerBundle.getBundleContext().getBundles())\n+                .filter(this::isActive).filter(this::isVaadinExtender)\n+                .forEach(activeBundle -> scanClasses(activeBundle, map,\n+                        this::handleBundleClassError));\n+        OSGiAccess.getInstance().addScannedClasses(map);\n+    }\n+\n+    private boolean isActive(Bundle bundle) {\n+        return (bundle.getState() & Bundle.ACTIVE) > 0;\n+    }\n+\n+    private boolean isVaadinExtender(Bundle bundle) {\n+        return !flowServerBundle.equals(bundle) && Boolean.TRUE.toString()\n+                .equals(bundle.getHeaders().get(\"Vaadin-OSGi-Extender\"));\n+    }\n+\n+    private void handleFlowServerClassError(String className,\n+            Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .trace(\"Couldn't load class '{}'\", className, throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NjQ3MQ==", "bodyText": "Perhaps, you mean by total duplication  that trace method is totally the same as warn  method.\nBut I think I disagree.\nAnd this code here is for ages : https://github.com/vaadin/flow/blob/2.4/flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java#L137\nhttps://github.com/vaadin/flow/blob/2.4/flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java#L143\nThis is reintroduced code.\nSo you are again reviewing the code in Nth time.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524896471", "createdAt": "2020-11-17T05:41:33Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+        open();\n+    }\n+\n+    /**\n+     * OSGi ServiceComponentRuntime calls this method while unregister the\n+     * Service(e.g when stop/uninstall the bundle)\n+     */\n+    @Deactivate\n+    public void deactivate() {\n+        close();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/client/*\");\n+        servletClientRegistration.compareAndSet(null,\n+                clientBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(clientBundle,\n+                                \"/META-INF/resources/VAADIN/static/client\"),\n+                        properties));\n+    }\n+\n+    private void unregisterClientResource(Bundle clientBundle) {\n+        ServiceRegistration<Servlet> registration = servletClientRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == clientBundle.getBundleId()) {\n+            registration.unregister();\n+            servletClientRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private boolean isPushModule(Bundle bundle) {\n+        return \"com.vaadin.flow.push\".equals(bundle.getSymbolicName());\n+    }\n+\n+    private boolean isClientModule(Bundle bundle) {\n+        return \"com.vaadin.flow.client\".equals(bundle.getSymbolicName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void scanContextInitializers() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        scanClasses(flowServerBundle, map, this::handleFlowServerClassError);\n+        Collection<Class<?>> classes = map.get(flowServerBundle.getBundleId());\n+\n+        Predicate<Class<?>> isInterface = Class::isInterface;\n+\n+        Collection<Class<? extends ServletContainerInitializer>> initializers = classes\n+                .stream()\n+                .filter(ServletContainerInitializer.class::isAssignableFrom)\n+                .filter(isInterface.negate())\n+                .map(clazz -> (Class<? extends ServletContainerInitializer>) clazz)\n+                .collect(Collectors.toList());\n+        OSGiAccess.getInstance().setServletContainerInitializers(initializers);\n+    }\n+\n+    private void scanActivatedBundle(Bundle bundle) {\n+        if (!isActive(bundle) || !isVaadinExtender(bundle)) {\n+            return;\n+        }\n+        if (OSGiAccess.getInstance().hasInitializers()) {\n+            Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+            scanClasses(bundle, map, this::handleBundleClassError);\n+            OSGiAccess.getInstance().addScannedClasses(map);\n+        } else {\n+            executor.execute(() -> scanActivatedBundle(bundle));\n+        }\n+    }\n+\n+    private void scanActiveBundles() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        Stream.of(flowServerBundle.getBundleContext().getBundles())\n+                .filter(this::isActive).filter(this::isVaadinExtender)\n+                .forEach(activeBundle -> scanClasses(activeBundle, map,\n+                        this::handleBundleClassError));\n+        OSGiAccess.getInstance().addScannedClasses(map);\n+    }\n+\n+    private boolean isActive(Bundle bundle) {\n+        return (bundle.getState() & Bundle.ACTIVE) > 0;\n+    }\n+\n+    private boolean isVaadinExtender(Bundle bundle) {\n+        return !flowServerBundle.equals(bundle) && Boolean.TRUE.toString()\n+                .equals(bundle.getHeaders().get(\"Vaadin-OSGi-Extender\"));\n+    }\n+\n+    private void handleFlowServerClassError(String className,\n+            Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .trace(\"Couldn't load class '{}'\", className, throwable);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMTUwNg=="}, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODM1NDg0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjozMzo1N1rOHysoLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTo0MjowMlrOH0lJeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMjAzMA==", "bodyText": "Should this and all other occurrences of getUrl() be updated to use getTemplate() instead ? Just to not add more technical debt ? Or if we intend to make the osgi specific registry will go away then not necessary.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522922030", "createdAt": "2020-11-13T12:33:57Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NjYzMg==", "bodyText": "This is reintroduced code.\nI would suggest to avoid (re-)reviewing the code which is not new but has been removed and then added back overall.\nThis is exactly the reason why I've not done any change : to keep the code the same as in 2.5.\nBut one more reason do not touch this: it will be completely removed once OSGi code moved to osgi repo.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524896632", "createdAt": "2020-11-17T05:42:02Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMjAzMA=="}, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTU3Njk2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxMzo0OVrOHzutOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTo0MjowOFrOH0lJnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwNDY2NQ==", "bodyText": "Again, adding back deprecated code is not that nice ... but OK for now if we address it soon anyway", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524004665", "createdAt": "2020-11-16T09:13:49Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -67,6 +231,25 @@ protected ApplicationRouteRegistry() {\n                 .forEach(routeFilters::add);\n     }\n \n+    /**\n+     * Gets the route registry for the given servlet context. If the servlet\n+     * context has no route registry, a new instance is created and assigned to\n+     * the context.\n+     *\n+     * @param context\n+     *            the vaadin context for which to get a route registry, not\n+     *            <code>null</code>\n+     * @return a registry instance for the given servlet context, not\n+     *         <code>null</code>\n+     * @deprecated this is deprecated in favor of\n+     *             {@code getInstance(VaadinContext)} and will be removed in a\n+     *             future release\n+     */\n+    @Deprecated\n+    public static ApplicationRouteRegistry getInstance(ServletContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NjY3MQ==", "bodyText": "This is actually done by accident.\nCode is reintroduced from 2.5 but now this method is not used internally and indeed should be removed.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524896671", "createdAt": "2020-11-17T05:42:08Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -67,6 +231,25 @@ protected ApplicationRouteRegistry() {\n                 .forEach(routeFilters::add);\n     }\n \n+    /**\n+     * Gets the route registry for the given servlet context. If the servlet\n+     * context has no route registry, a new instance is created and assigned to\n+     * the context.\n+     *\n+     * @param context\n+     *            the vaadin context for which to get a route registry, not\n+     *            <code>null</code>\n+     * @return a registry instance for the given servlet context, not\n+     *         <code>null</code>\n+     * @deprecated this is deprecated in favor of\n+     *             {@code getInstance(VaadinContext)} and will be removed in a\n+     *             future release\n+     */\n+    @Deprecated\n+    public static ApplicationRouteRegistry getInstance(ServletContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwNDY2NQ=="}, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTU5NDYwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxNjoyNlrOHzu43g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxNjoyNlrOHzu43g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwNzY0Ng==", "bodyText": "Wrong import order", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524007646", "createdAt": "2020-11-16T09:16:26Z", "author": {"login": "pleku"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -15,15 +15,18 @@\n  */\n package com.vaadin.flow.server.startup;\n \n-import javax.servlet.ServletContainerInitializer;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.Set;\n import java.util.stream.Stream;\n \n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTc2MDY2OnYy", "diffSide": "LEFT", "path": "flow-tests/test-root-context/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0MDo0NVrOHzwkdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjowNDoyNVrOH0ljmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNTE4OQ==", "bodyText": "Uh, shouldn't this still be applied for the module not to be released/deployed with Flow ?\nI understand that it is needed for snapshots due to being reused in tests, but probably not for named releases ? And thus this configuration should be still done for a release profile ?", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524035189", "createdAt": "2020-11-16T09:40:45Z", "author": {"login": "pleku"}, "path": "flow-tests/test-root-context/pom.xml", "diffHunk": "@@ -11,9 +11,6 @@\n     <artifactId>flow-test-root-context-npm</artifactId>\n     <name>Flow root context tests in NPM dev mode</name>\n     <packaging>war</packaging>\n-    <properties>\n-        <maven.deploy.skip>true</maven.deploy.skip>\n-    </properties>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwMzMyMw==", "bodyText": "It's hard to answer to the questions which are not related to the code at all without testing this.\nAnd I'm not able to test this because this PR is under review for several weeks.\nYes, the module should be deployed as a snapshot. And yes, it should not be deployed for a regular release.\nI'be been trying to prevent deploying it for the regular release via config options in the build jobs.\nBut looks like it was wrong. At least it turns out the SNAPSHOT doesn't even use release profile.\nI made one more profile snapshot and the module test-root-context is not anymore in release profile which should prevent releasing it.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524903323", "createdAt": "2020-11-17T06:04:25Z", "author": {"login": "denis-anisimov"}, "path": "flow-tests/test-root-context/pom.xml", "diffHunk": "@@ -11,9 +11,6 @@\n     <artifactId>flow-test-root-context-npm</artifactId>\n     <name>Flow root context tests in NPM dev mode</name>\n     <packaging>war</packaging>\n-    <properties>\n-        <maven.deploy.skip>true</maven.deploy.skip>\n-    </properties>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNTE4OQ=="}, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTc2NzY2OnYy", "diffSide": "RIGHT", "path": "flow-tests/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0MTo1NVrOHzwo4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjowNzozMFrOH0lnTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNjMyMw==", "bodyText": "I don't think we should release these modules other than for snapshots. Is it so ?", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524036323", "createdAt": "2020-11-16T09:41:55Z", "author": {"login": "pleku"}, "path": "flow-tests/pom.xml", "diffHunk": "@@ -280,6 +310,7 @@\n             <id>release</id>\n             <modules>\n                 <module>test-mixed/pom-pnpm-production.xml</module>\n+                <module>test-root-context</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNDI2OQ==", "bodyText": "Moved to a dedicated profile.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524904269", "createdAt": "2020-11-17T06:07:30Z", "author": {"login": "denis-anisimov"}, "path": "flow-tests/pom.xml", "diffHunk": "@@ -280,6 +310,7 @@\n             <id>release</id>\n             <modules>\n                 <module>test-mixed/pom-pnpm-production.xml</module>\n+                <module>test-root-context</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNjMyMw=="}, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTc3NzYzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/startup/VaadinAppShellInitializerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0MzoyMFrOHzwvMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0MzoyMFrOHzwvMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNzkzOQ==", "bodyText": "Wrong import ordering", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524037939", "createdAt": "2020-11-16T09:43:20Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/startup/VaadinAppShellInitializerTest.java", "diffHunk": "@@ -15,6 +17,11 @@\n import java.util.Set;\n import java.util.concurrent.ConcurrentMap;\n \n+import javax.annotation.concurrent.NotThreadSafe;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServletRequest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTc3OTgwOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/startup/ServletDeployerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0MzozN1rOHzwwjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0MzozN1rOHzwwjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzODI4Ng==", "bodyText": "Wrong import ordering", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524038286", "createdAt": "2020-11-16T09:43:37Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/startup/ServletDeployerTest.java", "diffHunk": "@@ -1,13 +1,17 @@\n package com.vaadin.flow.server.startup;\n \n-import javax.servlet.Registration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextEvent;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static org.easymock.EasyMock.anyBoolean;\n+import static org.easymock.EasyMock.anyObject;\n+import static org.easymock.EasyMock.anyString;\n+import static org.easymock.EasyMock.capture;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.newCapture;\n+import static org.easymock.EasyMock.replay;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTc5NTMzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/component/UITest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0NTo0N1rOHzw6Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0NTo0N1rOHzw6Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MDc3OA==", "bodyText": "Wrong import ordering", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524040778", "createdAt": "2020-11-16T09:45:47Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/component/UITest.java", "diffHunk": "@@ -1,7 +1,10 @@\n package com.vaadin.flow.component;\n \n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletException;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgwOTA5OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerDependenciesTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0Nzo1OFrOHzxDCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0Nzo1OFrOHzxDCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MzAxOQ==", "bodyText": "Wrong import ordering", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524043019", "createdAt": "2020-11-16T09:47:58Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerDependenciesTest.java", "diffHunk": "@@ -1,16 +1,28 @@\n package com.vaadin.flow.server;\n \n-import javax.servlet.http.HttpServletRequest;\n+import static org.hamcrest.CoreMatchers.both;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.either;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgxMTEyOnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerPushConfigurationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODoxOFrOHzxEYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODoxOFrOHzxEYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MzM2Mw==", "bodyText": "Wrong import ordering", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524043363", "createdAt": "2020-11-16T09:48:18Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerPushConfigurationTest.java", "diffHunk": "@@ -1,13 +1,19 @@\n package com.vaadin.flow.server;\n \n-import javax.servlet.http.HttpServletRequest;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgxMzE3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODozNFrOHzxFzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODozNFrOHzxFzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MzcyNg==", "bodyText": "Wrong import ordering", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524043726", "createdAt": "2020-11-16T09:48:34Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "diffHunk": "@@ -1,8 +1,12 @@\n package com.vaadin.flow.server;\n \n-import javax.servlet.http.HttpServletRequest;\n+import static com.vaadin.flow.server.Constants.VAADIN_MAPPING;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgxNDc1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODo1MFrOHzxG8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODo1MFrOHzxG8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NDAxOA==", "bodyText": "Wrong import ordering", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524044018", "createdAt": "2020-11-16T09:48:50Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java", "diffHunk": "@@ -1,14 +1,29 @@\n package com.vaadin.flow.server;\n \n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletContext;\n+import static com.vaadin.flow.server.Constants.VAADIN_SERVLET_RESOURCES;\n+import static com.vaadin.flow.server.DeploymentConfigurationFactory.DEV_FOLDER_MISSING_MESSAGE;\n+import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_PRODUCTION_MODE;\n+import static com.vaadin.flow.server.frontend.FrontendUtils.PARAM_TOKEN_FILE;\n+import static com.vaadin.flow.server.frontend.FrontendUtils.TOKEN_FILE;\n+import static java.util.Collections.emptyMap;\n+import static org.easymock.EasyMock.anyObject;\n+import static org.easymock.EasyMock.capture;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.replay;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgyMTA4OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/I18NProviderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0OTo0MVrOHzxK1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0OTo0MVrOHzxK1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NTAxNA==", "bodyText": "Wrong import ordering", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524045014", "createdAt": "2020-11-16T09:49:41Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/I18NProviderTest.java", "diffHunk": "@@ -15,32 +15,36 @@\n  */\n package com.vaadin.flow.server;\n \n-import javax.servlet.ServletConfig;\n+import java.util.Locale;\n+import java.util.concurrent.locks.ReentrantLock;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442ad42b4470fe7f28f34e70977830cbff288181"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTk0MjA3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDoxMTo1MlrOH0tnKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMTo0ODowOFrOH0xMVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNTMwNA==", "bodyText": "Why was this test removed ?", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r525035304", "createdAt": "2020-11-17T10:11:52Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "diffHunk": "@@ -111,8 +117,8 @@ public void should_reported_routing_hybrid() {\n                 e -> Constants.STATISTIC_ROUTING_SERVER.equals(e.getName())));\n     }\n \n-    @Test\n-    public void testFireSessionDestroy() throws ServletException {\n+    public void testFireSessionDestroy()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7d9cc8d82db0dfc3363a3f900dd5066f4f0d90"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5Mzk3NA==", "bodyText": "Good question.\nNo idea. Perhaps merge conflict consequence.\nReturned back.", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r525093974", "createdAt": "2020-11-17T11:48:08Z", "author": {"login": "denis-anisimov"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "diffHunk": "@@ -111,8 +117,8 @@ public void should_reported_routing_hybrid() {\n                 e -> Constants.STATISTIC_ROUTING_SERVER.equals(e.getName())));\n     }\n \n-    @Test\n-    public void testFireSessionDestroy() throws ServletException {\n+    public void testFireSessionDestroy()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNTMwNA=="}, "originalCommit": {"oid": "cb7d9cc8d82db0dfc3363a3f900dd5066f4f0d90"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjcxOTY5OnYy", "diffSide": "LEFT", "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzozNTozN1rOH01AvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzozNTozN1rOH01AvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1NjU0MA==", "bodyText": "How is it that your imports are again going to the wrong location and causing unnecessary changes ?", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r525156540", "createdAt": "2020-11-17T13:35:37Z", "author": {"login": "pleku"}, "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "diffHunk": "@@ -47,10 +51,6 @@\n import com.vaadin.flow.server.communication.StreamRequestHandler;\n import com.vaadin.tests.util.MockDeploymentConfiguration;\n \n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.junit.Assert.assertEquals;\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977e7f5fa39eda38e2c953fcbe6f8cfd4d14b55f"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3000, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}