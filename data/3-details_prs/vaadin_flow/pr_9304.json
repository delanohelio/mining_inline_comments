{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NzU2MTI1", "number": 9304, "title": "deferred call submission status API refactor", "bodyText": "Fixes #9243. After this commit, a user is able to notify the deferred call submission status via\nclient.deferredCallHandler = {\n  async handleDeferredCallSubmission(deferredCallSubmitter: DeferredCallSubmitter){\n    try{\n      await deferredCallSubmitter.submit();\n      console.log('submission succeeded');\n    }catch(error){\n      console.log('submission failed');\n      deferredCallSubmitter.keepDeferredCallInTheQueue();\n    }\n  }\n}\n\nChanges:\n\nuse a deferredCallSubmissionHandler class instead of a callback function, so that a user won't mistakenly calling the callback function directly instead of defining one\ninstead of relying on re-throwing error to keep the deferred request in the queue, now it uses deferredCallSubmitter.keepDeferredCallInTheQueue();\nrenamed EndpointRequest to DeferredCall\ncreated a common interface EndpointCallMetaInfo for holding the meta info of an endpoint call. Both MiddlewareContext and DeferredCall extend from it.\nsplit offline related code to a separate Offline.ts file", "createdAt": "2020-11-03T14:04:12Z", "url": "https://github.com/vaadin/flow/pull/9304", "merged": true, "mergeCommit": {"oid": "ea104a67ba54e9483a4f4d2c8cd6258de003e73c"}, "closed": true, "closedAt": "2020-11-04T13:35:41Z", "author": {"login": "haijian-vaadin"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWSpocAH2gAyNTE0NzU2MTI1OjM3MjdiNDhhOTM1MmJkNzk2NTkxNGZmYzZhNjZhMjFmOTM5Yzg5NmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZN1ZhAFqTUyMzM2MTY2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3727b48a9352bd7965914ffc6a66a21f939c896c", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/3727b48a9352bd7965914ffc6a66a21f939c896c", "committedDate": "2020-10-26T11:27:20Z", "message": "a dummy test to check if bender works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fc92155af2eec32a79e05a569df0482f961364e", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/3fc92155af2eec32a79e05a569df0482f961364e", "committedDate": "2020-10-26T11:29:25Z", "message": "more change to trigger snapshot build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74ec75925361a5834752f7fcf3b6d6870ebc19df", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/74ec75925361a5834752f7fcf3b6d6870ebc19df", "committedDate": "2020-10-26T14:08:45Z", "message": "use an interface instead of a callback function for handling deferred calls."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "280200774467585edea8fcce127c63acb012d05d", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/280200774467585edea8fcce127c63acb012d05d", "committedDate": "2020-10-27T09:25:49Z", "message": "feat: use command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b923726688a65826740911a8296a04055f1478d", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/2b923726688a65826740911a8296a04055f1478d", "committedDate": "2020-10-27T10:37:00Z", "message": "use a DeferedCall class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7387c3c48f6e0cbbf3d075c7a9575c4c6804a91", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/d7387c3c48f6e0cbbf3d075c7a9575c4c6804a91", "committedDate": "2020-10-29T12:14:35Z", "message": "Merge branch 'feature/offline' into deferred-call-refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62de8097b5fcc615e063e2f2b251efe4098d64fe", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/62de8097b5fcc615e063e2f2b251efe4098d64fe", "committedDate": "2020-10-30T20:17:55Z", "message": "split offline related to a separate file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f98b5f478a9735275e754ab81d80361d1a96813", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/1f98b5f478a9735275e754ab81d80361d1a96813", "committedDate": "2020-11-02T21:41:44Z", "message": "add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d20bad7128fcdabc2dd7081a79ce3b8059174159", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/d20bad7128fcdabc2dd7081a79ce3b8059174159", "committedDate": "2020-11-03T09:47:47Z", "message": "refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03a3d6631f71e5b237b5a6dccfb25dc0cb6ea436", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/03a3d6631f71e5b237b5a6dccfb25dc0cb6ea436", "committedDate": "2020-11-03T09:48:38Z", "message": "export Offline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "776daba238494b2ae485cfa2d3aa26f3a1feeeee", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/776daba238494b2ae485cfa2d3aa26f3a1feeeee", "committedDate": "2020-11-03T10:00:18Z", "message": "renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a97a37d6c5e62905f5cf10e4395dbb539ef580c", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/8a97a37d6c5e62905f5cf10e4395dbb539ef580c", "committedDate": "2020-11-03T10:35:50Z", "message": "rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ba57e7eead3c475db04b104f27ae0ed591a46ef", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/3ba57e7eead3c475db04b104f27ae0ed591a46ef", "committedDate": "2020-11-03T11:04:35Z", "message": "more renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc4ec3029fc0a35c78803f638d7e84ee71d74aac", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/bc4ec3029fc0a35c78803f638d7e84ee71d74aac", "committedDate": "2020-11-03T13:51:29Z", "message": "Merge remote-tracking branch 'origin/feature/offline' into deferred-call-refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/c88146ad8ffc137d73cf70b99e21262a26f3bc15", "committedDate": "2020-11-03T14:07:23Z", "message": "code format"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMTkzNTU2", "url": "https://github.com/vaadin/flow/pull/9304#pullrequestreview-523193556", "createdAt": "2020-11-04T09:45:10Z", "commit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0NToxMFrOHtQXwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDo0MTo1NFrOHtSiJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjE5NA==", "bodyText": "Typo (deferrecCall), should be deferrableCall or omitted", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517216194", "createdAt": "2020-11-04T09:45:10Z", "author": {"login": "joheriks"}, "path": "flow-client/src/test/frontend/OfflineTests.ts", "diffHunk": "@@ -0,0 +1,532 @@\n+/* tslint:disable: no-unused-expression */\n+const { describe, it, beforeEach, afterEach, after } = intern.getPlugin('interface.bdd');\n+const { expect } = intern.getPlugin('chai');\n+const { fetchMock } = intern.getPlugin('fetchMock');\n+const { sinon } = intern.getPlugin('sinon');\n+\n+import {\n+  ConnectClient,\n+} from \"../../main/resources/META-INF/resources/frontend/Connect\";\n+\n+import { openDB } from \"idb\";\n+import { DeferredCallSubmitter, OfflineHelper } from \"../../main/resources/META-INF/resources/frontend/Offline\";\n+\n+const VAADIN_DEFERRED_CALL_QUEUE_DB_NAME = 'vaadin-deferred-call-queue';\n+const VAADIN_DEFERRED_CALL_STORE_NAME = 'deferredCalls';\n+\n+// `connectClient.call` adds the host and context to the endpoint request.\n+// we need to add this origin when configuring fetch-mock\n+const base = window.location.origin;\n+const offline = new OfflineHelper();\n+describe(\"Offline\", () => {\n+  beforeEach(() => localStorage.clear());\n+\n+  after(() => {\n+    // @ts-ignore\n+    delete window.Vaadin;\n+  });\n+\n+  describe(\"Defer Request\", () => {\n+    let client: ConnectClient;\n+\n+    beforeEach(() => {\n+      client = new ConnectClient();\n+    });\n+\n+    afterEach(() => {\n+      sinon.restore();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"Should return a DeferrableResult that retains request meta when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\").callsFake((deferredCall: any) => {\n+        if (!deferredCall.id) {\n+          deferredCall.id = 100;\n+        }\n+        return { isDeferred: true, deferredCall };\n+      });\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.true;\n+      expect(result.deferredCall?.endpoint).to.equal('FooEndpoint');\n+      expect(result.deferredCall?.method).to.equal('fooMethod');\n+      expect(result.deferredCall?.params?.fooData).to.equal('foo');\n+    })\n+\n+    it(\"Should cache the endpoint call when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+      const cachedRequest = await db.get(VAADIN_DEFERRED_CALL_STORE_NAME, result.deferredCall?.id as number);\n+\n+      expect(cachedRequest.endpoint).to.equal('FooEndpoint');\n+      expect(cachedRequest.method).to.equal('fooMethod');\n+      expect(cachedRequest.params?.fooData).to.equal('foo');\n+\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+    })\n+\n+    it(\"Should not invoke the client.call method when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.false;\n+    })\n+\n+    it(\"Should invoke the client.call method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.true;\n+    })\n+\n+    it(\"Should not invoke the client.storeDeferredCall method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      const storeDeferredCallMock = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(storeDeferredCallMock.called).to.be.false;\n+    })\n+\n+    it(\"should return false when checking the isDefered prooperty of the return value of invoking deferRequest method online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.false;\n+    })\n+\n+    it(\"should return undefined when checking the endpointRequest prooperty of the return value of invoking deferRequest method offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const returnValue = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(returnValue.deferredCall).to.be.undefined;\n+    })\n+\n+    it(\"should defer endpoint call when server is not reachable even though browser is online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const storeDeferredCall = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      fetchMock.post(\n+        base + '/connect/FooEndpoint/fooMethod',\n+        Promise.reject(new TypeError('Failed to fetch'))\n+      )\n+  \n+      await client.deferrableCall('FooEndpoint', 'fooMethod');\n+  \n+      expect(storeDeferredCall.called).to.be.true;\n+    })\n+  \n+    it(\"should NOT defer endpoint call when server return error\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      const body = 'Unexpected error';\n+      const errorResponse = new Response(\n+        body,\n+        {\n+          status: 500,\n+          statusText: 'Internal Server Error'\n+        }\n+      );\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', errorResponse);\n+  \n+      try {\n+        await client.deferrableCall('FooEndpoint', 'fooMethod');\n+      } catch (error) {\n+        expect(error).to.be.instanceOf(Error)\n+          .and.have.property('message').that.has.string('Unexpected error');\n+      }\n+    })\n+  });\n+\n+  describe(\"submit deferred calls\", () => {\n+    let client: ConnectClient;\n+    let requestCallStub: any;\n+\n+    function fakeRequestCallFails() {\n+      requestCallStub.callsFake(() => {\n+        throw new Error();\n+      });\n+    }\n+\n+    async function insertARequest(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      for (let i = 0; i < numberOfRequests; i++) {\n+        await db.put(VAADIN_DEFERRED_CALL_STORE_NAME, { endpoint: 'FooEndpoint', method: 'fooMethod', params: { fooData: 'foo' } });\n+      }\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    async function verifyNumberOfRequsetsInTheQueue(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    beforeEach(async () => {\n+      client = new ConnectClient();\n+      requestCallStub = sinon.stub(client, 'requestCall').callsFake(async () => {\n+        await new Promise(resolve => setTimeout(resolve, 10))\n+      });\n+    });\n+\n+    afterEach(async () => {\n+      const db = await (offline as any).openOrCreateDB();\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"should check and submit the cached requests when receiving online event\", () => {\n+      const submitMethod = sinon.stub(ConnectClient.prototype, \"submitDeferredCalls\");\n+      client = new ConnectClient();\n+      self.dispatchEvent(new Event('online'));\n+      expect(submitMethod.called).to.be.true;\n+      submitMethod.restore();\n+    })\n+\n+    it(\"should submit the cached request when receiving online event\", async () => {\n+      await insertARequest(3);\n+\n+      await client.submitDeferredCalls();\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    })\n+\n+    it(\"should keep the request if submission fails\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should reject if submission fails', async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      }\n+\n+      expect(errors?.length).to.equal(1);\n+    });\n+\n+    it(\"should be able to resubmit cached request that was failed to submit\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await client.submitDeferredCalls();\n+\n+        await verifyNumberOfRequsetsInTheQueue(0);\n+      }\n+    });\n+\n+    it(\"should only submit once when receiving multiple online events\", async () => {\n+      await insertARequest();\n+\n+      await Promise.all([\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls()\n+      ])\n+\n+      expect(requestCallStub.calledOnce).to.be.true;\n+    })\n+\n+    it(\"should only submit once when receiving multiple online events after a failed submission\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await Promise.all([\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls()\n+        ])\n+\n+        expect(requestCallStub.calledOnce).to.be.true;\n+      }\n+    });\n+\n+    it('should invoke middleware with isDeferred context', async () => {\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', { fooData: 'foo' });\n+\n+      requestCallStub.restore();\n+\n+      const spyMiddleware = sinon.spy(async (context: any, next?: any) => {\n+        expect(context.endpoint).to.equal('FooEndpoint');\n+        expect(context.method).to.equal('fooMethod');\n+        expect(context.params).to.deep.equal({ fooData: 'foo' });\n+        expect(context.request).to.be.instanceOf(Request);\n+        expect(context.isDeferred).to.be.true;\n+        return next(context);\n+      });\n+      client.middlewares = [spyMiddleware];\n+\n+      try {\n+        await insertARequest();\n+\n+        expect(spyMiddleware.called).to.be.false;\n+\n+        await client.submitDeferredCalls();\n+\n+        expect(spyMiddleware.called).to.be.true;\n+      } finally {\n+        fetchMock.restore();\n+      }\n+    });\n+\n+    it('should invoke deferredCallHandler', async () => {\n+      await insertARequest();\n+\n+      const onDeferredCallStub = sinon.stub().resolves();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      await client.submitDeferredCalls();\n+\n+      expect(onDeferredCallStub.callCount).to.equal(1);\n+      const [call] = onDeferredCallStub.getCall(0).args;\n+      expect(call.deferredCall.endpoint).to.equal('FooEndpoint');\n+      expect(call.deferredCall.method).to.equal('fooMethod');\n+      expect(call.deferredCall.params).to.deep.equal({ fooData: 'foo' });\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    });\n+\n+    it('should reject if onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      } finally {\n+        expect(errors?.length).to.equal(1);\n+      }\n+    });\n+\n+    it('should keep request in the queue when onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };;\n+  \n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch(_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should set submitting status to false for all the request in the queue', async () => {\n+      try {\n+        await insertARequest(2);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        verifyNumberOfRequsetsInTheQueue(2)\n+        const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+        let cursor = await db.transaction(VAADIN_DEFERRED_CALL_STORE_NAME).store.openCursor();\n+        while (cursor) {\n+          expect(cursor.value.submitting).to.be.false;\n+          cursor = await cursor.continue();\n+        }\n+        await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+        db.close;\n+      }\n+    });\n+\n+    it('should submit all the endpoint calls in the queue even errors are encountered when submitting some calls', async () => {\n+      try {\n+        await insertARequest(3);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        expect(requestCallStub.callCount).to.equal(3);\n+        verifyNumberOfRequsetsInTheQueue(3)\n+      }\n+    });\n+\n+    describe('deferred call handler', () => {\n+      it('should be able to show a notification when a deferred call submission succeeds', async () => {\n+        const notifyOnSucess = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+            notifyOnSucess();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnSucess.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should be able to show a notification when deferred call submission fails', async () => {\n+        const notifyOnFailure = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              notifyOnFailure();\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails()\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnFailure.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should remove a succeeded endpoint call from the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint in the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } catch (_) {\n+          // expected\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(1);\n+        }\n+      });\n+\n+      it('should remove a failed endpoint call from the queue when user catches the error without calling deferrecCall.keepInTheQueue()', async () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 490}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjI2Nw==", "bodyText": "Typo (deferrecCall), should be deferrableCall or omitted.", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517216267", "createdAt": "2020-11-04T09:45:17Z", "author": {"login": "joheriks"}, "path": "flow-client/src/test/frontend/OfflineTests.ts", "diffHunk": "@@ -0,0 +1,532 @@\n+/* tslint:disable: no-unused-expression */\n+const { describe, it, beforeEach, afterEach, after } = intern.getPlugin('interface.bdd');\n+const { expect } = intern.getPlugin('chai');\n+const { fetchMock } = intern.getPlugin('fetchMock');\n+const { sinon } = intern.getPlugin('sinon');\n+\n+import {\n+  ConnectClient,\n+} from \"../../main/resources/META-INF/resources/frontend/Connect\";\n+\n+import { openDB } from \"idb\";\n+import { DeferredCallSubmitter, OfflineHelper } from \"../../main/resources/META-INF/resources/frontend/Offline\";\n+\n+const VAADIN_DEFERRED_CALL_QUEUE_DB_NAME = 'vaadin-deferred-call-queue';\n+const VAADIN_DEFERRED_CALL_STORE_NAME = 'deferredCalls';\n+\n+// `connectClient.call` adds the host and context to the endpoint request.\n+// we need to add this origin when configuring fetch-mock\n+const base = window.location.origin;\n+const offline = new OfflineHelper();\n+describe(\"Offline\", () => {\n+  beforeEach(() => localStorage.clear());\n+\n+  after(() => {\n+    // @ts-ignore\n+    delete window.Vaadin;\n+  });\n+\n+  describe(\"Defer Request\", () => {\n+    let client: ConnectClient;\n+\n+    beforeEach(() => {\n+      client = new ConnectClient();\n+    });\n+\n+    afterEach(() => {\n+      sinon.restore();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"Should return a DeferrableResult that retains request meta when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\").callsFake((deferredCall: any) => {\n+        if (!deferredCall.id) {\n+          deferredCall.id = 100;\n+        }\n+        return { isDeferred: true, deferredCall };\n+      });\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.true;\n+      expect(result.deferredCall?.endpoint).to.equal('FooEndpoint');\n+      expect(result.deferredCall?.method).to.equal('fooMethod');\n+      expect(result.deferredCall?.params?.fooData).to.equal('foo');\n+    })\n+\n+    it(\"Should cache the endpoint call when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+      const cachedRequest = await db.get(VAADIN_DEFERRED_CALL_STORE_NAME, result.deferredCall?.id as number);\n+\n+      expect(cachedRequest.endpoint).to.equal('FooEndpoint');\n+      expect(cachedRequest.method).to.equal('fooMethod');\n+      expect(cachedRequest.params?.fooData).to.equal('foo');\n+\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+    })\n+\n+    it(\"Should not invoke the client.call method when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.false;\n+    })\n+\n+    it(\"Should invoke the client.call method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.true;\n+    })\n+\n+    it(\"Should not invoke the client.storeDeferredCall method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      const storeDeferredCallMock = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(storeDeferredCallMock.called).to.be.false;\n+    })\n+\n+    it(\"should return false when checking the isDefered prooperty of the return value of invoking deferRequest method online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.false;\n+    })\n+\n+    it(\"should return undefined when checking the endpointRequest prooperty of the return value of invoking deferRequest method offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const returnValue = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(returnValue.deferredCall).to.be.undefined;\n+    })\n+\n+    it(\"should defer endpoint call when server is not reachable even though browser is online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const storeDeferredCall = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      fetchMock.post(\n+        base + '/connect/FooEndpoint/fooMethod',\n+        Promise.reject(new TypeError('Failed to fetch'))\n+      )\n+  \n+      await client.deferrableCall('FooEndpoint', 'fooMethod');\n+  \n+      expect(storeDeferredCall.called).to.be.true;\n+    })\n+  \n+    it(\"should NOT defer endpoint call when server return error\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      const body = 'Unexpected error';\n+      const errorResponse = new Response(\n+        body,\n+        {\n+          status: 500,\n+          statusText: 'Internal Server Error'\n+        }\n+      );\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', errorResponse);\n+  \n+      try {\n+        await client.deferrableCall('FooEndpoint', 'fooMethod');\n+      } catch (error) {\n+        expect(error).to.be.instanceOf(Error)\n+          .and.have.property('message').that.has.string('Unexpected error');\n+      }\n+    })\n+  });\n+\n+  describe(\"submit deferred calls\", () => {\n+    let client: ConnectClient;\n+    let requestCallStub: any;\n+\n+    function fakeRequestCallFails() {\n+      requestCallStub.callsFake(() => {\n+        throw new Error();\n+      });\n+    }\n+\n+    async function insertARequest(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      for (let i = 0; i < numberOfRequests; i++) {\n+        await db.put(VAADIN_DEFERRED_CALL_STORE_NAME, { endpoint: 'FooEndpoint', method: 'fooMethod', params: { fooData: 'foo' } });\n+      }\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    async function verifyNumberOfRequsetsInTheQueue(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    beforeEach(async () => {\n+      client = new ConnectClient();\n+      requestCallStub = sinon.stub(client, 'requestCall').callsFake(async () => {\n+        await new Promise(resolve => setTimeout(resolve, 10))\n+      });\n+    });\n+\n+    afterEach(async () => {\n+      const db = await (offline as any).openOrCreateDB();\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"should check and submit the cached requests when receiving online event\", () => {\n+      const submitMethod = sinon.stub(ConnectClient.prototype, \"submitDeferredCalls\");\n+      client = new ConnectClient();\n+      self.dispatchEvent(new Event('online'));\n+      expect(submitMethod.called).to.be.true;\n+      submitMethod.restore();\n+    })\n+\n+    it(\"should submit the cached request when receiving online event\", async () => {\n+      await insertARequest(3);\n+\n+      await client.submitDeferredCalls();\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    })\n+\n+    it(\"should keep the request if submission fails\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should reject if submission fails', async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      }\n+\n+      expect(errors?.length).to.equal(1);\n+    });\n+\n+    it(\"should be able to resubmit cached request that was failed to submit\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await client.submitDeferredCalls();\n+\n+        await verifyNumberOfRequsetsInTheQueue(0);\n+      }\n+    });\n+\n+    it(\"should only submit once when receiving multiple online events\", async () => {\n+      await insertARequest();\n+\n+      await Promise.all([\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls()\n+      ])\n+\n+      expect(requestCallStub.calledOnce).to.be.true;\n+    })\n+\n+    it(\"should only submit once when receiving multiple online events after a failed submission\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await Promise.all([\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls()\n+        ])\n+\n+        expect(requestCallStub.calledOnce).to.be.true;\n+      }\n+    });\n+\n+    it('should invoke middleware with isDeferred context', async () => {\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', { fooData: 'foo' });\n+\n+      requestCallStub.restore();\n+\n+      const spyMiddleware = sinon.spy(async (context: any, next?: any) => {\n+        expect(context.endpoint).to.equal('FooEndpoint');\n+        expect(context.method).to.equal('fooMethod');\n+        expect(context.params).to.deep.equal({ fooData: 'foo' });\n+        expect(context.request).to.be.instanceOf(Request);\n+        expect(context.isDeferred).to.be.true;\n+        return next(context);\n+      });\n+      client.middlewares = [spyMiddleware];\n+\n+      try {\n+        await insertARequest();\n+\n+        expect(spyMiddleware.called).to.be.false;\n+\n+        await client.submitDeferredCalls();\n+\n+        expect(spyMiddleware.called).to.be.true;\n+      } finally {\n+        fetchMock.restore();\n+      }\n+    });\n+\n+    it('should invoke deferredCallHandler', async () => {\n+      await insertARequest();\n+\n+      const onDeferredCallStub = sinon.stub().resolves();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      await client.submitDeferredCalls();\n+\n+      expect(onDeferredCallStub.callCount).to.equal(1);\n+      const [call] = onDeferredCallStub.getCall(0).args;\n+      expect(call.deferredCall.endpoint).to.equal('FooEndpoint');\n+      expect(call.deferredCall.method).to.equal('fooMethod');\n+      expect(call.deferredCall.params).to.deep.equal({ fooData: 'foo' });\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    });\n+\n+    it('should reject if onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      } finally {\n+        expect(errors?.length).to.equal(1);\n+      }\n+    });\n+\n+    it('should keep request in the queue when onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };;\n+  \n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch(_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should set submitting status to false for all the request in the queue', async () => {\n+      try {\n+        await insertARequest(2);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        verifyNumberOfRequsetsInTheQueue(2)\n+        const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+        let cursor = await db.transaction(VAADIN_DEFERRED_CALL_STORE_NAME).store.openCursor();\n+        while (cursor) {\n+          expect(cursor.value.submitting).to.be.false;\n+          cursor = await cursor.continue();\n+        }\n+        await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+        db.close;\n+      }\n+    });\n+\n+    it('should submit all the endpoint calls in the queue even errors are encountered when submitting some calls', async () => {\n+      try {\n+        await insertARequest(3);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        expect(requestCallStub.callCount).to.equal(3);\n+        verifyNumberOfRequsetsInTheQueue(3)\n+      }\n+    });\n+\n+    describe('deferred call handler', () => {\n+      it('should be able to show a notification when a deferred call submission succeeds', async () => {\n+        const notifyOnSucess = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+            notifyOnSucess();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnSucess.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should be able to show a notification when deferred call submission fails', async () => {\n+        const notifyOnFailure = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              notifyOnFailure();\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails()\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnFailure.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should remove a succeeded endpoint call from the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint in the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } catch (_) {\n+          // expected\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(1);\n+        }\n+      });\n+\n+      it('should remove a failed endpoint call from the queue when user catches the error without calling deferrecCall.keepInTheQueue()', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              // swallow the error\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint call in the queue when user catches the error and calls deferrecCall.keepInTheQueue()', async () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 510}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0MDM4Ng==", "bodyText": "Extreanous The at end of docstring.", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517240386", "createdAt": "2020-11-04T10:23:43Z", "author": {"login": "joheriks"}, "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "diffHunk": "@@ -182,16 +174,12 @@ export interface ConnectClientOptions {\n   middlewares?: Middleware[];\n \n   /**\n-   * The `onDeferredCall` property value\n+   * The `deferredCallSubmissionHandler` property valueThe", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI1MTYyMg==", "bodyText": "The name seems longish, how about deferredCallHandler?", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517251622", "createdAt": "2020-11-04T10:41:54Z", "author": {"login": "joheriks"}, "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "diffHunk": "@@ -182,16 +174,12 @@ export interface ConnectClientOptions {\n   middlewares?: Middleware[];\n \n   /**\n-   * The `onDeferredCall` property value\n+   * The `deferredCallSubmissionHandler` property valueThe\n    */\n-  onDeferredCall?: OnDeferredCallCallback\n+  deferredCallSubmissionHandler?: DeferredCallSubmissionHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ab44974d54a0efc99a17cf359569626c27965ee", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/3ab44974d54a0efc99a17cf359569626c27965ee", "committedDate": "2020-11-04T10:57:11Z", "message": "renaming and typo fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a62bdb21bf526312f701be60c636c6cb5306b419", "author": {"user": {"login": "haijian-vaadin", "name": "Haijian Wang"}}, "url": "https://github.com/vaadin/flow/commit/a62bdb21bf526312f701be60c636c6cb5306b419", "committedDate": "2020-11-04T10:58:18Z", "message": "Merge branch 'feature/offline' into deferred-call-refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzYxNjY3", "url": "https://github.com/vaadin/flow/pull/9304#pullrequestreview-523361667", "createdAt": "2020-11-04T13:32:26Z", "commit": {"oid": "a62bdb21bf526312f701be60c636c6cb5306b419"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4774, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}