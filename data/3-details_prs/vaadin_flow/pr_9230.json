{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5NjMwMzM4", "number": 9230, "title": "Cherry picks for 2.5", "bodyText": "Merge not squash", "createdAt": "2020-10-25T17:36:50Z", "url": "https://github.com/vaadin/flow/pull/9230", "merged": true, "mergeCommit": {"oid": "46abba94a783335b9992231183b8c8238f3dda0e"}, "closed": true, "closedAt": "2020-10-26T04:41:38Z", "author": {"login": "mshabarov"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRtZv6AH2gAyNTA5NjMwMzM4OmEyOWM5ZTMzZDg3NzZhYmM2OTQ1YmFhY2Y4MWU5ZDIxMzliMTNiMmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdWM14cgFqTUxNjQ2NDk1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a29c9e33d8776abc6945baacf81e9d2139b13b2b", "author": {"user": null}, "url": "https://github.com/vaadin/flow/commit/a29c9e33d8776abc6945baacf81e9d2139b13b2b", "committedDate": "2020-10-12T05:47:48Z", "message": "chore: IT for OSGi: add a listener for one more mapping (#9101)\n\nFixes #9087"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95ba9c66994c15ddf9e9ab43ea7d096fc45426b3", "author": {"user": null}, "url": "https://github.com/vaadin/flow/commit/95ba9c66994c15ddf9e9ab43ea7d096fc45426b3", "committedDate": "2020-10-12T05:47:48Z", "message": "Do more accurate check for error messages in IT (#9086)\n\nFixes #9068"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "086ddbfb6584d9d3b0148bfd5fc61ce3b399556e", "author": {"user": {"login": "tanbt", "name": "Tan Bui"}}, "url": "https://github.com/vaadin/flow/commit/086ddbfb6584d9d3b0148bfd5fc61ce3b399556e", "committedDate": "2020-10-21T04:01:25Z", "message": "Fix docs typo (#9066)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c173498f423351ed77cbc804c335cb5163fc7ea7", "author": {"user": {"login": "joheriks", "name": "Johannes Eriksson"}}, "url": "https://github.com/vaadin/flow/commit/c173498f423351ed77cbc804c335cb5163fc7ea7", "committedDate": "2020-10-21T04:01:25Z", "message": "feat: add support for Range header to StaticFileServer (#9154)\n\nA Range header can specify either a single byte range, e.g. Range: bytes=0-99, or multiple ranges,\ne.g. Range: bytes=0-99, 200-299. The ranges do not need to be sequential and can have overlap;\ne.g. Range: bytes=200-299, 0-219 is valid; such requests will open a new stream reading from the\nbeginning of the file for each out-of-order range. The motivation for this feature is to support video\nplayback on Safari.\n\nFixes #9083"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c609ae75131ad688b2bf02484ad4f95e35077eb4", "author": {"user": {"login": "dependabot[bot]", "name": null}}, "url": "https://github.com/vaadin/flow/commit/c609ae75131ad688b2bf02484ad4f95e35077eb4", "committedDate": "2020-10-21T04:01:25Z", "message": "chore: bump junit from 4.12 to 4.13.1 (#9162)\n\nBumps [junit](https://github.com/junit-team/junit4) from 4.12 to 4.13.1.\r\n- [Release notes](https://github.com/junit-team/junit4/releases)\r\n- [Changelog](https://github.com/junit-team/junit4/blob/main/doc/ReleaseNotes4.12.md)\r\n- [Commits](https://github.com/junit-team/junit4/compare/r4.12...r4.13.1)\r\n\r\nSigned-off-by: dependabot[bot] <support@github.com>\r\n\r\nCo-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b7be25286530f5c1962f6838f0a0c7e6521b9b5", "author": {"user": {"login": "pleku", "name": "Pekka Hyv\u00f6nen"}}, "url": "https://github.com/vaadin/flow/commit/0b7be25286530f5c1962f6838f0a0c7e6521b9b5", "committedDate": "2020-10-21T04:01:25Z", "message": "chore: bump httpclient to 4.5.13 (#9176)\n\nFixes #9173\n# Conflicts:\n#\tflow-server/pom.xml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d483186c09807efbc35a883ec761607ca4481bd", "author": {"user": {"login": "caalador", "name": null}}, "url": "https://github.com/vaadin/flow/commit/8d483186c09807efbc35a883ec761607ca4481bd", "committedDate": "2020-10-21T04:01:25Z", "message": "fix: update development plugins (#9190)\n\n* fix: update copy-webpack-plugin\n\nUpdate the copy-webpack-plugin due to a found\nvulnerability in the old version.\n\nFixes #9189\n\n* Update dev server to fix yargs-parser security vulnerability\n# Conflicts:\n#\tflow-server/src/main/java/com/vaadin/flow/server/frontend/NodeUpdater.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b779a3a733c4b2d36ba059b3c807618c335e3a7", "author": {"user": {"login": "jhult", "name": "Jonathan Hult"}}, "url": "https://github.com/vaadin/flow/commit/7b779a3a733c4b2d36ba059b3c807618c335e3a7", "committedDate": "2020-10-23T12:34:42Z", "message": "chore: Update README with branch versions (#9148)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f7e836c650e6915790757e5d73cd8c6136d320e", "author": {"user": {"login": "caalador", "name": null}}, "url": "https://github.com/vaadin/flow/commit/1f7e836c650e6915790757e5d73cd8c6136d320e", "committedDate": "2020-10-23T12:34:42Z", "message": "chore: Update chrome to 86 (#9221)\n\n# Conflicts:\n#\tflow-client/intern.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f", "author": {"user": {"login": "mshabarov", "name": "Mikhail Shabarov"}}, "url": "https://github.com/vaadin/flow/commit/9c9289aeed52653351a4b6d8af3610495374522f", "committedDate": "2020-10-25T17:29:45Z", "message": "Merge remote-tracking branch 'origin/2.4' into cp/2.5"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mzg0NDg3", "url": "https://github.com/vaadin/flow/pull/9230#pullrequestreview-516384487", "createdAt": "2020-10-25T18:17:36Z", "commit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxODoxNzozNlrOHn7c8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxODoxNzozNlrOHn7c8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYzMDU3Ng==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9230#discussion_r511630576", "createdAt": "2020-10-25T18:17:36Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -152,31 +162,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",\n+                                createContentRangeHeader(start, end,\n+                                        connection.getContentLengthLong()))\n+                        .getBytes());\n+\n+                if (position > start) {\n+                    // out-of-sequence range -> open new stream to the file\n+                    // alternative: use single stream with mark / reset\n+                    closeStream(connection.getInputStream());\n+                    connection = resourceURL.openConnection();\n+                    dataStream = connection.getInputStream();\n+                    position = 0L;\n+                }\n+                long skipped = dataStream.skip(start - position);\n+                assert(skipped == start - position);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+                position = end + 1;\n+            }\n+        } finally {\n+            closeStream(dataStream);\n+        }\n+        outputStream.write(String.format(\"\\r\\n--%s\", partBoundary).getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "originalPosition": 238}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mzg0NDg4", "url": "https://github.com/vaadin/flow/pull/9230#pullrequestreview-516384488", "createdAt": "2020-10-25T18:17:37Z", "commit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxODoxNzozN1rOHn7c8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxODoxNzozN1rOHn7c8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYzMDU3Nw==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL) \n Found reliance on default encoding in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL): String.getBytes()", "url": "https://github.com/vaadin/flow/pull/9230#discussion_r511630577", "createdAt": "2020-10-25T18:17:37Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -152,31 +162,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "originalPosition": 208}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mzg0NDkw", "url": "https://github.com/vaadin/flow/pull/9230#pullrequestreview-516384490", "createdAt": "2020-10-25T18:17:38Z", "commit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxODoxNzozOFrOHn7c8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxODoxNzozOFrOHn7c8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYzMDU3OQ==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9230#discussion_r511630579", "createdAt": "2020-10-25T18:17:38Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -152,31 +162,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "originalPosition": 213}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mzg0NDkz", "url": "https://github.com/vaadin/flow/pull/9230#pullrequestreview-516384493", "createdAt": "2020-10-25T18:17:39Z", "commit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxODoxNzozOVrOHn7c9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxODoxNzozOVrOHn7c9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYzMDU4Mg==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9230#discussion_r511630582", "createdAt": "2020-10-25T18:17:39Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -152,31 +162,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NDY0OTUz", "url": "https://github.com/vaadin/flow/pull/9230#pullrequestreview-516464953", "createdAt": "2020-10-26T04:41:17Z", "commit": {"oid": "9c9289aeed52653351a4b6d8af3610495374522f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4730, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}