{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMjI1MDk2", "number": 9177, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyM1rOEtaThQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNTozMlrOEtaT2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyMzU3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyM1rOHhLu7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyM1rOHhLu7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzI5Mg==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557292", "createdAt": "2020-10-14T10:05:23Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",\n+                                createContentRangeHeader(start, end,\n+                                        connection.getContentLengthLong()))\n+                        .getBytes());\n+\n+                if (position > start) {\n+                    // out-of-sequence range -> open new stream to the file\n+                    // alternative: use single stream with mark / reset\n+                    closeStream(connection.getInputStream());\n+                    connection = resourceURL.openConnection();\n+                    dataStream = connection.getInputStream();\n+                    position = 0L;\n+                }\n+                long skipped = dataStream.skip(start - position);\n+                assert(skipped == start - position);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+                position = end + 1;\n+            }\n+        } finally {\n+            closeStream(dataStream);\n+        }\n+        outputStream.write(String.format(\"\\r\\n--%s\", partBoundary).getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyMzY2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyNFrOHhLu9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyNFrOHhLu9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzMwMw==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL) \n Found reliance on default encoding in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL): String.getBytes()", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557303", "createdAt": "2020-10-14T10:05:24Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyMzc2OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyNVrOHhLvBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyNVrOHhLvBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzMxNw==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557317", "createdAt": "2020-10-14T10:05:25Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyMzg1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyNlrOHhLvDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyNlrOHhLvDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzMyNg==", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557326", "createdAt": "2020-10-14T10:05:26Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyMzk1OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyN1rOHhLvGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyN1rOHhLvGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzMzOA==", "bodyText": "Refactor this method to reduce its Cognitive Complexity from 19 to the 15 allowed.", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557338", "createdAt": "2020-10-14T10:05:27Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))\n+                .collect(Collectors.toList());\n+        if (methods.size() > 1) {\n+            String msg = String.format(\"Class '%s' contains \"\n+                            + \"several event handler method with the same name '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        } else if (methods.size() == 1) {\n+            return Optional.of(methods.get(0));\n+        } else if (!Component.class.equals(clazz)) {\n+            return findMethod(instance, clazz.getSuperclass(), methodName);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean hasMethodAnnotation(Method method) {\n+        // Check for polymer event handler annotation.\n+        final boolean hasEventHandler = ReflectTools.hasAnnotation(method,\n+                \"com.vaadin.flow.component.polymertemplate.EventHandler\");\n+        return hasEventHandler || method\n+                .isAnnotationPresent(ClientCallable.class);\n+    }\n+\n+    private static void invokeMethod(Component instance, Method method,\n+            JsonArray args, int promiseId) {\n+        if (promiseId == -1) {\n+            invokeMethod(instance, method, args);\n+        } else {\n+            try {\n+                Serializable returnValue = (Serializable) invokeMethod(instance,\n+                        method, args);\n+\n+                instance.getElement().executeJs(\"this.$server['\"\n+                                + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n+                        returnValue);\n+            } catch (RuntimeException e) {\n+                instance.getElement().executeJs(\"this.$server['\"\n+                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static Object invokeMethod(Component instance, Method method,\n+            JsonArray args) {\n         try {\n-            Class<?> clazz = Class\n-                    .forName(\"com.vaadin.flow.component.polymertemplate.rpc.\"\n-                            + PublishedServerEventHandlerRpcHandler.class\n-                                    .getSimpleName());\n-            Method handleMethod = Stream.of(clazz.getDeclaredMethods())\n-                    .filter(method -> Modifier.isStatic(method.getModifiers())\n-                            && Modifier.isPublic(method.getModifiers()))\n-                    .findFirst().get();\n-            handleMethod.invoke(null, node, invocationJson);\n-        } catch (ClassNotFoundException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .debug(\"Polymer handler is called even though the polymer module is not in the classpath\");\n-            // Just ignore: the functionality is not available\n+            method.setAccessible(true);\n+            return method.invoke(instance, decodeArgs(instance, method, args));\n         } catch (IllegalAccessException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .warn(\"Implemenation error occured\", e);\n+            throw new RuntimeException(e);\n         } catch (InvocationTargetException e) {\n-            throw new IllegalStateException(e);\n+            LoggerFactory.getLogger(\n+                    PublishedServerEventHandlerRpcHandler.class.getName())\n+                    .debug(null, e);\n+            throw new RuntimeException(e.getCause());\n         }\n+    }\n \n-        return Optional.empty();\n+    private static Object[] decodeArgs(Component instance, Method method,\n+            JsonArray argsFromClient) {\n+        int methodArgs = method.getParameterCount();\n+        int clientValuesCount = argsFromClient.length();\n+        JsonArray argValues;\n+        if (method.isVarArgs()) {\n+            if (clientValuesCount >= methodArgs - 1) {\n+                argValues = unwrapVarArgs(argsFromClient, method);\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not enough \"\n+                                        + \"to call the method '%s' declared in '%s' which \"\n+                                        + \"has vararg parameter and the number of arguments %d\",\n+                                argsFromClient.length(), method.getName(),\n+                                method.getDeclaringClass().getName(),\n+                                method.getParameterCount());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        } else {\n+            if (methodArgs == clientValuesCount) {\n+                argValues = argsFromClient;\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not equal \"\n+                                        + \"to the number of arguments (%d) in the method '%s' \"\n+                                        + \"declared in '%s'\", argsFromClient.length(),\n+                                method.getParameterCount(), method.getName(),\n+                                method.getDeclaringClass().getName());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        }\n+        List<Object> decoded = new ArrayList<>(method.getParameterCount());\n+        Class<?>[] methodParameterTypes = method.getParameterTypes();\n+        for (int i = 0; i < argValues.length(); i++) {\n+            Class<?> type = methodParameterTypes[i];\n+            decoded.add(decodeArg(instance, method, type, i, argValues.get(i)));\n+        }\n+        return decoded.toArray(new Object[method.getParameterCount()]);\n+    }\n+\n+    private static JsonArray unwrapVarArgs(JsonArray argsFromClient,\n+            Method method) {\n+        int paramCount = method.getParameterCount();\n+        if (argsFromClient.length() == paramCount) {\n+            if (argsFromClient.get(paramCount - 1).getType()\n+                    .equals(JsonType.ARRAY)) {\n+                return argsFromClient;\n+            }\n+        }\n+        JsonArray result = Json.createArray();\n+        JsonArray rest = Json.createArray();\n+        int newIndex = 0;\n+        for (int i = 0; i < argsFromClient.length(); i++) {\n+            JsonValue value = argsFromClient.get(i);\n+            if (i < paramCount - 1) {\n+                result.set(i, value);\n+            } else {\n+                rest.set(newIndex, value);\n+                newIndex++;\n+            }\n+        }\n+        result.set(paramCount - 1, rest);\n+        return result;\n     }\n \n+    private static Object decodeArg(Component instance, Method method,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyNDA0OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyOFrOHhLvKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyOFrOHhLvKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzM1NA==", "bodyText": "Replace this lambda with a method reference.", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557354", "createdAt": "2020-10-14T10:05:28Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyNDEzOnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyOFrOHhLvOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyOFrOHhLvOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzM2OQ==", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557369", "createdAt": "2020-10-14T10:05:28Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyNDE3OnYy", "diffSide": "RIGHT", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyOVrOHhLvQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNToyOVrOHhLvQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzM3OQ==", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557379", "createdAt": "2020-10-14T10:05:29Z", "author": {"login": "vaadin-bot"}, "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyNDI0OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNTozMFrOHhLvTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNTozMFrOHhLvTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzM4OQ==", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557389", "createdAt": "2020-10-14T10:05:30Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyNDM1OnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNTozMVrOHhLvXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNTozMVrOHhLvXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzQwNA==", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557404", "createdAt": "2020-10-14T10:05:31Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUyNDQyOnYy", "diffSide": "RIGHT", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNTozMlrOHhLvYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowNTozMlrOHhLvYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzQxMQ==", "bodyText": "Remove this use of \"ModelType\"; it is deprecated. \n Remove this use of \"PolymerTemplate\"; it is deprecated.", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557411", "createdAt": "2020-10-14T10:05:32Z", "author": {"login": "vaadin-bot"}, "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)\n+                .isSupportedClass(convertedType) && ((JsonObject) argValue)\n+                .hasKey(\"nodeId\");\n+    }\n+\n+    /**\n+     * Get the template model object and type.\n+     *\n+     * @param template\n+     *         polymer template to get model from\n+     * @param argValue\n+     *         argument value\n+     * @param convertedType\n+     *         value type\n+     * @return the provided model value\n+     * @throws IllegalStateException\n+     *         if the component is not attached to the UI\n+         */\n+        public static Object getTemplateItem(Component template,\n+                JsonObject argValue, Type convertedType) {\n+            final Optional<UI> ui = template.getUI();\n+            if (ui.isPresent()) {\n+                StateNode node = ui.get().getInternals().getStateTree()\n+                        .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+\n+                ModelType propertyType = ((PolymerTemplate<?>) template)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2932, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}