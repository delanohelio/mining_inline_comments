{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMTM5NzE0", "number": 412, "title": "Cancel request by timeout", "bodyText": "#409 - wrapped Pie slices with TimeoutSlice", "createdAt": "2020-07-31T13:19:42Z", "url": "https://github.com/artipie/artipie/pull/412", "merged": true, "mergeCommit": {"oid": "8b3c3527f8d3bdd398ac6cee771caa5f1abf612a"}, "closed": true, "closedAt": "2020-08-05T13:20:19Z", "author": {"login": "g4s8"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6UEbvAH2gAyNDYwMTM5NzE0OjE3ODA4YjlkYzFiYTgwYTZjMWQ5YWQ5Y2RjNjQwMDIxODUyNWRhYTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc77A43gH2gAyNDYwMTM5NzE0OmE3YzhjMTk0ZTRjMjY5Yzc3OTI3MDBlYmIxNDI1NGQyMDY0ZDM2ZmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "17808b9dc1ba80a6c1d9ad9cdc6400218525daa9", "author": {"user": {"login": "g4s8", "name": "Kirill"}}, "url": "https://github.com/artipie/artipie/commit/17808b9dc1ba80a6c1d9ad9cdc6400218525daa9", "committedDate": "2020-07-31T13:16:38Z", "message": "#409 - cancel request by timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c4ba209f954e2a290086c81549694aba44ca655", "author": {"user": {"login": "g4s8", "name": "Kirill"}}, "url": "https://github.com/artipie/artipie/commit/6c4ba209f954e2a290086c81549694aba44ca655", "committedDate": "2020-07-31T13:18:10Z", "message": "#409 - wrap all slices with timeout slice"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5ODM5NjU5", "url": "https://github.com/artipie/artipie/pull/412#pullrequestreview-459839659", "createdAt": "2020-08-03T08:27:21Z", "commit": {"oid": "6c4ba209f954e2a290086c81549694aba44ca655"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODoyNzoyMVrOG6wlmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODoyODozMlrOG6wn0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NjY0OQ==", "bodyText": "@g4s8 future should complete only after this.origin.accept has been completed, please move future.complete invocation to .thenRun()", "url": "https://github.com/artipie/artipie/pull/412#discussion_r464266649", "createdAt": "2020-08-03T08:27:21Z", "author": {"login": "olegmoz"}, "path": "src/main/java/com/artipie/http/TimeoutSlice.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http;\n+\n+import com.artipie.asto.Content;\n+import com.artipie.http.rs.RsStatus;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * Slice which cancel requests on timeout.\n+ * <p>\n+ * If response is not sent in fixed time-span,\n+ * this slice will respond with {@code 503} status code.\n+ * </p>\n+ * @since 0.10\n+ */\n+public final class TimeoutSlice implements Slice {\n+\n+    /**\n+     * Origin slice.\n+     */\n+    private final Slice origin;\n+\n+    /**\n+     * Timeout duration.\n+     */\n+    private final Duration duration;\n+\n+    /**\n+     * Executor service.\n+     */\n+    private final ScheduledExecutorService exec;\n+\n+    /**\n+     * Wrpap {@link Slice} implementation.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration) {\n+        this(\n+            origin,\n+            duration,\n+            Executors.newSingleThreadScheduledExecutor(\n+                run -> new Thread(run, TimeoutSlice.class.getSimpleName())\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Wrpap {@link Slice} implementation with specified scheduler.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     * @param exec Scheduler\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration,\n+        final ScheduledExecutorService exec) {\n+        this.origin = origin;\n+        this.duration = duration;\n+        this.exec = exec;\n+    }\n+\n+    @Override\n+    public Response response(final String line, final Iterable<Map.Entry<String, String>> headers,\n+        final Publisher<ByteBuffer> body) {\n+        return new TimeoutResponse(\n+            this.origin.response(line, headers, body), this.duration, this.exec\n+        );\n+    }\n+\n+    /**\n+     * Response with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutResponse implements Response {\n+\n+        /**\n+         * Origin response.\n+         */\n+        private final Response origin;\n+\n+        /**\n+         * Timeout duration.\n+         */\n+        private final Duration duration;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin response\n+         * @param duration Timeout duration\n+         * @param exec Executor service\n+         */\n+        TimeoutResponse(final Response origin, final Duration duration,\n+            final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.duration = duration;\n+            this.exec = exec;\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> send(final Connection connection) {\n+            final TimeoutConnection tcon = new TimeoutConnection(connection, this.exec);\n+            return CompletableFuture.anyOf(\n+                this.origin.send(tcon).toCompletableFuture(),\n+                tcon.timeout(this.duration)\n+            ).thenApply(ignore -> null);\n+        }\n+    }\n+\n+    /**\n+     * Connection with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutConnection implements Connection {\n+\n+        /**\n+         * Origin connection.\n+         */\n+        private final Connection origin;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Completed flag.\n+         */\n+        private final AtomicBoolean completed;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin connection\n+         * @param exec Scheduler\n+         */\n+        TimeoutConnection(final Connection origin, final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.exec = exec;\n+            this.completed = new AtomicBoolean();\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> accept(final RsStatus status, final Headers headers,\n+            final Publisher<ByteBuffer> body) {\n+            final CompletionStage<Void> res;\n+            if (this.completed.compareAndSet(false, true)) {\n+                res = this.origin.accept(status, headers, body);\n+            } else {\n+                res = CompletableFuture.completedFuture(null);\n+            }\n+            return res;\n+        }\n+\n+        /**\n+         * Start timeout task.\n+         * @param duration Timeout duration\n+         * @return Task future\n+         */\n+        CompletableFuture<?> timeout(final Duration duration) {\n+            final CompletableFuture<?> future = new CompletableFuture<>();\n+            this.exec.schedule(\n+                () -> {\n+                    if (this.completed.compareAndSet(false, true)) {\n+                        this.origin.accept(\n+                            RsStatus.UNAVAILABLE, Headers.EMPTY,\n+                            new Content.From(\n+                                \"Request cancelled by timeout\".getBytes(StandardCharsets.UTF_8)\n+                            )\n+                        );\n+                        future.complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c4ba209f954e2a290086c81549694aba44ca655"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NzIxNw==", "bodyText": "@g4s8 I'd suggest to use milliseconds here as it is default precision in Java libraries", "url": "https://github.com/artipie/artipie/pull/412#discussion_r464267217", "createdAt": "2020-08-03T08:28:32Z", "author": {"login": "olegmoz"}, "path": "src/main/java/com/artipie/http/TimeoutSlice.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http;\n+\n+import com.artipie.asto.Content;\n+import com.artipie.http.rs.RsStatus;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * Slice which cancel requests on timeout.\n+ * <p>\n+ * If response is not sent in fixed time-span,\n+ * this slice will respond with {@code 503} status code.\n+ * </p>\n+ * @since 0.10\n+ */\n+public final class TimeoutSlice implements Slice {\n+\n+    /**\n+     * Origin slice.\n+     */\n+    private final Slice origin;\n+\n+    /**\n+     * Timeout duration.\n+     */\n+    private final Duration duration;\n+\n+    /**\n+     * Executor service.\n+     */\n+    private final ScheduledExecutorService exec;\n+\n+    /**\n+     * Wrpap {@link Slice} implementation.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration) {\n+        this(\n+            origin,\n+            duration,\n+            Executors.newSingleThreadScheduledExecutor(\n+                run -> new Thread(run, TimeoutSlice.class.getSimpleName())\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Wrpap {@link Slice} implementation with specified scheduler.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     * @param exec Scheduler\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration,\n+        final ScheduledExecutorService exec) {\n+        this.origin = origin;\n+        this.duration = duration;\n+        this.exec = exec;\n+    }\n+\n+    @Override\n+    public Response response(final String line, final Iterable<Map.Entry<String, String>> headers,\n+        final Publisher<ByteBuffer> body) {\n+        return new TimeoutResponse(\n+            this.origin.response(line, headers, body), this.duration, this.exec\n+        );\n+    }\n+\n+    /**\n+     * Response with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutResponse implements Response {\n+\n+        /**\n+         * Origin response.\n+         */\n+        private final Response origin;\n+\n+        /**\n+         * Timeout duration.\n+         */\n+        private final Duration duration;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin response\n+         * @param duration Timeout duration\n+         * @param exec Executor service\n+         */\n+        TimeoutResponse(final Response origin, final Duration duration,\n+            final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.duration = duration;\n+            this.exec = exec;\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> send(final Connection connection) {\n+            final TimeoutConnection tcon = new TimeoutConnection(connection, this.exec);\n+            return CompletableFuture.anyOf(\n+                this.origin.send(tcon).toCompletableFuture(),\n+                tcon.timeout(this.duration)\n+            ).thenApply(ignore -> null);\n+        }\n+    }\n+\n+    /**\n+     * Connection with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutConnection implements Connection {\n+\n+        /**\n+         * Origin connection.\n+         */\n+        private final Connection origin;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Completed flag.\n+         */\n+        private final AtomicBoolean completed;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin connection\n+         * @param exec Scheduler\n+         */\n+        TimeoutConnection(final Connection origin, final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.exec = exec;\n+            this.completed = new AtomicBoolean();\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> accept(final RsStatus status, final Headers headers,\n+            final Publisher<ByteBuffer> body) {\n+            final CompletionStage<Void> res;\n+            if (this.completed.compareAndSet(false, true)) {\n+                res = this.origin.accept(status, headers, body);\n+            } else {\n+                res = CompletableFuture.completedFuture(null);\n+            }\n+            return res;\n+        }\n+\n+        /**\n+         * Start timeout task.\n+         * @param duration Timeout duration\n+         * @return Task future\n+         */\n+        CompletableFuture<?> timeout(final Duration duration) {\n+            final CompletableFuture<?> future = new CompletableFuture<>();\n+            this.exec.schedule(\n+                () -> {\n+                    if (this.completed.compareAndSet(false, true)) {\n+                        this.origin.accept(\n+                            RsStatus.UNAVAILABLE, Headers.EMPTY,\n+                            new Content.From(\n+                                \"Request cancelled by timeout\".getBytes(StandardCharsets.UTF_8)\n+                            )\n+                        );\n+                        future.complete(null);\n+                    }\n+                },\n+                duration.getSeconds(), TimeUnit.SECONDS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c4ba209f954e2a290086c81549694aba44ca655"}, "originalPosition": 208}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79a58b6ead915bbbdee277a7bb757a0d94a8303f", "author": {"user": {"login": "g4s8", "name": "Kirill"}}, "url": "https://github.com/artipie/artipie/commit/79a58b6ead915bbbdee277a7bb757a0d94a8303f", "committedDate": "2020-08-04T12:55:35Z", "message": "#409 - (cr) using millis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1b1a7ed03937a3c3e6cac3621d5ffd02d027f2c", "author": {"user": {"login": "g4s8", "name": "Kirill"}}, "url": "https://github.com/artipie/artipie/commit/d1b1a7ed03937a3c3e6cac3621d5ffd02d027f2c", "committedDate": "2020-08-04T12:55:50Z", "message": "Merge branch 'master' into 409"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNzg4MzUz", "url": "https://github.com/artipie/artipie/pull/412#pullrequestreview-460788353", "createdAt": "2020-08-04T13:00:33Z", "commit": {"oid": "d1b1a7ed03937a3c3e6cac3621d5ffd02d027f2c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baa6e3915f75df26820fdcd8b4c9e1420be31283", "author": {"user": {"login": "g4s8", "name": "Kirill"}}, "url": "https://github.com/artipie/artipie/commit/baa6e3915f75df26820fdcd8b4c9e1420be31283", "committedDate": "2020-08-04T13:11:55Z", "message": "Merge branch 'master' into 409"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7c8c194e4c269c7792700ebb14254d2064d36fc", "author": {"user": {"login": "g4s8", "name": "Kirill"}}, "url": "https://github.com/artipie/artipie/commit/a7c8c194e4c269c7792700ebb14254d2064d36fc", "committedDate": "2020-08-05T13:12:59Z", "message": "Merge branch 'master' into 409"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3089, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}