{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMTM5NzE0", "number": 412, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODoyNzoyMVrOEUg5Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODoyODozMlrOEUg6iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTQ1ODk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/TimeoutSlice.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODoyNzoyMVrOG6wlmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODoyNzoyMVrOG6wlmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NjY0OQ==", "bodyText": "@g4s8 future should complete only after this.origin.accept has been completed, please move future.complete invocation to .thenRun()", "url": "https://github.com/artipie/artipie/pull/412#discussion_r464266649", "createdAt": "2020-08-03T08:27:21Z", "author": {"login": "olegmoz"}, "path": "src/main/java/com/artipie/http/TimeoutSlice.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http;\n+\n+import com.artipie.asto.Content;\n+import com.artipie.http.rs.RsStatus;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * Slice which cancel requests on timeout.\n+ * <p>\n+ * If response is not sent in fixed time-span,\n+ * this slice will respond with {@code 503} status code.\n+ * </p>\n+ * @since 0.10\n+ */\n+public final class TimeoutSlice implements Slice {\n+\n+    /**\n+     * Origin slice.\n+     */\n+    private final Slice origin;\n+\n+    /**\n+     * Timeout duration.\n+     */\n+    private final Duration duration;\n+\n+    /**\n+     * Executor service.\n+     */\n+    private final ScheduledExecutorService exec;\n+\n+    /**\n+     * Wrpap {@link Slice} implementation.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration) {\n+        this(\n+            origin,\n+            duration,\n+            Executors.newSingleThreadScheduledExecutor(\n+                run -> new Thread(run, TimeoutSlice.class.getSimpleName())\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Wrpap {@link Slice} implementation with specified scheduler.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     * @param exec Scheduler\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration,\n+        final ScheduledExecutorService exec) {\n+        this.origin = origin;\n+        this.duration = duration;\n+        this.exec = exec;\n+    }\n+\n+    @Override\n+    public Response response(final String line, final Iterable<Map.Entry<String, String>> headers,\n+        final Publisher<ByteBuffer> body) {\n+        return new TimeoutResponse(\n+            this.origin.response(line, headers, body), this.duration, this.exec\n+        );\n+    }\n+\n+    /**\n+     * Response with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutResponse implements Response {\n+\n+        /**\n+         * Origin response.\n+         */\n+        private final Response origin;\n+\n+        /**\n+         * Timeout duration.\n+         */\n+        private final Duration duration;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin response\n+         * @param duration Timeout duration\n+         * @param exec Executor service\n+         */\n+        TimeoutResponse(final Response origin, final Duration duration,\n+            final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.duration = duration;\n+            this.exec = exec;\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> send(final Connection connection) {\n+            final TimeoutConnection tcon = new TimeoutConnection(connection, this.exec);\n+            return CompletableFuture.anyOf(\n+                this.origin.send(tcon).toCompletableFuture(),\n+                tcon.timeout(this.duration)\n+            ).thenApply(ignore -> null);\n+        }\n+    }\n+\n+    /**\n+     * Connection with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutConnection implements Connection {\n+\n+        /**\n+         * Origin connection.\n+         */\n+        private final Connection origin;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Completed flag.\n+         */\n+        private final AtomicBoolean completed;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin connection\n+         * @param exec Scheduler\n+         */\n+        TimeoutConnection(final Connection origin, final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.exec = exec;\n+            this.completed = new AtomicBoolean();\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> accept(final RsStatus status, final Headers headers,\n+            final Publisher<ByteBuffer> body) {\n+            final CompletionStage<Void> res;\n+            if (this.completed.compareAndSet(false, true)) {\n+                res = this.origin.accept(status, headers, body);\n+            } else {\n+                res = CompletableFuture.completedFuture(null);\n+            }\n+            return res;\n+        }\n+\n+        /**\n+         * Start timeout task.\n+         * @param duration Timeout duration\n+         * @return Task future\n+         */\n+        CompletableFuture<?> timeout(final Duration duration) {\n+            final CompletableFuture<?> future = new CompletableFuture<>();\n+            this.exec.schedule(\n+                () -> {\n+                    if (this.completed.compareAndSet(false, true)) {\n+                        this.origin.accept(\n+                            RsStatus.UNAVAILABLE, Headers.EMPTY,\n+                            new Content.From(\n+                                \"Request cancelled by timeout\".getBytes(StandardCharsets.UTF_8)\n+                            )\n+                        );\n+                        future.complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c4ba209f954e2a290086c81549694aba44ca655"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTQ2MjUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/TimeoutSlice.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODoyODozMlrOG6wn0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODoyODozMlrOG6wn0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NzIxNw==", "bodyText": "@g4s8 I'd suggest to use milliseconds here as it is default precision in Java libraries", "url": "https://github.com/artipie/artipie/pull/412#discussion_r464267217", "createdAt": "2020-08-03T08:28:32Z", "author": {"login": "olegmoz"}, "path": "src/main/java/com/artipie/http/TimeoutSlice.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http;\n+\n+import com.artipie.asto.Content;\n+import com.artipie.http.rs.RsStatus;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * Slice which cancel requests on timeout.\n+ * <p>\n+ * If response is not sent in fixed time-span,\n+ * this slice will respond with {@code 503} status code.\n+ * </p>\n+ * @since 0.10\n+ */\n+public final class TimeoutSlice implements Slice {\n+\n+    /**\n+     * Origin slice.\n+     */\n+    private final Slice origin;\n+\n+    /**\n+     * Timeout duration.\n+     */\n+    private final Duration duration;\n+\n+    /**\n+     * Executor service.\n+     */\n+    private final ScheduledExecutorService exec;\n+\n+    /**\n+     * Wrpap {@link Slice} implementation.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration) {\n+        this(\n+            origin,\n+            duration,\n+            Executors.newSingleThreadScheduledExecutor(\n+                run -> new Thread(run, TimeoutSlice.class.getSimpleName())\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Wrpap {@link Slice} implementation with specified scheduler.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     * @param exec Scheduler\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration,\n+        final ScheduledExecutorService exec) {\n+        this.origin = origin;\n+        this.duration = duration;\n+        this.exec = exec;\n+    }\n+\n+    @Override\n+    public Response response(final String line, final Iterable<Map.Entry<String, String>> headers,\n+        final Publisher<ByteBuffer> body) {\n+        return new TimeoutResponse(\n+            this.origin.response(line, headers, body), this.duration, this.exec\n+        );\n+    }\n+\n+    /**\n+     * Response with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutResponse implements Response {\n+\n+        /**\n+         * Origin response.\n+         */\n+        private final Response origin;\n+\n+        /**\n+         * Timeout duration.\n+         */\n+        private final Duration duration;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin response\n+         * @param duration Timeout duration\n+         * @param exec Executor service\n+         */\n+        TimeoutResponse(final Response origin, final Duration duration,\n+            final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.duration = duration;\n+            this.exec = exec;\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> send(final Connection connection) {\n+            final TimeoutConnection tcon = new TimeoutConnection(connection, this.exec);\n+            return CompletableFuture.anyOf(\n+                this.origin.send(tcon).toCompletableFuture(),\n+                tcon.timeout(this.duration)\n+            ).thenApply(ignore -> null);\n+        }\n+    }\n+\n+    /**\n+     * Connection with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutConnection implements Connection {\n+\n+        /**\n+         * Origin connection.\n+         */\n+        private final Connection origin;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Completed flag.\n+         */\n+        private final AtomicBoolean completed;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin connection\n+         * @param exec Scheduler\n+         */\n+        TimeoutConnection(final Connection origin, final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.exec = exec;\n+            this.completed = new AtomicBoolean();\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> accept(final RsStatus status, final Headers headers,\n+            final Publisher<ByteBuffer> body) {\n+            final CompletionStage<Void> res;\n+            if (this.completed.compareAndSet(false, true)) {\n+                res = this.origin.accept(status, headers, body);\n+            } else {\n+                res = CompletableFuture.completedFuture(null);\n+            }\n+            return res;\n+        }\n+\n+        /**\n+         * Start timeout task.\n+         * @param duration Timeout duration\n+         * @return Task future\n+         */\n+        CompletableFuture<?> timeout(final Duration duration) {\n+            final CompletableFuture<?> future = new CompletableFuture<>();\n+            this.exec.schedule(\n+                () -> {\n+                    if (this.completed.compareAndSet(false, true)) {\n+                        this.origin.accept(\n+                            RsStatus.UNAVAILABLE, Headers.EMPTY,\n+                            new Content.From(\n+                                \"Request cancelled by timeout\".getBytes(StandardCharsets.UTF_8)\n+                            )\n+                        );\n+                        future.complete(null);\n+                    }\n+                },\n+                duration.getSeconds(), TimeUnit.SECONDS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c4ba209f954e2a290086c81549694aba44ca655"}, "originalPosition": 208}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2302, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}