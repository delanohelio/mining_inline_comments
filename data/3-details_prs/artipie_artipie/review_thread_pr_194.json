{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MjgxMjkx", "number": 194, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDoyNDo0NFrOECf75A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDozODoyMVrOECgNPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDU1ODQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/RepoConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDoyNDo0NFrOGe_fig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDoyNDo0NFrOGe_fig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1MDczMA==", "bodyText": "@g4s8 It's better to use Concatenation here and create the String only when all bytes are read. ByteBuffer can ends at the middle of UTF-8 char (let's assume that buffer size = 4. When you try to read 1\u0444\u044b\u04322, byte buffer will read 1\u0444 and the first byte of \u044b. It causes the resulted string will be like 1\u0444??\u04322)", "url": "https://github.com/artipie/artipie/pull/194#discussion_r435150730", "createdAt": "2020-06-04T10:24:44Z", "author": {"login": "brastak"}, "path": "src/main/java/com/artipie/RepoConfig.java", "diffHunk": "@@ -90,58 +100,82 @@ public RepoConfig(final Key prefix, final Publisher<ByteBuffer> content) {\n      *\n      * @return Async string of URL\n      */\n-    public CompletionStage<URL> url() {\n-        return this.string(\"url\").thenApply(\n-            str -> {\n-                try {\n-                    return new URL(str);\n-                } catch (final MalformedURLException ex) {\n-                    throw new IllegalArgumentException(\n-                        String.format(\"Failed to build URL from '%s'\", str),\n-                        ex\n-                    );\n-                }\n-            }\n-        );\n+    public URL url() {\n+        final String str = this.string(\"url\");\n+        try {\n+            return new URL(str);\n+        } catch (final MalformedURLException ex) {\n+            throw new IllegalArgumentException(\n+                String.format(\"Failed to build URL from '%s'\", str),\n+                ex\n+            );\n+        }\n     }\n \n     /**\n      * Read maximum allowed Content-Length value for incoming requests.\n      *\n      * @return Maximum allowed value, empty if none specified.\n      */\n-    public CompletionStage<Optional<Long>> contentLengthMax() {\n-        return this.stringOpt(\"content-length-max\").thenApply(opt -> opt.map(Long::valueOf));\n+    public Optional<Long> contentLengthMax() {\n+        return this.stringOpt(\"content-length-max\").map(Long::valueOf);\n     }\n \n     /**\n      * Storage.\n      * @return Async storage for repo\n      */\n-    public CompletionStage<Storage> storage() {\n-        return this.repoConfig()\n-            .thenApply(map -> map.yamlMapping(\"storage\"))\n-            .thenApply(YamlStorageSettings::new)\n-            .thenApply(YamlStorageSettings::storage)\n-            .thenApply(storage -> new SubStorage(this.prefix, storage));\n+    public Storage storage() {\n+        final YamlMapping repo = this.repoConfig();\n+        final Storage storage;\n+        final YamlNode node = repo.value(\"storage\");\n+        if (node instanceof Scalar) {\n+            storage = this.storages.storage(((Scalar) node).value());\n+        } else if (node instanceof YamlMapping) {\n+            storage = new YamlStorage((YamlMapping) node).storage();\n+        } else {\n+            throw new IllegalStateException(String.format(\"Invalid storage config: %s\", node));\n+        }\n+        return new SubStorage(this.prefix, storage);\n     }\n \n     /**\n      * Custom repository configuration.\n      * @return Async custom repository config or Optional.empty\n      */\n-    public CompletionStage<Optional<YamlMapping>> settings() {\n-        return this.repoConfig().thenApply(\n-            map -> Optional.ofNullable(map.yamlMapping(\"settings\"))\n-        );\n+    public Optional<YamlMapping> settings() {\n+        return Optional.ofNullable(this.repoConfig().yamlMapping(\"settings\"));\n     }\n \n     /**\n      * Repository permissions.\n      * @return Async permissions\n      */\n-    public CompletionStage<Permissions> permissions() {\n-        return this.repoConfig().thenApply(RpPermissions::new);\n+    public Permissions permissions() {\n+        return new RpPermissions(this.repoConfig());\n+    }\n+\n+    /**\n+     * Create async yaml config from content publisher.\n+     * @param storages Storage aliases\n+     * @param prefix Repository prefix\n+     * @param pub Yaml content publisher\n+     * @return Completion stage of yaml\n+     */\n+    @SuppressWarnings(\"PMD.ProhibitPublicStaticMethods\")\n+    public static CompletionStage<RepoConfig> fromPublisher(final StorageAliases storages,\n+        final Key prefix, final Publisher<ByteBuffer> pub) {\n+        return Flowable.fromPublisher(pub)\n+            .reduce(\n+                new StringBuilder(),\n+                (acc, buf) -> acc.append(\n+                    new String(new Remaining(buf).bytes(), StandardCharsets.UTF_8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c95ebfe5ace6cc155424f5c5aaf82dc0c542673"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDU3MDE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/StorageAliases.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDoyODoyOFrOGe_nLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDoyODoyOFrOGe_nLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1MjY4Nw==", "bodyText": "@g4s8 The same issue - create the string after reading all bytes", "url": "https://github.com/artipie/artipie/pull/194#discussion_r435152687", "createdAt": "2020-06-04T10:28:28Z", "author": {"login": "brastak"}, "path": "src/main/java/com/artipie/StorageAliases.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie;\n+\n+import com.amihaiemil.eoyaml.Yaml;\n+import com.amihaiemil.eoyaml.YamlMapping;\n+import com.artipie.asto.Key;\n+import com.artipie.asto.Remaining;\n+import com.artipie.asto.Storage;\n+import hu.akarnokd.rxjava2.interop.SingleInterop;\n+import io.reactivex.Flowable;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Storage configuration by alias.\n+ * @since 0.4\n+ */\n+public interface StorageAliases {\n+\n+    /**\n+     * Empty storage alias.\n+     */\n+    StorageAliases EMPTY = alias -> {\n+        throw new IllegalStateException(String.format(\"No storage alias found: %s\", alias));\n+    };\n+\n+    /**\n+     * Find storage by alias.\n+     * @param alias Storage alias\n+     * @return Storage instance\n+     */\n+    Storage storage(String alias);\n+\n+    /**\n+     * Find storage aliases config for repo.\n+     * @param storage Config storage\n+     * @param repo Repo key\n+     * @return Async storages\n+     */\n+    @SuppressWarnings(\"PMD.ProhibitPublicStaticMethods\")\n+    static CompletableFuture<StorageAliases> find(final Storage storage, final Key repo) {\n+        final Key.From key = new Key.From(repo, \"_storages.yaml\");\n+        return storage.exists(key).thenCompose(\n+            found -> {\n+                final CompletableFuture<StorageAliases> res;\n+                if (found) {\n+                    res = storage.value(key).thenCompose(\n+                        pub -> Flowable.fromPublisher(pub)\n+                            .reduce(\n+                                new StringBuilder(),\n+                                (acc, buf) -> acc.append(\n+                                    new String(new Remaining(buf).bytes(), StandardCharsets.UTF_8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c95ebfe5ace6cc155424f5c5aaf82dc0c542673"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDYwMjg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/repo/FlatLayout.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDozODoyMVrOGe_7FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDozODoyMVrOGe_7FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1Nzc4MA==", "bodyText": "@g4s8 It seems that we should to think about caching. We do a lot of config readings on each request. Maybe create the issue?", "url": "https://github.com/artipie/artipie/pull/194#discussion_r435157780", "createdAt": "2020-06-04T10:38:21Z", "author": {"login": "brastak"}, "path": "src/main/java/com/artipie/repo/FlatLayout.java", "diffHunk": "@@ -103,13 +104,16 @@ public Slice resolve(final String path) {\n                         final Slice slice;\n                         if (exist) {\n                             slice = new AsyncSlice(\n-                                storage.value(key).thenCombine(\n+                                StorageAliases.find(storage, key.parent().get()).thenCompose(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c95ebfe5ace6cc155424f5c5aaf82dc0c542673"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2418, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}