{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NDUwNDk0", "number": 404, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyODo0M1rOETlO5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyODo0M1rOETlO5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTY4NDIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/metrics/asto/StorageMetrics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyODo0M1rOG5ZPFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyODo0M1rOG5ZPFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNTQ3OA==", "bodyText": "@g4s8 this approach to updating values will lead to race conditions right away (the method is called at least once for each request, that's very often) and very high performance overhead (one memory update is 3 storage ops). I believe that buffering ans synchronizing writes is mandatory here from the start.\nWhat do you think about collecting data to InMemoryMetrics and publishing it periodically to Storage approximately the same way we publish it to log? That way we have buffering and synchronized writes.", "url": "https://github.com/artipie/artipie/pull/404#discussion_r462835478", "createdAt": "2020-07-30T08:28:43Z", "author": {"login": "olegmoz"}, "path": "src/main/java/com/artipie/metrics/asto/StorageMetrics.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.metrics.asto;\n+\n+import com.artipie.asto.Content;\n+import com.artipie.asto.Key;\n+import com.artipie.asto.Storage;\n+import com.artipie.asto.ext.PublisherAs;\n+import com.artipie.metrics.Counter;\n+import com.artipie.metrics.Gauge;\n+import com.artipie.metrics.Metrics;\n+import com.jcabi.log.Logger;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * Storage metrics.\n+ * @since 0.19\n+ */\n+public final class StorageMetrics implements Metrics {\n+\n+    /**\n+     * Storage for metrics.\n+     */\n+    private final Storage storage;\n+\n+    /**\n+     * New storage metrics.\n+     * @param storage Storage\n+     */\n+    public StorageMetrics(final Storage storage) {\n+        this.storage = storage;\n+    }\n+\n+    @Override\n+    public Counter counter(final String name) {\n+        return new StorageDatabase(this.storage, new Key.From(name));\n+    }\n+\n+    @Override\n+    public Gauge gauge(final String name) {\n+        return new StorageDatabase(this.storage, new Key.From(name));\n+    }\n+\n+    /**\n+     * Storage metrics database.\n+     * @since 0.19\n+     */\n+    private static final class StorageDatabase implements Counter, Gauge {\n+\n+        /**\n+         * Storage.\n+         */\n+        private final Storage storage;\n+\n+        /**\n+         * Metrics key.\n+         */\n+        private final Key key;\n+\n+        /**\n+         * New storage metrics database.\n+         * @param storage Storage\n+         * @param key Key\n+         */\n+        StorageDatabase(final Storage storage, final Key key) {\n+            this.storage = storage;\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public void set(final long value) {\n+            this.storage.save(this.key, content(value))\n+                .handle(StorageDatabase::handle);\n+        }\n+\n+        @Override\n+        public void add(final long amount) {\n+            this.storage.exists(this.key).thenCompose(\n+                exists -> {\n+                    final CompletionStage<Long> res;\n+                    if (exists) {\n+                        res = this.storage.value(this.key).thenCompose(\n+                            content -> new PublisherAs(content)\n+                                .string(StandardCharsets.UTF_8)\n+                                .thenApply(Long::valueOf)\n+                        );\n+                    } else {\n+                        res = CompletableFuture.completedFuture(0L);\n+                    }\n+                    return res;\n+                }\n+            ).thenCompose(val -> this.storage.save(this.key, content(val + amount)))\n+                .handle(StorageDatabase::handle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13967ae87b89d125779bb822a4114f30afe273a6"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2293, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}