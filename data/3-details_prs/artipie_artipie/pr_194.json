{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MjgxMjkx", "number": 194, "title": "Using storage aliases", "bodyText": "#78 - using storage aliases for repo configuration. Refactored RepoConfig methods to be synchronous to avoid one more (5-th) callback parameter for constructing configuration. This feature helps to hide actual credentials from config and restrict user permissions to allow modify repository settings only without changing storage configuration (in case of Central).", "createdAt": "2020-06-03T15:31:00Z", "url": "https://github.com/artipie/artipie/pull/194", "merged": true, "mergeCommit": {"oid": "f1399452c9be7479c71f407aa37ab171ac596820"}, "closed": true, "closedAt": "2020-06-04T13:30:54Z", "author": {"login": "g4s8"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnrK0mAH2gAyNDI3MjgxMjkxOjNjOTVlYmZlNWFjZTZjYzE1NTQyNGY1YzVhYWY4MmRjMGM1NDI2NzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcn9BvFAFqTQyNDM4MDAyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3c95ebfe5ace6cc155424f5c5aaf82dc0c542673", "author": {"user": {"login": "g4s8", "name": "Kirill"}}, "url": "https://github.com/artipie/artipie/commit/3c95ebfe5ace6cc155424f5c5aaf82dc0c542673", "committedDate": "2020-06-03T15:26:52Z", "message": "#78 - using storage aliases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzA2NzIx", "url": "https://github.com/artipie/artipie/pull/194#pullrequestreview-424306721", "createdAt": "2020-06-04T10:24:44Z", "commit": {"oid": "3c95ebfe5ace6cc155424f5c5aaf82dc0c542673"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDoyNDo0NFrOGe_fig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDozODoyMVrOGe_7FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1MDczMA==", "bodyText": "@g4s8 It's better to use Concatenation here and create the String only when all bytes are read. ByteBuffer can ends at the middle of UTF-8 char (let's assume that buffer size = 4. When you try to read 1\u0444\u044b\u04322, byte buffer will read 1\u0444 and the first byte of \u044b. It causes the resulted string will be like 1\u0444??\u04322)", "url": "https://github.com/artipie/artipie/pull/194#discussion_r435150730", "createdAt": "2020-06-04T10:24:44Z", "author": {"login": "brastak"}, "path": "src/main/java/com/artipie/RepoConfig.java", "diffHunk": "@@ -90,58 +100,82 @@ public RepoConfig(final Key prefix, final Publisher<ByteBuffer> content) {\n      *\n      * @return Async string of URL\n      */\n-    public CompletionStage<URL> url() {\n-        return this.string(\"url\").thenApply(\n-            str -> {\n-                try {\n-                    return new URL(str);\n-                } catch (final MalformedURLException ex) {\n-                    throw new IllegalArgumentException(\n-                        String.format(\"Failed to build URL from '%s'\", str),\n-                        ex\n-                    );\n-                }\n-            }\n-        );\n+    public URL url() {\n+        final String str = this.string(\"url\");\n+        try {\n+            return new URL(str);\n+        } catch (final MalformedURLException ex) {\n+            throw new IllegalArgumentException(\n+                String.format(\"Failed to build URL from '%s'\", str),\n+                ex\n+            );\n+        }\n     }\n \n     /**\n      * Read maximum allowed Content-Length value for incoming requests.\n      *\n      * @return Maximum allowed value, empty if none specified.\n      */\n-    public CompletionStage<Optional<Long>> contentLengthMax() {\n-        return this.stringOpt(\"content-length-max\").thenApply(opt -> opt.map(Long::valueOf));\n+    public Optional<Long> contentLengthMax() {\n+        return this.stringOpt(\"content-length-max\").map(Long::valueOf);\n     }\n \n     /**\n      * Storage.\n      * @return Async storage for repo\n      */\n-    public CompletionStage<Storage> storage() {\n-        return this.repoConfig()\n-            .thenApply(map -> map.yamlMapping(\"storage\"))\n-            .thenApply(YamlStorageSettings::new)\n-            .thenApply(YamlStorageSettings::storage)\n-            .thenApply(storage -> new SubStorage(this.prefix, storage));\n+    public Storage storage() {\n+        final YamlMapping repo = this.repoConfig();\n+        final Storage storage;\n+        final YamlNode node = repo.value(\"storage\");\n+        if (node instanceof Scalar) {\n+            storage = this.storages.storage(((Scalar) node).value());\n+        } else if (node instanceof YamlMapping) {\n+            storage = new YamlStorage((YamlMapping) node).storage();\n+        } else {\n+            throw new IllegalStateException(String.format(\"Invalid storage config: %s\", node));\n+        }\n+        return new SubStorage(this.prefix, storage);\n     }\n \n     /**\n      * Custom repository configuration.\n      * @return Async custom repository config or Optional.empty\n      */\n-    public CompletionStage<Optional<YamlMapping>> settings() {\n-        return this.repoConfig().thenApply(\n-            map -> Optional.ofNullable(map.yamlMapping(\"settings\"))\n-        );\n+    public Optional<YamlMapping> settings() {\n+        return Optional.ofNullable(this.repoConfig().yamlMapping(\"settings\"));\n     }\n \n     /**\n      * Repository permissions.\n      * @return Async permissions\n      */\n-    public CompletionStage<Permissions> permissions() {\n-        return this.repoConfig().thenApply(RpPermissions::new);\n+    public Permissions permissions() {\n+        return new RpPermissions(this.repoConfig());\n+    }\n+\n+    /**\n+     * Create async yaml config from content publisher.\n+     * @param storages Storage aliases\n+     * @param prefix Repository prefix\n+     * @param pub Yaml content publisher\n+     * @return Completion stage of yaml\n+     */\n+    @SuppressWarnings(\"PMD.ProhibitPublicStaticMethods\")\n+    public static CompletionStage<RepoConfig> fromPublisher(final StorageAliases storages,\n+        final Key prefix, final Publisher<ByteBuffer> pub) {\n+        return Flowable.fromPublisher(pub)\n+            .reduce(\n+                new StringBuilder(),\n+                (acc, buf) -> acc.append(\n+                    new String(new Remaining(buf).bytes(), StandardCharsets.UTF_8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c95ebfe5ace6cc155424f5c5aaf82dc0c542673"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1MjY4Nw==", "bodyText": "@g4s8 The same issue - create the string after reading all bytes", "url": "https://github.com/artipie/artipie/pull/194#discussion_r435152687", "createdAt": "2020-06-04T10:28:28Z", "author": {"login": "brastak"}, "path": "src/main/java/com/artipie/StorageAliases.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie;\n+\n+import com.amihaiemil.eoyaml.Yaml;\n+import com.amihaiemil.eoyaml.YamlMapping;\n+import com.artipie.asto.Key;\n+import com.artipie.asto.Remaining;\n+import com.artipie.asto.Storage;\n+import hu.akarnokd.rxjava2.interop.SingleInterop;\n+import io.reactivex.Flowable;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Storage configuration by alias.\n+ * @since 0.4\n+ */\n+public interface StorageAliases {\n+\n+    /**\n+     * Empty storage alias.\n+     */\n+    StorageAliases EMPTY = alias -> {\n+        throw new IllegalStateException(String.format(\"No storage alias found: %s\", alias));\n+    };\n+\n+    /**\n+     * Find storage by alias.\n+     * @param alias Storage alias\n+     * @return Storage instance\n+     */\n+    Storage storage(String alias);\n+\n+    /**\n+     * Find storage aliases config for repo.\n+     * @param storage Config storage\n+     * @param repo Repo key\n+     * @return Async storages\n+     */\n+    @SuppressWarnings(\"PMD.ProhibitPublicStaticMethods\")\n+    static CompletableFuture<StorageAliases> find(final Storage storage, final Key repo) {\n+        final Key.From key = new Key.From(repo, \"_storages.yaml\");\n+        return storage.exists(key).thenCompose(\n+            found -> {\n+                final CompletableFuture<StorageAliases> res;\n+                if (found) {\n+                    res = storage.value(key).thenCompose(\n+                        pub -> Flowable.fromPublisher(pub)\n+                            .reduce(\n+                                new StringBuilder(),\n+                                (acc, buf) -> acc.append(\n+                                    new String(new Remaining(buf).bytes(), StandardCharsets.UTF_8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c95ebfe5ace6cc155424f5c5aaf82dc0c542673"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1Nzc4MA==", "bodyText": "@g4s8 It seems that we should to think about caching. We do a lot of config readings on each request. Maybe create the issue?", "url": "https://github.com/artipie/artipie/pull/194#discussion_r435157780", "createdAt": "2020-06-04T10:38:21Z", "author": {"login": "brastak"}, "path": "src/main/java/com/artipie/repo/FlatLayout.java", "diffHunk": "@@ -103,13 +104,16 @@ public Slice resolve(final String path) {\n                         final Slice slice;\n                         if (exist) {\n                             slice = new AsyncSlice(\n-                                storage.value(key).thenCombine(\n+                                StorageAliases.find(storage, key.parent().get()).thenCompose(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c95ebfe5ace6cc155424f5c5aaf82dc0c542673"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bcc95c3e5fdcfd3d352c9b5641370c837d8c239", "author": {"user": {"login": "g4s8", "name": "Kirill"}}, "url": "https://github.com/artipie/artipie/commit/2bcc95c3e5fdcfd3d352c9b5641370c837d8c239", "committedDate": "2020-06-04T11:56:20Z", "message": "#78 - review fixes string building"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzgwMDI2", "url": "https://github.com/artipie/artipie/pull/194#pullrequestreview-424380026", "createdAt": "2020-06-04T12:15:14Z", "commit": {"oid": "2bcc95c3e5fdcfd3d352c9b5641370c837d8c239"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3211, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}