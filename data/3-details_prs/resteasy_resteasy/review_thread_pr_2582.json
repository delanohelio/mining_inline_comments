{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5ODc3NjU3", "number": 2582, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTozMDo1MVrOEx0RAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTozMjoxNFrOEx0TjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjcyMDAxOnYy", "diffSide": "RIGHT", "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTozMDo1MVrOHoHM4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMDowMDowOVrOHoITaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMzA3NQ==", "bodyText": "Shouldn't we remove this commented line?", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511823075", "createdAt": "2020-10-26T09:30:51Z", "author": {"login": "cescoffier"}, "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java", "diffHunk": "@@ -20,6 +20,8 @@\n import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n import org.jboss.resteasy.microprofile.client.impl.MpClient;\n import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n+import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n+//import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0MTEyOQ==", "bodyText": "Thanks. Fixed.", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511841129", "createdAt": "2020-10-26T10:00:09Z", "author": {"login": "jimma"}, "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java", "diffHunk": "@@ -20,6 +20,8 @@\n import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n import org.jboss.resteasy.microprofile.client.impl.MpClient;\n import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n+import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n+//import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMzA3NQ=="}, "originalCommit": {"oid": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjcyNjUzOnYy", "diffSide": "RIGHT", "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTozMjoxNFrOHoHQkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1ODo1M1rOHoTpow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDAxNw==", "bodyText": "should it handle rejection?", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511824017", "createdAt": "2020-10-26T09:32:14Z", "author": {"login": "cescoffier"}, "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java", "diffHunk": "@@ -0,0 +1,290 @@\n+package org.jboss.resteasy.microprofile.client.publisher;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.core.ResteasyContext;\n+import org.jboss.resteasy.plugins.providers.sse.SseEventInputImpl;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import javax.ws.rs.ext.Providers;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Publisher implementation emitting server-sent-event downstream.\n+ *\n+ * @param <T> the type of event.\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")\n+public class SSEPublisher<T> implements Publisher<T> {\n+\n+    private static final Runnable CLEARED = () -> {\n+        // sentinel indicating we are done.\n+    };\n+\n+    private final SseEventInputImpl input;\n+    private final Type genericType;\n+    private final Providers providers;\n+    private final ExecutorService executor;\n+\n+    private static final Logger LOGGER = Logger.getLogger(SSEPublisher.class);\n+\n+    public SSEPublisher(final Type genericType, final Providers providers, final SseEventInputImpl input, final ExecutorService es) {\n+        this.genericType = genericType;\n+        this.input = input;\n+        this.providers = providers;\n+        this.executor = es;\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> downstream) {\n+        SSEProcessor<? super T> processor = new SSEProcessor<>(downstream,\n+                Integer.getInteger(\"resteasy.microprofile.sseclient.buffersize\", 512));\n+        downstream.onSubscribe(processor);\n+        pump(processor, input);\n+    }\n+\n+    /**\n+     * Reads the server-sent event from the {@code input} and pass them to the processor.\n+     * The processor handles the downstream requests and buffer/drop items according to them.\n+     *\n+     * @param processor the stream\n+     * @param input     the SSE input\n+     */\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n+        Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n+        executor.execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0MTE5Mg==", "bodyText": "Do you mean handle executor injection ?", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511841192", "createdAt": "2020-10-26T10:00:16Z", "author": {"login": "jimma"}, "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java", "diffHunk": "@@ -0,0 +1,290 @@\n+package org.jboss.resteasy.microprofile.client.publisher;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.core.ResteasyContext;\n+import org.jboss.resteasy.plugins.providers.sse.SseEventInputImpl;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import javax.ws.rs.ext.Providers;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Publisher implementation emitting server-sent-event downstream.\n+ *\n+ * @param <T> the type of event.\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")\n+public class SSEPublisher<T> implements Publisher<T> {\n+\n+    private static final Runnable CLEARED = () -> {\n+        // sentinel indicating we are done.\n+    };\n+\n+    private final SseEventInputImpl input;\n+    private final Type genericType;\n+    private final Providers providers;\n+    private final ExecutorService executor;\n+\n+    private static final Logger LOGGER = Logger.getLogger(SSEPublisher.class);\n+\n+    public SSEPublisher(final Type genericType, final Providers providers, final SseEventInputImpl input, final ExecutorService es) {\n+        this.genericType = genericType;\n+        this.input = input;\n+        this.providers = providers;\n+        this.executor = es;\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> downstream) {\n+        SSEProcessor<? super T> processor = new SSEProcessor<>(downstream,\n+                Integer.getInteger(\"resteasy.microprofile.sseclient.buffersize\", 512));\n+        downstream.onSubscribe(processor);\n+        pump(processor, input);\n+    }\n+\n+    /**\n+     * Reads the server-sent event from the {@code input} and pass them to the processor.\n+     * The processor handles the downstream requests and buffer/drop items according to them.\n+     *\n+     * @param processor the stream\n+     * @param input     the SSE input\n+     */\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n+        Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n+        executor.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDAxNw=="}, "originalCommit": {"oid": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzY5Mw==", "bodyText": "if the executor is stopped (for whatever reason), you cannot submit another task. You will receive a RejectedExecutionException. What should we do in this case? Log and return a failed publisher? Log and return a Publisher just emitting the completion signal?", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511857693", "createdAt": "2020-10-26T10:28:02Z", "author": {"login": "cescoffier"}, "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java", "diffHunk": "@@ -0,0 +1,290 @@\n+package org.jboss.resteasy.microprofile.client.publisher;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.core.ResteasyContext;\n+import org.jboss.resteasy.plugins.providers.sse.SseEventInputImpl;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import javax.ws.rs.ext.Providers;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Publisher implementation emitting server-sent-event downstream.\n+ *\n+ * @param <T> the type of event.\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")\n+public class SSEPublisher<T> implements Publisher<T> {\n+\n+    private static final Runnable CLEARED = () -> {\n+        // sentinel indicating we are done.\n+    };\n+\n+    private final SseEventInputImpl input;\n+    private final Type genericType;\n+    private final Providers providers;\n+    private final ExecutorService executor;\n+\n+    private static final Logger LOGGER = Logger.getLogger(SSEPublisher.class);\n+\n+    public SSEPublisher(final Type genericType, final Providers providers, final SseEventInputImpl input, final ExecutorService es) {\n+        this.genericType = genericType;\n+        this.input = input;\n+        this.providers = providers;\n+        this.executor = es;\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> downstream) {\n+        SSEProcessor<? super T> processor = new SSEProcessor<>(downstream,\n+                Integer.getInteger(\"resteasy.microprofile.sseclient.buffersize\", 512));\n+        downstream.onSubscribe(processor);\n+        pump(processor, input);\n+    }\n+\n+    /**\n+     * Reads the server-sent event from the {@code input} and pass them to the processor.\n+     * The processor handles the downstream requests and buffer/drop items according to them.\n+     *\n+     * @param processor the stream\n+     * @param input     the SSE input\n+     */\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n+        Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n+        executor.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDAxNw=="}, "originalCommit": {"oid": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNzA0Mw==", "bodyText": "@cescoffier Thanks for pointing out this issue.  I modified to this to create a new thread to run this if there is RejectedExecutionException thrown.", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r512027043", "createdAt": "2020-10-26T14:58:53Z", "author": {"login": "jimma"}, "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java", "diffHunk": "@@ -0,0 +1,290 @@\n+package org.jboss.resteasy.microprofile.client.publisher;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.core.ResteasyContext;\n+import org.jboss.resteasy.plugins.providers.sse.SseEventInputImpl;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import javax.ws.rs.ext.Providers;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Publisher implementation emitting server-sent-event downstream.\n+ *\n+ * @param <T> the type of event.\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")\n+public class SSEPublisher<T> implements Publisher<T> {\n+\n+    private static final Runnable CLEARED = () -> {\n+        // sentinel indicating we are done.\n+    };\n+\n+    private final SseEventInputImpl input;\n+    private final Type genericType;\n+    private final Providers providers;\n+    private final ExecutorService executor;\n+\n+    private static final Logger LOGGER = Logger.getLogger(SSEPublisher.class);\n+\n+    public SSEPublisher(final Type genericType, final Providers providers, final SseEventInputImpl input, final ExecutorService es) {\n+        this.genericType = genericType;\n+        this.input = input;\n+        this.providers = providers;\n+        this.executor = es;\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> downstream) {\n+        SSEProcessor<? super T> processor = new SSEProcessor<>(downstream,\n+                Integer.getInteger(\"resteasy.microprofile.sseclient.buffersize\", 512));\n+        downstream.onSubscribe(processor);\n+        pump(processor, input);\n+    }\n+\n+    /**\n+     * Reads the server-sent event from the {@code input} and pass them to the processor.\n+     * The processor handles the downstream requests and buffer/drop items according to them.\n+     *\n+     * @param processor the stream\n+     * @param input     the SSE input\n+     */\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n+        Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n+        executor.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDAxNw=="}, "originalCommit": {"oid": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4895, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}