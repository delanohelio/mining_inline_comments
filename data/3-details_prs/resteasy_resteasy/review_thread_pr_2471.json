{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MjI5Njk4", "number": 2471, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDowNjoyOVrOEN1Y0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDoyMTo1M1rOEOembQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTQxNjQ5OnYy", "diffSide": "RIGHT", "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDowNjoyOVrOGwqJxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjoyNzoxNFrOGxbfEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTQ2Mw==", "bodyText": "You will never get a cache hit with \"boundary\" as equals() still checks parameters being equal.  Maybe just not cache at all if there is a \"boundary\"?", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r453675463", "createdAt": "2020-07-13T14:06:29Z", "author": {"login": "patriot1burke"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNTY4OA==", "bodyText": "From my local test, equals() doesn't check parameters as Key's contentTypes are all changed with \"boundary\" removal in this line:\nif (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {\n    this.contentType = new MediaType(request.getHttpHeaders().getMediaType().getType(), request.getHttpHeaders().getMediaType().getSubtype());\n}\n\nFor the following  two request Content-Types, it will create Key with the same contentType : multipart/form-data\nContent-type: multipart/form-data; boundary=50ccecb8-085c-4869-841f-b40f8d77fe23\nContent-type: multipart/form-data; boundary=ad96d758-8668-4657-b8ca-671a5fbb9269", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r453735688", "createdAt": "2020-07-13T15:30:20Z", "author": {"login": "jimma"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTQ2Mw=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0MDgxMw==", "bodyText": "I'm sorry, but this is too idealistic. This bug occurs on any request as the media type can be parameterized. A simple example is using server-async-http.\ncurl 'http://localhost:8080/chat/listener/ping' --header 'Content-Type: text/plain; 1=1'\ncurl 'http://localhost:8080/chat/listener/ping' --header 'Content-Type: text/plain; 1=2'\n\nA safe fix would be to include all fields in both equals and hashCode. The maximum cache size nicely resolves the concern if there are other unknown exploits, since it limits the worst case cost.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r453840813", "createdAt": "2020-07-13T18:17:55Z", "author": {"login": "ben-manes"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTQ2Mw=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3NDc1Mg==", "bodyText": "You definitely do not need to include parameters within the hash code.  Hash codes do not have to be unique and there would only be possible collisions if you had two different resource methods that were dispatched based on media type parameters, i.e. \"application/foo+json;version=1\".\nYou DO want equals to match based on parameters, but not any dynamic parameters like boundary.  IMO, the fix is fine.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r453874752", "createdAt": "2020-07-13T19:17:10Z", "author": {"login": "patriot1burke"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTQ2Mw=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3NTQyMA==", "bodyText": "Parameter types are compared here:\nhttps://github.com/resteasy/Resteasy/blob/91036412da9ae08c3959d7b4ec33ddc2a584c0d8/resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java#L45", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r453875420", "createdAt": "2020-07-13T19:18:29Z", "author": {"login": "patriot1burke"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTQ2Mw=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg4MTE1OA==", "bodyText": "The maximum cache size is certainly the major fix, but without that the simple dynamic parameter of a counter is all that was needed to demonstrate a HashDoS attack. The same resource method was being dispatched to, but since contentType isn't in the hashCode mix it results in a collision and degrading to O(n) map operations.\nUsing a naive JMeter test where every request increments a counter in the dynamic parameter, hitting the same resource, showed latencies degrade as", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r453881158", "createdAt": "2020-07-13T19:28:40Z", "author": {"login": "ben-manes"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTQ2Mw=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxMDMzNg==", "bodyText": "@ben-manes can you share sample project and jmeter config for ^^^?", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454310336", "createdAt": "2020-07-14T12:12:21Z", "author": {"login": "rsvoboda"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTQ2Mw=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4MzcyOQ==", "bodyText": "@rsvoboda Attached to RESTEASY-2643 as unsupported type on github. Included the steps, as sent to RedHat security for their verification. This increments a dynamic parameter on every request, counter=${counter_value}.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454483729", "createdAt": "2020-07-14T16:27:14Z", "author": {"login": "ben-manes"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTQ2Mw=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzI5NDk3OnYy", "diffSide": "RIGHT", "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/RootNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo0NToyOFrOGxOSVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo0NToyOFrOGxOSVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2NzQ3Ng==", "bodyText": "Why are here these extra braces?", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454267476", "createdAt": "2020-07-14T10:45:28Z", "author": {"login": "rsvoboda"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/RootNode.java", "diffHunk": "@@ -56,10 +69,12 @@ public ResourceInvoker match(HttpRequest request, int start)\n          request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\r\n       } else {\r\n          match = root.match(request, start);\r\n-         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r\n+         if (cache.size() < CACHE_SIZE && match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r\n             //System.out.println(\"*** caching: \" + key.method + \" \" + key.path);\r\n             match.match = null;\r\n-            cache.putIfAbsent(key, match);\r\n+            {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzMwNzQxOnYy", "diffSide": "RIGHT", "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/RootNode.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo0OTozMFrOGxOaCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjozMjo0OFrOGxbt1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2OTQ0OQ==", "bodyText": "So once the cache is full, nothing gets added / old entries removed?", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454269449", "createdAt": "2020-07-14T10:49:30Z", "author": {"login": "rsvoboda"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/RootNode.java", "diffHunk": "@@ -56,10 +69,12 @@ public ResourceInvoker match(HttpRequest request, int start)\n          request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\r\n       } else {\r\n          match = root.match(request, start);\r\n-         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r\n+         if (cache.size() < CACHE_SIZE && match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMwODQxMQ==", "bodyText": "It's ideal that we remove the LRU entry when the cache is full.  Later we can look at ConcurrentLinkedHashMap  which Ben suggested.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454308411", "createdAt": "2020-07-14T12:08:34Z", "author": {"login": "jimma"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/RootNode.java", "diffHunk": "@@ -56,10 +69,12 @@ public ResourceInvoker match(HttpRequest request, int start)\n          request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\r\n       } else {\r\n          match = root.match(request, start);\r\n-         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r\n+         if (cache.size() < CACHE_SIZE && match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2OTQ0OQ=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyNTgzOQ==", "bodyText": "Just remember, that 99% of apps will only have a handful of media types (< 5), usually only 1 (json).  Might be a little bigger if character sets are involved, but there's only a handful of those in existence as well.  The issue here was a media type that adds a random parameter.  IMO, if you hit the cache size you're dealing with an app that has another random parameter and the cache will be useless.  Might as well clear it and turn it off in that scenario.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454325839", "createdAt": "2020-07-14T12:39:52Z", "author": {"login": "patriot1burke"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/RootNode.java", "diffHunk": "@@ -56,10 +69,12 @@ public ResourceInvoker match(HttpRequest request, int start)\n          request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\r\n       } else {\r\n          match = root.match(request, start);\r\n-         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r\n+         if (cache.size() < CACHE_SIZE && match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2OTQ0OQ=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NzUwOA==", "bodyText": "Isn't this per route? The cache size would be hit if an application has more than CACHE_SIZE routes, in the expected case.\nThe MediaTypeHeaderDelegate is a cache of media types and it clears itself when full. It doesn't condition for dynamic parameters, so a multipart route would invalidate it regularly.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454487508", "createdAt": "2020-07-14T16:32:48Z", "author": {"login": "ben-manes"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/RootNode.java", "diffHunk": "@@ -56,10 +69,12 @@ public ResourceInvoker match(HttpRequest request, int start)\n          request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\r\n       } else {\r\n          match = root.match(request, start);\r\n-         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r\n+         if (cache.size() < CACHE_SIZE && match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2OTQ0OQ=="}, "originalCommit": {"oid": "91036412da9ae08c3959d7b4ec33ddc2a584c0d8"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDMyODM4OnYy", "diffSide": "RIGHT", "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNTowOToxN1rOGxYLTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzowNzoyNFrOGxxEsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyOTUxOQ==", "bodyText": "is request.getHttpHeaders().getMediaType() always not null ? Just to be sure no NPE can jump from this.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454429519", "createdAt": "2020-07-14T15:09:17Z", "author": {"login": "rsvoboda"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bb24dbd5e987353118dd26bd445a158c01b0f47"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ3ODcyOA==", "bodyText": "Actually the build is failing in resteasy-undertow testsuite because a NPE exactly there. So this has to be fixed @jimma .", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454478728", "createdAt": "2020-07-14T16:19:39Z", "author": {"login": "asoldano"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyOTUxOQ=="}, "originalCommit": {"oid": "2bb24dbd5e987353118dd26bd445a158c01b0f47"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgzNzQyNA==", "bodyText": "Fixed.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454837424", "createdAt": "2020-07-15T07:07:24Z", "author": {"login": "jimma"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyOTUxOQ=="}, "originalCommit": {"oid": "2bb24dbd5e987353118dd26bd445a158c01b0f47"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjE2ODc3OnYy", "diffSide": "RIGHT", "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDoyMTo1M1rOGxpz_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMDoyMDo1M1rOGyVwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxODQ2Mw==", "bodyText": "MediaType.equals() checks the parameters, so I question removing all of the parameters when \"boundary\" is present. Actually, I guess, in principle, that it's possible to use the boundary parameter in a @consumes annotation, but it doesn't seem likely. So it seems reasonable to me to remove only the \"boundary\" parameter and leave the others in place.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454718463", "createdAt": "2020-07-15T00:21:53Z", "author": {"login": "ronsigal"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {\n+               this.contentType = new MediaType(request.getHttpHeaders().getMediaType().getType(), request.getHttpHeaders().getMediaType().getSubtype());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bb24dbd5e987353118dd26bd445a158c01b0f47"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NjYyNg==", "bodyText": "@ronsigal  @patriot1burke The \"boundary\" parameter check and remove all parameters still can't stop the cache to be invalidated by GET request with ContentType=text/html;version=1~2500.\nI think we can directly disable this cache when the request ConteType contains parameter \"boundary\" or other items to make it less vulnerable. I already sent my change. Please review again.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r454886626", "createdAt": "2020-07-15T08:37:04Z", "author": {"login": "jimma"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {\n+               this.contentType = new MediaType(request.getHttpHeaders().getMediaType().getType(), request.getHttpHeaders().getMediaType().getSubtype());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxODQ2Mw=="}, "originalCommit": {"oid": "2bb24dbd5e987353118dd26bd445a158c01b0f47"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzODM4OA==", "bodyText": "I see - that's the change in RootNode which uses the cache only when there are no parameters. That seems like a reasonable heuristic.", "url": "https://github.com/resteasy/resteasy/pull/2471#discussion_r455438388", "createdAt": "2020-07-16T00:20:53Z", "author": {"login": "ronsigal"}, "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/registry/MatchCache.java", "diffHunk": "@@ -26,7 +26,11 @@ public Key(final HttpRequest request, final int start) {\n             this.path = start == 0 ? matchingPath : matchingPath.substring(start);\n             this.start = start;\n             this.method = request.getHttpMethod();\n-            this.contentType = request.getHttpHeaders().getMediaType();\n+            if (request.getHttpHeaders().getMediaType().getParameters().containsKey(\"boundary\")) {\n+               this.contentType = new MediaType(request.getHttpHeaders().getMediaType().getType(), request.getHttpHeaders().getMediaType().getSubtype());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxODQ2Mw=="}, "originalCommit": {"oid": "2bb24dbd5e987353118dd26bd445a158c01b0f47"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4907, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}