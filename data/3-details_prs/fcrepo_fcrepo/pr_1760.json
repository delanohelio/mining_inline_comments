{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NjE2NzYw", "number": 1760, "title": "FCREPO-3409 - DC membership index", "bodyText": "JIRA Ticket: https://jira.lyrasis.org/browse/FCREPO-3409\nWhat does this Pull Request do?\nAdds and populates a membership index, which tracks the membership history of resources.\nI'm not sure if a message should be emitted when membership changes, but there is not an existing test indicating so.\nHow should this be tested?\nThe application's behaviors should be unchanged from before since the service to add membership to responses has not been completed. I could update this PR to add it, but it was a separate ticket https://jira.lyrasis.org/browse/FCREPO-3165\nSo it should build and the new tests should pass.\nInterested parties\n@fcrepo4/committers", "createdAt": "2020-09-30T16:00:29Z", "url": "https://github.com/fcrepo/fcrepo/pull/1760", "merged": true, "mergeCommit": {"oid": "01278198200cae577835621f8d5136f99c444e26"}, "closed": true, "closedAt": "2020-10-05T20:47:03Z", "author": {"login": "bbpennel"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdODsG2AFqTQ5OTc1MzczNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdPqDKbAFqTUwMjQwNzAyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NzUzNzM3", "url": "https://github.com/fcrepo/fcrepo/pull/1760#pullrequestreview-499753737", "createdAt": "2020-09-30T19:40:53Z", "commit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxOTo0MDo1NFrOHasnNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMDowNzozNVrOHatdpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1NTk1Nw==", "bodyText": "Not sure but do you need the WHERE EXISTS clause as it seems identical to the above WHERE clause just with the addition of the \" AND mto.operation = :deleteOp\" + line. Could that be added to the original WHERE clause and the second one removed?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497755957", "createdAt": "2020-09-30T19:40:54Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1OTA0MQ==", "bodyText": "I saw this a couple places, just wondering if there is a benefit to passing a static string in versus just using 'delete' here? Same for the :addOp and 'add'?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497759041", "createdAt": "2020-09-30T19:46:48Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ==", "bodyText": "I think this needs the @Transactional annotation.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497762631", "createdAt": "2020-09-30T19:53:36Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);\n+\n+        // Add the new membership operation\n+        addMembership(txId, sourceId, membership, startTime, null);\n+    }\n+\n+    /**\n+     * Add new membership property to the index\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     * @param endTime time the membership triple ends, or never if not provided\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime, final Instant endTime) {\n+        final var endTimestamp = endTime == null ? NO_END_TIMESTAMP : Timestamp.from(endTime);\n+        // Add the new membership operation\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"targetId\", membership.getObject().getURI(),\n+                \"sourceId\", sourceId.getFullId(),\n+                \"startTime\", Timestamp.from(startTime),\n+                \"endTime\", endTimestamp,\n+                \"txId\", txId,\n+                \"operation\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(INSERT_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * Get a stream of membership triples with\n+     * @param txId transaction from which membership will be retrieved, or null for no transaction\n+     * @param subjectId ID of the subject\n+     * @return Stream of membership triples\n+     */\n+    public Stream<Triple> getMembership(final String txId, final FedoraId subjectId) {\n+        final Node subjectNode = NodeFactory.createURI(subjectId.getBaseId());\n+\n+        final RowMapper<Triple> membershipMapper = (rs, rowNum) ->\n+                Triple.create(subjectNode,\n+                              NodeFactory.createURI(rs.getString(\"property\")),\n+                              NodeFactory.createURI(rs.getString(\"object_id\")));\n+\n+        List<Triple> membership = null;\n+        if (txId == null) {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant());\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP, parameterSource, membershipMapper);\n+            }\n+        } else {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant(),\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO_IN_TX, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP,\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_IN_TX, parameterSource, membershipMapper);\n+            }\n+        }\n+\n+        return membership.stream();\n+    }\n+\n+    /**\n+     * Perform a commit of operations stored in the specified transaction\n+     * @param txId transaction id\n+     */\n+    public void commitTransaction(final String txId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2OTg5Mw==", "bodyText": "I must be reading this wrong. It appears that if you are not using auto versioning then any change to a direct container rebuilds its entire membership history?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497769893", "createdAt": "2020-09-30T20:07:35Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNDE4OTI3", "url": "https://github.com/fcrepo/fcrepo/pull/1760#pullrequestreview-500418927", "createdAt": "2020-10-01T14:39:30Z", "commit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDozOTozMFrOHbNoWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzo0OToyNFrOHbU-3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5NjkyMQ==", "bodyText": "Going forward, I think it would be better if we inject the config objects rather than directly from properties. It will make it easier if we don't have to search through the entire code base to find where a property is being accessed. You could either inject the config bean and programmatically access the value you want, or use a value annotation like @Value(\"#{configBeanName.autoVersioningEnabled}\").", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498296921", "createdAt": "2020-10-01T14:39:30Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4NzU2MQ==", "bodyText": "Missing an argument", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498387561", "createdAt": "2020-10-01T16:54:44Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDMyNQ==", "bodyText": "m2 is not used.\nI think this could also be rewritten like: .sorted(Comparator.comparing(m -> m.getFedoraId().getFullId()))", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498394325", "createdAt": "2020-10-01T17:07:10Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDc2OQ==", "bodyText": "Are you just trying to sort the mementos by date? If so, I think they should already be sorted.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498394769", "createdAt": "2020-10-01T17:07:59Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDMyNQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTYyOQ==", "bodyText": "Why are you using a while loop rather than a for loop?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498395629", "createdAt": "2020-10-01T17:09:37Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))\n+                .map(memento -> new DirectContainerProperties(memento))\n+                .collect(Collectors.toList());\n+\n+        // Reduce timeline to entries where significant properties change\n+        final var changeEntries = new ArrayList<DirectContainerProperties>();\n+        var curr = entryList.get(0);\n+        changeEntries.add(curr);\n+        int i = 1;\n+        while (i < entryList.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5ODg0MQ==", "bodyText": "I think you'll actually want a @Transactional at this level", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498398841", "createdAt": "2020-10-01T17:15:30Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTYxMQ==", "bodyText": "@Transactional", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498399611", "createdAt": "2020-10-01T17:16:51Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTc1MA==", "bodyText": "@Transactional", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498399750", "createdAt": "2020-10-01T17:17:07Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMTM5OA==", "bodyText": "Perhaps the column names should be constants?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498401398", "createdAt": "2020-10-01T17:20:12Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxNzM3NQ==", "bodyText": "I think there may be some oddness here when addMembership() is called after calling deleteMembershipForSource(), but it's possible that I just don't understand the intended behavior. The problem I see is that there are two different types of deletes, with or without the force flag. deleteMembershipForSource() creates deletes with the force flag, and I assume that you would always want to apply them. However, this method will delete all of these operations in the transaction, so they won't be applied. Won't this result in duplicate entries (assuming there aren't any db constraints being violated)? I think the case where this matters is MembershipServiceImpl#L104.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498417375", "createdAt": "2020-10-01T17:49:24Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 436}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a831edb1b0d09db43e149ee3a001a87cc74a7667", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/a831edb1b0d09db43e149ee3a001a87cc74a7667", "committedDate": "2020-10-01T18:58:35Z", "message": "Initial commit of membership service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dba75f7b807f66f66520ebbb29d098a2bb5d383", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/8dba75f7b807f66f66520ebbb29d098a2bb5d383", "committedDate": "2020-10-01T18:58:35Z", "message": "Implement getMembers for non-mementos, allow committing of transactions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fea69370a66740a1edfd1e8346ad088f8cc1bf8", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/4fea69370a66740a1edfd1e8346ad088f8cc1bf8", "committedDate": "2020-10-01T18:58:36Z", "message": "Implement and test modification of DirectContainers, adjustments to interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1a91ac78edb71b6e116d8d77557a2e62b83c6f5", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/a1a91ac78edb71b6e116d8d77557a2e62b83c6f5", "committedDate": "2020-10-01T18:58:36Z", "message": "Implement getting membership for mementos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67a562f490566e747b02609040a28bf5307f932f", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/67a562f490566e747b02609040a28bf5307f932f", "committedDate": "2020-10-01T18:59:19Z", "message": "Trigger membership indexing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2a6f8dd81dedb70029e09d1f5e2bcf16081ef45", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/f2a6f8dd81dedb70029e09d1f5e2bcf16081ef45", "committedDate": "2020-10-01T18:59:19Z", "message": "Return empty list for getUserTypes() if the resource is deleted and the user rdf is not present"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db11116944ed6a090bac017f1e38292f9f581ff3", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/db11116944ed6a090bac017f1e38292f9f581ff3", "committedDate": "2020-10-01T19:00:09Z", "message": "Handle resources being purged. Fix up tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f88e38f798a2450f3ddca5070101aeda5d04a9c1", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/f88e38f798a2450f3ddca5070101aeda5d04a9c1", "committedDate": "2020-10-01T19:00:09Z", "message": "Mysql membership config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f10d32395643baba8e38eb614638bca2ec286bf", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/4f10d32395643baba8e38eb614638bca2ec286bf", "committedDate": "2020-10-01T19:00:09Z", "message": "Rebuild membership index during a rebuild"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80756127756820e1ad464e87b6d2d7bc286434de", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/80756127756820e1ad464e87b6d2d7bc286434de", "committedDate": "2020-10-01T19:00:09Z", "message": "Handle modifications of DCs with autoversioning disabled by regenerating the index for that DC. Differentiate between 'end' and 'delete' more consistently."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34a67b4917396f2cbbd83e23b1421c5b04f1cb01", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/34a67b4917396f2cbbd83e23b1421c5b04f1cb01", "committedDate": "2020-10-01T19:00:09Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4abc61e19d78e7b9acc9282d0c6c00624649361", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/e4abc61e19d78e7b9acc9282d0c6c00624649361", "committedDate": "2020-10-01T19:00:09Z", "message": "Add primary key to avoid max primary key length error in some dbs. Other adjustments to accomodate specific db requirements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c18bac31a4b0ef9ab37ad43b5859782cf591d5d", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/8c18bac31a4b0ef9ab37ad43b5859782cf591d5d", "committedDate": "2020-10-01T19:00:09Z", "message": "Adjustments for dbs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed94142905c43c7eedac4f9233b8e0ef68289b1a", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/ed94142905c43c7eedac4f9233b8e0ef68289b1a", "committedDate": "2020-10-01T19:00:09Z", "message": "Reduce fields in index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50004a2d5f82fc75eb729a5f040e8a8edca6bb67", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/50004a2d5f82fc75eb729a5f040e8a8edca6bb67", "committedDate": "2020-10-01T19:00:09Z", "message": "Update index for mysql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51cf5f15f9f7a9e9e8493f656cee4627e7a8f3ff", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/51cf5f15f9f7a9e9e8493f656cee4627e7a8f3ff", "committedDate": "2020-10-01T19:00:09Z", "message": "Address feedback and some mysql issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edbbd407825cea0b6df5188a761cd43e52783351", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/edbbd407825cea0b6df5188a761cd43e52783351", "committedDate": "2020-10-01T19:00:09Z", "message": "Datetime for date fields in mariadb and mysql, timestamp for postgres and h2"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/a64c47de676a72456a64bcef747fffb7b3890cc5", "committedDate": "2020-10-01T12:53:29Z", "message": "Update index for mysql"}, "afterCommit": {"oid": "edbbd407825cea0b6df5188a761cd43e52783351", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/edbbd407825cea0b6df5188a761cd43e52783351", "committedDate": "2020-10-01T19:00:09Z", "message": "Datetime for date fields in mariadb and mysql, timestamp for postgres and h2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da3b4a13493ea6d7129ed42633135514727fecc8", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/da3b4a13493ea6d7129ed42633135514727fecc8", "committedDate": "2020-10-01T19:34:22Z", "message": "Use constants for parameter names, use OcflPropsConfig for getting autoversioning state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22e9c047d602ebb0cc870d5f66372241095ff6e0", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/22e9c047d602ebb0cc870d5f66372241095ff6e0", "committedDate": "2020-10-01T20:41:08Z", "message": "Fix word order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04b837f99591584b495aec00da3b83b626ae3014", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/04b837f99591584b495aec00da3b83b626ae3014", "committedDate": "2020-10-02T18:01:11Z", "message": "Return TimeMap from getTimeMap. Timemap now has method for getting a list of version times"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9422e6203b8521bff2df7b159327a34f5215b358", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/9422e6203b8521bff2df7b159327a34f5215b358", "committedDate": "2020-10-02T18:05:00Z", "message": "Perform more selective reindexing when a DC is modified with on demand versioning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/be16c5850f662ae201dfce45866f6d65d2b8bf8b", "committedDate": "2020-10-05T14:00:17Z", "message": "Add transactional to indexManager methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMDkxNTk5", "url": "https://github.com/fcrepo/fcrepo/pull/1760#pullrequestreview-502091599", "createdAt": "2020-10-05T14:05:55Z", "commit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMTg4MzY3", "url": "https://github.com/fcrepo/fcrepo/pull/1760#pullrequestreview-502188367", "createdAt": "2020-10-05T15:44:42Z", "commit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNTo0NDo0M1rOHcjDdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozMjo1MFrOHcm_zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NjUwMw==", "bodyText": "To be clear, this SQL deletes membership relations when the provided dateTime is either before (or at) the \"start_time\" of the relationship or the provided dateTime is before (or at) the \"end_time\" of the relationship?\nIt probably makes sense... I am just trying to understand the scenario.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499696503", "createdAt": "2020-10-05T15:44:43Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MzI3OA==", "bodyText": "Can this method be removed? It does not appear to be called anywhere.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499743278", "createdAt": "2020-10-05T17:00:21Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/mariadb-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    @Transactional\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                TX_ID_PARAM, txId,\n+                SOURCE_ID_PARAM, sourceId.getFullId(),\n+                SUBJECT_ID_PARAM, membership.getSubject().getURI(),\n+                PROPERTY_PARAM, membership.getPredicate().getURI(),\n+                OBJECT_ID_PARAM, membership.getObject().getURI(),\n+                OPERATION_PARAM, ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    TX_ID_PARAM, txId,\n+                    SOURCE_ID_PARAM, sourceId.getFullId(),\n+                    SUBJECT_ID_PARAM, membership.getSubject().getURI(),\n+                    PROPERTY_PARAM, membership.getPredicate().getURI(),\n+                    OBJECT_ID_PARAM, membership.getObject().getURI(),\n+                    END_TIME_PARAM, Timestamp.from(endTime),\n+                    NO_END_TIME_PARAM, NO_END_TIMESTAMP,\n+                    DELETE_OP_PARAM, DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NTk4Mw==", "bodyText": "txId never used.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499755983", "createdAt": "2020-10-05T17:23:23Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import javax.transaction.Transactional;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Inject\n+    private OcflPropsConfig propsConfig;\n+\n+    @Override\n+    @Transactional\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            if (propsConfig.isAutoVersioningEnabled()) {\n+                modifyDCAutoversioned(txId, fedoraResc);\n+            } else {\n+                modifyDCOnDemandVersioning(txId, fedoraResc);\n+            }\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private void modifyDCAutoversioned(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var dcRdfResc = getRdfResource(dcResc);\n+\n+        final var dcLastModified = dcResc.getLastModifiedDate();\n+\n+        // Delete/end existing membership from this container\n+        indexManager.endMembershipForSource(txId, dcResc.getFedoraId(), dcLastModified);\n+\n+        // Add updated membership properties for all non-tombstone children\n+        dcResc.getChildren()\n+                .filter(child -> !(child instanceof Tombstone))\n+                .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                .forEach(newMembership -> indexManager.addMembership(txId, dcId,\n+                        newMembership, dcLastModified));\n+    }\n+\n+    private void modifyDCOnDemandVersioning(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var mementoDatetimes = dcResc.getTimeMap().listMementoDatetimes();\n+        final Instant lastVersionDatetime;\n+        if (mementoDatetimes.size() == 0) {\n+            // If no previous versions of DC, then cleanup and repopulate everything\n+            lastVersionDatetime = null;\n+        } else {\n+            // If at least one past version, then reindex membership involving the last version and after\n+            lastVersionDatetime = mementoDatetimes.get(mementoDatetimes.size() - 1);\n+        }\n+        indexManager.deleteMembershipForSourceAfter(txId, dcId, lastVersionDatetime);\n+        populateMembershipHistory(txId, dcResc, lastVersionDatetime);\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTEwMQ==", "bodyText": "Maybe add a , between \"{}\" and \"member\"?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499761101", "createdAt": "2020-10-05T17:32:50Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import javax.transaction.Transactional;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Inject\n+    private OcflPropsConfig propsConfig;\n+\n+    @Override\n+    @Transactional\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            if (propsConfig.isAutoVersioningEnabled()) {\n+                modifyDCAutoversioned(txId, fedoraResc);\n+            } else {\n+                modifyDCOnDemandVersioning(txId, fedoraResc);\n+            }\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private void modifyDCAutoversioned(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var dcRdfResc = getRdfResource(dcResc);\n+\n+        final var dcLastModified = dcResc.getLastModifiedDate();\n+\n+        // Delete/end existing membership from this container\n+        indexManager.endMembershipForSource(txId, dcResc.getFedoraId(), dcLastModified);\n+\n+        // Add updated membership properties for all non-tombstone children\n+        dcResc.getChildren()\n+                .filter(child -> !(child instanceof Tombstone))\n+                .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                .forEach(newMembership -> indexManager.addMembership(txId, dcId,\n+                        newMembership, dcLastModified));\n+    }\n+\n+    private void modifyDCOnDemandVersioning(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var mementoDatetimes = dcResc.getTimeMap().listMementoDatetimes();\n+        final Instant lastVersionDatetime;\n+        if (mementoDatetimes.size() == 0) {\n+            // If no previous versions of DC, then cleanup and repopulate everything\n+            lastVersionDatetime = null;\n+        } else {\n+            // If at least one past version, then reindex membership involving the last version and after\n+            lastVersionDatetime = mementoDatetimes.get(mementoDatetimes.size() - 1);\n+        }\n+        indexManager.deleteMembershipForSourceAfter(txId, dcId, lastVersionDatetime);\n+        populateMembershipHistory(txId, dcResc, lastVersionDatetime);\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\", fedoraId);\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            populateMembershipHistory(txId, fedoraResc, null);\n+        }\n+    }\n+\n+    private void populateMembershipHistory(final String txId, final FedoraResource fedoraResc,\n+            final Instant afterTime) {\n+        final var containerId = fedoraResc.getFedoraId();\n+        final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+        final List<DirectContainerProperties> timeline;\n+        // If provided, filter the timeline to just entries active on or after the specified time\n+        if (afterTime != null) {\n+            timeline = propertyTimeline.stream().filter(e -> e.startDatetime.compareTo(afterTime) >= 0\n+                    || e.endDatetime.compareTo(afterTime) >= 0)\n+                .collect(Collectors.toList());\n+        } else {\n+            timeline = propertyTimeline;\n+        }\n+\n+        // get all the members of the DC and index the history for each, accounting for changes to the DC\n+        fedoraResc.getChildren().forEach(member -> {\n+            final var memberDeleted = member instanceof Tombstone;\n+            final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+            log.debug(\"Populating membership history for DirectContainer {}member {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 314}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a421b4d36ea5e0fc3f94dae05234ac000c51b25f", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/fcrepo/fcrepo/commit/a421b4d36ea5e0fc3f94dae05234ac000c51b25f", "committedDate": "2020-10-05T19:11:00Z", "message": "Remove unused parameter and method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNDA3MDIz", "url": "https://github.com/fcrepo/fcrepo/pull/1760#pullrequestreview-502407023", "createdAt": "2020-10-05T20:45:34Z", "commit": {"oid": "a421b4d36ea5e0fc3f94dae05234ac000c51b25f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2963, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}