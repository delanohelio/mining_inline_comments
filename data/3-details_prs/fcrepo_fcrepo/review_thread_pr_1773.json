{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMTYxNTM3", "number": 1773, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoyODoyMlrOEsnFaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMjowNTozNlrOEtAXiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjEzMTYwOnYy", "diffSide": "RIGHT", "path": "fcrepo-search-impl/src/main/java/org/fcrepo/search/impl/DbSearchIndexImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoyODoyMlrOHf8m3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNTowNTowNVrOHgCjog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MDg5Mg==", "bodyText": "As you noted, this can fail if multiple threads attempt to concurrently add the same types. Does it not throw an exception in that case? If so, I think you could safely swallow it and proceed because you'll get a failure on line 394 if the types weren't actually created.", "url": "https://github.com/fcrepo/fcrepo/pull/1773#discussion_r503260892", "createdAt": "2020-10-12T12:28:22Z", "author": {"login": "pwinckles"}, "path": "fcrepo-search-impl/src/main/java/org/fcrepo/search/impl/DbSearchIndexImpl.java", "diffHunk": "@@ -346,33 +363,69 @@ private void deleteRdfTypeAssociations(final Long resourceId) {\n                 deleteParams);\n     }\n \n-    private ArrayList<Long> findOrCreateRdfTypesInDb(final List<URI> rdfTypes) {\n-        final var jdbcInsertRdfTypes = new SimpleJdbcInsert(this.jdbcTemplate.getJdbcTemplate());\n-        jdbcInsertRdfTypes.withTableName(SEARCH_RDF_TYPE_TABLE).usingGeneratedKeyColumns(\n-                ID_COLUMN);\n-        final var rdfTypeIds = new ArrayList<Long>();\n-        for (var rdfTypeUri : rdfTypes) {\n-            final var typeParams = new MapSqlParameterSource();\n-            typeParams.addValue(RDF_TYPE_URI_PARAM, rdfTypeUri.toString());\n-            final var results = jdbcTemplate.queryForList(SELECT_RDF_TYPE_ID,\n-                    typeParams);\n-            if (CollectionUtils.isEmpty(results)) {\n-                final Number key = jdbcInsertRdfTypes.executeAndReturnKey(typeParams);\n-                rdfTypeIds.add(key.longValue());\n-            } else {\n-                rdfTypeIds.add((long) results.get(0).get(ID_COLUMN));\n+    private List<Long> findOrCreateRdfTypesInDb(final List<URI> rdfTypes) {\n+        final List<String> rdfTypes_str = rdfTypes.stream().map(URI::toString).collect(Collectors.toList());\n+\n+        final List<RdfType> results = jdbcTemplate.query(SELECT_RDF_TYPE_ID,\n+                Map.of(RDF_TYPE_URI_PARAM, rdfTypes_str), RDF_TYPE_ROW_MAPPER);\n+        // List of existing type ids.\n+        final var rdfTypeIds = results.stream().map(RdfType::getTypeId).collect(Collectors.toList());\n+        // List of existing type uris.\n+        final var rdfTypeUris = results.stream().map(RdfType::getTypeUri).collect(Collectors.toList());\n+        // Type uris that don't already have a record. Needs to be a set to avoid inserting the same URI and\n+        final var missingUris = rdfTypes_str.stream().filter(t -> !rdfTypeUris.contains(t))\n+                .collect(Collectors.toSet());\n+\n+        if (!missingUris.isEmpty()) {\n+            final List<MapSqlParameterSource> parameterSourcesList = new ArrayList<>();\n+            missingUris.forEach(u -> {\n+                final var assocParams = new MapSqlParameterSource();\n+                assocParams.addValue(RDF_TYPE_URI_PARAM, u);\n+                LOGGER.debug(\"Adding rdf type uri: \" + u);\n+                parameterSourcesList.add(assocParams);\n+            });\n+            final MapSqlParameterSource[] psArray = parameterSourcesList.toArray(new MapSqlParameterSource[0]);\n+            // Batch insert all the records.\n+            jdbcTemplate.batchUpdate(INSERT_RDF_TYPE, psArray);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c016b404e3090e524eb72cbe2dc485ab7ec6f0a"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM0NjcyMw==", "bodyText": "What happens if there are two concurrent requests, one is inserting types A, B, and C and the other is inserting B, C, and D? Since it's a batch update, will the end result be that the database either contains A, B, and C or B, C, and D? Or will it contain all of the types?", "url": "https://github.com/fcrepo/fcrepo/pull/1773#discussion_r503346723", "createdAt": "2020-10-12T14:46:58Z", "author": {"login": "pwinckles"}, "path": "fcrepo-search-impl/src/main/java/org/fcrepo/search/impl/DbSearchIndexImpl.java", "diffHunk": "@@ -346,33 +363,69 @@ private void deleteRdfTypeAssociations(final Long resourceId) {\n                 deleteParams);\n     }\n \n-    private ArrayList<Long> findOrCreateRdfTypesInDb(final List<URI> rdfTypes) {\n-        final var jdbcInsertRdfTypes = new SimpleJdbcInsert(this.jdbcTemplate.getJdbcTemplate());\n-        jdbcInsertRdfTypes.withTableName(SEARCH_RDF_TYPE_TABLE).usingGeneratedKeyColumns(\n-                ID_COLUMN);\n-        final var rdfTypeIds = new ArrayList<Long>();\n-        for (var rdfTypeUri : rdfTypes) {\n-            final var typeParams = new MapSqlParameterSource();\n-            typeParams.addValue(RDF_TYPE_URI_PARAM, rdfTypeUri.toString());\n-            final var results = jdbcTemplate.queryForList(SELECT_RDF_TYPE_ID,\n-                    typeParams);\n-            if (CollectionUtils.isEmpty(results)) {\n-                final Number key = jdbcInsertRdfTypes.executeAndReturnKey(typeParams);\n-                rdfTypeIds.add(key.longValue());\n-            } else {\n-                rdfTypeIds.add((long) results.get(0).get(ID_COLUMN));\n+    private List<Long> findOrCreateRdfTypesInDb(final List<URI> rdfTypes) {\n+        final List<String> rdfTypes_str = rdfTypes.stream().map(URI::toString).collect(Collectors.toList());\n+\n+        final List<RdfType> results = jdbcTemplate.query(SELECT_RDF_TYPE_ID,\n+                Map.of(RDF_TYPE_URI_PARAM, rdfTypes_str), RDF_TYPE_ROW_MAPPER);\n+        // List of existing type ids.\n+        final var rdfTypeIds = results.stream().map(RdfType::getTypeId).collect(Collectors.toList());\n+        // List of existing type uris.\n+        final var rdfTypeUris = results.stream().map(RdfType::getTypeUri).collect(Collectors.toList());\n+        // Type uris that don't already have a record. Needs to be a set to avoid inserting the same URI and\n+        final var missingUris = rdfTypes_str.stream().filter(t -> !rdfTypeUris.contains(t))\n+                .collect(Collectors.toSet());\n+\n+        if (!missingUris.isEmpty()) {\n+            final List<MapSqlParameterSource> parameterSourcesList = new ArrayList<>();\n+            missingUris.forEach(u -> {\n+                final var assocParams = new MapSqlParameterSource();\n+                assocParams.addValue(RDF_TYPE_URI_PARAM, u);\n+                LOGGER.debug(\"Adding rdf type uri: \" + u);\n+                parameterSourcesList.add(assocParams);\n+            });\n+            final MapSqlParameterSource[] psArray = parameterSourcesList.toArray(new MapSqlParameterSource[0]);\n+            // Batch insert all the records.\n+            jdbcTemplate.batchUpdate(INSERT_RDF_TYPE, psArray);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MDg5Mg=="}, "originalCommit": {"oid": "3c016b404e3090e524eb72cbe2dc485ab7ec6f0a"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1ODM3MA==", "bodyText": "It looks like we need to go back and use the standard jdbc batch which should return a BatchUpdateException and return success and failure counts. I'll give this a try next", "url": "https://github.com/fcrepo/fcrepo/pull/1773#discussion_r503358370", "createdAt": "2020-10-12T15:05:05Z", "author": {"login": "whikloj"}, "path": "fcrepo-search-impl/src/main/java/org/fcrepo/search/impl/DbSearchIndexImpl.java", "diffHunk": "@@ -346,33 +363,69 @@ private void deleteRdfTypeAssociations(final Long resourceId) {\n                 deleteParams);\n     }\n \n-    private ArrayList<Long> findOrCreateRdfTypesInDb(final List<URI> rdfTypes) {\n-        final var jdbcInsertRdfTypes = new SimpleJdbcInsert(this.jdbcTemplate.getJdbcTemplate());\n-        jdbcInsertRdfTypes.withTableName(SEARCH_RDF_TYPE_TABLE).usingGeneratedKeyColumns(\n-                ID_COLUMN);\n-        final var rdfTypeIds = new ArrayList<Long>();\n-        for (var rdfTypeUri : rdfTypes) {\n-            final var typeParams = new MapSqlParameterSource();\n-            typeParams.addValue(RDF_TYPE_URI_PARAM, rdfTypeUri.toString());\n-            final var results = jdbcTemplate.queryForList(SELECT_RDF_TYPE_ID,\n-                    typeParams);\n-            if (CollectionUtils.isEmpty(results)) {\n-                final Number key = jdbcInsertRdfTypes.executeAndReturnKey(typeParams);\n-                rdfTypeIds.add(key.longValue());\n-            } else {\n-                rdfTypeIds.add((long) results.get(0).get(ID_COLUMN));\n+    private List<Long> findOrCreateRdfTypesInDb(final List<URI> rdfTypes) {\n+        final List<String> rdfTypes_str = rdfTypes.stream().map(URI::toString).collect(Collectors.toList());\n+\n+        final List<RdfType> results = jdbcTemplate.query(SELECT_RDF_TYPE_ID,\n+                Map.of(RDF_TYPE_URI_PARAM, rdfTypes_str), RDF_TYPE_ROW_MAPPER);\n+        // List of existing type ids.\n+        final var rdfTypeIds = results.stream().map(RdfType::getTypeId).collect(Collectors.toList());\n+        // List of existing type uris.\n+        final var rdfTypeUris = results.stream().map(RdfType::getTypeUri).collect(Collectors.toList());\n+        // Type uris that don't already have a record. Needs to be a set to avoid inserting the same URI and\n+        final var missingUris = rdfTypes_str.stream().filter(t -> !rdfTypeUris.contains(t))\n+                .collect(Collectors.toSet());\n+\n+        if (!missingUris.isEmpty()) {\n+            final List<MapSqlParameterSource> parameterSourcesList = new ArrayList<>();\n+            missingUris.forEach(u -> {\n+                final var assocParams = new MapSqlParameterSource();\n+                assocParams.addValue(RDF_TYPE_URI_PARAM, u);\n+                LOGGER.debug(\"Adding rdf type uri: \" + u);\n+                parameterSourcesList.add(assocParams);\n+            });\n+            final MapSqlParameterSource[] psArray = parameterSourcesList.toArray(new MapSqlParameterSource[0]);\n+            // Batch insert all the records.\n+            jdbcTemplate.batchUpdate(INSERT_RDF_TYPE, psArray);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MDg5Mg=="}, "originalCommit": {"oid": "3c016b404e3090e524eb72cbe2dc485ab7ec6f0a"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NjI3NDAxOnYy", "diffSide": "RIGHT", "path": "fcrepo-search-impl/src/main/java/org/fcrepo/search/impl/DbSearchIndexImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMjowNTozNlrOHgjVtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMjowNTozNlrOHgjVtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5NTQ3Ng==", "bodyText": "Doesn't matter that much because I suspect we're only ever dealing with a handful of types, but this can be optimized a little:\nfinal var rdfTypeIds = new ArrayList<Long>(rdfTypes.size());\nfinal var rdfTypeUris = new HashSet<String>();\n\nfor (final var type : results) {\n    rdfTypeIds.add(type.getTypeId());\n    rdfTypeUris.add(type.getTypeUri());\n}\n\nfinal var missingUris = rdfTypes.stream().map(URI::toString).filter(t -> !rdfTypeUris.contains(t)).collect(Collectors.toSet());", "url": "https://github.com/fcrepo/fcrepo/pull/1773#discussion_r503895476", "createdAt": "2020-10-13T12:05:36Z", "author": {"login": "pwinckles"}, "path": "fcrepo-search-impl/src/main/java/org/fcrepo/search/impl/DbSearchIndexImpl.java", "diffHunk": "@@ -346,33 +376,69 @@ private void deleteRdfTypeAssociations(final Long resourceId) {\n                 deleteParams);\n     }\n \n-    private ArrayList<Long> findOrCreateRdfTypesInDb(final List<URI> rdfTypes) {\n-        final var jdbcInsertRdfTypes = new SimpleJdbcInsert(this.jdbcTemplate.getJdbcTemplate());\n-        jdbcInsertRdfTypes.withTableName(SEARCH_RDF_TYPE_TABLE).usingGeneratedKeyColumns(\n-                ID_COLUMN);\n-        final var rdfTypeIds = new ArrayList<Long>();\n-        for (var rdfTypeUri : rdfTypes) {\n-            final var typeParams = new MapSqlParameterSource();\n-            typeParams.addValue(RDF_TYPE_URI_PARAM, rdfTypeUri.toString());\n-            final var results = jdbcTemplate.queryForList(SELECT_RDF_TYPE_ID,\n-                    typeParams);\n-            if (CollectionUtils.isEmpty(results)) {\n-                final Number key = jdbcInsertRdfTypes.executeAndReturnKey(typeParams);\n-                rdfTypeIds.add(key.longValue());\n-            } else {\n-                rdfTypeIds.add((long) results.get(0).get(ID_COLUMN));\n+    private List<Long> findOrCreateRdfTypesInDb(final List<URI> rdfTypes) {\n+        final List<String> rdfTypes_str = rdfTypes.stream().map(URI::toString).collect(Collectors.toList());\n+\n+        final List<RdfType> results = jdbcTemplate.query(SELECT_RDF_TYPE_ID,\n+                Map.of(RDF_TYPE_URI_PARAM, rdfTypes_str), RDF_TYPE_ROW_MAPPER);\n+        // List of existing type ids.\n+        final var rdfTypeIds = results.stream().map(RdfType::getTypeId).collect(Collectors.toList());\n+        // List of existing type uris.\n+        final var rdfTypeUris = results.stream().map(RdfType::getTypeUri).collect(Collectors.toList());\n+        // Type uris that don't already have a record. Needs to be a set to avoid inserting the same URI and\n+        final var missingUris = rdfTypes_str.stream().filter(t -> !rdfTypeUris.contains(t))\n+                .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ed7af2db94e65734d69b0068908b913222e543a"}, "originalPosition": 231}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1685, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}