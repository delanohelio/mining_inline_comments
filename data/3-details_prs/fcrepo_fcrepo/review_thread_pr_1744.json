{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3Mjg4OTAy", "number": 1744, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzowMDo0NlrOEfcWjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo0OTo1M1rOEgIidA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDA1ODM3OnYy", "diffSide": "RIGHT", "path": "fcrepo-http-api/src/test/java/org/fcrepo/integration/http/api/FedoraVersioningIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzowMDo0NlrOHLt9kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowNDowNlrOHMll9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0OTQyNQ==", "bodyText": "It seems like the goal is to ensure that the session factory defaults to NEW_VERSION for all tests. Rather than lots of finally blocks, would it make sense to call objectSessionFactory.setDefaultCommitType(CommitType.NEW_VERSION); in a @After method?", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482049425", "createdAt": "2020-09-02T13:00:46Z", "author": {"login": "bbpennel"}, "path": "fcrepo-http-api/src/test/java/org/fcrepo/integration/http/api/FedoraVersioningIT.java", "diffHunk": "@@ -240,21 +241,26 @@ public void getTimeMapFromAgWithChildrenWithDifferentVersions() throws Exception\n \n     @Test\n     public void getMementoFromAgChild() throws Exception {\n-        final var childId1 = id + \"/child1\";\n+        objectSessionFactory.setDefaultCommitType(CommitType.UNVERSIONED);\n+        try {\n+            final var childId1 = id + \"/child1\";\n \n-        createVersionedArchivalGroup(id);\n-        createMemento(subjectUri);\n-        TimeUnit.SECONDS.sleep(1);\n+            createVersionedArchivalGroup(id);\n+            createMemento(subjectUri);\n+            TimeUnit.SECONDS.sleep(1);\n \n-        putVersionedBinary(childId1, OCTET_STREAM_TYPE, \"v2\", false);\n-        final var mementoUri = createMemento(subjectUri);\n-        final var mementoTime = mementoUri.substring(mementoUri.lastIndexOf(\"/\"));\n+            putVersionedBinary(childId1, OCTET_STREAM_TYPE, \"v2\", false);\n+            final var mementoUri = createMemento(subjectUri);\n+            final var mementoTime = mementoUri.substring(mementoUri.lastIndexOf(\"/\"));\n \n-        final HttpGet httpGet = new HttpGet(subjectUri + \"/child1/fcr:versions\" + mementoTime);\n-        try (final CloseableHttpResponse response = execute(httpGet)) {\n-            assertMementoDatetimeHeaderMatches(response, now());\n-            assertEquals(\"Binary content of memento must match original content\",\n-                    \"v2\", EntityUtils.toString(response.getEntity()));\n+            final HttpGet httpGet = new HttpGet(subjectUri + \"/child1/fcr:versions\" + mementoTime);\n+            try (final CloseableHttpResponse response = execute(httpGet)) {\n+                assertMementoDatetimeHeaderMatches(response, now());\n+                assertEquals(\"Binary content of memento must match original content\",\n+                        \"v2\", EntityUtils.toString(response.getEntity()));\n+            }\n+        } finally {\n+            objectSessionFactory.setDefaultCommitType(CommitType.NEW_VERSION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MDg4Ng==", "bodyText": "done", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482960886", "createdAt": "2020-09-03T13:04:06Z", "author": {"login": "pwinckles"}, "path": "fcrepo-http-api/src/test/java/org/fcrepo/integration/http/api/FedoraVersioningIT.java", "diffHunk": "@@ -240,21 +241,26 @@ public void getTimeMapFromAgWithChildrenWithDifferentVersions() throws Exception\n \n     @Test\n     public void getMementoFromAgChild() throws Exception {\n-        final var childId1 = id + \"/child1\";\n+        objectSessionFactory.setDefaultCommitType(CommitType.UNVERSIONED);\n+        try {\n+            final var childId1 = id + \"/child1\";\n \n-        createVersionedArchivalGroup(id);\n-        createMemento(subjectUri);\n-        TimeUnit.SECONDS.sleep(1);\n+            createVersionedArchivalGroup(id);\n+            createMemento(subjectUri);\n+            TimeUnit.SECONDS.sleep(1);\n \n-        putVersionedBinary(childId1, OCTET_STREAM_TYPE, \"v2\", false);\n-        final var mementoUri = createMemento(subjectUri);\n-        final var mementoTime = mementoUri.substring(mementoUri.lastIndexOf(\"/\"));\n+            putVersionedBinary(childId1, OCTET_STREAM_TYPE, \"v2\", false);\n+            final var mementoUri = createMemento(subjectUri);\n+            final var mementoTime = mementoUri.substring(mementoUri.lastIndexOf(\"/\"));\n \n-        final HttpGet httpGet = new HttpGet(subjectUri + \"/child1/fcr:versions\" + mementoTime);\n-        try (final CloseableHttpResponse response = execute(httpGet)) {\n-            assertMementoDatetimeHeaderMatches(response, now());\n-            assertEquals(\"Binary content of memento must match original content\",\n-                    \"v2\", EntityUtils.toString(response.getEntity()));\n+            final HttpGet httpGet = new HttpGet(subjectUri + \"/child1/fcr:versions\" + mementoTime);\n+            try (final CloseableHttpResponse response = execute(httpGet)) {\n+                assertMementoDatetimeHeaderMatches(response, now());\n+                assertEquals(\"Binary content of memento must match original content\",\n+                        \"v2\", EntityUtils.toString(response.getEntity()));\n+            }\n+        } finally {\n+            objectSessionFactory.setDefaultCommitType(CommitType.NEW_VERSION);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0OTQyNQ=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDIxOTM1OnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/CreateResourceServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzozNzoyMFrOHLvgNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDoyODoxOFrOHMEgaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3NDY3Nw==", "bodyText": "Creating the description after the binary is probably fine, just curious if there were specific reasons for the change?", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482074677", "createdAt": "2020-09-02T13:37:20Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/CreateResourceServiceImpl.java", "diffHunk": "@@ -132,6 +129,8 @@ public void perform(final String txId, final String userPrincipal, final FedoraI\n \n         try {\n             pSession.persist(createOp);\n+            // Populate the description for the new binary\n+            createDescription(pSession, userPrincipal, fedoraId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQxODc5Mg==", "bodyText": "Yes, the binary must be created before its description. It is now a hard requirement now that a parent must be created before its children, if they are stored within the same OCFL object.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482418792", "createdAt": "2020-09-02T20:28:18Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/CreateResourceServiceImpl.java", "diffHunk": "@@ -132,6 +129,8 @@ public void perform(final String txId, final String userPrincipal, final FedoraI\n \n         try {\n             pSession.persist(createOp);\n+            // Populate the description for the new binary\n+            createDescription(pSession, userPrincipal, fedoraId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3NDY3Nw=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDMzOTc4OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ResourceHeadersAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDowMjo1OFrOHLwrfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDozMDozMlrOHMEsBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA5Mzk1MA==", "bodyText": "Is the need for this structure due to not having a common interface for ResourceHeaders between core and the storage module, or are there other functional differences? I guess the options are to either tightly couple the two projects by separating out some common interfaces into another storage/kernal api module, or to keep them loosely coupled via an adapter. Judging by this PR, the ResourceHeaders and exceptions seem to be the main interfaces that are missing, so I can see how another module would seem like overkill at the moment. I just worry a bit about remembering to maintain the bidirectional field setup if headers change, but hopefully they are pretty stable.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482093950", "createdAt": "2020-09-02T14:02:58Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ResourceHeadersAdapter.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.persistence.common.ResourceHeadersImpl;\n+\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Objects;\n+\n+/**\n+ * Adapter for converting between different ResourceHeader implementations.\n+ *\n+ * @author pwinckles\n+ */\n+public class ResourceHeadersAdapter implements ResourceHeaders {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyMTc2NQ==", "bodyText": "Yes, your analysis is correct, and I agree with your observations. I would propose that we proceed with the adapter in this PR, and do a subsequent PR to extract a common interface, if that is the direction we decide to go.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482421765", "createdAt": "2020-09-02T20:30:32Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ResourceHeadersAdapter.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.persistence.common.ResourceHeadersImpl;\n+\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Objects;\n+\n+/**\n+ * Adapter for converting between different ResourceHeader implementations.\n+ *\n+ * @author pwinckles\n+ */\n+public class ResourceHeadersAdapter implements ResourceHeaders {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA5Mzk1MA=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDgxNjMzOnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTozODo0NVrOHL1VOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowNDo0NVrOHMlngA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDE2OQ==", "bodyText": "Obviously it won't change in this PR, but perhaps the close method shouldn't throw Exception? I think you can override the signature of the close method within the object session interface to remove the exception, or change it to a different one", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482170169", "createdAt": "2020-09-02T15:38:45Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -97,16 +83,21 @@ private void rebuild() {\n         searchIndex.reset();\n \n         final var txId = UUID.randomUUID().toString();\n-        final var stagingDir = createStagingDir(txId);\n \n         try {\n             LOGGER.debug(\"Reading object ids...\");\n \n             try (final var ocflIds = ocflRepository.listObjectIds()) {\n                 ocflIds.forEach(ocflId -> {\n                     LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.create(ocflId, stagingDir)) {\n+                    try (var session = objectSessionFactory.newSession(ocflId)) {\n                         indexOcflObject(ocflId, txId, session);\n+                    } catch (Exception e) {\n+                        // The session's close method signature throws Exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MTI4MA==", "bodyText": "Yes, this is a fair point. I will make the change after this pr", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482961280", "createdAt": "2020-09-03T13:04:45Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -97,16 +83,21 @@ private void rebuild() {\n         searchIndex.reset();\n \n         final var txId = UUID.randomUUID().toString();\n-        final var stagingDir = createStagingDir(txId);\n \n         try {\n             LOGGER.debug(\"Reading object ids...\");\n \n             try (final var ocflIds = ocflRepository.listObjectIds()) {\n                 ocflIds.forEach(ocflId -> {\n                     LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.create(ocflId, stagingDir)) {\n+                    try (var session = objectSessionFactory.newSession(ocflId)) {\n                         indexOcflObject(ocflId, txId, session);\n+                    } catch (Exception e) {\n+                        // The session's close method signature throws Exception", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDE2OQ=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDgzNTE3OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo0Mjo0N1rOHL1gxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowNDo1MlrOHMln2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MzEyNg==", "bodyText": "Any reason not to merge this if with the one wrapping it? Seems to be an and with no other routes.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482173126", "createdAt": "2020-09-02T15:42:47Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -129,75 +120,60 @@ private void rebuild() {\n                 return null;\n             });\n             throw e;\n-        } finally {\n-            cleanupStaging(stagingDir);\n         }\n     }\n \n     private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        try (final var subpaths = session.listHeadSubpaths()) {\n-            final var rootId = new AtomicReference<FedoraId>();\n-            final var fedoraIds = new ArrayList<FedoraId>();\n-            final var headersList = new ArrayList<ResourceHeaders>();\n-            subpaths.forEach(subpath -> {\n-                if (PersistencePaths.isHeaderFile(subpath)) {\n-                    //we're only interested in sidecar subpaths\n-                    try {\n-                        final var headers = deserializeHeaders(session.read(subpath));\n-                        final var fedoraId = headers.getId();\n-                        fedoraIds.add(fedoraId);\n-                        if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                            rootId.set(headers.getId());\n-                        }\n+        final var rootId = new AtomicReference<FedoraId>();\n+        final var fedoraIds = new ArrayList<FedoraId>();\n+        final var headersList = new ArrayList<ResourceHeaders>();\n \n-                        if (!headers.isDeleted()) {\n-                            if (!fedoraId.isRepositoryRoot()) {\n-                                var parentId = headers.getParent();\n+        session.streamResourceHeaders().forEach(storageHeaders -> {\n+            final var headers = new ResourceHeadersAdapter(storageHeaders);\n \n-                                if (parentId == null) {\n-                                    if (headers.isObjectRoot()) {\n-                                        parentId = FedoraId.getRepositoryRootId();\n-                                    }\n-                                }\n+            final var fedoraId = headers.getId();\n+            fedoraIds.add(fedoraId);\n+            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                rootId.set(fedoraId);\n+            }\n \n-                                if (parentId != null) {\n-                                    this.containmentIndex.addContainedBy(txId, parentId,\n-                                            headers.getId());\n-                                }\n+            if (!headers.isDeleted()) {\n+                if (!fedoraId.isRepositoryRoot()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MTM2OA==", "bodyText": "done", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482961368", "createdAt": "2020-09-03T13:04:52Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -129,75 +120,60 @@ private void rebuild() {\n                 return null;\n             });\n             throw e;\n-        } finally {\n-            cleanupStaging(stagingDir);\n         }\n     }\n \n     private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        try (final var subpaths = session.listHeadSubpaths()) {\n-            final var rootId = new AtomicReference<FedoraId>();\n-            final var fedoraIds = new ArrayList<FedoraId>();\n-            final var headersList = new ArrayList<ResourceHeaders>();\n-            subpaths.forEach(subpath -> {\n-                if (PersistencePaths.isHeaderFile(subpath)) {\n-                    //we're only interested in sidecar subpaths\n-                    try {\n-                        final var headers = deserializeHeaders(session.read(subpath));\n-                        final var fedoraId = headers.getId();\n-                        fedoraIds.add(fedoraId);\n-                        if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                            rootId.set(headers.getId());\n-                        }\n+        final var rootId = new AtomicReference<FedoraId>();\n+        final var fedoraIds = new ArrayList<FedoraId>();\n+        final var headersList = new ArrayList<ResourceHeaders>();\n \n-                        if (!headers.isDeleted()) {\n-                            if (!fedoraId.isRepositoryRoot()) {\n-                                var parentId = headers.getParent();\n+        session.streamResourceHeaders().forEach(storageHeaders -> {\n+            final var headers = new ResourceHeadersAdapter(storageHeaders);\n \n-                                if (parentId == null) {\n-                                    if (headers.isObjectRoot()) {\n-                                        parentId = FedoraId.getRepositoryRootId();\n-                                    }\n-                                }\n+            final var fedoraId = headers.getId();\n+            fedoraIds.add(fedoraId);\n+            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                rootId.set(fedoraId);\n+            }\n \n-                                if (parentId != null) {\n-                                    this.containmentIndex.addContainedBy(txId, parentId,\n-                                            headers.getId());\n-                                }\n+            if (!headers.isDeleted()) {\n+                if (!fedoraId.isRepositoryRoot()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MzEyNg=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDg4MjA0OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo1MzoxNVrOHL19lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNzoyMzoyNFrOHMweyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4MDUwMg==", "bodyText": "I recognize this was already here, but I don't really understand the scenario where the root id would need to be overridden. Maybe we should add a comment describing the case? It seems like for both AGs and atomic resources the rootId is getting set", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482180502", "createdAt": "2020-09-02T15:53:15Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -129,75 +120,60 @@ private void rebuild() {\n                 return null;\n             });\n             throw e;\n-        } finally {\n-            cleanupStaging(stagingDir);\n         }\n     }\n \n     private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        try (final var subpaths = session.listHeadSubpaths()) {\n-            final var rootId = new AtomicReference<FedoraId>();\n-            final var fedoraIds = new ArrayList<FedoraId>();\n-            final var headersList = new ArrayList<ResourceHeaders>();\n-            subpaths.forEach(subpath -> {\n-                if (PersistencePaths.isHeaderFile(subpath)) {\n-                    //we're only interested in sidecar subpaths\n-                    try {\n-                        final var headers = deserializeHeaders(session.read(subpath));\n-                        final var fedoraId = headers.getId();\n-                        fedoraIds.add(fedoraId);\n-                        if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                            rootId.set(headers.getId());\n-                        }\n+        final var rootId = new AtomicReference<FedoraId>();\n+        final var fedoraIds = new ArrayList<FedoraId>();\n+        final var headersList = new ArrayList<ResourceHeaders>();\n \n-                        if (!headers.isDeleted()) {\n-                            if (!fedoraId.isRepositoryRoot()) {\n-                                var parentId = headers.getParent();\n+        session.streamResourceHeaders().forEach(storageHeaders -> {\n+            final var headers = new ResourceHeadersAdapter(storageHeaders);\n \n-                                if (parentId == null) {\n-                                    if (headers.isObjectRoot()) {\n-                                        parentId = FedoraId.getRepositoryRootId();\n-                                    }\n-                                }\n+            final var fedoraId = headers.getId();\n+            fedoraIds.add(fedoraId);\n+            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                rootId.set(fedoraId);\n+            }\n \n-                                if (parentId != null) {\n-                                    this.containmentIndex.addContainedBy(txId, parentId,\n-                                            headers.getId());\n-                                }\n+            if (!headers.isDeleted()) {\n+                if (!fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n \n-                                headersList.add(headers);\n-                            }\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n+                                    fedoraId.getFullId()));\n                         }\n-                    } catch (PersistentStorageException e) {\n-                        throw new RepositoryRuntimeException(format(\"fedora-to-ocfl index rebuild failed: %s\",\n-                                e.getMessage()), e);\n                     }\n-                }\n-            });\n-\n-            // if a resource is not an AG then there should only be a single resource per OCFL object\n-            if (fedoraIds.size() == 1 && rootId.get() == null) {\n-                rootId.set(fedoraIds.get(0));\n-            }\n \n-            fedoraIds.forEach(fedoraIdentifier -> {\n-                var rootFedoraIdentifier = rootId.get();\n-                if (rootFedoraIdentifier == null) {\n-                    rootFedoraIdentifier = fedoraIdentifier;\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n                 }\n-                fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-            });\n-\n-            headersList.forEach(headers -> {\n-                searchIndex.addUpdateIndex(txId, headers);\n-                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-            });\n+            }\n+        });\n \n-        } catch (final PersistentStorageException e) {\n-            throw new RepositoryRuntimeException(\"Failed to rebuild fedora-to-ocfl index: \" +\n-                    e.getMessage(), e);\n+        // if a resource is not an AG then there should only be a single resource per OCFL object\n+        if (fedoraIds.size() == 1 && rootId.get() == null) {\n+            rootId.set(fedoraIds.get(0));\n         }\n+\n+        fedoraIds.forEach(fedoraIdentifier -> {\n+            var rootFedoraIdentifier = rootId.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MjMwMQ==", "bodyText": "Yes, it's a hold over from an original iteration of this class. I changed it to throw an exception if the root id isn't found, because it should always be.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482962301", "createdAt": "2020-09-03T13:06:18Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -129,75 +120,60 @@ private void rebuild() {\n                 return null;\n             });\n             throw e;\n-        } finally {\n-            cleanupStaging(stagingDir);\n         }\n     }\n \n     private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        try (final var subpaths = session.listHeadSubpaths()) {\n-            final var rootId = new AtomicReference<FedoraId>();\n-            final var fedoraIds = new ArrayList<FedoraId>();\n-            final var headersList = new ArrayList<ResourceHeaders>();\n-            subpaths.forEach(subpath -> {\n-                if (PersistencePaths.isHeaderFile(subpath)) {\n-                    //we're only interested in sidecar subpaths\n-                    try {\n-                        final var headers = deserializeHeaders(session.read(subpath));\n-                        final var fedoraId = headers.getId();\n-                        fedoraIds.add(fedoraId);\n-                        if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                            rootId.set(headers.getId());\n-                        }\n+        final var rootId = new AtomicReference<FedoraId>();\n+        final var fedoraIds = new ArrayList<FedoraId>();\n+        final var headersList = new ArrayList<ResourceHeaders>();\n \n-                        if (!headers.isDeleted()) {\n-                            if (!fedoraId.isRepositoryRoot()) {\n-                                var parentId = headers.getParent();\n+        session.streamResourceHeaders().forEach(storageHeaders -> {\n+            final var headers = new ResourceHeadersAdapter(storageHeaders);\n \n-                                if (parentId == null) {\n-                                    if (headers.isObjectRoot()) {\n-                                        parentId = FedoraId.getRepositoryRootId();\n-                                    }\n-                                }\n+            final var fedoraId = headers.getId();\n+            fedoraIds.add(fedoraId);\n+            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                rootId.set(fedoraId);\n+            }\n \n-                                if (parentId != null) {\n-                                    this.containmentIndex.addContainedBy(txId, parentId,\n-                                            headers.getId());\n-                                }\n+            if (!headers.isDeleted()) {\n+                if (!fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n \n-                                headersList.add(headers);\n-                            }\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n+                                    fedoraId.getFullId()));\n                         }\n-                    } catch (PersistentStorageException e) {\n-                        throw new RepositoryRuntimeException(format(\"fedora-to-ocfl index rebuild failed: %s\",\n-                                e.getMessage()), e);\n                     }\n-                }\n-            });\n-\n-            // if a resource is not an AG then there should only be a single resource per OCFL object\n-            if (fedoraIds.size() == 1 && rootId.get() == null) {\n-                rootId.set(fedoraIds.get(0));\n-            }\n \n-            fedoraIds.forEach(fedoraIdentifier -> {\n-                var rootFedoraIdentifier = rootId.get();\n-                if (rootFedoraIdentifier == null) {\n-                    rootFedoraIdentifier = fedoraIdentifier;\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n                 }\n-                fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-            });\n-\n-            headersList.forEach(headers -> {\n-                searchIndex.addUpdateIndex(txId, headers);\n-                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-            });\n+            }\n+        });\n \n-        } catch (final PersistentStorageException e) {\n-            throw new RepositoryRuntimeException(\"Failed to rebuild fedora-to-ocfl index: \" +\n-                    e.getMessage(), e);\n+        // if a resource is not an AG then there should only be a single resource per OCFL object\n+        if (fedoraIds.size() == 1 && rootId.get() == null) {\n+            rootId.set(fedoraIds.get(0));\n         }\n+\n+        fedoraIds.forEach(fedoraIdentifier -> {\n+            var rootFedoraIdentifier = rootId.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4MDUwMg=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEzOTI3NA==", "bodyText": "It seems like you can remove\n            var rootFedoraIdentifier = rootId.get();\n            if (rootFedoraIdentifier == null) {\n                rootFedoraIdentifier = fedoraIdentifier;\n            }\n\nsince a null root id now throws an exception a few lines above this?", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483139274", "createdAt": "2020-09-03T17:23:24Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -129,75 +120,60 @@ private void rebuild() {\n                 return null;\n             });\n             throw e;\n-        } finally {\n-            cleanupStaging(stagingDir);\n         }\n     }\n \n     private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        try (final var subpaths = session.listHeadSubpaths()) {\n-            final var rootId = new AtomicReference<FedoraId>();\n-            final var fedoraIds = new ArrayList<FedoraId>();\n-            final var headersList = new ArrayList<ResourceHeaders>();\n-            subpaths.forEach(subpath -> {\n-                if (PersistencePaths.isHeaderFile(subpath)) {\n-                    //we're only interested in sidecar subpaths\n-                    try {\n-                        final var headers = deserializeHeaders(session.read(subpath));\n-                        final var fedoraId = headers.getId();\n-                        fedoraIds.add(fedoraId);\n-                        if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                            rootId.set(headers.getId());\n-                        }\n+        final var rootId = new AtomicReference<FedoraId>();\n+        final var fedoraIds = new ArrayList<FedoraId>();\n+        final var headersList = new ArrayList<ResourceHeaders>();\n \n-                        if (!headers.isDeleted()) {\n-                            if (!fedoraId.isRepositoryRoot()) {\n-                                var parentId = headers.getParent();\n+        session.streamResourceHeaders().forEach(storageHeaders -> {\n+            final var headers = new ResourceHeadersAdapter(storageHeaders);\n \n-                                if (parentId == null) {\n-                                    if (headers.isObjectRoot()) {\n-                                        parentId = FedoraId.getRepositoryRootId();\n-                                    }\n-                                }\n+            final var fedoraId = headers.getId();\n+            fedoraIds.add(fedoraId);\n+            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                rootId.set(fedoraId);\n+            }\n \n-                                if (parentId != null) {\n-                                    this.containmentIndex.addContainedBy(txId, parentId,\n-                                            headers.getId());\n-                                }\n+            if (!headers.isDeleted()) {\n+                if (!fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n \n-                                headersList.add(headers);\n-                            }\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n+                                    fedoraId.getFullId()));\n                         }\n-                    } catch (PersistentStorageException e) {\n-                        throw new RepositoryRuntimeException(format(\"fedora-to-ocfl index rebuild failed: %s\",\n-                                e.getMessage()), e);\n                     }\n-                }\n-            });\n-\n-            // if a resource is not an AG then there should only be a single resource per OCFL object\n-            if (fedoraIds.size() == 1 && rootId.get() == null) {\n-                rootId.set(fedoraIds.get(0));\n-            }\n \n-            fedoraIds.forEach(fedoraIdentifier -> {\n-                var rootFedoraIdentifier = rootId.get();\n-                if (rootFedoraIdentifier == null) {\n-                    rootFedoraIdentifier = fedoraIdentifier;\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n                 }\n-                fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-            });\n-\n-            headersList.forEach(headers -> {\n-                searchIndex.addUpdateIndex(txId, headers);\n-                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-            });\n+            }\n+        });\n \n-        } catch (final PersistentStorageException e) {\n-            throw new RepositoryRuntimeException(\"Failed to rebuild fedora-to-ocfl index: \" +\n-                    e.getMessage(), e);\n+        // if a resource is not an AG then there should only be a single resource per OCFL object\n+        if (fedoraIds.size() == 1 && rootId.get() == null) {\n+            rootId.set(fedoraIds.get(0));\n         }\n+\n+        fedoraIds.forEach(fedoraIdentifier -> {\n+            var rootFedoraIdentifier = rootId.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4MDUwMg=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDkwMjc4OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo1Nzo0MlrOHL2KRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzoxMDoxN1rOHMl1lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4Mzc0OQ==", "bodyText": "I'm a little concerned that it seems like we are loading headers for all the resources in an OCFL object into memory at once, since it seems likely some day fedora is going to end up indexing an object with millions of files, but this seems to have already been the case, so its probably something for another time.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482183749", "createdAt": "2020-09-02T15:57:42Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -129,75 +120,60 @@ private void rebuild() {\n                 return null;\n             });\n             throw e;\n-        } finally {\n-            cleanupStaging(stagingDir);\n         }\n     }\n \n     private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        try (final var subpaths = session.listHeadSubpaths()) {\n-            final var rootId = new AtomicReference<FedoraId>();\n-            final var fedoraIds = new ArrayList<FedoraId>();\n-            final var headersList = new ArrayList<ResourceHeaders>();\n-            subpaths.forEach(subpath -> {\n-                if (PersistencePaths.isHeaderFile(subpath)) {\n-                    //we're only interested in sidecar subpaths\n-                    try {\n-                        final var headers = deserializeHeaders(session.read(subpath));\n-                        final var fedoraId = headers.getId();\n-                        fedoraIds.add(fedoraId);\n-                        if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                            rootId.set(headers.getId());\n-                        }\n+        final var rootId = new AtomicReference<FedoraId>();\n+        final var fedoraIds = new ArrayList<FedoraId>();\n+        final var headersList = new ArrayList<ResourceHeaders>();\n \n-                        if (!headers.isDeleted()) {\n-                            if (!fedoraId.isRepositoryRoot()) {\n-                                var parentId = headers.getParent();\n+        session.streamResourceHeaders().forEach(storageHeaders -> {\n+            final var headers = new ResourceHeadersAdapter(storageHeaders);\n \n-                                if (parentId == null) {\n-                                    if (headers.isObjectRoot()) {\n-                                        parentId = FedoraId.getRepositoryRootId();\n-                                    }\n-                                }\n+            final var fedoraId = headers.getId();\n+            fedoraIds.add(fedoraId);\n+            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                rootId.set(fedoraId);\n+            }\n \n-                                if (parentId != null) {\n-                                    this.containmentIndex.addContainedBy(txId, parentId,\n-                                            headers.getId());\n-                                }\n+            if (!headers.isDeleted()) {\n+                if (!fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n \n-                                headersList.add(headers);\n-                            }\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n+                                    fedoraId.getFullId()));\n                         }\n-                    } catch (PersistentStorageException e) {\n-                        throw new RepositoryRuntimeException(format(\"fedora-to-ocfl index rebuild failed: %s\",\n-                                e.getMessage()), e);\n                     }\n-                }\n-            });\n-\n-            // if a resource is not an AG then there should only be a single resource per OCFL object\n-            if (fedoraIds.size() == 1 && rootId.get() == null) {\n-                rootId.set(fedoraIds.get(0));\n-            }\n \n-            fedoraIds.forEach(fedoraIdentifier -> {\n-                var rootFedoraIdentifier = rootId.get();\n-                if (rootFedoraIdentifier == null) {\n-                    rootFedoraIdentifier = fedoraIdentifier;\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n                 }\n-                fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-            });\n-\n-            headersList.forEach(headers -> {\n-                searchIndex.addUpdateIndex(txId, headers);\n-                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-            });\n+            }\n+        });\n \n-        } catch (final PersistentStorageException e) {\n-            throw new RepositoryRuntimeException(\"Failed to rebuild fedora-to-ocfl index: \" +\n-                    e.getMessage(), e);\n+        // if a resource is not an AG then there should only be a single resource per OCFL object\n+        if (fedoraIds.size() == 1 && rootId.get() == null) {\n+            rootId.set(fedoraIds.get(0));\n         }\n+\n+        fedoraIds.forEach(fedoraIdentifier -> {\n+            var rootFedoraIdentifier = rootId.get();\n+            if (rootFedoraIdentifier == null) {\n+                rootFedoraIdentifier = fedoraIdentifier;\n+            }\n+            fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+            LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+        });\n+\n+        headersList.forEach(headers -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzMTAwMA==", "bodyText": "I agree with this 100%. I will create a jira for addressing this problem.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482431000", "createdAt": "2020-09-02T20:37:42Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -129,75 +120,60 @@ private void rebuild() {\n                 return null;\n             });\n             throw e;\n-        } finally {\n-            cleanupStaging(stagingDir);\n         }\n     }\n \n     private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        try (final var subpaths = session.listHeadSubpaths()) {\n-            final var rootId = new AtomicReference<FedoraId>();\n-            final var fedoraIds = new ArrayList<FedoraId>();\n-            final var headersList = new ArrayList<ResourceHeaders>();\n-            subpaths.forEach(subpath -> {\n-                if (PersistencePaths.isHeaderFile(subpath)) {\n-                    //we're only interested in sidecar subpaths\n-                    try {\n-                        final var headers = deserializeHeaders(session.read(subpath));\n-                        final var fedoraId = headers.getId();\n-                        fedoraIds.add(fedoraId);\n-                        if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                            rootId.set(headers.getId());\n-                        }\n+        final var rootId = new AtomicReference<FedoraId>();\n+        final var fedoraIds = new ArrayList<FedoraId>();\n+        final var headersList = new ArrayList<ResourceHeaders>();\n \n-                        if (!headers.isDeleted()) {\n-                            if (!fedoraId.isRepositoryRoot()) {\n-                                var parentId = headers.getParent();\n+        session.streamResourceHeaders().forEach(storageHeaders -> {\n+            final var headers = new ResourceHeadersAdapter(storageHeaders);\n \n-                                if (parentId == null) {\n-                                    if (headers.isObjectRoot()) {\n-                                        parentId = FedoraId.getRepositoryRootId();\n-                                    }\n-                                }\n+            final var fedoraId = headers.getId();\n+            fedoraIds.add(fedoraId);\n+            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                rootId.set(fedoraId);\n+            }\n \n-                                if (parentId != null) {\n-                                    this.containmentIndex.addContainedBy(txId, parentId,\n-                                            headers.getId());\n-                                }\n+            if (!headers.isDeleted()) {\n+                if (!fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n \n-                                headersList.add(headers);\n-                            }\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n+                                    fedoraId.getFullId()));\n                         }\n-                    } catch (PersistentStorageException e) {\n-                        throw new RepositoryRuntimeException(format(\"fedora-to-ocfl index rebuild failed: %s\",\n-                                e.getMessage()), e);\n                     }\n-                }\n-            });\n-\n-            // if a resource is not an AG then there should only be a single resource per OCFL object\n-            if (fedoraIds.size() == 1 && rootId.get() == null) {\n-                rootId.set(fedoraIds.get(0));\n-            }\n \n-            fedoraIds.forEach(fedoraIdentifier -> {\n-                var rootFedoraIdentifier = rootId.get();\n-                if (rootFedoraIdentifier == null) {\n-                    rootFedoraIdentifier = fedoraIdentifier;\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n                 }\n-                fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-            });\n-\n-            headersList.forEach(headers -> {\n-                searchIndex.addUpdateIndex(txId, headers);\n-                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-            });\n+            }\n+        });\n \n-        } catch (final PersistentStorageException e) {\n-            throw new RepositoryRuntimeException(\"Failed to rebuild fedora-to-ocfl index: \" +\n-                    e.getMessage(), e);\n+        // if a resource is not an AG then there should only be a single resource per OCFL object\n+        if (fedoraIds.size() == 1 && rootId.get() == null) {\n+            rootId.set(fedoraIds.get(0));\n         }\n+\n+        fedoraIds.forEach(fedoraIdentifier -> {\n+            var rootFedoraIdentifier = rootId.get();\n+            if (rootFedoraIdentifier == null) {\n+                rootFedoraIdentifier = fedoraIdentifier;\n+            }\n+            fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+            LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+        });\n+\n+        headersList.forEach(headers -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4Mzc0OQ=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2NDg4NA==", "bodyText": "https://jira.lyrasis.org/browse/FCREPO-3408", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482964884", "createdAt": "2020-09-03T13:10:17Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -129,75 +120,60 @@ private void rebuild() {\n                 return null;\n             });\n             throw e;\n-        } finally {\n-            cleanupStaging(stagingDir);\n         }\n     }\n \n     private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        try (final var subpaths = session.listHeadSubpaths()) {\n-            final var rootId = new AtomicReference<FedoraId>();\n-            final var fedoraIds = new ArrayList<FedoraId>();\n-            final var headersList = new ArrayList<ResourceHeaders>();\n-            subpaths.forEach(subpath -> {\n-                if (PersistencePaths.isHeaderFile(subpath)) {\n-                    //we're only interested in sidecar subpaths\n-                    try {\n-                        final var headers = deserializeHeaders(session.read(subpath));\n-                        final var fedoraId = headers.getId();\n-                        fedoraIds.add(fedoraId);\n-                        if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                            rootId.set(headers.getId());\n-                        }\n+        final var rootId = new AtomicReference<FedoraId>();\n+        final var fedoraIds = new ArrayList<FedoraId>();\n+        final var headersList = new ArrayList<ResourceHeaders>();\n \n-                        if (!headers.isDeleted()) {\n-                            if (!fedoraId.isRepositoryRoot()) {\n-                                var parentId = headers.getParent();\n+        session.streamResourceHeaders().forEach(storageHeaders -> {\n+            final var headers = new ResourceHeadersAdapter(storageHeaders);\n \n-                                if (parentId == null) {\n-                                    if (headers.isObjectRoot()) {\n-                                        parentId = FedoraId.getRepositoryRootId();\n-                                    }\n-                                }\n+            final var fedoraId = headers.getId();\n+            fedoraIds.add(fedoraId);\n+            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                rootId.set(fedoraId);\n+            }\n \n-                                if (parentId != null) {\n-                                    this.containmentIndex.addContainedBy(txId, parentId,\n-                                            headers.getId());\n-                                }\n+            if (!headers.isDeleted()) {\n+                if (!fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n \n-                                headersList.add(headers);\n-                            }\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n+                                    fedoraId.getFullId()));\n                         }\n-                    } catch (PersistentStorageException e) {\n-                        throw new RepositoryRuntimeException(format(\"fedora-to-ocfl index rebuild failed: %s\",\n-                                e.getMessage()), e);\n                     }\n-                }\n-            });\n-\n-            // if a resource is not an AG then there should only be a single resource per OCFL object\n-            if (fedoraIds.size() == 1 && rootId.get() == null) {\n-                rootId.set(fedoraIds.get(0));\n-            }\n \n-            fedoraIds.forEach(fedoraIdentifier -> {\n-                var rootFedoraIdentifier = rootId.get();\n-                if (rootFedoraIdentifier == null) {\n-                    rootFedoraIdentifier = fedoraIdentifier;\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n                 }\n-                fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-            });\n-\n-            headersList.forEach(headers -> {\n-                searchIndex.addUpdateIndex(txId, headers);\n-                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-            });\n+            }\n+        });\n \n-        } catch (final PersistentStorageException e) {\n-            throw new RepositoryRuntimeException(\"Failed to rebuild fedora-to-ocfl index: \" +\n-                    e.getMessage(), e);\n+        // if a resource is not an AG then there should only be a single resource per OCFL object\n+        if (fedoraIds.size() == 1 && rootId.get() == null) {\n+            rootId.set(fedoraIds.get(0));\n         }\n+\n+        fedoraIds.forEach(fedoraIdentifier -> {\n+            var rootFedoraIdentifier = rootId.get();\n+            if (rootFedoraIdentifier == null) {\n+                rootFedoraIdentifier = fedoraIdentifier;\n+            }\n+            fedoraToOcflObjectIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+            LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+        });\n+\n+        headersList.forEach(headers -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4Mzc0OQ=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTM5NDc0OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/UpdateNonRdfSourcePersister.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowNDozNlrOHL7HOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowNzowMlrOHMltRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDg4OA==", "bodyText": "Since all calls to OcflObjectSession methods now require being wrapped in StorageExceptionConverter.exec, I am wondering if it might make sense to have OcflPersistentStorageSession.findOrCreateSession return the OcflObjectSession decorator that wraps calls to the real OcflObjectSession with exception conversions internally, rather than leaving it up to callers to do the conversion. Just a suggestion though, the current approach obviously works too.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482264888", "createdAt": "2020-09-02T18:04:36Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/UpdateNonRdfSourcePersister.java", "diffHunk": "@@ -56,20 +55,16 @@ public void persist(final OcflPersistentStorageSession session, final ResourceOp\n         log.debug(\"retrieved mapping: {}\", mapping);\n         final OcflObjectSession objSession = session.findOrCreateSession(mapping.getOcflObjectId());\n \n-        boolean cleanupInternal = false;\n         // If storing an external binary, clean up internal binary if needed\n         if (forExternalBinary((NonRdfSourceOperation) operation)) {\n             // Read the resource headers prior to updating how the existing resource is stored\n-            final var headerPath = PersistencePaths.headerPath(rootIdentifier, resourceId);\n-            final var headers = (ResourceHeadersImpl) readHeaders(objSession, headerPath);\n-            cleanupInternal = headers.getExternalUrl() == null;\n+            final var headers = StorageExceptionConverter.exec(() ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzMTM0NA==", "bodyText": "Excellent idea", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482431344", "createdAt": "2020-09-02T20:38:01Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/UpdateNonRdfSourcePersister.java", "diffHunk": "@@ -56,20 +55,16 @@ public void persist(final OcflPersistentStorageSession session, final ResourceOp\n         log.debug(\"retrieved mapping: {}\", mapping);\n         final OcflObjectSession objSession = session.findOrCreateSession(mapping.getOcflObjectId());\n \n-        boolean cleanupInternal = false;\n         // If storing an external binary, clean up internal binary if needed\n         if (forExternalBinary((NonRdfSourceOperation) operation)) {\n             // Read the resource headers prior to updating how the existing resource is stored\n-            final var headerPath = PersistencePaths.headerPath(rootIdentifier, resourceId);\n-            final var headers = (ResourceHeadersImpl) readHeaders(objSession, headerPath);\n-            cleanupInternal = headers.getExternalUrl() == null;\n+            final var headers = StorageExceptionConverter.exec(() ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDg4OA=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2Mjc1OQ==", "bodyText": "Unfortunately, this doesn't work because the fcrepo exceptions are checked and can't be added to the method signature.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482962759", "createdAt": "2020-09-03T13:07:02Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/UpdateNonRdfSourcePersister.java", "diffHunk": "@@ -56,20 +55,16 @@ public void persist(final OcflPersistentStorageSession session, final ResourceOp\n         log.debug(\"retrieved mapping: {}\", mapping);\n         final OcflObjectSession objSession = session.findOrCreateSession(mapping.getOcflObjectId());\n \n-        boolean cleanupInternal = false;\n         // If storing an external binary, clean up internal binary if needed\n         if (forExternalBinary((NonRdfSourceOperation) operation)) {\n             // Read the resource headers prior to updating how the existing resource is stored\n-            final var headerPath = PersistencePaths.headerPath(rootIdentifier, resourceId);\n-            final var headers = (ResourceHeadersImpl) readHeaders(objSession, headerPath);\n-            cleanupInternal = headers.getExternalUrl() == null;\n+            final var headers = StorageExceptionConverter.exec(() ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDg4OA=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTgyNjc2OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/test/java/org/fcrepo/persistence/ocfl/impl/OcflPersistentStorageSessionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOToyNTo1NlrOHL_adw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowNzowOVrOHMltoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMzNTM1MQ==", "bodyText": "It might make sense to add a utility method somewhere to get this configuration of an object mapper since it seems to be standard for our DefaultOcflObjectSessionFactorys", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482335351", "createdAt": "2020-09-02T19:25:56Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/test/java/org/fcrepo/persistence/ocfl/impl/OcflPersistentStorageSessionTest.java", "diffHunk": "@@ -153,9 +149,14 @@ public void setUp() throws Exception {\n         final var repoDir = tempFolder.newFolder(\"ocfl-repo\").toPath();\n         final var workDir = tempFolder.newFolder(\"ocfl-work\").toPath();\n \n+        final var objectMapper = new ObjectMapper()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2Mjg0OQ==", "bodyText": "done", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482962849", "createdAt": "2020-09-03T13:07:09Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/test/java/org/fcrepo/persistence/ocfl/impl/OcflPersistentStorageSessionTest.java", "diffHunk": "@@ -153,9 +149,14 @@ public void setUp() throws Exception {\n         final var repoDir = tempFolder.newFolder(\"ocfl-repo\").toPath();\n         final var workDir = tempFolder.newFolder(\"ocfl-work\").toPath();\n \n+        final var objectMapper = new ObjectMapper()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMzNTM1MQ=="}, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTg1OTU2OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/test/java/org/fcrepo/persistence/ocfl/impl/UpdateRDFSourcePersisterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTozMDoyMVrOHL_xOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTozMDoyMVrOHL_xOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM0MTE3Nw==", "bodyText": "the battle of the IDE import sort orders continues", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r482341177", "createdAt": "2020-09-02T19:30:21Z", "author": {"login": "bbpennel"}, "path": "fcrepo-persistence-ocfl/src/test/java/org/fcrepo/persistence/ocfl/impl/UpdateRDFSourcePersisterTest.java", "diffHunk": "@@ -63,6 +39,27 @@\n import org.mockito.Mock;\n import org.mockito.junit.MockitoJUnitRunner;\n \n+import java.io.InputStream;\n+import java.util.stream.Stream;\n+\n+import static org.apache.jena.graph.NodeFactory.createLiteral;\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.BASIC_CONTAINER;\n+import static org.fcrepo.kernel.api.operations.ResourceOperationType.UPDATE;\n+import static org.fcrepo.persistence.common.ResourceHeaderUtils.newResourceHeaders;\n+import static org.fcrepo.persistence.common.ResourceHeaderUtils.touchCreationHeaders;\n+import static org.fcrepo.persistence.common.ResourceHeaderUtils.touchModificationHeaders;\n+import static org.junit.Assert.assertEquals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe53a47873d3221e2818e20dd70fec3fbcc0cea7"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTA3ODM5OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-api/src/main/java/org/fcrepo/persistence/api/exceptions/PersistentStorageException.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0MDoxM1rOHMzFig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDowMjozMlrOHM1k1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MTk2Mg==", "bodyText": "Any reason not to instead \"extend\" org.fcrepo.kernel.api.exception.RepositoryRuntimeException?", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483181962", "createdAt": "2020-09-03T18:40:13Z", "author": {"login": "awoods"}, "path": "fcrepo-persistence-api/src/main/java/org/fcrepo/persistence/api/exceptions/PersistentStorageException.java", "diffHunk": "@@ -23,7 +23,7 @@\n  * @author whikloj\n  * @since 2019-09-20\n  */\n-public class PersistentStorageException extends Exception {\n+public class PersistentStorageException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyMjc0Mw==", "bodyText": "Nope, is that preferable? If so, I'll change it.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483222743", "createdAt": "2020-09-03T20:02:32Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-api/src/main/java/org/fcrepo/persistence/api/exceptions/PersistentStorageException.java", "diffHunk": "@@ -23,7 +23,7 @@\n  * @author whikloj\n  * @since 2019-09-20\n  */\n-public class PersistentStorageException extends Exception {\n+public class PersistentStorageException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MTk2Mg=="}, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTIxOTc5OnYy", "diffSide": "LEFT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/DeleteResourcePersister.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyNDowOFrOHM0c7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDowMjo1MFrOHM1lbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNDMzMg==", "bodyText": "All of the logic around handling staged or versioned files is now in fcrepo-storage-ocfl?", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483204332", "createdAt": "2020-09-03T19:24:08Z", "author": {"login": "awoods"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/DeleteResourcePersister.java", "diffHunk": "@@ -47,81 +42,28 @@ protected DeleteResourcePersister(final FedoraToOcflObjectIndex fedoraOcflIndex)\n     public void persist(final OcflPersistentStorageSession session, final ResourceOperation operation)\n             throws PersistentStorageException {\n         final var mapping = getMapping(session.getId(), operation.getResourceId());\n-        final var fedoraResourceRoot = mapping.getRootObjectIdentifier();\n         final var resourceId = operation.getResourceId();\n+\n         final var objectSession = session.findOrCreateSession(mapping.getOcflObjectId());\n-        final var user = operation.getUserPrincipal();\n-        final var deleteTime = Instant.now();\n-        log.debug(\"Deleting {} from {}\", resourceId, mapping.getOcflObjectId());\n-        if (fedoraResourceRoot.equals(resourceId)) {\n-            // We are at the root of the object, so delete all the data files.\n-            try {\n-                if (objectSession.isNewInSession()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyMjg5Mg==", "bodyText": "Yep", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483222892", "createdAt": "2020-09-03T20:02:50Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/DeleteResourcePersister.java", "diffHunk": "@@ -47,81 +42,28 @@ protected DeleteResourcePersister(final FedoraToOcflObjectIndex fedoraOcflIndex)\n     public void persist(final OcflPersistentStorageSession session, final ResourceOperation operation)\n             throws PersistentStorageException {\n         final var mapping = getMapping(session.getId(), operation.getResourceId());\n-        final var fedoraResourceRoot = mapping.getRootObjectIdentifier();\n         final var resourceId = operation.getResourceId();\n+\n         final var objectSession = session.findOrCreateSession(mapping.getOcflObjectId());\n-        final var user = operation.getUserPrincipal();\n-        final var deleteTime = Instant.now();\n-        log.debug(\"Deleting {} from {}\", resourceId, mapping.getOcflObjectId());\n-        if (fedoraResourceRoot.equals(resourceId)) {\n-            // We are at the root of the object, so delete all the data files.\n-            try {\n-                if (objectSession.isNewInSession()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNDMzMg=="}, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTIzMjgwOnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/FcrepoOcflObjectSessionWrapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyODozMVrOHM0lKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDowMzo1M1rOHM1nRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNjQ0Mg==", "bodyText": "The \"throws\" clause can now be removed, no?", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483206442", "createdAt": "2020-09-03T19:28:31Z", "author": {"login": "awoods"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/FcrepoOcflObjectSessionWrapper.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import org.fcrepo.persistence.api.exceptions.PersistentItemNotFoundException;\n+import org.fcrepo.persistence.api.exceptions.PersistentStorageException;\n+import org.fcrepo.storage.ocfl.CommitType;\n+import org.fcrepo.storage.ocfl.NotFoundException;\n+import org.fcrepo.storage.ocfl.OcflObjectSession;\n+import org.fcrepo.storage.ocfl.OcflVersionInfo;\n+import org.fcrepo.storage.ocfl.ResourceContent;\n+import org.fcrepo.storage.ocfl.ResourceHeaders;\n+\n+import java.io.InputStream;\n+import java.time.OffsetDateTime;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Wrapper around an OcflObjectSession to convert exceptions into fcrepo exceptions\n+ *\n+ * @author pwinckles\n+ */\n+public class FcrepoOcflObjectSessionWrapper implements OcflObjectSession {\n+\n+    private final OcflObjectSession inner;\n+\n+    /**\n+     * @param inner the session to wrap\n+     */\n+    public FcrepoOcflObjectSessionWrapper(final OcflObjectSession inner) {\n+        this.inner = inner;\n+    }\n+\n+    @Override\n+    public String sessionId() {\n+        return inner.sessionId();\n+    }\n+\n+    @Override\n+    public String ocflObjectId() {\n+        return inner.ocflObjectId();\n+    }\n+\n+    @Override\n+    public void writeResource(final ResourceHeaders headers, final InputStream content) {\n+        exec(() -> inner.writeResource(headers, content));\n+    }\n+\n+    @Override\n+    public void deleteContentFile(final ResourceHeaders headers) {\n+        exec(() -> inner.deleteContentFile(headers));\n+    }\n+\n+    @Override\n+    public void deleteResource(final String resourceId) {\n+        exec(() -> inner.deleteResource(resourceId));\n+    }\n+\n+    @Override\n+    public boolean containsResource(final String resourceId) {\n+        return exec(() -> inner.containsResource(resourceId));\n+    }\n+\n+    @Override\n+    public ResourceHeaders readHeaders(final String resourceId) {\n+        return exec(() -> inner.readHeaders(resourceId));\n+    }\n+\n+    @Override\n+    public ResourceHeaders readHeaders(final String resourceId, final String versionNumber) {\n+        return exec(() -> inner.readHeaders(resourceId, versionNumber));\n+    }\n+\n+    @Override\n+    public ResourceContent readContent(final String resourceId) {\n+        return exec(() -> inner.readContent(resourceId));\n+    }\n+\n+    @Override\n+    public ResourceContent readContent(final String resourceId, final String versionNumber) {\n+        return exec(() -> inner.readContent(resourceId, versionNumber));\n+    }\n+\n+    @Override\n+    public List<OcflVersionInfo> listVersions(final String resourceId) {\n+        return exec(() -> inner.listVersions(resourceId));\n+    }\n+\n+    @Override\n+    public Stream<ResourceHeaders> streamResourceHeaders() {\n+        return exec(inner::streamResourceHeaders);\n+    }\n+\n+    @Override\n+    public void versionCreationTimestamp(final OffsetDateTime timestamp) {\n+        inner.versionCreationTimestamp(timestamp);\n+    }\n+\n+    @Override\n+    public void versionAuthor(final String name, final String address) {\n+        inner.versionAuthor(name, address);\n+    }\n+\n+    @Override\n+    public void versionMessage(final String message) {\n+        inner.versionMessage(message);\n+    }\n+\n+    @Override\n+    public void commitType(final CommitType commitType) {\n+        inner.commitType(commitType);\n+    }\n+\n+    @Override\n+    public void commit() {\n+        exec(inner::commit);\n+    }\n+\n+    @Override\n+    public void abort() {\n+        exec(inner::abort);\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return inner.isOpen();\n+    }\n+\n+    @Override\n+    public void close() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyMzM2NQ==", "bodyText": "Not cleanly until I update fcrepo-storage-ocfl because the exception is still on the interface's signature.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483223365", "createdAt": "2020-09-03T20:03:53Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/FcrepoOcflObjectSessionWrapper.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import org.fcrepo.persistence.api.exceptions.PersistentItemNotFoundException;\n+import org.fcrepo.persistence.api.exceptions.PersistentStorageException;\n+import org.fcrepo.storage.ocfl.CommitType;\n+import org.fcrepo.storage.ocfl.NotFoundException;\n+import org.fcrepo.storage.ocfl.OcflObjectSession;\n+import org.fcrepo.storage.ocfl.OcflVersionInfo;\n+import org.fcrepo.storage.ocfl.ResourceContent;\n+import org.fcrepo.storage.ocfl.ResourceHeaders;\n+\n+import java.io.InputStream;\n+import java.time.OffsetDateTime;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Wrapper around an OcflObjectSession to convert exceptions into fcrepo exceptions\n+ *\n+ * @author pwinckles\n+ */\n+public class FcrepoOcflObjectSessionWrapper implements OcflObjectSession {\n+\n+    private final OcflObjectSession inner;\n+\n+    /**\n+     * @param inner the session to wrap\n+     */\n+    public FcrepoOcflObjectSessionWrapper(final OcflObjectSession inner) {\n+        this.inner = inner;\n+    }\n+\n+    @Override\n+    public String sessionId() {\n+        return inner.sessionId();\n+    }\n+\n+    @Override\n+    public String ocflObjectId() {\n+        return inner.ocflObjectId();\n+    }\n+\n+    @Override\n+    public void writeResource(final ResourceHeaders headers, final InputStream content) {\n+        exec(() -> inner.writeResource(headers, content));\n+    }\n+\n+    @Override\n+    public void deleteContentFile(final ResourceHeaders headers) {\n+        exec(() -> inner.deleteContentFile(headers));\n+    }\n+\n+    @Override\n+    public void deleteResource(final String resourceId) {\n+        exec(() -> inner.deleteResource(resourceId));\n+    }\n+\n+    @Override\n+    public boolean containsResource(final String resourceId) {\n+        return exec(() -> inner.containsResource(resourceId));\n+    }\n+\n+    @Override\n+    public ResourceHeaders readHeaders(final String resourceId) {\n+        return exec(() -> inner.readHeaders(resourceId));\n+    }\n+\n+    @Override\n+    public ResourceHeaders readHeaders(final String resourceId, final String versionNumber) {\n+        return exec(() -> inner.readHeaders(resourceId, versionNumber));\n+    }\n+\n+    @Override\n+    public ResourceContent readContent(final String resourceId) {\n+        return exec(() -> inner.readContent(resourceId));\n+    }\n+\n+    @Override\n+    public ResourceContent readContent(final String resourceId, final String versionNumber) {\n+        return exec(() -> inner.readContent(resourceId, versionNumber));\n+    }\n+\n+    @Override\n+    public List<OcflVersionInfo> listVersions(final String resourceId) {\n+        return exec(() -> inner.listVersions(resourceId));\n+    }\n+\n+    @Override\n+    public Stream<ResourceHeaders> streamResourceHeaders() {\n+        return exec(inner::streamResourceHeaders);\n+    }\n+\n+    @Override\n+    public void versionCreationTimestamp(final OffsetDateTime timestamp) {\n+        inner.versionCreationTimestamp(timestamp);\n+    }\n+\n+    @Override\n+    public void versionAuthor(final String name, final String address) {\n+        inner.versionAuthor(name, address);\n+    }\n+\n+    @Override\n+    public void versionMessage(final String message) {\n+        inner.versionMessage(message);\n+    }\n+\n+    @Override\n+    public void commitType(final CommitType commitType) {\n+        inner.commitType(commitType);\n+    }\n+\n+    @Override\n+    public void commit() {\n+        exec(inner::commit);\n+    }\n+\n+    @Override\n+    public void abort() {\n+        exec(inner::abort);\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return inner.isOpen();\n+    }\n+\n+    @Override\n+    public void close() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNjQ0Mg=="}, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTI3ODQ5OnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/OcflPersistentStorageSession.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo0Mzo1NFrOHM1Bpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo0Mzo1NFrOHM1Bpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMzczNA==", "bodyText": "This method can probably be private.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483213734", "createdAt": "2020-09-03T19:43:54Z", "author": {"login": "awoods"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/OcflPersistentStorageSession.java", "diffHunk": "@@ -360,17 +332,46 @@ public void rollback() throws PersistentStorageException {\n             rollbackCommittedSessions();\n         }\n \n-        cleanupStagingDir();\n-\n         this.state = State.ROLLED_BACK;\n         LOGGER.debug(\"Successfully rolled back storage session {}\", sessionId);\n     }\n \n+    /**\n+     * Resolve an instant to a version\n+     *\n+     * @param objSession session\n+     * @param fedoraId the FedoraId of the resource\n+     * @param version version time\n+     * @return name of version\n+     * @throws PersistentStorageException thrown if version not found\n+     */\n+    public String resolveVersionNumber(final OcflObjectSession objSession,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTI5NzgwOnYy", "diffSide": "RIGHT", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/OcflPersistentStorageSession.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo0OTo1M1rOHM1NcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDowNjowOFrOHM1rOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNjc1Mg==", "bodyText": "Should we also be looking for other \"child\" types? such as, ACL or HashURI?\n..or, is there any reason not to also return the asBaseId()?", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483216752", "createdAt": "2020-09-03T19:49:53Z", "author": {"login": "awoods"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/OcflPersistentStorageSession.java", "diffHunk": "@@ -434,9 +427,19 @@ private void actionNeedsWrite() throws PersistentStorageException {\n         }\n     }\n \n-    private void cleanupStagingDir() {\n-        if (Files.exists(sessionStagingDir) && !FileUtils.deleteQuietly(sessionStagingDir.toFile())) {\n-            LOGGER.warn(\"Failed to cleanup session staging directory at {}\", sessionStagingDir);\n+    /**\n+     * Returns the RDF topic to be returned for a given resource identifier\n+     * For example:  passing info:fedora/resource1/fcr:metadata would return\n+     *  info:fedora/resource1 since  info:fedora/resource1 would be the expected\n+     *  topic.\n+     * @param fedoraIdentifier The fedora identifier\n+     * @return The resolved topic\n+     */\n+    private FedoraId resolveTopic(final FedoraId fedoraIdentifier) {\n+        if (fedoraIdentifier.isDescription()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyNDM3Ng==", "bodyText": "To be honest, I don't understand the behavior here and was just keeping it consistent with the existing code. I'm more than happy to change it, but I don't know what the correct behavior is.", "url": "https://github.com/fcrepo/fcrepo/pull/1744#discussion_r483224376", "createdAt": "2020-09-03T20:06:08Z", "author": {"login": "pwinckles"}, "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/OcflPersistentStorageSession.java", "diffHunk": "@@ -434,9 +427,19 @@ private void actionNeedsWrite() throws PersistentStorageException {\n         }\n     }\n \n-    private void cleanupStagingDir() {\n-        if (Files.exists(sessionStagingDir) && !FileUtils.deleteQuietly(sessionStagingDir.toFile())) {\n-            LOGGER.warn(\"Failed to cleanup session staging directory at {}\", sessionStagingDir);\n+    /**\n+     * Returns the RDF topic to be returned for a given resource identifier\n+     * For example:  passing info:fedora/resource1/fcr:metadata would return\n+     *  info:fedora/resource1 since  info:fedora/resource1 would be the expected\n+     *  topic.\n+     * @param fedoraIdentifier The fedora identifier\n+     * @return The resolved topic\n+     */\n+    private FedoraId resolveTopic(final FedoraId fedoraIdentifier) {\n+        if (fedoraIdentifier.isDescription()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNjc1Mg=="}, "originalCommit": {"oid": "07220a0248104955d81bcefa00727de9797af1d5"}, "originalPosition": 309}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1898, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}