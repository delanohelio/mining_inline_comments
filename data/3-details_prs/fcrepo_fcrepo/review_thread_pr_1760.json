{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NjE2NzYw", "number": 1760, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxOTo0MDo1NFrOEpLWgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozMjo1MFrOEqamWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjEzMDU4OnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxOTo0MDo1NFrOHasnNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODowODo1OFrOHbVn6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1NTk1Nw==", "bodyText": "Not sure but do you need the WHERE EXISTS clause as it seems identical to the above WHERE clause just with the addition of the \" AND mto.operation = :deleteOp\" + line. Could that be added to the original WHERE clause and the second one removed?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497755957", "createdAt": "2020-09-30T19:40:54Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyNzg4MA==", "bodyText": "The first WHERE clause is in order to get the new value for end_time, and the WHERE EXISTS is to determine which membership entries are being ended. But I'll add the operation check to the first subquery, just in case there are multiple operations for membership entry in the current transaction. If I'm remembering correctly, this query ended up kind of dumb looking because h2 doesn't support joins in UPDATE queries, so I had to have the two nearly identical subqueries.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498427880", "createdAt": "2020-10-01T18:08:58Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1NTk1Nw=="}, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjE0OTcwOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxOTo0Njo0OFrOHaszQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzoyMDoxNFrOHbKCNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1OTA0MQ==", "bodyText": "I saw this a couple places, just wondering if there is a benefit to passing a static string in versus just using 'delete' here? Same for the :addOp and 'add'?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497759041", "createdAt": "2020-09-30T19:46:48Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzODAwNQ==", "bodyText": "mainly for programmer error. When I was working on it I originally had 'delete' hardcoded in the query, but ended up with mismatches between the values in different places ('delete' vs 'deleted') which failed silently since it was valid sql. By passing in a constant it means I'll get an error if I misspell :deleteOp since the variable would be missing.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498238005", "createdAt": "2020-10-01T13:20:14Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1OTA0MQ=="}, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjE3MjQ2OnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxOTo1MzozNlrOHatBRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjowNDoxNFrOHbRXlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ==", "bodyText": "I think this needs the @Transactional annotation.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497762631", "createdAt": "2020-09-30T19:53:36Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);\n+\n+        // Add the new membership operation\n+        addMembership(txId, sourceId, membership, startTime, null);\n+    }\n+\n+    /**\n+     * Add new membership property to the index\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     * @param endTime time the membership triple ends, or never if not provided\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime, final Instant endTime) {\n+        final var endTimestamp = endTime == null ? NO_END_TIMESTAMP : Timestamp.from(endTime);\n+        // Add the new membership operation\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"targetId\", membership.getObject().getURI(),\n+                \"sourceId\", sourceId.getFullId(),\n+                \"startTime\", Timestamp.from(startTime),\n+                \"endTime\", endTimestamp,\n+                \"txId\", txId,\n+                \"operation\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(INSERT_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * Get a stream of membership triples with\n+     * @param txId transaction from which membership will be retrieved, or null for no transaction\n+     * @param subjectId ID of the subject\n+     * @return Stream of membership triples\n+     */\n+    public Stream<Triple> getMembership(final String txId, final FedoraId subjectId) {\n+        final Node subjectNode = NodeFactory.createURI(subjectId.getBaseId());\n+\n+        final RowMapper<Triple> membershipMapper = (rs, rowNum) ->\n+                Triple.create(subjectNode,\n+                              NodeFactory.createURI(rs.getString(\"property\")),\n+                              NodeFactory.createURI(rs.getString(\"object_id\")));\n+\n+        List<Triple> membership = null;\n+        if (txId == null) {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant());\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP, parameterSource, membershipMapper);\n+            }\n+        } else {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant(),\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO_IN_TX, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP,\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_IN_TX, parameterSource, membershipMapper);\n+            }\n+        }\n+\n+        return membership.stream();\n+    }\n+\n+    /**\n+     * Perform a commit of operations stored in the specified transaction\n+     * @param txId transaction id\n+     */\n+    public void commitTransaction(final String txId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzOTkyMA==", "bodyText": "I'll add that. Is it needed for all methods that modify the index?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498239920", "createdAt": "2020-10-01T13:22:57Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);\n+\n+        // Add the new membership operation\n+        addMembership(txId, sourceId, membership, startTime, null);\n+    }\n+\n+    /**\n+     * Add new membership property to the index\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     * @param endTime time the membership triple ends, or never if not provided\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime, final Instant endTime) {\n+        final var endTimestamp = endTime == null ? NO_END_TIMESTAMP : Timestamp.from(endTime);\n+        // Add the new membership operation\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"targetId\", membership.getObject().getURI(),\n+                \"sourceId\", sourceId.getFullId(),\n+                \"startTime\", Timestamp.from(startTime),\n+                \"endTime\", endTimestamp,\n+                \"txId\", txId,\n+                \"operation\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(INSERT_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * Get a stream of membership triples with\n+     * @param txId transaction from which membership will be retrieved, or null for no transaction\n+     * @param subjectId ID of the subject\n+     * @return Stream of membership triples\n+     */\n+    public Stream<Triple> getMembership(final String txId, final FedoraId subjectId) {\n+        final Node subjectNode = NodeFactory.createURI(subjectId.getBaseId());\n+\n+        final RowMapper<Triple> membershipMapper = (rs, rowNum) ->\n+                Triple.create(subjectNode,\n+                              NodeFactory.createURI(rs.getString(\"property\")),\n+                              NodeFactory.createURI(rs.getString(\"object_id\")));\n+\n+        List<Triple> membership = null;\n+        if (txId == null) {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant());\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP, parameterSource, membershipMapper);\n+            }\n+        } else {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant(),\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO_IN_TX, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP,\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_IN_TX, parameterSource, membershipMapper);\n+            }\n+        }\n+\n+        return membership.stream();\n+    }\n+\n+    /**\n+     * Perform a commit of operations stored in the specified transaction\n+     * @param txId transaction id\n+     */\n+    public void commitTransaction(final String txId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ=="}, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2NjIzOA==", "bodyText": "Just if you are performing multiple SQL statements that all either need to succeed or the whole thing fail. In the Containment index only commit and reset are transactional as they each have more than one updates that must occur.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498266238", "createdAt": "2020-10-01T13:59:09Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);\n+\n+        // Add the new membership operation\n+        addMembership(txId, sourceId, membership, startTime, null);\n+    }\n+\n+    /**\n+     * Add new membership property to the index\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     * @param endTime time the membership triple ends, or never if not provided\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime, final Instant endTime) {\n+        final var endTimestamp = endTime == null ? NO_END_TIMESTAMP : Timestamp.from(endTime);\n+        // Add the new membership operation\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"targetId\", membership.getObject().getURI(),\n+                \"sourceId\", sourceId.getFullId(),\n+                \"startTime\", Timestamp.from(startTime),\n+                \"endTime\", endTimestamp,\n+                \"txId\", txId,\n+                \"operation\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(INSERT_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * Get a stream of membership triples with\n+     * @param txId transaction from which membership will be retrieved, or null for no transaction\n+     * @param subjectId ID of the subject\n+     * @return Stream of membership triples\n+     */\n+    public Stream<Triple> getMembership(final String txId, final FedoraId subjectId) {\n+        final Node subjectNode = NodeFactory.createURI(subjectId.getBaseId());\n+\n+        final RowMapper<Triple> membershipMapper = (rs, rowNum) ->\n+                Triple.create(subjectNode,\n+                              NodeFactory.createURI(rs.getString(\"property\")),\n+                              NodeFactory.createURI(rs.getString(\"object_id\")));\n+\n+        List<Triple> membership = null;\n+        if (txId == null) {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant());\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP, parameterSource, membershipMapper);\n+            }\n+        } else {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant(),\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO_IN_TX, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP,\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_IN_TX, parameterSource, membershipMapper);\n+            }\n+        }\n+\n+        return membership.stream();\n+    }\n+\n+    /**\n+     * Perform a commit of operations stored in the specified transaction\n+     * @param txId transaction id\n+     */\n+    public void commitTransaction(final String txId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ=="}, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM1ODE2Nw==", "bodyText": "Okay, I'll add the annotation to a few more places", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498358167", "createdAt": "2020-10-01T16:04:14Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);\n+\n+        // Add the new membership operation\n+        addMembership(txId, sourceId, membership, startTime, null);\n+    }\n+\n+    /**\n+     * Add new membership property to the index\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     * @param endTime time the membership triple ends, or never if not provided\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime, final Instant endTime) {\n+        final var endTimestamp = endTime == null ? NO_END_TIMESTAMP : Timestamp.from(endTime);\n+        // Add the new membership operation\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"targetId\", membership.getObject().getURI(),\n+                \"sourceId\", sourceId.getFullId(),\n+                \"startTime\", Timestamp.from(startTime),\n+                \"endTime\", endTimestamp,\n+                \"txId\", txId,\n+                \"operation\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(INSERT_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * Get a stream of membership triples with\n+     * @param txId transaction from which membership will be retrieved, or null for no transaction\n+     * @param subjectId ID of the subject\n+     * @return Stream of membership triples\n+     */\n+    public Stream<Triple> getMembership(final String txId, final FedoraId subjectId) {\n+        final Node subjectNode = NodeFactory.createURI(subjectId.getBaseId());\n+\n+        final RowMapper<Triple> membershipMapper = (rs, rowNum) ->\n+                Triple.create(subjectNode,\n+                              NodeFactory.createURI(rs.getString(\"property\")),\n+                              NodeFactory.createURI(rs.getString(\"object_id\")));\n+\n+        List<Triple> membership = null;\n+        if (txId == null) {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant());\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP, parameterSource, membershipMapper);\n+            }\n+        } else {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant(),\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO_IN_TX, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP,\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_IN_TX, parameterSource, membershipMapper);\n+            }\n+        }\n+\n+        return membership.stream();\n+    }\n+\n+    /**\n+     * Perform a commit of operations stored in the specified transaction\n+     * @param txId transaction id\n+     */\n+    public void commitTransaction(final String txId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ=="}, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 525}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjIxNzU1OnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMDowNzozNVrOHatdpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODowMjozM1rOHbVbFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2OTg5Mw==", "bodyText": "I must be reading this wrong. It appears that if you are not using auto versioning then any change to a direct container rebuilds its entire membership history?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497769893", "createdAt": "2020-09-30T20:07:35Z", "author": {"login": "whikloj"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyNDU5OQ==", "bodyText": "No, you're reading it correctly. I ended up doing that because modifying the mutable head of a DC can change the committed membership entries, including for deleted members, so it seemed like things were going to get very messy. But thinking about it some more today, I'm realizing I can probably do it as a modification, so I'll try to switch it over.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498424599", "createdAt": "2020-10-01T18:02:33Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2OTg5Mw=="}, "originalCommit": {"oid": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTU3NzkzOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDozOTozMFrOHbNoWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoxNDo1OFrOHbVz6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5NjkyMQ==", "bodyText": "Going forward, I think it would be better if we inject the config objects rather than directly from properties. It will make it easier if we don't have to search through the entire code base to find where a property is being accessed. You could either inject the config bean and programmatically access the value you want, or use a value annotation like @Value(\"#{configBeanName.autoVersioningEnabled}\").", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498296921", "createdAt": "2020-10-01T14:39:30Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyOTQ4OQ==", "bodyText": "I initially tried to inject the config object, but it wasn't available within fcrepo-kernel-impl because fcrepo-configs isn't a dependency of that module. Maybe it should be? It might be nice if weren't coming from an OCFL named class as well.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498429489", "createdAt": "2020-10-01T18:12:03Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5NjkyMQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMDk1Mg==", "bodyText": "It shouldn't be a problem for any module to take a dependency on fcrepo-configs.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498430952", "createdAt": "2020-10-01T18:14:58Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5NjkyMQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDEzMzAyOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjo1NDo0NFrOHbTKaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjo1NDo0NFrOHbTKaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4NzU2MQ==", "bodyText": "Missing an argument", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498387561", "createdAt": "2020-10-01T16:54:44Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDE3MTczOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzowNzoxMFrOHbTk1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoxNjoyM1rOHbV2_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDMyNQ==", "bodyText": "m2 is not used.\nI think this could also be rewritten like: .sorted(Comparator.comparing(m -> m.getFedoraId().getFullId()))", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498394325", "createdAt": "2020-10-01T17:07:10Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDc2OQ==", "bodyText": "Are you just trying to sort the mementos by date? If so, I think they should already be sorted.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498394769", "createdAt": "2020-10-01T17:07:59Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDMyNQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMTc0MA==", "bodyText": "Yes, I'm trying to sort them by date, I'm happy to remove the sort (and its typo) if we can rely on the versions to be sorted in ascending order. If that's a guarantee, perhaps we should update the documentation for org.fcrepo.persistence.api.PersistentStorageSession.listVersions(FedoraId) to state that? Any other theoretic persistence implementations would need to ensure order too.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498431740", "createdAt": "2020-10-01T18:16:23Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDMyNQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDE3OTIwOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzowOTozN1rOHbTp7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoxODo1MFrOHbV7_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTYyOQ==", "bodyText": "Why are you using a while loop rather than a for loop?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498395629", "createdAt": "2020-10-01T17:09:37Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))\n+                .map(memento -> new DirectContainerProperties(memento))\n+                .collect(Collectors.toList());\n+\n+        // Reduce timeline to entries where significant properties change\n+        final var changeEntries = new ArrayList<DirectContainerProperties>();\n+        var curr = entryList.get(0);\n+        changeEntries.add(curr);\n+        int i = 1;\n+        while (i < entryList.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMzAyMw==", "bodyText": "Hmm, I'd like to think I had a reason at some point, but doesn't seem like there is one, I'll switch it.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498433023", "createdAt": "2020-10-01T18:18:50Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))\n+                .map(memento -> new DirectContainerProperties(memento))\n+                .collect(Collectors.toList());\n+\n+        // Reduce timeline to entries where significant properties change\n+        final var changeEntries = new ArrayList<DirectContainerProperties>();\n+        var curr = entryList.get(0);\n+        changeEntries.add(curr);\n+        int i = 1;\n+        while (i < entryList.size()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTYyOQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDE5ODAwOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoxNTozMFrOHbT2eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoxNTozMFrOHbT2eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5ODg0MQ==", "bodyText": "I think you'll actually want a @Transactional at this level", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498398841", "createdAt": "2020-10-01T17:15:30Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDIwMzA4OnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoxNjo1MVrOHbT5ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoyNjozOFrOHbWL8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTYxMQ==", "bodyText": "@Transactional", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498399611", "createdAt": "2020-10-01T17:16:51Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNDQyMA==", "bodyText": "Sure. In the case of a container with lots of members this could be a very long transaction, I'm guessing that won't be problematic?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498434420", "createdAt": "2020-10-01T18:21:29Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTYxMQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNzEwNQ==", "bodyText": "No, I wouldn't expect that would be a problem", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498437105", "createdAt": "2020-10-01T18:26:38Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTYxMQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDIwMzg5OnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoxNzowN1rOHbT6Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoxNzowN1rOHbT6Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTc1MA==", "bodyText": "@Transactional", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498399750", "createdAt": "2020-10-01T17:17:07Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDIxMzY3OnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoyMDoxMlrOHbUAdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoyNjo1N1rOHbWMkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMTM5OA==", "bodyText": "Perhaps the column names should be constants?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498401398", "createdAt": "2020-10-01T17:20:12Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNTIzMA==", "bodyText": "The parameter names or the column names? I'm okay with constants for the parameter names", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498435230", "createdAt": "2020-10-01T18:23:09Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMTM5OA=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNzI2NA==", "bodyText": "The keys in the map", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498437264", "createdAt": "2020-10-01T18:26:57Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMTM5OA=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDMxMDczOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzo0OToyNFrOHbU-3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoyNTozMVrOHbWJvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxNzM3NQ==", "bodyText": "I think there may be some oddness here when addMembership() is called after calling deleteMembershipForSource(), but it's possible that I just don't understand the intended behavior. The problem I see is that there are two different types of deletes, with or without the force flag. deleteMembershipForSource() creates deletes with the force flag, and I assume that you would always want to apply them. However, this method will delete all of these operations in the transaction, so they won't be applied. Won't this result in duplicate entries (assuming there aren't any db constraints being violated)? I think the case where this matters is MembershipServiceImpl#L104.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498417375", "createdAt": "2020-10-01T17:49:24Z", "author": {"login": "pwinckles"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 436}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNjU0MQ==", "bodyText": "That's a good point, I believe I should exclude force_flag deletes from being cleaned up here.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498436541", "createdAt": "2020-10-01T18:25:31Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxNzM3NQ=="}, "originalCommit": {"oid": "a64c47de676a72456a64bcef747fffb7b3890cc5"}, "originalPosition": 436}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODcxMjkwOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNTo0NDo0M1rOHcjDdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDozMDowMVrOHcsrYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NjUwMw==", "bodyText": "To be clear, this SQL deletes membership relations when the provided dateTime is either before (or at) the \"start_time\" of the relationship or the provided dateTime is before (or at) the \"end_time\" of the relationship?\nIt probably makes sense... I am just trying to understand the scenario.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499696503", "createdAt": "2020-10-05T15:44:43Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMzAyOQ==", "bodyText": "Yes, that's right. It is to deal with obnoxious history rewriting from modifying mutable head versions of DirectContainers. Sorry to do this to you, but consider the following timeline, in a repo with autoversioning turned off:\n\nCreate membership resc coll1 and direct container dc1 with membership relation ex:hasMember1, at time T0.\nAt time T1, resource dc1/mem1 is created. This adds an entry to the index:\n<coll1> ex:hasMember1 <dc1/mem1> which spans T1 to forever.\nAt time T2, dc1 is changed to have relation ex:hasMember2. The index is now:\n<coll1> ex:hasMember2 <dc1/mem1> which spans T1 to forever (the old entry is deleted since its end time was >= T2)\nAt T3, create V1 of dc1. No changes to the index.\nAt time T4, dc1 is changed to have relation ex:hasMember3. The index is now:\n<coll1> ex:hasMember2 <dc1/mem1> which spans T1 to T4 (T3/V1 locked ex:hasMember2 in, which changes at T4)\n<coll1> ex:hasMember3 <dc1/mem1> which spans T4 to forever.\nAt T5, dc1 is changed back to relation ex:hasMember1. History in the index is editted:\n<coll1> ex:hasMember2 <dc1/mem1> which spans T1 to T5 (note, end time changed)\n<coll1> ex:hasMember1 <dc1/mem1> which spans T5 to forever.\n\nThe query in question allows the last few states to be rewritten. Alternatively, I could regenerate the full history of membership produced by dc1 whenever its modified, which I had earlier in the PR. Its simpler, but obviously costly in scenarios where clients create versions of DCs and modify them.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499813029", "createdAt": "2020-10-05T19:10:10Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NjUwMw=="}, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NDE3Nw==", "bodyText": "Thanks for the explanation and deep consideration of scenarios.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499854177", "createdAt": "2020-10-05T20:30:01Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NjUwMw=="}, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTAwMzUwOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzowMDoyMVrOHcl6Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODo1MTo0MlrOHcpjug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MzI3OA==", "bodyText": "Can this method be removed? It does not appear to be called anywhere.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499743278", "createdAt": "2020-10-05T17:00:21Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/mariadb-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    @Transactional\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                TX_ID_PARAM, txId,\n+                SOURCE_ID_PARAM, sourceId.getFullId(),\n+                SUBJECT_ID_PARAM, membership.getSubject().getURI(),\n+                PROPERTY_PARAM, membership.getPredicate().getURI(),\n+                OBJECT_ID_PARAM, membership.getObject().getURI(),\n+                OPERATION_PARAM, ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    TX_ID_PARAM, txId,\n+                    SOURCE_ID_PARAM, sourceId.getFullId(),\n+                    SUBJECT_ID_PARAM, membership.getSubject().getURI(),\n+                    PROPERTY_PARAM, membership.getPredicate().getURI(),\n+                    OBJECT_ID_PARAM, membership.getObject().getURI(),\n+                    END_TIME_PARAM, Timestamp.from(endTime),\n+                    NO_END_TIME_PARAM, NO_END_TIMESTAMP,\n+                    DELETE_OP_PARAM, DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMzA2Ng==", "bodyText": "Good catch, I think this got leftover during a few refactors of populateMembershipHistory", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499803066", "createdAt": "2020-10-05T18:51:42Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/mariadb-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    @Transactional\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                TX_ID_PARAM, txId,\n+                SOURCE_ID_PARAM, sourceId.getFullId(),\n+                SUBJECT_ID_PARAM, membership.getSubject().getURI(),\n+                PROPERTY_PARAM, membership.getPredicate().getURI(),\n+                OBJECT_ID_PARAM, membership.getObject().getURI(),\n+                OPERATION_PARAM, ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    TX_ID_PARAM, txId,\n+                    SOURCE_ID_PARAM, sourceId.getFullId(),\n+                    SUBJECT_ID_PARAM, membership.getSubject().getURI(),\n+                    PROPERTY_PARAM, membership.getPredicate().getURI(),\n+                    OBJECT_ID_PARAM, membership.getObject().getURI(),\n+                    END_TIME_PARAM, Timestamp.from(endTime),\n+                    NO_END_TIME_PARAM, NO_END_TIMESTAMP,\n+                    DELETE_OP_PARAM, DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MzI3OA=="}, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTA4Mjk2OnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoyMzoyM1rOHcmrzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoyMzoyM1rOHcmrzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NTk4Mw==", "bodyText": "txId never used.", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499755983", "createdAt": "2020-10-05T17:23:23Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import javax.transaction.Transactional;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Inject\n+    private OcflPropsConfig propsConfig;\n+\n+    @Override\n+    @Transactional\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            if (propsConfig.isAutoVersioningEnabled()) {\n+                modifyDCAutoversioned(txId, fedoraResc);\n+            } else {\n+                modifyDCOnDemandVersioning(txId, fedoraResc);\n+            }\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private void modifyDCAutoversioned(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var dcRdfResc = getRdfResource(dcResc);\n+\n+        final var dcLastModified = dcResc.getLastModifiedDate();\n+\n+        // Delete/end existing membership from this container\n+        indexManager.endMembershipForSource(txId, dcResc.getFedoraId(), dcLastModified);\n+\n+        // Add updated membership properties for all non-tombstone children\n+        dcResc.getChildren()\n+                .filter(child -> !(child instanceof Tombstone))\n+                .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                .forEach(newMembership -> indexManager.addMembership(txId, dcId,\n+                        newMembership, dcLastModified));\n+    }\n+\n+    private void modifyDCOnDemandVersioning(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var mementoDatetimes = dcResc.getTimeMap().listMementoDatetimes();\n+        final Instant lastVersionDatetime;\n+        if (mementoDatetimes.size() == 0) {\n+            // If no previous versions of DC, then cleanup and repopulate everything\n+            lastVersionDatetime = null;\n+        } else {\n+            // If at least one past version, then reindex membership involving the last version and after\n+            lastVersionDatetime = mementoDatetimes.get(mementoDatetimes.size() - 1);\n+        }\n+        indexManager.deleteMembershipForSourceAfter(txId, dcId, lastVersionDatetime);\n+        populateMembershipHistory(txId, dcResc, lastVersionDatetime);\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTExNDUxOnYy", "diffSide": "RIGHT", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozMjo1MFrOHcm_zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODo0ODoxMlrOHcpcFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTEwMQ==", "bodyText": "Maybe add a , between \"{}\" and \"member\"?", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499761101", "createdAt": "2020-10-05T17:32:50Z", "author": {"login": "awoods"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import javax.transaction.Transactional;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Inject\n+    private OcflPropsConfig propsConfig;\n+\n+    @Override\n+    @Transactional\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            if (propsConfig.isAutoVersioningEnabled()) {\n+                modifyDCAutoversioned(txId, fedoraResc);\n+            } else {\n+                modifyDCOnDemandVersioning(txId, fedoraResc);\n+            }\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private void modifyDCAutoversioned(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var dcRdfResc = getRdfResource(dcResc);\n+\n+        final var dcLastModified = dcResc.getLastModifiedDate();\n+\n+        // Delete/end existing membership from this container\n+        indexManager.endMembershipForSource(txId, dcResc.getFedoraId(), dcLastModified);\n+\n+        // Add updated membership properties for all non-tombstone children\n+        dcResc.getChildren()\n+                .filter(child -> !(child instanceof Tombstone))\n+                .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                .forEach(newMembership -> indexManager.addMembership(txId, dcId,\n+                        newMembership, dcLastModified));\n+    }\n+\n+    private void modifyDCOnDemandVersioning(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var mementoDatetimes = dcResc.getTimeMap().listMementoDatetimes();\n+        final Instant lastVersionDatetime;\n+        if (mementoDatetimes.size() == 0) {\n+            // If no previous versions of DC, then cleanup and repopulate everything\n+            lastVersionDatetime = null;\n+        } else {\n+            // If at least one past version, then reindex membership involving the last version and after\n+            lastVersionDatetime = mementoDatetimes.get(mementoDatetimes.size() - 1);\n+        }\n+        indexManager.deleteMembershipForSourceAfter(txId, dcId, lastVersionDatetime);\n+        populateMembershipHistory(txId, dcResc, lastVersionDatetime);\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\", fedoraId);\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            populateMembershipHistory(txId, fedoraResc, null);\n+        }\n+    }\n+\n+    private void populateMembershipHistory(final String txId, final FedoraResource fedoraResc,\n+            final Instant afterTime) {\n+        final var containerId = fedoraResc.getFedoraId();\n+        final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+        final List<DirectContainerProperties> timeline;\n+        // If provided, filter the timeline to just entries active on or after the specified time\n+        if (afterTime != null) {\n+            timeline = propertyTimeline.stream().filter(e -> e.startDatetime.compareTo(afterTime) >= 0\n+                    || e.endDatetime.compareTo(afterTime) >= 0)\n+                .collect(Collectors.toList());\n+        } else {\n+            timeline = propertyTimeline;\n+        }\n+\n+        // get all the members of the DC and index the history for each, accounting for changes to the DC\n+        fedoraResc.getChildren().forEach(member -> {\n+            final var memberDeleted = member instanceof Tombstone;\n+            final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+            log.debug(\"Populating membership history for DirectContainer {}member {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMTEwOQ==", "bodyText": "I know it looks goofy, but that would result in two spaces between DirectContainer and member if the member isn't deleted. I could remove the deletion state from the debug statement though", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499801109", "createdAt": "2020-10-05T18:48:12Z", "author": {"login": "bbpennel"}, "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import javax.transaction.Transactional;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Inject\n+    private OcflPropsConfig propsConfig;\n+\n+    @Override\n+    @Transactional\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            if (propsConfig.isAutoVersioningEnabled()) {\n+                modifyDCAutoversioned(txId, fedoraResc);\n+            } else {\n+                modifyDCOnDemandVersioning(txId, fedoraResc);\n+            }\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private void modifyDCAutoversioned(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var dcRdfResc = getRdfResource(dcResc);\n+\n+        final var dcLastModified = dcResc.getLastModifiedDate();\n+\n+        // Delete/end existing membership from this container\n+        indexManager.endMembershipForSource(txId, dcResc.getFedoraId(), dcLastModified);\n+\n+        // Add updated membership properties for all non-tombstone children\n+        dcResc.getChildren()\n+                .filter(child -> !(child instanceof Tombstone))\n+                .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                .forEach(newMembership -> indexManager.addMembership(txId, dcId,\n+                        newMembership, dcLastModified));\n+    }\n+\n+    private void modifyDCOnDemandVersioning(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var mementoDatetimes = dcResc.getTimeMap().listMementoDatetimes();\n+        final Instant lastVersionDatetime;\n+        if (mementoDatetimes.size() == 0) {\n+            // If no previous versions of DC, then cleanup and repopulate everything\n+            lastVersionDatetime = null;\n+        } else {\n+            // If at least one past version, then reindex membership involving the last version and after\n+            lastVersionDatetime = mementoDatetimes.get(mementoDatetimes.size() - 1);\n+        }\n+        indexManager.deleteMembershipForSourceAfter(txId, dcId, lastVersionDatetime);\n+        populateMembershipHistory(txId, dcResc, lastVersionDatetime);\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\", fedoraId);\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            populateMembershipHistory(txId, fedoraResc, null);\n+        }\n+    }\n+\n+    private void populateMembershipHistory(final String txId, final FedoraResource fedoraResc,\n+            final Instant afterTime) {\n+        final var containerId = fedoraResc.getFedoraId();\n+        final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+        final List<DirectContainerProperties> timeline;\n+        // If provided, filter the timeline to just entries active on or after the specified time\n+        if (afterTime != null) {\n+            timeline = propertyTimeline.stream().filter(e -> e.startDatetime.compareTo(afterTime) >= 0\n+                    || e.endDatetime.compareTo(afterTime) >= 0)\n+                .collect(Collectors.toList());\n+        } else {\n+            timeline = propertyTimeline;\n+        }\n+\n+        // get all the members of the DC and index the history for each, accounting for changes to the DC\n+        fedoraResc.getChildren().forEach(member -> {\n+            final var memberDeleted = member instanceof Tombstone;\n+            final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+            log.debug(\"Populating membership history for DirectContainer {}member {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTEwMQ=="}, "originalCommit": {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b"}, "originalPosition": 314}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1670, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}