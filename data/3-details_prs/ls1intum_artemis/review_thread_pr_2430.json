{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNzgzNTcx", "number": 2430, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOToyMToyN1rOE68oQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDo1Mjo0NFrOE8wh-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjQ2MjA4OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOToyMToyN1rOH2TtTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDozMjowMFrOH2wd1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcwODA0NQ==", "bodyText": "then -> the.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r526708045", "createdAt": "2020-11-19T09:21:27Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -152,3 +152,12 @@ Additional notes on the controller methods:\n * Use ``./gradlew spotlessCheck`` and ``./gradlew spotlessApply`` to check Java code style and to automatically fix it.\n \n Some parts of these guidelines are adapted from https://medium.com/@madhupathy/ultimate-clean-code-guide-for-java-spring-based-applications-4d4c9095cc2a\n+\n+15. Solution for known issues\n+==============================\n+* ``JpaSystemException: null index column for collection`` caused by ``@OrderColumn`` annotation\n+    #. Save the child entity (e.g. `Feedback <https://github.com/ls1intum/Artemis/blob/develop/src/main/java/de/tum/in/www1/artemis/domain/Feedback.java>`_) without connection to the parent entity (e.g. `Result <https://github.com/ls1intum/Artemis/blob/develop/src/main/java/de/tum/in/www1/artemis/domain/Result.java>`_)\n+    #. Add back then connection of the child entity to the parent entity", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642ef3c8bc938c6fb42c37c5f86b5ff383e75f80"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3OTIyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                #. Add back then connection of the child entity to the parent entity\n          \n          \n            \n                #. Add back the connection of the child entity to the parent entity", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r527179221", "createdAt": "2020-11-19T20:32:00Z", "author": {"login": "fde312"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -152,3 +152,12 @@ Additional notes on the controller methods:\n * Use ``./gradlew spotlessCheck`` and ``./gradlew spotlessApply`` to check Java code style and to automatically fix it.\n \n Some parts of these guidelines are adapted from https://medium.com/@madhupathy/ultimate-clean-code-guide-for-java-spring-based-applications-4d4c9095cc2a\n+\n+15. Solution for known issues\n+==============================\n+* ``JpaSystemException: null index column for collection`` caused by ``@OrderColumn`` annotation\n+    #. Save the child entity (e.g. `Feedback <https://github.com/ls1intum/Artemis/blob/develop/src/main/java/de/tum/in/www1/artemis/domain/Feedback.java>`_) without connection to the parent entity (e.g. `Result <https://github.com/ls1intum/Artemis/blob/develop/src/main/java/de/tum/in/www1/artemis/domain/Result.java>`_)\n+    #. Add back then connection of the child entity to the parent entity", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcwODA0NQ=="}, "originalCommit": {"oid": "642ef3c8bc938c6fb42c37c5f86b5ff383e75f80"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTA3OTMxOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODo1Njo1M1rOH2tGmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODo1Njo1M1rOH2tGmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyNDEyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            15. Solution for known issues\n          \n          \n            \n            15. Solutions for known issues", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r527124123", "createdAt": "2020-11-19T18:56:53Z", "author": {"login": "kloessst"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -152,3 +152,12 @@ Additional notes on the controller methods:\n * Use ``./gradlew spotlessCheck`` and ``./gradlew spotlessApply`` to check Java code style and to automatically fix it.\n \n Some parts of these guidelines are adapted from https://medium.com/@madhupathy/ultimate-clean-code-guide-for-java-spring-based-applications-4d4c9095cc2a\n+\n+15. Solution for known issues", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642ef3c8bc938c6fb42c37c5f86b5ff383e75f80"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTg3MjU1OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMDo0OTowM1rOH3tn_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMDo0OTowM1rOH3tn_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4MTI0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need to association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n          \n          \n            \n            * If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528181244", "createdAt": "2020-11-21T10:49:03Z", "author": {"login": "FuchsDominik"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet\n+\n+\n+Best Practices\n+===============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need to association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1983e5156632505ded01c5a9108170d13776237f"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTg3NDY4OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMDo1MToyNFrOH3to-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMDo1MToyNFrOH3to-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4MTQ5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to be made to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n          \n          \n            \n              * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528181497", "createdAt": "2020-11-21T10:51:24Z", "author": {"login": "FuchsDominik"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet\n+\n+\n+Best Practices\n+===============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need to association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to be made to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1983e5156632505ded01c5a9108170d13776237f"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjAwNjQzOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzozMjo1OVrOH3ulUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDoyNzozN1rOH4HTWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5Njk0NQ==", "bodyText": "Shouldn't this be easier to implement instead of more difficult?", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528196945", "createdAt": "2020-11-21T13:32:59Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMTk0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n          \n          \n            \n            In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528601947", "createdAt": "2020-11-23T10:27:37Z", "author": {"login": "fde312"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5Njk0NQ=="}, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjAwOTI3OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzozNjo0OFrOH3umrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDoyNDoxOVrOH4HLww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5NzI5NA==", "bodyText": "with be stuck -> will be stuck", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528197294", "createdAt": "2020-11-21T13:36:48Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDAwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n          \n          \n            \n                    For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528600003", "createdAt": "2020-11-23T10:24:19Z", "author": {"login": "fde312"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5NzI5NA=="}, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjAxMDkyOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzozOToyMFrOH3unfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDoyNToxNVrOH4HN9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5NzUwMA==", "bodyText": "Double whitespace after (saved/updated/synchronized).", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528197500", "createdAt": "2020-11-21T13:39:20Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDU2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n          \n          \n            \n            * ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528600567", "createdAt": "2020-11-23T10:25:15Z", "author": {"login": "fde312"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5NzUwMA=="}, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjAxMjE4OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzo0MDoxNlrOH3uoBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDoyNTo0NlrOH4HPUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5NzYzOA==", "bodyText": "Missing fullstop.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528197638", "createdAt": "2020-11-21T13:40:16Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDkxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Not used in Artemis yet\n          \n          \n            \n            Not used in Artemis yet.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528600914", "createdAt": "2020-11-23T10:25:46Z", "author": {"login": "fde312"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5NzYzOA=="}, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjAxMjMwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzo0MDoyOFrOH3uoFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDoyNTo1NlrOH4HPpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5NzY1NA==", "bodyText": "One = too much here.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528197654", "createdAt": "2020-11-21T13:40:28Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet\n+\n+\n+Best Practices\n+===============", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDk5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===============\n          \n          \n            \n            ==============", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528600997", "createdAt": "2020-11-23T10:25:56Z", "author": {"login": "fde312"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet\n+\n+\n+Best Practices\n+===============", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5NzY1NA=="}, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjAxNDI1OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzo0MjozMVrOH3upAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDoyNjo0M1rOH4HRJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5Nzg4OA==", "bodyText": "Four too many =.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528197888", "createdAt": "2020-11-21T13:42:31Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet\n+\n+\n+Best Practices\n+===============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+               // cut association to parent object\n+               feedback.setResult(null);\n+               // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+               feedback = feedbackRepository.save(feedback);\n+               // restore the association to the parent object\n+               feedback.setResult(result);\n+               savedFeedbacks.add(feedback);\n+               });\n+\n+        // set the association of the parent to its child objects which are now persisted in the database\n+        result.setFeedbacks(savedFeedbacks);\n+        // persist the parent object\n+        return resultRepository.save(result);\n+\n+\n+Solutions for known issues\n+==============================", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMTM4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ==============================\n          \n          \n            \n            ==========================", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528601382", "createdAt": "2020-11-23T10:26:43Z", "author": {"login": "fde312"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet\n+\n+\n+Best Practices\n+===============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+               // cut association to parent object\n+               feedback.setResult(null);\n+               // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+               feedback = feedbackRepository.save(feedback);\n+               // restore the association to the parent object\n+               feedback.setResult(result);\n+               savedFeedbacks.add(feedback);\n+               });\n+\n+        // set the association of the parent to its child objects which are now persisted in the database\n+        result.setFeedbacks(savedFeedbacks);\n+        // persist the parent object\n+        return resultRepository.save(result);\n+\n+\n+Solutions for known issues\n+==============================", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5Nzg4OA=="}, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjAxNzYwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzo0Njo1NVrOH3uqlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzo0Njo1NVrOH3uqlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5ODI5NA==", "bodyText": "The indentation here looks off, considering we use 4 spaces below. I suggest:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           // cut association to parent object\n          \n          \n            \n                           feedback.setResult(null);\n          \n          \n            \n                           // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n          \n          \n            \n                           feedback = feedbackRepository.save(feedback);\n          \n          \n            \n                           // restore the association to the parent object\n          \n          \n            \n                           feedback.setResult(result);\n          \n          \n            \n                           savedFeedbacks.add(feedback);\n          \n          \n            \n                           });\n          \n          \n            \n                       // cut association to parent object\n          \n          \n            \n                       feedback.setResult(null);\n          \n          \n            \n                       // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n          \n          \n            \n                       feedback = feedbackRepository.save(feedback);\n          \n          \n            \n                       // restore the association to the parent object\n          \n          \n            \n                       feedback.setResult(result);\n          \n          \n            \n                       savedFeedbacks.add(feedback);\n          \n          \n            \n                   });", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528198294", "createdAt": "2020-11-21T13:46:55Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized)  to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet\n+\n+\n+Best Practices\n+===============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+               // cut association to parent object\n+               feedback.setResult(null);\n+               // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+               feedback = feedbackRepository.save(feedback);\n+               // restore the association to the parent object\n+               feedback.setResult(result);\n+               savedFeedbacks.add(feedback);\n+               });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjAxODU1OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMzo0Nzo1MVrOH3urAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDoyNDo0NFrOH4HMvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5ODQwMA==", "bodyText": "This also has one = too much.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528198400", "createdAt": "2020-11-21T13:47:51Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDI1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            =================\n          \n          \n            \n            ================", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528600253", "createdAt": "2020-11-23T10:24:44Z", "author": {"login": "fde312"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more difficult to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process with be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+=================", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5ODQwMA=="}, "originalCommit": {"oid": "1398412106a785574106fbff126da4e7c8991fec"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzA1MjIwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODoxNToxNVrOH4ZvhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDowMjo0M1rOH4dXjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwNDA2OQ==", "bodyText": "GitHub Actions complains now with Explicit markup ends without a blank line; unexpected unindent.. I think we just need to add an additional new line. (All the other code-blocks have two empty lines trailing.)", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528904069", "createdAt": "2020-11-23T18:15:15Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+           // cut association to parent object\n+           feedback.setResult(null);\n+           // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+           feedback = feedbackRepository.save(feedback);\n+           // restore the association to the parent object\n+           feedback.setResult(result);\n+           savedFeedbacks.add(feedback);\n+       });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e1f680c3ba4b033bc6fa6a4e6f872393b25032"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2MzQ2OQ==", "bodyText": "Nice catch", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528963469", "createdAt": "2020-11-23T20:02:43Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,235 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+           // cut association to parent object\n+           feedback.setResult(null);\n+           // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+           feedback = feedbackRepository.save(feedback);\n+           // restore the association to the parent object\n+           feedback.setResult(result);\n+           savedFeedbacks.add(feedback);\n+       });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwNDA2OQ=="}, "originalCommit": {"oid": "88e1f680c3ba4b033bc6fa6a4e6f872393b25032"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ1OTkzOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDowODoyM1rOH4diow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDo0MDowNlrOH4ehAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NjMwNw==", "bodyText": "[...] inverse of an OneToMany relationship. [...]", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528966307", "createdAt": "2020-11-23T20:08:23Z", "author": {"login": "JohannesWeiss"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4MjI3Mg==", "bodyText": "... a OneToMany ... is actually the correct form here for the following reason:\nThe word \u201cone\u201d starts with a vowel, but the sound it makes is the consonant \u201cw.\u201d", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528982272", "createdAt": "2020-11-23T20:40:06Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NjMwNw=="}, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ2Mjk0OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDowOToxN1rOH4dkbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDowOToxN1rOH4dkbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2Njc2Ng==", "bodyText": "[...] inverse of -a- itself. [...]", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528966766", "createdAt": "2020-11-23T20:09:17Z", "author": {"login": "JohannesWeiss"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ3NTUzOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMjo1OVrOH4dr1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDozMTowOVrOH4ePvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODY2MQ==", "bodyText": "what do you mean with retrieving and building an object's relationship? I don't fully understand the first sentence: The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object.\nshould we use database language, like fetching an object vs joining tables?", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528968661", "createdAt": "2020-11-23T20:12:59Z", "author": {"login": "TobiasPr"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3Nzg1Mw==", "bodyText": "Retrieving and building refers to creating the java object and instantiating its relationships to other objects. Selecting the object refers to simply selecting an object from the database. I'm not sure how to reformulate this more clearly. Do you have a suggestion?", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528977853", "createdAt": "2020-11-23T20:31:09Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODY2MQ=="}, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ3NjQ2OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMzoxOVrOH4dsZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMzoxOVrOH4dsZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODgwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Database Relationship\n          \n          \n            \n            Database Relationships\n          \n      \n    \n    \n  \n\nmaybe use the plural here as you\u00b4re talking about relationships in general and not just one?", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528968805", "createdAt": "2020-11-23T20:13:19Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ4NzUwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxNjo0MFrOH4dzMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxNjo0MFrOH4dzMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3MDU0NQ==", "bodyText": "In Java, .... in Java - you could leave the second one out just  a Collection or array type is used to hold...", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528970545", "createdAt": "2020-11-23T20:16:40Z", "author": {"login": "TobiasPr"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ5NzgwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxOTo0OVrOH4d5pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDozMDoxMlrOH5DeAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3MjE5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n          \n          \n            \n            A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. If there is a relationship to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (containing both objects' primary keys). |br|", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528972196", "createdAt": "2020-11-23T20:19:49Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4NzcxMg==", "bodyText": "See cf269c7", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r529587712", "createdAt": "2020-11-24T14:30:12Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3MjE5Ng=="}, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzUwNTQ1OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoyMjowOVrOH4d-JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoyMjowOVrOH4d-JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3MzM0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n          \n          \n            \n            * **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has a list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528973349", "createdAt": "2020-11-23T20:22:09Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzUxODUwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoyNjoxNFrOH4eGFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoyNjoxNFrOH4eGFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NTM4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n          \n          \n            \n            * ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, the corresponding ``Result`` is also deleted.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528975381", "createdAt": "2020-11-23T20:26:14Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzUyOTAxOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoyOTozNlrOH4eMaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoyOTozNlrOH4eMaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NzAwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n          \n          \n            \n                    Hibernate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r528977001", "createdAt": "2020-11-23T20:29:36Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationship\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used in Java to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of a **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of a itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, also the ``Result`` is deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eae9000251759d1c212d158d7e17c5f53c0f2f3"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzg5MTIxOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjoxNzoxMlrOH4hh4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjoxNzoxMlrOH4hh4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzMTY1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n          \n          \n            \n              * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for a ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate them with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r529031650", "createdAt": "2020-11-23T22:17:12Z", "author": {"login": "kloessst"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationships\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of an **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, the corresponding ``Result`` is also deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fa6a552f59b72cbdfa42a14627fe5c6eb1ce071"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzkwNzk5OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjoyMjoxNVrOH4hroA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDoyNzo0N1rOH5DWxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzNDE0NA==", "bodyText": "This block seems to be duplicated. This is already explained above. You could just reference the ordered collections section.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r529034144", "createdAt": "2020-11-23T22:22:15Z", "author": {"login": "kloessst"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationships\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of an **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, the corresponding ``Result`` is also deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+           // cut association to parent object\n+           feedback.setResult(null);\n+           // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+           feedback = feedbackRepository.save(feedback);\n+           // restore the association to the parent object\n+           feedback.setResult(result);\n+           savedFeedbacks.add(feedback);\n+       });\n+       \n+\n+        // set the association of the parent to its child objects which are now persisted in the database\n+        result.setFeedbacks(savedFeedbacks);\n+        // persist the parent object\n+        return resultRepository.save(result);\n+\n+\n+Solutions for known issues\n+==========================\n+\n+* ``org.hibernate.LazyInitializationException : could not initialize proxy \u2013 no Session`` caused by ``fetchType.LAZY``. You must explicitly load the associated object from the database before trying to access those. Example of how to eagerly fetch the feedbacks with the result:\n+\n+ .. code-block:: java\n+\n+    // ResultRepository.java\n+    @Query(\"select r from Result r left join fetch r.feedbacks where r.id = :resultId\")\n+    Optional<Result> findByIdWithEagerFeedbacks(@Param(\"resultId\") Long id);\n+\n+\n+* ``JpaSystemException: null index column for collection`` caused by ``@OrderColumn`` annotation:\n+\n+ #. Save the child entity (e.g., `Feedback <https://github.com/ls1intum/Artemis/blob/develop/src/main/java/de/tum/in/www1/artemis/domain/Feedback.java>`_) without connection to the parent entity (e.g., `Result <https://github.com/ls1intum/Artemis/blob/develop/src/main/java/de/tum/in/www1/artemis/domain/Result.java>`_)\n+ #. Add back the connection of the child entity to the parent entity.\n+ #. Save the parent entity.\n+ #. Always use the returned value after saving the entity, see: ``feedback = feedbackRepository.save(feedback);``\n+\n+ .. code:: java\n+\n+    // ProgrammingAssessmentService\n+    List<Feedback> savedFeedbacks = new ArrayList<>();\n+    result.getFeedbacks().forEach(feedback -> {\n+        // cut association to parent object\n+        feedback.setResult(null);\n+        // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+        feedback = feedbackRepository.save(feedback);\n+        // restore the association to the parent object\n+        feedback.setResult(result);\n+        savedFeedbacks.add(feedback);\n+    });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fa6a552f59b72cbdfa42a14627fe5c6eb1ce071"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4NTg2MA==", "bodyText": "See e56ec3f", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r529585860", "createdAt": "2020-11-24T14:27:47Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationships\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of an **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, the corresponding ``Result`` is also deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate it with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hiberanate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+           // cut association to parent object\n+           feedback.setResult(null);\n+           // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+           feedback = feedbackRepository.save(feedback);\n+           // restore the association to the parent object\n+           feedback.setResult(result);\n+           savedFeedbacks.add(feedback);\n+       });\n+       \n+\n+        // set the association of the parent to its child objects which are now persisted in the database\n+        result.setFeedbacks(savedFeedbacks);\n+        // persist the parent object\n+        return resultRepository.save(result);\n+\n+\n+Solutions for known issues\n+==========================\n+\n+* ``org.hibernate.LazyInitializationException : could not initialize proxy \u2013 no Session`` caused by ``fetchType.LAZY``. You must explicitly load the associated object from the database before trying to access those. Example of how to eagerly fetch the feedbacks with the result:\n+\n+ .. code-block:: java\n+\n+    // ResultRepository.java\n+    @Query(\"select r from Result r left join fetch r.feedbacks where r.id = :resultId\")\n+    Optional<Result> findByIdWithEagerFeedbacks(@Param(\"resultId\") Long id);\n+\n+\n+* ``JpaSystemException: null index column for collection`` caused by ``@OrderColumn`` annotation:\n+\n+ #. Save the child entity (e.g., `Feedback <https://github.com/ls1intum/Artemis/blob/develop/src/main/java/de/tum/in/www1/artemis/domain/Feedback.java>`_) without connection to the parent entity (e.g., `Result <https://github.com/ls1intum/Artemis/blob/develop/src/main/java/de/tum/in/www1/artemis/domain/Result.java>`_)\n+ #. Add back the connection of the child entity to the parent entity.\n+ #. Save the parent entity.\n+ #. Always use the returned value after saving the entity, see: ``feedback = feedbackRepository.save(feedback);``\n+\n+ .. code:: java\n+\n+    // ProgrammingAssessmentService\n+    List<Feedback> savedFeedbacks = new ArrayList<>();\n+    result.getFeedbacks().forEach(feedback -> {\n+        // cut association to parent object\n+        feedback.setResult(null);\n+        // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+        feedback = feedbackRepository.save(feedback);\n+        // restore the association to the parent object\n+        feedback.setResult(result);\n+        savedFeedbacks.add(feedback);\n+    });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzNDE0NA=="}, "originalCommit": {"oid": "6fa6a552f59b72cbdfa42a14627fe5c6eb1ce071"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTQ1OTEzOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODoyMTo0NFrOH4w3ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDoyNzo0NFrOH5DWpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4MjkyMg==", "bodyText": "Unfortunately the warnings are still here. :( (I assume because this line contains whitespaces and isn't empty.)", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r529282922", "createdAt": "2020-11-24T08:21:44Z", "author": {"login": "FrankeLukas"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationships\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of an **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, the corresponding ``Result`` is also deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for a ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate them with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hibernate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+           // cut association to parent object\n+           feedback.setResult(null);\n+           // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+           feedback = feedbackRepository.save(feedback);\n+           // restore the association to the parent object\n+           feedback.setResult(result);\n+           savedFeedbacks.add(feedback);\n+       });\n+       ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7656ecb2966524e50cbdadd6b6b9cc91e786f11a"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4NTgzMA==", "bodyText": "Should be fixed now: e56ec3f", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r529585830", "createdAt": "2020-11-24T14:27:44Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,236 @@\n+**********************\n+Database Relationships\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. In Java, if a relationship is to a collection of other objects, a ``Collection`` or ``array`` type is used to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of an **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, the corresponding ``Result`` is also deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:\n+\n+  * **Ordered Collection**: When you want to order the collection of objects of the relationship, then always use a ``List``. It is important to note here that there is no inherent order in a database table. One could argue that you can use the ``id`` field for the ordering, but there are edge cases where this can lead to problems. Therefore, for a ordered collection, **always** annotate it with ``@OrderColumn``. An order column indicates to hibernate that we want to order our collection based on a specific column of our data table. By default, the column name it expects is *tablenameS\\_order*. For ordered collections, we also recommend that you annotate them with ``CascadeType.ALL`` and ``orphanRemoval = true``. E.g.:\n+\n+       .. code-block:: java\n+\n+        //Result.java\n+        @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+        @OrderColumn\n+        @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonView(QuizView.Before.class)\n+        private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+       .. note::\n+        Hibernate will take care of the ordering for you but you must create the order column in the database. This is not created automatically!\n+\n+\n+    With ordered collections, you have to be very careful with the way you persist the objects in the database. You must first persist the child object without a relation to the parent object. Then, you recreate the association and persist the parent object. Example of how to correctly persist objects in an ordered collection:\n+\n+       .. code-block:: java\n+\n+        // ProgrammingAssessmentService\n+        List<Feedback> savedFeedbacks = new ArrayList<>();\n+        result.getFeedbacks().forEach(feedback -> {\n+           // cut association to parent object\n+           feedback.setResult(null);\n+           // persist the child object without an association to the parent object. IMPORTANT: Use the object returned from the database!\n+           feedback = feedbackRepository.save(feedback);\n+           // restore the association to the parent object\n+           feedback.setResult(result);\n+           savedFeedbacks.add(feedback);\n+       });\n+       ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4MjkyMg=="}, "originalCommit": {"oid": "7656ecb2966524e50cbdadd6b6b9cc91e786f11a"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTQ1MTQ1OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/database.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDo1Mjo0NFrOH5Eg7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowMzo1NVrOH5FDxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNDg0Ng==", "bodyText": "Why is this .. ordered: needed?", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r529604846", "createdAt": "2020-11-24T14:52:44Z", "author": {"login": "JannisBittlmayer"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,226 @@\n+**********************\n+Database Relationships\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does not count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. If there is a relationship to a collection of other objects, a ``Collection`` or ``array`` type is used to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (containing both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of an **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, the corresponding ``Result`` is also deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf269c7dc128b5075c973f51d65bb863b0fb61e9"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMzc2NQ==", "bodyText": "This is a way to label specific sections in Markdown. We use this to reference this section from within the text.", "url": "https://github.com/ls1intum/Artemis/pull/2430#discussion_r529613765", "createdAt": "2020-11-24T15:03:55Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/database.rst", "diffHunk": "@@ -0,0 +1,226 @@\n+**********************\n+Database Relationships\n+**********************\n+\n+WORK IN PROGRESS\n+\n+1. Retrieving and Building Objects\n+==================================\n+\n+The cost of retrieving and building an object's relationships far exceeds the cost of selecting the object. This is especially true for relationships where it would trigger the loading of every child through the relationship hierarchy. The solution to this issue is **lazy fetching** (lazy loading). Lazy fetching allows the fetching of a relationship to be deferred until it is accessed. This is important not only to avoid the database access, but also to avoid the cost of building the objects if they are not needed. |br|\n+\n+In JPA lazy fetching can be set on any relationship using the fetch attribute. The fetch can be set to either ``LAZY`` or ``EAGER`` as defined in the ``FetchType`` enum. The default fetch type is ``LAZY`` for all relationships except for **OneToOne** and **ManyToOne**, but in general it is a good idea to make every relationship ``LAZY``. The ``EAGER`` default for **OneToOne** and **ManyToOne** is for implementation reasons (more easier to implement), not because it is a good idea. |br|\n+\n+We **always** use ``FetchType.LAZY``, unless there is a very strong case to be made for ``FetchType.EAGER``.\n+\n+       .. note::\n+        Additional effort to use ``FetchType.LAZY`` does not count as a strong argument.\n+\n+2. Relationships\n+================\n+\n+A relationship is a reference from one object to another. In a relational database relationships are defined through foreign keys. The source row contains the primary key of the target row to define the relationship (and sometimes the inverse). A query must be performed to read the target objects of the relationship using the foreign key and primary key information. If there is a relationship to a collection of other objects, a ``Collection`` or ``array`` type is used to hold the contents of the relationship. In a relational database, collection relations are either defined by the target objects having a foreign key back to the source object's primary key, or by having an intermediate join table to store the relationship (containing both objects' primary keys). |br|\n+\n+In this section, we depict common entity relationships we use in Artemis and show some code snippets. \n+\n+* **OneToOne** A unique reference from one object to another. It is also inverse of itself. Example: one ``Complaint`` has a reference to one ``Result``.\n+\n+ .. code:: java\n+\n+    // Complaint.java\n+    @OneToOne\n+    @JoinColumn(unique = true)\n+    private Result result;\n+\n+* **OneToMany** A ``Collection`` or ``Map`` of objects. It is the inverse of a **ManyToOne** relationship. Example: one ``Result`` has a list of ``Feedback`` elements. For ordered OneToMany relations see :ref:`ordered collections <ordered>`.\n+\n+ .. code:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* **ManyToOne** A reference from one object to another. It is the inverse of an **OneToMany** relationship. Example: one ``Feedback`` has a reference to one ``Result``. \n+\n+ .. code:: java\n+\n+    // Feedback.java\n+    @ManyToOne\n+    @JsonIgnoreProperties(\"feedbacks\")\n+    private Result result;\n+\n+\n+* **ManyToMany** ``A Collection`` or ``Map`` of objects. It is the inverse of itself. Example: one ``Exercise`` has a list of ``LearningGoal`` elements, one ``LearningGoal`` has list of ``Exercise`` elements. In other words: many exercises are connected to many learning goals and vice-versa.\n+\n+ .. code:: java\n+\n+    // Exercise.java\n+    @ManyToMany(mappedBy = \"exercises\")\n+    public Set<LearningGoal> learningGoals = new HashSet<>();\n+\n+    // LearningGoal.java\n+    @ManyToMany\n+    @JoinTable(name = \"learning_goal_exercise\", joinColumns = @JoinColumn(name = \"learning_goal_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"exercise_id\", referencedColumnName = \"id\"))\n+    @JsonIgnoreProperties(\"learningGoals\")\n+    private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+ .. warning::\n+        For **OneToMany**, **ManyToOne**, and **ManyToMany** relationships you must not forget to mark the associated elements with ``@JsonIgnoreProperties()``. Without this, the object serialization process will be stuck in an endless loop and throw an error. For more information check out the examples listed above and see: `Jackson and JsonIgnoreType <https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype>`_. \n+\n+\n+2. Cascade Types\n+================\n+Entity relationships often depend on the existence of another entity \u2014 for example, the Result-Feedback relationship. Without the Result, the Feedback entity doesn't have any meaning of its own. When we delete the Result entity, our Feedback entity should also get deleted. For more information see: `jpa cascade types <https://www.baeldung.com/jpa-cascade-types>`_.\n+\n+* ``CascadeType.ALL`` Propagates all operations mentioned below from the parent object to the to child object. \n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToMany(mappedBy = \"result\", cascade = CascadeType.ALL, orphanRemoval = true)\n+    @OrderColumn\n+    @JsonIgnoreProperties(value = \"result\", allowSetters = true)\n+    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+    @JsonView(QuizView.Before.class)\n+    private List<Feedback> feedbacks = new ArrayList<>();\n+\n+\n+* ``CascadeType.PERSIST`` When persisting a parent entity, it also persists the child entities held in its fields. This cascade rule is helpful for relationships where the parent acts as a *container* to the child entity. If you do not use this, you have to ensure that you persist the child entity first, otherwise an error will be thrown. Example: The code below propagates the **persist** operation from parent ``AnswerCounter`` to child ``AnswerOption``. When an ``AnswerCounter`` is persisted, its ``AnswerOption`` is persisted as well.\u00a0\n+\n+ .. code-block:: java\n+\n+    // AnswerCounter.java\n+    @OneToOne(cascade = { CascadeType.PERSIST })\n+    @JoinColumn(unique = true)\n+    private AnswerOption answer;\n+\n+\n+* ``CascadeType.MERGE`` If you merge the source entity (saved/updated/synchronized) to the database, the merge is cascaded to the target of the association. This rule applies to existing objects only. Use this type to always merge/synchronize the existing data in the table with the data in the object. Example below: whenever we merge a ``Result`` to the database, i.e. save the changes on the object, the ``Assessor`` object is also merged/saved.\u00a0\n+\n+ .. code-block:: java\n+\n+    // Result.java\n+    @OneToOne(cascade = CascadeType.MERGE, fetch = FetchType.LAZY)\n+    @JoinColumn(unique = false)\n+    private User assessor;\n+\n+\n+* ``CascadeType.REMOVE`` If the source entity is removed, the target of the association is also removed. Example below: propagates **remove** operation from parent ``Submission`` to child ``Result``. When a ``Submission`` is deleted, the corresponding ``Result`` is also deleted.\n+\n+ .. code-block:: java\n+\n+    // Submission.java\n+    @OneToOne(mappedBy = \"submission\", fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)\n+    @JsonIgnoreProperties({ \"submission\", \"participation\" })\n+    @JoinColumn(unique = true)\n+    private Result result;\n+ \n+\n+* ``CascadeType.REFRESH`` If the source entity is refreshed, it cascades the refresh to the target of the association. This is used to refresh the data in the object and its associations. This is useful for cases where there is a change which needs to be synchronized FROM the database.\n+\n+Not used in Artemis yet.\n+\n+\n+Best Practices\n+==============\n+* If you want to create a ``@OneToMany`` relationship or ``@ManyToMany`` relationship, first think about if it is important for the association to be ordered. If you do not need the association to be ordered, then always go for a ``Set`` instead of ``List``. If you are unsure, start with a ``Set``.\u00a0\n+\n+  * **Unordered Collection**: A ``Set`` comes with certain advantages such as ensuring that there are no duplicates and null values in your collection. There are also performance arguments to use a ``Set``, especially for ``@ManyToMany`` relationships. For more information see this `stackoverflow thread <https://stackoverflow.com/questions/4655392/which-java-type-do-you-use-for-jpa-collections-and-why>`_. E.g.:\n+\n+       .. code-block:: java\n+\n+        // Course.java\n+        @OneToMany(mappedBy = \"course\", fetch = FetchType.LAZY)\n+        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n+        @JsonIgnoreProperties(\"course\")\n+        private Set<Exercise> exercises = new HashSet<>();\n+\n+\n+.. _ordered:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNDg0Ng=="}, "originalCommit": {"oid": "cf269c7dc128b5075c973f51d65bb863b0fb61e9"}, "originalPosition": 145}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4463, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}