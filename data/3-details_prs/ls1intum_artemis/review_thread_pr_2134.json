{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0Njk0ODIy", "number": 2134, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMDoyNTo1MVrOEofAMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjo1OToxNFrOEoiZFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwODg2NDUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/domain/Feedback.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMDoyNTo1MVrOHZmlwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo1MDoxN1rOHZpVxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwODcwNg==", "bodyText": "Actually, those references ensure the deletion of referenced conflicts when the feedback is deleted.", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496608706", "createdAt": "2020-09-29T10:25:51Z", "author": {"login": "bigultekin"}, "path": "src/main/java/de/tum/in/www1/artemis/domain/Feedback.java", "diffHunk": "@@ -70,6 +70,7 @@\n     @ManyToOne\n     private GradingInstruction gradingInstruction;\n \n+    // TODO: JP remove these two references as they are not really needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0331afe5392e22aa43fed769e10bd1a756c29467"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1Mzc2Nw==", "bodyText": "We now, but we don't like the implementation, so we want to find a better way in the future", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496653767", "createdAt": "2020-09-29T11:50:17Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/domain/Feedback.java", "diffHunk": "@@ -70,6 +70,7 @@\n     @ManyToOne\n     private GradingInstruction gradingInstruction;\n \n+    // TODO: JP remove these two references as they are not really needed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwODcwNg=="}, "originalCommit": {"oid": "0331afe5392e22aa43fed769e10bd1a756c29467"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTAyODMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/repository/FeedbackConflictRepository.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMToxMzoyNlrOHZoKMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo1MDozMVrOHZpWPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzNDQxOQ==", "bodyText": "Maybe it would be a good idea to start using the text blocks @MaisiKoleni was referencing today in the meeting as this is a rather long query", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496634419", "createdAt": "2020-09-29T11:13:26Z", "author": {"login": "anditurdiu"}, "path": "src/main/java/de/tum/in/www1/artemis/repository/FeedbackConflictRepository.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package de.tum.in.www1.artemis.repository;\n+\n+import java.util.List;\n+\n+import org.springframework.data.jpa.repository.JpaRepository;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.query.Param;\n+import org.springframework.stereotype.Repository;\n+\n+import de.tum.in.www1.artemis.domain.FeedbackConflict;\n+\n+/**\n+ * Spring Data JPA repository for the FeedbackConflict entity.\n+ */\n+@Repository\n+public interface FeedbackConflictRepository extends JpaRepository<FeedbackConflict, Long> {\n+\n+    @Query(\"select distinct conflict from FeedbackConflict conflict where conflict.conflict = true and (conflict.firstFeedback.id in (:feedbackIds) or conflict.secondFeedback.id in (:feedbackIds))\")\n+    List<FeedbackConflict> findAllByFeedbackList(@Param(\"feedbackIds\") List<Long> feedbackIds);\n+\n+    @Query(\"select distinct conflict from FeedbackConflict conflict where conflict.conflict = true and \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267cef6a5077a32da798f027cc06be22bf14ced2"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1Mzg4NQ==", "bodyText": "in a follow up, yes", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496653885", "createdAt": "2020-09-29T11:50:31Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/repository/FeedbackConflictRepository.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package de.tum.in.www1.artemis.repository;\n+\n+import java.util.List;\n+\n+import org.springframework.data.jpa.repository.JpaRepository;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.query.Param;\n+import org.springframework.stereotype.Repository;\n+\n+import de.tum.in.www1.artemis.domain.FeedbackConflict;\n+\n+/**\n+ * Spring Data JPA repository for the FeedbackConflict entity.\n+ */\n+@Repository\n+public interface FeedbackConflictRepository extends JpaRepository<FeedbackConflict, Long> {\n+\n+    @Query(\"select distinct conflict from FeedbackConflict conflict where conflict.conflict = true and (conflict.firstFeedback.id in (:feedbackIds) or conflict.secondFeedback.id in (:feedbackIds))\")\n+    List<FeedbackConflict> findAllByFeedbackList(@Param(\"feedbackIds\") List<Long> feedbackIds);\n+\n+    @Query(\"select distinct conflict from FeedbackConflict conflict where conflict.conflict = true and \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzNDQxOQ=="}, "originalCommit": {"oid": "267cef6a5077a32da798f027cc06be22bf14ced2"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTI1NTM3OnYy", "diffSide": "RIGHT", "path": "src/main/resources/config/liquibase/changelog/20200726015816_changelog.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjoxOToyN1rOHZqU6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjozNDo0MFrOHZq5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTkzMA==", "bodyText": "Why is the name here not something like feedback_conflictPK?", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496669930", "createdAt": "2020-09-29T12:19:27Z", "author": {"login": "stefanwaldhauser"}, "path": "src/main/resources/config/liquibase/changelog/20200726015816_changelog.xml", "diffHunk": "@@ -1,9 +1,9 @@\n <?xml version=\"1.1\" encoding=\"UTF-8\" standalone=\"no\"?>\n <databaseChangeLog xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\" xmlns:ext=\"http://www.liquibase.org/xml/ns/dbchangelog-ext\" xmlns:pro=\"http://www.liquibase.org/xml/ns/pro\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-3.9.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.9.xsd\">\n-    <changeSet author=\"birtan (generated)\" id=\"1595721518853-31\">\n-        <createTable tableName=\"text_assessment_conflict\">\n+    <changeSet author=\"birtan\" id=\"20200726015816\">\n+        <createTable tableName=\"feedback_conflict\">\n             <column autoIncrement=\"true\" name=\"id\" type=\"BIGINT\">\n-                <constraints nullable=\"false\" primaryKey=\"true\" primaryKeyName=\"text_assessment_conflictPK\"/>\n+                <constraints nullable=\"false\" primaryKey=\"true\" primaryKeyName=\"assessment_conflictPK\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267cef6a5077a32da798f027cc06be22bf14ced2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MTkyMg==", "bodyText": "good point, we should adapt it", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496671922", "createdAt": "2020-09-29T12:22:51Z", "author": {"login": "krusche"}, "path": "src/main/resources/config/liquibase/changelog/20200726015816_changelog.xml", "diffHunk": "@@ -1,9 +1,9 @@\n <?xml version=\"1.1\" encoding=\"UTF-8\" standalone=\"no\"?>\n <databaseChangeLog xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\" xmlns:ext=\"http://www.liquibase.org/xml/ns/dbchangelog-ext\" xmlns:pro=\"http://www.liquibase.org/xml/ns/pro\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-3.9.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.9.xsd\">\n-    <changeSet author=\"birtan (generated)\" id=\"1595721518853-31\">\n-        <createTable tableName=\"text_assessment_conflict\">\n+    <changeSet author=\"birtan\" id=\"20200726015816\">\n+        <createTable tableName=\"feedback_conflict\">\n             <column autoIncrement=\"true\" name=\"id\" type=\"BIGINT\">\n-                <constraints nullable=\"false\" primaryKey=\"true\" primaryKeyName=\"text_assessment_conflictPK\"/>\n+                <constraints nullable=\"false\" primaryKey=\"true\" primaryKeyName=\"assessment_conflictPK\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTkzMA=="}, "originalCommit": {"oid": "267cef6a5077a32da798f027cc06be22bf14ced2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3OTIyNA==", "bodyText": "done", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496679224", "createdAt": "2020-09-29T12:34:40Z", "author": {"login": "bigultekin"}, "path": "src/main/resources/config/liquibase/changelog/20200726015816_changelog.xml", "diffHunk": "@@ -1,9 +1,9 @@\n <?xml version=\"1.1\" encoding=\"UTF-8\" standalone=\"no\"?>\n <databaseChangeLog xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\" xmlns:ext=\"http://www.liquibase.org/xml/ns/dbchangelog-ext\" xmlns:pro=\"http://www.liquibase.org/xml/ns/pro\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-3.9.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.9.xsd\">\n-    <changeSet author=\"birtan (generated)\" id=\"1595721518853-31\">\n-        <createTable tableName=\"text_assessment_conflict\">\n+    <changeSet author=\"birtan\" id=\"20200726015816\">\n+        <createTable tableName=\"feedback_conflict\">\n             <column autoIncrement=\"true\" name=\"id\" type=\"BIGINT\">\n-                <constraints nullable=\"false\" primaryKey=\"true\" primaryKeyName=\"text_assessment_conflictPK\"/>\n+                <constraints nullable=\"false\" primaryKey=\"true\" primaryKeyName=\"assessment_conflictPK\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTkzMA=="}, "originalCommit": {"oid": "267cef6a5077a32da798f027cc06be22bf14ced2"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQxOTc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/AutomaticTextAssessmentConflictService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjo1OToxNFrOHZr43w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjo1OToxNFrOHZr43w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NTUxOQ==", "bodyText": "Codacy found an issue: Useless parentheses.", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496695519", "createdAt": "2020-09-29T12:59:14Z", "author": {"login": "artemis-bot"}, "path": "src/main/java/de/tum/in/www1/artemis/service/AutomaticTextAssessmentConflictService.java", "diffHunk": "@@ -61,82 +61,81 @@ public void asyncCheckFeedbackConsistency(List<TextBlock> textBlocks, List<Feedb\n         feedbackList.removeIf(f -> !f.hasReference());\n \n         // If text block doesn't have a cluster id don't create an object\n-        List<TextAssessmentConflictRequestDTO> textAssessmentConflictRequestDTOS = feedbackList.stream().flatMap(feedback -> {\n+        List<TextFeedbackConflictRequestDTO> textFeedbackConflictRequestDTOS = feedbackList.stream().flatMap(feedback -> {\n             Optional<TextBlock> textBlock = textBlockRepository\n                     .findById(textBlocks.stream().filter(block -> block.getId().equals(feedback.getReference())).findFirst().get().getId());\n-            if (textBlock.isPresent() && textBlock.get().getCluster() != null) {\n-                return Stream.of(new TextAssessmentConflictRequestDTO(textBlock.get().getId(), textBlock.get().getText(), textBlock.get().getCluster().getId(), feedback.getId(),\n+            if (textBlock.isPresent() && textBlock.get().getCluster() != null && feedback.getDetailText() != null) {\n+                return Stream.of(new TextFeedbackConflictRequestDTO(textBlock.get().getId(), textBlock.get().getText(), textBlock.get().getCluster().getId(), feedback.getId(),\n                         feedback.getDetailText(), feedback.getCredits()));\n             }\n             else {\n                 return Stream.empty();\n             }\n         }).collect(toList());\n \n-        if (textAssessmentConflictRequestDTOS.isEmpty()) {\n+        if (textFeedbackConflictRequestDTOS.isEmpty()) {\n             return;\n         }\n \n         // remote service call to athene\n-        final List<TextAssessmentConflictResponseDTO> textAssessmentConflictResponseDTOS;\n+        final List<FeedbackConflictResponseDTO> feedbackConflictResponseDTOS;\n         try {\n-            textAssessmentConflictResponseDTOS = textAssessmentConflictService.checkFeedbackConsistencies(textAssessmentConflictRequestDTOS, exerciseId, 0);\n+            feedbackConflictResponseDTOS = textAssessmentConflictService.checkFeedbackConsistencies(textFeedbackConflictRequestDTOS, exerciseId, 0);\n         }\n         catch (NetworkingError networkingError) {\n             log.error(networkingError.getMessage(), networkingError);\n             return;\n         }\n \n         // create an array to store conflicts\n-        List<TextAssessmentConflict> textAssessmentConflicts = new ArrayList<>();\n+        List<FeedbackConflict> feedbackConflicts = new ArrayList<>();\n \n         // look for new conflicts\n         // Athene may find conflicts with feedback ids that are not in the feedback repository any more. So check for them. (May happen if the feedback is deleted in Artemis but\n         // already stored in Athene)\n-        textAssessmentConflictResponseDTOS.forEach(conflict -> {\n+        feedbackConflictResponseDTOS.forEach(conflict -> {\n             Optional<Feedback> firstFeedback = feedbackRepository.findById(conflict.getFirstFeedbackId());\n             Optional<Feedback> secondFeedback = feedbackRepository.findById(conflict.getSecondFeedbackId());\n-            List<TextAssessmentConflict> storedConflicts = this.textAssessmentConflictRepository.findByFirstAndSecondFeedback(conflict.getFirstFeedbackId(),\n-                    conflict.getSecondFeedbackId());\n+            List<FeedbackConflict> storedConflicts = this.feedbackConflictRepository.findByFirstAndSecondFeedback(conflict.getFirstFeedbackId(), conflict.getSecondFeedbackId());\n             // if the found conflict is present but its type has changed, update it\n             if (!storedConflicts.isEmpty() && !storedConflicts.get(0).getType().equals(conflict.getType())) {\n                 storedConflicts.get(0).setType(conflict.getType());\n-                textAssessmentConflicts.add(storedConflicts.get(0));\n+                feedbackConflicts.add(storedConflicts.get(0));\n             }\n \n             // new conflict\n             if (firstFeedback.isPresent() && secondFeedback.isPresent() && storedConflicts.isEmpty()) {\n-                TextAssessmentConflict textAssessmentConflict = new TextAssessmentConflict();\n-                textAssessmentConflict.setConflict(true);\n-                textAssessmentConflict.setFirstFeedback(firstFeedback.get());\n-                textAssessmentConflict.setSecondFeedback(secondFeedback.get());\n-                textAssessmentConflict.setType(conflict.getType());\n-                textAssessmentConflict.setCreatedAt(ZonedDateTime.now());\n-                textAssessmentConflicts.add(textAssessmentConflict);\n+                FeedbackConflict feedbackConflict = new FeedbackConflict();\n+                feedbackConflict.setConflict(true);\n+                feedbackConflict.setFirstFeedback(firstFeedback.get());\n+                feedbackConflict.setSecondFeedback(secondFeedback.get());\n+                feedbackConflict.setType(conflict.getType());\n+                feedbackConflict.setCreatedAt(ZonedDateTime.now());\n+                feedbackConflicts.add(feedbackConflict);\n             }\n         });\n \n         // find solved conflicts and add them to list\n-        textAssessmentConflicts.addAll(this.findSolvedConflicts(textAssessmentConflictRequestDTOS, textAssessmentConflictResponseDTOS));\n+        feedbackConflicts.addAll(this.findSolvedConflicts(textFeedbackConflictRequestDTOS, feedbackConflictResponseDTOS));\n \n-        textAssessmentConflictRepository.saveAll(textAssessmentConflicts);\n+        feedbackConflictRepository.saveAll(feedbackConflicts);\n     }\n \n     /**\n      * Searches if the feedback that are sent to Athene already have conflicts in the database(storedConflicts),\n      * If the stored conflicts are not returned from Athene after the consistency check, it means that they are solved and set as solved.\n      *\n-     * @param textAssessmentConflictRequestDTOS the list sent to Athene for check\n-     * @param textAssessmentConflictResponseDTOS returned list with found conflicts.\n+     * @param textFeedbackConflictRequestDTOS the list sent to Athene for check\n+     * @param feedbackConflictResponseDTOS returned list with found conflicts.\n      * @return solved conflicts\n      */\n-    private List<TextAssessmentConflict> findSolvedConflicts(List<TextAssessmentConflictRequestDTO> textAssessmentConflictRequestDTOS,\n-            List<TextAssessmentConflictResponseDTO> textAssessmentConflictResponseDTOS) {\n-        List<Long> feedbackIds = textAssessmentConflictRequestDTOS.stream().map(TextAssessmentConflictRequestDTO::getFeedbackId).collect(toList());\n-        List<TextAssessmentConflict> storedConflicts = this.textAssessmentConflictRepository.findAllByFeedbackList(feedbackIds);\n+    private List<FeedbackConflict> findSolvedConflicts(List<TextFeedbackConflictRequestDTO> textFeedbackConflictRequestDTOS,\n+            List<FeedbackConflictResponseDTO> feedbackConflictResponseDTOS) {\n+        List<Long> feedbackIds = textFeedbackConflictRequestDTOS.stream().map(TextFeedbackConflictRequestDTO::getFeedbackId).collect(toList());\n+        List<FeedbackConflict> storedConflicts = this.feedbackConflictRepository.findAllByFeedbackList(feedbackIds);\n \n         storedConflicts.forEach(conflict -> {\n-            boolean isPresent = textAssessmentConflictResponseDTOS.stream().anyMatch(newConflicts -> (newConflicts.getFirstFeedbackId() == conflict.getFirstFeedback().getId()\n+            boolean isPresent = feedbackConflictResponseDTOS.stream().anyMatch(newConflicts -> (newConflicts.getFirstFeedbackId() == conflict.getFirstFeedback().getId()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "441ba2b77de1130f77504b89fd79298171849323"}, "originalPosition": 146}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4719, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}