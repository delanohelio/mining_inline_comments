{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1OTY2MDkx", "number": 1323, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoyMzo1MVrODz6Evg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwOTo0Njo1MFrOD0JxDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzU1NDU0OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/overview/notification/notification.service.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoyMzo1MVrOGImJ0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjowMzowMlrOGIpioA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2Njg5OA==", "bodyText": "I guess we should cleanup subscribedTopics as well, right?", "url": "https://github.com/ls1intum/Artemis/pull/1323#discussion_r411666898", "createdAt": "2020-04-20T20:23:51Z", "author": {"login": "krusche"}, "path": "src/main/webapp/app/overview/notification/notification.service.ts", "diffHunk": "@@ -183,4 +174,13 @@ export class NotificationService {\n         const courseId = target.course || notification.course.id;\n         this.router.navigate([target.mainPage, courseId, target.entity, target.id]);\n     }\n+\n+    private initNotificationObserver(): void {\n+        this.notificationObserver = new BehaviorSubject<Notification | null>(null);\n+    }\n+\n+    public cleanUp(): void {\n+        this.cachedNotifications = new Observable<EntityArrayResponseType>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beb2c8cfee202167579b1fa2730cce7c3874e98b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjQwMA==", "bodyText": "Had that on my todo :-) Is now cleaned up during logout: 0af1890", "url": "https://github.com/ls1intum/Artemis/pull/1323#discussion_r411722400", "createdAt": "2020-04-20T22:03:02Z", "author": {"login": "sascha11110"}, "path": "src/main/webapp/app/overview/notification/notification.service.ts", "diffHunk": "@@ -183,4 +174,13 @@ export class NotificationService {\n         const courseId = target.course || notification.course.id;\n         this.router.navigate([target.mainPage, courseId, target.entity, target.id]);\n     }\n+\n+    private initNotificationObserver(): void {\n+        this.notificationObserver = new BehaviorSubject<Notification | null>(null);\n+    }\n+\n+    public cleanUp(): void {\n+        this.cachedNotifications = new Observable<EntityArrayResponseType>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2Njg5OA=="}, "originalCommit": {"oid": "beb2c8cfee202167579b1fa2730cce7c3874e98b"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDEyNTU2OnYy", "diffSide": "RIGHT", "path": "src/test/java/de/tum/in/www1/artemis/NotificationResourceIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwOTo0Njo1MFrOGI81WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDozOToyOVrOGI-7JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzODQ4OQ==", "bodyText": "One thing regarding all the test cases:\nYou currently only check that the notification is returned when calling recent-for-user, which is totally fine.\nI think you do not test right now that the notification is only delivered once (correct me if I'm wrong), so I propose you execute another call to the same endpoint again and verify that the list is either empty or does at least not contain notification1 and notification2.\nThe same applies to the other test cases.", "url": "https://github.com/ls1intum/Artemis/pull/1323#discussion_r412038489", "createdAt": "2020-04-21T09:46:50Z", "author": {"login": "sleiss"}, "path": "src/test/java/de/tum/in/www1/artemis/NotificationResourceIntegrationTest.java", "diffHunk": "@@ -101,36 +115,132 @@ public void testCreateNotification_asInstructor_BAD_REQUEST() throws Exception {\n     }\n \n     @Test\n-    @WithMockUser(username = \"instructor1\", roles = \"INSTRUCTOR\")\n-    public void testGetNotifications_asInstructor() throws Exception {\n-        GroupNotificationType type = GroupNotificationType.INSTRUCTOR;\n-        GroupNotification groupNotification = new GroupNotification(exercise.getCourse(), \"Title\", \"Notification Text\", null, type);\n-        groupNotification.setTarget(groupNotification.getExerciseUpdatedTarget(exercise));\n-        notificationRepository.save(groupNotification);\n-        List<Notification> notificationResponse = request.get(\"/api/notifications\", HttpStatus.OK, List.class);\n-        assertThat(notificationResponse.size()).as(\"response length is 1\").isEqualTo(1);\n+    @Sql({ \"/h2/custom-functions.sql\" })\n+    @WithMockUser(username = \"student1\", roles = \"USER\")\n+    public void testGetNotifications_recipientEvaluation() throws Exception {\n+        User recipient = userService.getUser();\n+        SingleUserNotification notification1 = ModelFactory.generateSingleUserNotification(ZonedDateTime.now(), recipient);\n+        notificationRepository.save(notification1);\n+        SingleUserNotification notification2 = ModelFactory.generateSingleUserNotification(ZonedDateTime.now(), users.get(1));\n+        notificationRepository.save(notification2);\n+\n+        List<Notification> notifications = request.getList(\"/api/notifications\", HttpStatus.OK, Notification.class);\n+        assertThat(notifications).as(\"Notification with recipient equal to current user is returned\").contains(notification1);\n+        assertThat(notifications).as(\"Notification with recipient not equal to current user is not returned\").doesNotContain(notification2);\n+\n+        List<Notification> recentNotifications = request.getList(\"/api/notifications/recent-for-user\", HttpStatus.OK, Notification.class);\n+        assertThat(recentNotifications).as(\"Recent notification with recipient equal to current user is returned\").contains(notification1);\n+        assertThat(recentNotifications).as(\"Recent notification with recipient not equal to current user is not returned\").doesNotContain(notification2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f3fe0f1725171f1d4e8eea9f638d77ce117ca47"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3Mjc0MA==", "bodyText": "As discussed on zoom this is tested implicitly via testGetRecentNotifications().", "url": "https://github.com/ls1intum/Artemis/pull/1323#discussion_r412072740", "createdAt": "2020-04-21T10:39:29Z", "author": {"login": "sascha11110"}, "path": "src/test/java/de/tum/in/www1/artemis/NotificationResourceIntegrationTest.java", "diffHunk": "@@ -101,36 +115,132 @@ public void testCreateNotification_asInstructor_BAD_REQUEST() throws Exception {\n     }\n \n     @Test\n-    @WithMockUser(username = \"instructor1\", roles = \"INSTRUCTOR\")\n-    public void testGetNotifications_asInstructor() throws Exception {\n-        GroupNotificationType type = GroupNotificationType.INSTRUCTOR;\n-        GroupNotification groupNotification = new GroupNotification(exercise.getCourse(), \"Title\", \"Notification Text\", null, type);\n-        groupNotification.setTarget(groupNotification.getExerciseUpdatedTarget(exercise));\n-        notificationRepository.save(groupNotification);\n-        List<Notification> notificationResponse = request.get(\"/api/notifications\", HttpStatus.OK, List.class);\n-        assertThat(notificationResponse.size()).as(\"response length is 1\").isEqualTo(1);\n+    @Sql({ \"/h2/custom-functions.sql\" })\n+    @WithMockUser(username = \"student1\", roles = \"USER\")\n+    public void testGetNotifications_recipientEvaluation() throws Exception {\n+        User recipient = userService.getUser();\n+        SingleUserNotification notification1 = ModelFactory.generateSingleUserNotification(ZonedDateTime.now(), recipient);\n+        notificationRepository.save(notification1);\n+        SingleUserNotification notification2 = ModelFactory.generateSingleUserNotification(ZonedDateTime.now(), users.get(1));\n+        notificationRepository.save(notification2);\n+\n+        List<Notification> notifications = request.getList(\"/api/notifications\", HttpStatus.OK, Notification.class);\n+        assertThat(notifications).as(\"Notification with recipient equal to current user is returned\").contains(notification1);\n+        assertThat(notifications).as(\"Notification with recipient not equal to current user is not returned\").doesNotContain(notification2);\n+\n+        List<Notification> recentNotifications = request.getList(\"/api/notifications/recent-for-user\", HttpStatus.OK, Notification.class);\n+        assertThat(recentNotifications).as(\"Recent notification with recipient equal to current user is returned\").contains(notification1);\n+        assertThat(recentNotifications).as(\"Recent notification with recipient not equal to current user is not returned\").doesNotContain(notification2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzODQ4OQ=="}, "originalCommit": {"oid": "9f3fe0f1725171f1d4e8eea9f638d77ce117ca47"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 105, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}