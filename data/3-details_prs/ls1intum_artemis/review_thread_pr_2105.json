{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MDA2OTM1", "number": 2105, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0Njo0NlrOEop4Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwMjoyNzozOFrOEp_G9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDY0NjUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0Njo0NlrOHZ3syA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzoyMzowNVrOHZ5EAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4OTAzMg==", "bodyText": "Important: FeedbackService (and all other services) must be independent of Bamboo specifics. It should only depend on the more general ContinuousIntegrationService. This is an important design principle in Artemis to avoid issues with other VC / CI systems (Gitlab, Jenkins) and future implementations of those.\nI think you have two options:\n\nMove this method into Bamboo service\nFind an abstraction for BambooTestJobDTO that can be used for Jenkins, Bamboo and potentially all other CI Services\n\nThe 2nd option is used for the StaticCodeAnalysisReportDTO which is basically independent from the concrete CI system. However, this does not mean that you also need to choose it here", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r496889032", "createdAt": "2020-09-29T16:46:46Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "diffHunk": "@@ -94,6 +97,59 @@ public FeedbackService(FeedbackRepository feedbackRepository) {\n         return feedbackList;\n     }\n \n+    /**\n+     * Create an automatic feedback object from a test job.\n+     * @param testJob the test case to be transformed.\n+     * @param successful if the test case was successful.\n+     * @param programmingLanguage the programming language of the exercise.\n+     * @return Feedback object for the test job\n+     */\n+    public Feedback createFeedbackFromTestJob(BambooBuildResultNotificationDTO.BambooTestJobDTO testJob, boolean successful, final ProgrammingLanguage programmingLanguage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1a93cc85986e34276a849c2fd6075fe2d173c0d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MzU0Mg==", "bodyText": "Ok good point. I think I'm just using the name and errors property of the BambooTestJobDTO. I could also just give these directly as parameters to the method.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r496893542", "createdAt": "2020-09-29T16:53:28Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "diffHunk": "@@ -94,6 +97,59 @@ public FeedbackService(FeedbackRepository feedbackRepository) {\n         return feedbackList;\n     }\n \n+    /**\n+     * Create an automatic feedback object from a test job.\n+     * @param testJob the test case to be transformed.\n+     * @param successful if the test case was successful.\n+     * @param programmingLanguage the programming language of the exercise.\n+     * @return Feedback object for the test job\n+     */\n+    public Feedback createFeedbackFromTestJob(BambooBuildResultNotificationDTO.BambooTestJobDTO testJob, boolean successful, final ProgrammingLanguage programmingLanguage) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4OTAzMg=="}, "originalCommit": {"oid": "f1a93cc85986e34276a849c2fd6075fe2d173c0d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMTM2MA==", "bodyText": "I updated the signature of the method which is now independent of bamboo-specific models.\nTherefore it is now also used in the JenkinsService.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r496911360", "createdAt": "2020-09-29T17:23:05Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "diffHunk": "@@ -94,6 +97,59 @@ public FeedbackService(FeedbackRepository feedbackRepository) {\n         return feedbackList;\n     }\n \n+    /**\n+     * Create an automatic feedback object from a test job.\n+     * @param testJob the test case to be transformed.\n+     * @param successful if the test case was successful.\n+     * @param programmingLanguage the programming language of the exercise.\n+     * @return Feedback object for the test job\n+     */\n+    public Feedback createFeedbackFromTestJob(BambooBuildResultNotificationDTO.BambooTestJobDTO testJob, boolean successful, final ProgrammingLanguage programmingLanguage) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4OTAzMg=="}, "originalCommit": {"oid": "f1a93cc85986e34276a849c2fd6075fe2d173c0d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTEwNzg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODo0OTowNlrOHZ8MFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOTowMDoyN1rOHZ8k-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2MjU4Mw==", "bodyText": "The method name is now misleading as there is no test job any more.\nI suggest to use a different one", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r496962583", "createdAt": "2020-09-29T18:49:06Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "diffHunk": "@@ -94,6 +96,60 @@ public FeedbackService(FeedbackRepository feedbackRepository) {\n         return feedbackList;\n     }\n \n+    /**\n+     * Create an automatic feedback object from a test job.\n+     * @param testName the test case name.\n+     * @param testErrors a list of errors generated by the test job\n+     * @param successful if the test case was successful.\n+     * @param programmingLanguage the programming language of the exercise.\n+     * @return Feedback object for the test job\n+     */\n+    public Feedback createFeedbackFromTestJob(String testName, List<String> testErrors, boolean successful, final ProgrammingLanguage programmingLanguage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caeaf59588a1a48e88917ec343aa688537c3a0c2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2ODk1Mw==", "bodyText": "createFeedbackFromTestCase ?", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r496968953", "createdAt": "2020-09-29T19:00:27Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "diffHunk": "@@ -94,6 +96,60 @@ public FeedbackService(FeedbackRepository feedbackRepository) {\n         return feedbackList;\n     }\n \n+    /**\n+     * Create an automatic feedback object from a test job.\n+     * @param testName the test case name.\n+     * @param testErrors a list of errors generated by the test job\n+     * @param successful if the test case was successful.\n+     * @param programmingLanguage the programming language of the exercise.\n+     * @return Feedback object for the test job\n+     */\n+    public Feedback createFeedbackFromTestJob(String testName, List<String> testErrors, boolean successful, final ProgrammingLanguage programmingLanguage) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2MjU4Mw=="}, "originalCommit": {"oid": "caeaf59588a1a48e88917ec343aa688537c3a0c2"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzQ4ODY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/exception/ContinousIntegrationException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0MTo0N1rOHb0Y3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzo0ODozN1rOHb2Vig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMTkzMw==", "bodyText": "Is this true? Maybe we better write something else here.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498931933", "createdAt": "2020-10-02T16:41:47Z", "author": {"login": "MaisiKoleni"}, "path": "src/main/java/de/tum/in/www1/artemis/exception/ContinousIntegrationException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package de.tum.in.www1.artemis.exception;\n+\n+/**\n+ * Created by muenchdo on 22/06/16.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2Mzg1MA==", "bodyText": "I remove the comment.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498963850", "createdAt": "2020-10-02T17:48:37Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/exception/ContinousIntegrationException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package de.tum.in.www1.artemis.exception;\n+\n+/**\n+ * Created by muenchdo on 22/06/16.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMTkzMw=="}, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzUwMzA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Njo1NVrOHb0iag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzo0ODoyMVrOHb2VAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNDM3OA==", "bodyText": "Just a note / to-do for a followup: Improve this to include multiple lines.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498934378", "createdAt": "2020-10-02T16:46:55Z", "author": {"login": "MaisiKoleni"}, "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "diffHunk": "@@ -94,6 +96,60 @@ public FeedbackService(FeedbackRepository feedbackRepository) {\n         return feedbackList;\n     }\n \n+    /**\n+     * Create an automatic feedback object from a test job.\n+     * @param testName the test case name.\n+     * @param testErrors a list of errors generated by the test job\n+     * @param successful if the test case was successful.\n+     * @param programmingLanguage the programming language of the exercise.\n+     * @return Feedback object for the test job\n+     */\n+    public Feedback createFeedbackFromTestCase(String testName, List<String> testErrors, boolean successful, final ProgrammingLanguage programmingLanguage) {\n+\n+        Feedback feedback = new Feedback();\n+        feedback.setText(testName);\n+\n+        if (!successful) {\n+\n+            String errorMessageString = testErrors.stream().map(errorString -> processResultErrorMessage(programmingLanguage, errorString)).reduce(\"\", String::concat);\n+\n+            if (errorMessageString.length() > FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS) {\n+                errorMessageString = errorMessageString.substring(0, FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS);\n+            }\n+\n+            feedback.setDetailText(errorMessageString);\n+        }\n+        else {\n+            feedback.setDetailText(null);\n+        }\n+\n+        feedback.setType(FeedbackType.AUTOMATIC);\n+        feedback.setPositive(successful);\n+\n+        return feedback;\n+    }\n+\n+    /**\n+     * Filters and processes a feedback error message, thereby removing any unwanted strings depending on\n+     * the programming language, or just reformatting it to only show the most important details.\n+     *\n+     * @param programmingLanguage The programming language for which the feedback was generated\n+     * @param message The raw error message in the feedback\n+     * @return A filtered and better formatted error message\n+     */\n+    private String processResultErrorMessage(final ProgrammingLanguage programmingLanguage, final String message) {\n+        if (programmingLanguage == ProgrammingLanguage.JAVA) {\n+            // Splitting string at the first linebreak to only get the first line of the Exception\n+            return message.split(\"\\\\n\", 2)[0]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MzcxNQ==", "bodyText": "I added a TODO comment for this.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498963715", "createdAt": "2020-10-02T17:48:21Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/service/FeedbackService.java", "diffHunk": "@@ -94,6 +96,60 @@ public FeedbackService(FeedbackRepository feedbackRepository) {\n         return feedbackList;\n     }\n \n+    /**\n+     * Create an automatic feedback object from a test job.\n+     * @param testName the test case name.\n+     * @param testErrors a list of errors generated by the test job\n+     * @param successful if the test case was successful.\n+     * @param programmingLanguage the programming language of the exercise.\n+     * @return Feedback object for the test job\n+     */\n+    public Feedback createFeedbackFromTestCase(String testName, List<String> testErrors, boolean successful, final ProgrammingLanguage programmingLanguage) {\n+\n+        Feedback feedback = new Feedback();\n+        feedback.setText(testName);\n+\n+        if (!successful) {\n+\n+            String errorMessageString = testErrors.stream().map(errorString -> processResultErrorMessage(programmingLanguage, errorString)).reduce(\"\", String::concat);\n+\n+            if (errorMessageString.length() > FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS) {\n+                errorMessageString = errorMessageString.substring(0, FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS);\n+            }\n+\n+            feedback.setDetailText(errorMessageString);\n+        }\n+        else {\n+            feedback.setDetailText(null);\n+        }\n+\n+        feedback.setType(FeedbackType.AUTOMATIC);\n+        feedback.setPositive(successful);\n+\n+        return feedback;\n+    }\n+\n+    /**\n+     * Filters and processes a feedback error message, thereby removing any unwanted strings depending on\n+     * the programming language, or just reformatting it to only show the most important details.\n+     *\n+     * @param programmingLanguage The programming language for which the feedback was generated\n+     * @param message The raw error message in the feedback\n+     * @return A filtered and better formatted error message\n+     */\n+    private String processResultErrorMessage(final ProgrammingLanguage programmingLanguage, final String message) {\n+        if (programmingLanguage == ProgrammingLanguage.JAVA) {\n+            // Splitting string at the first linebreak to only get the first line of the Exception\n+            return message.split(\"\\\\n\", 2)[0]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNDM3OA=="}, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzUwOTc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/ProgrammingExerciseGradingService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0OToxMVrOHb0mhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzo0ODowOFrOHb2UuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNTQyOA==", "bodyText": "See #1659\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .anyMatch(feedback -> feedback.getText() != null && feedback.getText().equals(testCase.getTestName()) && feedback.isPositive() == Boolean.TRUE);\n          \n          \n            \n                            .anyMatch(feedback -> feedback.getText() != null && feedback.getText().equals(testCase.getTestName()) && Boolean.TRUE.equals(feedback.isPositive()));", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498935428", "createdAt": "2020-10-02T16:49:11Z", "author": {"login": "MaisiKoleni"}, "path": "src/main/java/de/tum/in/www1/artemis/service/ProgrammingExerciseGradingService.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.eclipse.jgit.lib.ObjectId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.messaging.simp.SimpMessageSendingOperations;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.*;\n+import de.tum.in.www1.artemis.domain.enumeration.FeedbackType;\n+import de.tum.in.www1.artemis.domain.enumeration.SubmissionType;\n+import de.tum.in.www1.artemis.domain.participation.*;\n+import de.tum.in.www1.artemis.exception.ContinousIntegrationException;\n+import de.tum.in.www1.artemis.repository.ResultRepository;\n+import de.tum.in.www1.artemis.service.connectors.ContinuousIntegrationService;\n+import de.tum.in.www1.artemis.web.rest.errors.EntityNotFoundException;\n+\n+@Service\n+public class ProgrammingExerciseGradingService {\n+\n+    private final Logger log = LoggerFactory.getLogger(ProgrammingExerciseGradingService.class);\n+\n+    private final Optional<ContinuousIntegrationService> continuousIntegrationService;\n+\n+    private final ProgrammingExerciseTestCaseService testCaseService;\n+\n+    private final ProgrammingExerciseService programmingExerciseService;\n+\n+    private final ProgrammingSubmissionService programmingSubmissionService;\n+\n+    private final SimpMessageSendingOperations messagingTemplate;\n+\n+    private final ResultRepository resultRepository;\n+\n+    private final ParticipationService participationService;\n+\n+    public ProgrammingExerciseGradingService(ProgrammingExerciseTestCaseService testCaseService, ProgrammingExerciseService programmingExerciseService,\n+            ProgrammingSubmissionService programmingSubmissionService, ParticipationService participationService, ResultRepository resultRepository,\n+            Optional<ContinuousIntegrationService> continuousIntegrationService, SimpMessageSendingOperations messagingTemplate) {\n+        this.testCaseService = testCaseService;\n+        this.programmingExerciseService = programmingExerciseService;\n+        this.programmingSubmissionService = programmingSubmissionService;\n+        this.participationService = participationService;\n+        this.continuousIntegrationService = continuousIntegrationService;\n+        this.resultRepository = resultRepository;\n+        this.messagingTemplate = messagingTemplate;\n+    }\n+\n+    /**\n+     * Use the given requestBody to extract the relevant information from it. Fetch and attach the result's feedback items to it. For programming exercises the test cases are\n+     * extracted from the feedbacks & the result is updated with the information from the test cases.\n+     *\n+     * @param participation the participation for which the build was finished\n+     * @param requestBody   RequestBody containing the build result and its feedback items\n+     * @return result after compilation\n+     */\n+    public Optional<Result> processNewProgrammingExerciseResult(@NotNull Participation participation, @NotNull Object requestBody) {\n+        log.debug(\"Received new build result (NEW) for participation \" + participation.getId());\n+\n+        if (!(participation instanceof ProgrammingExerciseParticipation)) {\n+            throw new EntityNotFoundException(\"Participation with id \" + participation.getId() + \" is not a programming exercise participation!\");\n+        }\n+\n+        Result result;\n+        try {\n+            result = continuousIntegrationService.get().onBuildCompleted((ProgrammingExerciseParticipation) participation, requestBody);\n+        }\n+        catch (ContinousIntegrationException ex) {\n+            log.error(\"Result for participation \" + participation.getId() + \" could not be created due to the following exception: \" + ex);\n+            return Optional.empty();\n+        }\n+\n+        if (result != null) {\n+            ProgrammingExercise programmingExercise = (ProgrammingExercise) participation.getExercise();\n+            boolean isSolutionParticipation = participation instanceof SolutionProgrammingExerciseParticipation;\n+            boolean isTemplateParticipation = participation instanceof TemplateProgrammingExerciseParticipation;\n+            // Find out which test cases were executed and calculate the score according to their status and weight.\n+            // This needs to be done as some test cases might not have been executed.\n+            // When the result is from a solution participation , extract the feedback items (= test cases) and store them in our database.\n+            if (isSolutionParticipation) {\n+                extractTestCasesFromResult(programmingExercise, result);\n+            }\n+            result = updateResult(result, programmingExercise, !isSolutionParticipation && !isTemplateParticipation);\n+            result = resultRepository.save(result);\n+            // workaround to prevent that result.submission suddenly turns into a proxy and cannot be used any more later after returning this method\n+\n+            // If the solution participation was updated, also trigger the template participation build.\n+            if (isSolutionParticipation) {\n+                // This method will return without triggering the build if the submission is not of type TEST.\n+                triggerTemplateBuildIfTestCasesChanged(programmingExercise.getId(), result.getId());\n+            }\n+        }\n+        return Optional.ofNullable(result);\n+    }\n+\n+    /**\n+     * Trigger the build of the template repository, if the submission of the provided result is of type TEST.\n+     * Will use the commitHash of the submission for triggering the template build.\n+     *\n+     * If the submission of the provided result is not of type TEST, the method will return without triggering the build.\n+     *\n+     * @param programmingExerciseId ProgrammingExercise id that belongs to the result.\n+     * @param resultId              Result id.\n+     */\n+    private void triggerTemplateBuildIfTestCasesChanged(long programmingExerciseId, long resultId) {\n+        ProgrammingSubmission submission;\n+        try {\n+            submission = programmingSubmissionService.findByResultId(resultId);\n+        }\n+        catch (EntityNotFoundException ex) {\n+            // This is an unlikely error that would mean that no submission could be created for the result. In this case we can only log and abort.\n+            log.error(\"Could not trigger the build of the template repository for the programming exercise id \" + programmingExerciseId\n+                    + \" because no submission could be found for the provided result id \" + resultId);\n+            return;\n+        }\n+        // We only trigger the template build when the test repository was changed.\n+        if (!submission.getType().equals(SubmissionType.TEST)) {\n+            return;\n+        }\n+        // We use the last commitHash of the test repository.\n+        ObjectId testCommitHash = ObjectId.fromString(submission.getCommitHash());\n+        try {\n+            programmingSubmissionService.triggerTemplateBuildAndNotifyUser(programmingExerciseId, testCommitHash, SubmissionType.TEST);\n+        }\n+        catch (EntityNotFoundException ex) {\n+            // If for some reason the programming exercise does not have a template participation, we can only log and abort.\n+            log.error(\"Could not trigger the build of the template repository for the programming exercise id \" + programmingExerciseId\n+                    + \" because no template participation could be found for the given exercise\");\n+        }\n+    }\n+\n+    /**\n+     * Generates test cases from the given result's feedbacks & notifies the subscribing users about the test cases if they have changed. Has the side effect of sending a message\n+     * through the websocket!\n+     *\n+     * @param exercise the programming exercise for which the test cases should be extracted from the new result\n+     * @param result   from which to extract the test cases.\n+     */\n+    private void extractTestCasesFromResult(ProgrammingExercise exercise, Result result) {\n+        boolean haveTestCasesChanged = testCaseService.generateTestCasesFromFeedbacks(result.getFeedbacks(), exercise);\n+        if (haveTestCasesChanged) {\n+            // Notify the client about the updated testCases\n+            Set<ProgrammingExerciseTestCase> testCases = testCaseService.findByExerciseId(exercise.getId());\n+            messagingTemplate.convertAndSend(\"/topic/programming-exercise/\" + exercise.getId() + \"/test-cases\", testCases);\n+        }\n+    }\n+\n+    /**\n+     * Updates an incoming result with the information of the exercises test cases. This update includes:\n+     * - Checking which test cases were not executed as this is not part of the bamboo build (not all test cases are executed in an exercise with sequential test runs)\n+     * - Checking the due date and the afterDueDate flag\n+     * - Recalculating the score based based on the successful test cases weight vs the total weight of all test cases.\n+     *\n+     * If there are no test cases stored in the database for the given exercise (i.e. we have a legacy exercise) or the weight has not been changed, then the result will not change\n+     *\n+     * @param result   to modify with new score, result string & added feedbacks (not executed tests)\n+     * @param exercise the result belongs to.\n+     * @param isStudentParticipation boolean flag indicating weather the participation of the result is not a solution/template participation.\n+     * @return Result with updated feedbacks, score and result string.\n+     */\n+    public Result updateResult(Result result, ProgrammingExercise exercise, boolean isStudentParticipation) {\n+        Set<ProgrammingExerciseTestCase> testCases = testCaseService.findActiveByExerciseId(exercise.getId());\n+        Set<ProgrammingExerciseTestCase> testCasesForCurrentDate = testCases;\n+        // We don't filter the test cases for the solution/template participation's results as they are used as indicators for the instructor!\n+        if (isStudentParticipation) {\n+            testCasesForCurrentDate = filterTestCasesForCurrentDate(exercise, testCases);\n+        }\n+        return updateResult(testCases, testCasesForCurrentDate, result, exercise);\n+    }\n+\n+    /**\n+     * Updates <b>all</b> latest automatic results of the given exercise with the information of the exercises test cases. This update includes:\n+     * - Checking which test cases were not executed as this is not part of the bamboo build (not all test cases are executed in an exercise with sequential test runs)\n+     * - Checking the due date and the afterDueDate flag\n+     * - Recalculating the score based based on the successful test cases weight vs the total weight of all test cases.\n+     *\n+     * If there are no test cases stored in the database for the given exercise (i.e. we have a legacy exercise) or the weight has not been changed, then the result will not change\n+     *\n+     * @param exercise the exercise whose results should be updated\n+     * @return the results of the exercise that have been updated\n+     */\n+    public List<Result> updateAllResults(ProgrammingExercise exercise) {\n+        Set<ProgrammingExerciseTestCase> testCases = testCaseService.findActiveByExerciseId(exercise.getId());\n+\n+        ArrayList<Result> updatedResults = new ArrayList<>();\n+\n+        Result templateResult = exercise.getTemplateParticipation().findLatestResult();\n+        Result solutionResult = exercise.getSolutionParticipation().findLatestResult();\n+        // template and solution are always updated using ALL test cases\n+        if (templateResult != null) {\n+            updateResult(testCases, testCases, templateResult, exercise);\n+            updatedResults.add(templateResult);\n+        }\n+        if (solutionResult != null) {\n+            updateResult(testCases, testCases, solutionResult, exercise);\n+            updatedResults.add(solutionResult);\n+        }\n+        // filter the test cases for the student results if necessary\n+        Set<ProgrammingExerciseTestCase> testCasesForCurrentDate = filterTestCasesForCurrentDate(exercise, testCases);\n+        // We only update the latest automatic results here, later manual assessments are not affected\n+        List<StudentParticipation> participations = participationService.findByExerciseIdWithLatestAutomaticResultAndFeedbacks(exercise.getId());\n+\n+        for (StudentParticipation studentParticipation : participations) {\n+            Result result = studentParticipation.findLatestResult();\n+            if (result != null) {\n+                updateResult(testCases, testCasesForCurrentDate, result, exercise);\n+                updatedResults.add(result);\n+            }\n+        }\n+        return updatedResults;\n+    }\n+\n+    private Set<ProgrammingExerciseTestCase> filterTestCasesForCurrentDate(ProgrammingExercise exercise, Set<ProgrammingExerciseTestCase> testCases) {\n+        boolean shouldTestsWithAfterDueDateFlagBeRemoved = exercise.getBuildAndTestStudentSubmissionsAfterDueDate() != null\n+                && ZonedDateTime.now().isBefore(exercise.getBuildAndTestStudentSubmissionsAfterDueDate());\n+        // Filter all test cases from the score calculation that are only executed after due date if the due date has not yet passed.\n+        return testCases.stream().filter(testCase -> !shouldTestsWithAfterDueDateFlagBeRemoved || !testCase.isAfterDueDate()).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * TODO: For now we are only concerned with not breaking existing functionality and not losing static code analysis feedback.\n+     * This method has to be extended/refactored when a grading concept for static code analysis has been created\n+     */\n+    private Result updateResult(Set<ProgrammingExerciseTestCase> testCases, Set<ProgrammingExerciseTestCase> testCasesForCurrentDate, @NotNull Result result,\n+            ProgrammingExercise exercise) {\n+\n+        // Distinguish between static code analysis feedback and test case feedback\n+        List<Feedback> testCaseFeedback = new ArrayList<>();\n+        List<Feedback> staticCodeAnalysisFeedback = new ArrayList<>();\n+        for (var feedback : result.getFeedbacks()) {\n+            if (feedback.isStaticCodeAnalysisFeedback()) {\n+                staticCodeAnalysisFeedback.add(feedback);\n+            }\n+            else {\n+                testCaseFeedback.add(feedback);\n+            }\n+        }\n+\n+        // Case 1: There are tests and test case feedback, find out which tests were not executed or should only count to the score after the due date.\n+        if (testCasesForCurrentDate.size() > 0 && testCaseFeedback.size() > 0 && result.getFeedbacks().size() > 0) {\n+            // Remove feedbacks that the student should not see yet because of the due date.\n+            removeFeedbacksForAfterDueDateTests(result, testCasesForCurrentDate);\n+\n+            Set<ProgrammingExerciseTestCase> successfulTestCases = testCasesForCurrentDate.stream().filter(isSuccessful(result)).collect(Collectors.toSet());\n+\n+            // Add feedbacks for tests that were not executed (\"test was not executed\").\n+            createFeedbackForNotExecutedTests(result, testCasesForCurrentDate);\n+\n+            // Recalculate the achieved score by including the test cases individual weight.\n+            // The score is always calculated from ALL test cases, regardless of the current date!\n+            updateScore(result, successfulTestCases, testCases, exercise);\n+\n+            // Create a new result string that reflects passed, failed & not executed test cases.\n+            updateResultString(result, successfulTestCases, testCasesForCurrentDate);\n+        }\n+        // Case 2: There are no test cases that are executed before the due date has passed. We need to do this to differentiate this case from a build error.\n+        else if (testCases.size() > 0 && result.getFeedbacks().size() > 0 && testCaseFeedback.size() > 0) {\n+            removeAllTestCaseFeedbackAndSetScoreToZero(result, staticCodeAnalysisFeedback);\n+        }\n+        // Case 3: If there is no test case feedback, the build has failed or it has previously fallen under case 2. In this case we just return the original result without\n+        // changing it.\n+        return result;\n+    }\n+\n+    /**\n+     * Check which tests were not executed and add a new Feedback for them to the exercise.\n+     * @param result of the build run.\n+     * @param allTests of the given programming exercise.\n+     */\n+    private void createFeedbackForNotExecutedTests(Result result, Set<ProgrammingExerciseTestCase> allTests) {\n+        List<Feedback> feedbacksForNotExecutedTestCases = allTests.stream().filter(wasNotExecuted(result))\n+                .map(testCase -> new Feedback().type(FeedbackType.AUTOMATIC).text(testCase.getTestName()).detailText(\"Test was not executed.\")).collect(Collectors.toList());\n+        result.addFeedbacks(feedbacksForNotExecutedTestCases);\n+    }\n+\n+    /**\n+     * Check which tests were executed but which result should not be made public to the student yet.\n+     * @param result of the build run.\n+     * @param testCasesForCurrentDate of the given programming exercise.\n+     */\n+    private void removeFeedbacksForAfterDueDateTests(Result result, Set<ProgrammingExerciseTestCase> testCasesForCurrentDate) {\n+        // Find feedback which is not associated with test cases for the current date. Does not remove static code analysis feedback\n+        List<Feedback> feedbacksToFilterForCurrentDate = result.getFeedbacks().stream().filter(\n+                feedback -> !feedback.isStaticCodeAnalysisFeedback() && testCasesForCurrentDate.stream().noneMatch(testCase -> testCase.getTestName().equals(feedback.getText())))\n+                .collect(Collectors.toList());\n+        feedbacksToFilterForCurrentDate.forEach(result::removeFeedback);\n+        // If there are no feedbacks left after filtering those not valid for the current date, also setHasFeedback to false.\n+        if (result.getFeedbacks().stream().noneMatch(feedback -> feedback.isPositive() == Boolean.FALSE\n+                || feedback.getType() != null && (feedback.getType().equals(FeedbackType.MANUAL) || feedback.getType().equals(FeedbackType.MANUAL_UNREFERENCED))))\n+            result.setHasFeedback(false);\n+    }\n+\n+    /**\n+     * Update the score given the positive tests score divided by all tests's score.\n+     * Takes weight, bonus multiplier and absolute bonus points into account\n+     *\n+     * @param result of the build run.\n+     * @param successfulTestCases test cases with positive feedback.\n+     * @param allTests of a given programming exercise.\n+     */\n+    private void updateScore(Result result, Set<ProgrammingExerciseTestCase> successfulTestCases, Set<ProgrammingExerciseTestCase> allTests,\n+            ProgrammingExercise programmingExercise) {\n+        if (successfulTestCases.size() > 0) {\n+\n+            double weightSum = allTests.stream().mapToDouble(ProgrammingExerciseTestCase::getWeight).sum();\n+            double successfulTestPoints = successfulTestCases.stream().mapToDouble(test -> {\n+                double testWeight = test.getWeight() * test.getBonusMultiplier();\n+                double testPoints = testWeight / weightSum * programmingExercise.getMaxScore();\n+                double testPointsWithBonus = testPoints + test.getBonusPoints();\n+                // update credits of related feedback\n+                result.getFeedbacks().stream().filter(fb -> fb.getText().equals(test.getTestName())).findFirst().ifPresent(feedback -> feedback.setCredits(testPointsWithBonus));\n+                return testPointsWithBonus;\n+            }).sum();\n+            double maxPoints = programmingExercise.getMaxScore() + Optional.ofNullable(programmingExercise.getBonusPoints()).orElse(0.0);\n+            // The points are capped by the maximum achievable points\n+            if (successfulTestPoints > maxPoints) {\n+                successfulTestPoints = maxPoints;\n+            }\n+            // The score is calculated as a percentage of the maximum points\n+            long score = (long) (successfulTestPoints / programmingExercise.getMaxScore() * 100.0);\n+\n+            result.setScore(score);\n+        }\n+        else {\n+            result.setScore(0L);\n+        }\n+    }\n+\n+    /**\n+     * Update the result's result string given the successful tests vs. all tests (x of y passed).\n+     * @param result of the build run.\n+     * @param successfulTestCases test cases with positive feedback.\n+     * @param allTests of the given programming exercise.\n+     */\n+    private void updateResultString(Result result, Set<ProgrammingExerciseTestCase> successfulTestCases, Set<ProgrammingExerciseTestCase> allTests) {\n+        // Create a new result string that reflects passed, failed & not executed test cases.\n+        String newResultString = successfulTestCases.size() + \" of \" + allTests.size() + \" passed\";\n+        result.setResultString(newResultString);\n+    }\n+\n+    /**\n+     * Remove all test case feedback information from a result and treat it as if it has a score of 0.\n+     * @param result Result containing all feedback\n+     * @param staticCodeAnalysisFeedback Static code analysis feedback to keep\n+     */\n+    private void removeAllTestCaseFeedbackAndSetScoreToZero(Result result, List<Feedback> staticCodeAnalysisFeedback) {\n+        result.setFeedbacks(staticCodeAnalysisFeedback);\n+        result.hasFeedback(staticCodeAnalysisFeedback.size() > 0);\n+        result.setScore(0L);\n+        result.setResultString(\"0 of 0 passed\");\n+    }\n+\n+    /**\n+     * Check if the provided test was found in the result's feedbacks with positive = true.\n+     * @param result of the build run.\n+     * @return true if there is a positive feedback for a given test.\n+     */\n+    private Predicate<ProgrammingExerciseTestCase> isSuccessful(Result result) {\n+        return testCase -> result.getFeedbacks().stream()\n+                .anyMatch(feedback -> feedback.getText() != null && feedback.getText().equals(testCase.getTestName()) && feedback.isPositive() == Boolean.TRUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MzY0MQ==", "bodyText": "Changed this.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498963641", "createdAt": "2020-10-02T17:48:08Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/service/ProgrammingExerciseGradingService.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.eclipse.jgit.lib.ObjectId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.messaging.simp.SimpMessageSendingOperations;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.*;\n+import de.tum.in.www1.artemis.domain.enumeration.FeedbackType;\n+import de.tum.in.www1.artemis.domain.enumeration.SubmissionType;\n+import de.tum.in.www1.artemis.domain.participation.*;\n+import de.tum.in.www1.artemis.exception.ContinousIntegrationException;\n+import de.tum.in.www1.artemis.repository.ResultRepository;\n+import de.tum.in.www1.artemis.service.connectors.ContinuousIntegrationService;\n+import de.tum.in.www1.artemis.web.rest.errors.EntityNotFoundException;\n+\n+@Service\n+public class ProgrammingExerciseGradingService {\n+\n+    private final Logger log = LoggerFactory.getLogger(ProgrammingExerciseGradingService.class);\n+\n+    private final Optional<ContinuousIntegrationService> continuousIntegrationService;\n+\n+    private final ProgrammingExerciseTestCaseService testCaseService;\n+\n+    private final ProgrammingExerciseService programmingExerciseService;\n+\n+    private final ProgrammingSubmissionService programmingSubmissionService;\n+\n+    private final SimpMessageSendingOperations messagingTemplate;\n+\n+    private final ResultRepository resultRepository;\n+\n+    private final ParticipationService participationService;\n+\n+    public ProgrammingExerciseGradingService(ProgrammingExerciseTestCaseService testCaseService, ProgrammingExerciseService programmingExerciseService,\n+            ProgrammingSubmissionService programmingSubmissionService, ParticipationService participationService, ResultRepository resultRepository,\n+            Optional<ContinuousIntegrationService> continuousIntegrationService, SimpMessageSendingOperations messagingTemplate) {\n+        this.testCaseService = testCaseService;\n+        this.programmingExerciseService = programmingExerciseService;\n+        this.programmingSubmissionService = programmingSubmissionService;\n+        this.participationService = participationService;\n+        this.continuousIntegrationService = continuousIntegrationService;\n+        this.resultRepository = resultRepository;\n+        this.messagingTemplate = messagingTemplate;\n+    }\n+\n+    /**\n+     * Use the given requestBody to extract the relevant information from it. Fetch and attach the result's feedback items to it. For programming exercises the test cases are\n+     * extracted from the feedbacks & the result is updated with the information from the test cases.\n+     *\n+     * @param participation the participation for which the build was finished\n+     * @param requestBody   RequestBody containing the build result and its feedback items\n+     * @return result after compilation\n+     */\n+    public Optional<Result> processNewProgrammingExerciseResult(@NotNull Participation participation, @NotNull Object requestBody) {\n+        log.debug(\"Received new build result (NEW) for participation \" + participation.getId());\n+\n+        if (!(participation instanceof ProgrammingExerciseParticipation)) {\n+            throw new EntityNotFoundException(\"Participation with id \" + participation.getId() + \" is not a programming exercise participation!\");\n+        }\n+\n+        Result result;\n+        try {\n+            result = continuousIntegrationService.get().onBuildCompleted((ProgrammingExerciseParticipation) participation, requestBody);\n+        }\n+        catch (ContinousIntegrationException ex) {\n+            log.error(\"Result for participation \" + participation.getId() + \" could not be created due to the following exception: \" + ex);\n+            return Optional.empty();\n+        }\n+\n+        if (result != null) {\n+            ProgrammingExercise programmingExercise = (ProgrammingExercise) participation.getExercise();\n+            boolean isSolutionParticipation = participation instanceof SolutionProgrammingExerciseParticipation;\n+            boolean isTemplateParticipation = participation instanceof TemplateProgrammingExerciseParticipation;\n+            // Find out which test cases were executed and calculate the score according to their status and weight.\n+            // This needs to be done as some test cases might not have been executed.\n+            // When the result is from a solution participation , extract the feedback items (= test cases) and store them in our database.\n+            if (isSolutionParticipation) {\n+                extractTestCasesFromResult(programmingExercise, result);\n+            }\n+            result = updateResult(result, programmingExercise, !isSolutionParticipation && !isTemplateParticipation);\n+            result = resultRepository.save(result);\n+            // workaround to prevent that result.submission suddenly turns into a proxy and cannot be used any more later after returning this method\n+\n+            // If the solution participation was updated, also trigger the template participation build.\n+            if (isSolutionParticipation) {\n+                // This method will return without triggering the build if the submission is not of type TEST.\n+                triggerTemplateBuildIfTestCasesChanged(programmingExercise.getId(), result.getId());\n+            }\n+        }\n+        return Optional.ofNullable(result);\n+    }\n+\n+    /**\n+     * Trigger the build of the template repository, if the submission of the provided result is of type TEST.\n+     * Will use the commitHash of the submission for triggering the template build.\n+     *\n+     * If the submission of the provided result is not of type TEST, the method will return without triggering the build.\n+     *\n+     * @param programmingExerciseId ProgrammingExercise id that belongs to the result.\n+     * @param resultId              Result id.\n+     */\n+    private void triggerTemplateBuildIfTestCasesChanged(long programmingExerciseId, long resultId) {\n+        ProgrammingSubmission submission;\n+        try {\n+            submission = programmingSubmissionService.findByResultId(resultId);\n+        }\n+        catch (EntityNotFoundException ex) {\n+            // This is an unlikely error that would mean that no submission could be created for the result. In this case we can only log and abort.\n+            log.error(\"Could not trigger the build of the template repository for the programming exercise id \" + programmingExerciseId\n+                    + \" because no submission could be found for the provided result id \" + resultId);\n+            return;\n+        }\n+        // We only trigger the template build when the test repository was changed.\n+        if (!submission.getType().equals(SubmissionType.TEST)) {\n+            return;\n+        }\n+        // We use the last commitHash of the test repository.\n+        ObjectId testCommitHash = ObjectId.fromString(submission.getCommitHash());\n+        try {\n+            programmingSubmissionService.triggerTemplateBuildAndNotifyUser(programmingExerciseId, testCommitHash, SubmissionType.TEST);\n+        }\n+        catch (EntityNotFoundException ex) {\n+            // If for some reason the programming exercise does not have a template participation, we can only log and abort.\n+            log.error(\"Could not trigger the build of the template repository for the programming exercise id \" + programmingExerciseId\n+                    + \" because no template participation could be found for the given exercise\");\n+        }\n+    }\n+\n+    /**\n+     * Generates test cases from the given result's feedbacks & notifies the subscribing users about the test cases if they have changed. Has the side effect of sending a message\n+     * through the websocket!\n+     *\n+     * @param exercise the programming exercise for which the test cases should be extracted from the new result\n+     * @param result   from which to extract the test cases.\n+     */\n+    private void extractTestCasesFromResult(ProgrammingExercise exercise, Result result) {\n+        boolean haveTestCasesChanged = testCaseService.generateTestCasesFromFeedbacks(result.getFeedbacks(), exercise);\n+        if (haveTestCasesChanged) {\n+            // Notify the client about the updated testCases\n+            Set<ProgrammingExerciseTestCase> testCases = testCaseService.findByExerciseId(exercise.getId());\n+            messagingTemplate.convertAndSend(\"/topic/programming-exercise/\" + exercise.getId() + \"/test-cases\", testCases);\n+        }\n+    }\n+\n+    /**\n+     * Updates an incoming result with the information of the exercises test cases. This update includes:\n+     * - Checking which test cases were not executed as this is not part of the bamboo build (not all test cases are executed in an exercise with sequential test runs)\n+     * - Checking the due date and the afterDueDate flag\n+     * - Recalculating the score based based on the successful test cases weight vs the total weight of all test cases.\n+     *\n+     * If there are no test cases stored in the database for the given exercise (i.e. we have a legacy exercise) or the weight has not been changed, then the result will not change\n+     *\n+     * @param result   to modify with new score, result string & added feedbacks (not executed tests)\n+     * @param exercise the result belongs to.\n+     * @param isStudentParticipation boolean flag indicating weather the participation of the result is not a solution/template participation.\n+     * @return Result with updated feedbacks, score and result string.\n+     */\n+    public Result updateResult(Result result, ProgrammingExercise exercise, boolean isStudentParticipation) {\n+        Set<ProgrammingExerciseTestCase> testCases = testCaseService.findActiveByExerciseId(exercise.getId());\n+        Set<ProgrammingExerciseTestCase> testCasesForCurrentDate = testCases;\n+        // We don't filter the test cases for the solution/template participation's results as they are used as indicators for the instructor!\n+        if (isStudentParticipation) {\n+            testCasesForCurrentDate = filterTestCasesForCurrentDate(exercise, testCases);\n+        }\n+        return updateResult(testCases, testCasesForCurrentDate, result, exercise);\n+    }\n+\n+    /**\n+     * Updates <b>all</b> latest automatic results of the given exercise with the information of the exercises test cases. This update includes:\n+     * - Checking which test cases were not executed as this is not part of the bamboo build (not all test cases are executed in an exercise with sequential test runs)\n+     * - Checking the due date and the afterDueDate flag\n+     * - Recalculating the score based based on the successful test cases weight vs the total weight of all test cases.\n+     *\n+     * If there are no test cases stored in the database for the given exercise (i.e. we have a legacy exercise) or the weight has not been changed, then the result will not change\n+     *\n+     * @param exercise the exercise whose results should be updated\n+     * @return the results of the exercise that have been updated\n+     */\n+    public List<Result> updateAllResults(ProgrammingExercise exercise) {\n+        Set<ProgrammingExerciseTestCase> testCases = testCaseService.findActiveByExerciseId(exercise.getId());\n+\n+        ArrayList<Result> updatedResults = new ArrayList<>();\n+\n+        Result templateResult = exercise.getTemplateParticipation().findLatestResult();\n+        Result solutionResult = exercise.getSolutionParticipation().findLatestResult();\n+        // template and solution are always updated using ALL test cases\n+        if (templateResult != null) {\n+            updateResult(testCases, testCases, templateResult, exercise);\n+            updatedResults.add(templateResult);\n+        }\n+        if (solutionResult != null) {\n+            updateResult(testCases, testCases, solutionResult, exercise);\n+            updatedResults.add(solutionResult);\n+        }\n+        // filter the test cases for the student results if necessary\n+        Set<ProgrammingExerciseTestCase> testCasesForCurrentDate = filterTestCasesForCurrentDate(exercise, testCases);\n+        // We only update the latest automatic results here, later manual assessments are not affected\n+        List<StudentParticipation> participations = participationService.findByExerciseIdWithLatestAutomaticResultAndFeedbacks(exercise.getId());\n+\n+        for (StudentParticipation studentParticipation : participations) {\n+            Result result = studentParticipation.findLatestResult();\n+            if (result != null) {\n+                updateResult(testCases, testCasesForCurrentDate, result, exercise);\n+                updatedResults.add(result);\n+            }\n+        }\n+        return updatedResults;\n+    }\n+\n+    private Set<ProgrammingExerciseTestCase> filterTestCasesForCurrentDate(ProgrammingExercise exercise, Set<ProgrammingExerciseTestCase> testCases) {\n+        boolean shouldTestsWithAfterDueDateFlagBeRemoved = exercise.getBuildAndTestStudentSubmissionsAfterDueDate() != null\n+                && ZonedDateTime.now().isBefore(exercise.getBuildAndTestStudentSubmissionsAfterDueDate());\n+        // Filter all test cases from the score calculation that are only executed after due date if the due date has not yet passed.\n+        return testCases.stream().filter(testCase -> !shouldTestsWithAfterDueDateFlagBeRemoved || !testCase.isAfterDueDate()).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * TODO: For now we are only concerned with not breaking existing functionality and not losing static code analysis feedback.\n+     * This method has to be extended/refactored when a grading concept for static code analysis has been created\n+     */\n+    private Result updateResult(Set<ProgrammingExerciseTestCase> testCases, Set<ProgrammingExerciseTestCase> testCasesForCurrentDate, @NotNull Result result,\n+            ProgrammingExercise exercise) {\n+\n+        // Distinguish between static code analysis feedback and test case feedback\n+        List<Feedback> testCaseFeedback = new ArrayList<>();\n+        List<Feedback> staticCodeAnalysisFeedback = new ArrayList<>();\n+        for (var feedback : result.getFeedbacks()) {\n+            if (feedback.isStaticCodeAnalysisFeedback()) {\n+                staticCodeAnalysisFeedback.add(feedback);\n+            }\n+            else {\n+                testCaseFeedback.add(feedback);\n+            }\n+        }\n+\n+        // Case 1: There are tests and test case feedback, find out which tests were not executed or should only count to the score after the due date.\n+        if (testCasesForCurrentDate.size() > 0 && testCaseFeedback.size() > 0 && result.getFeedbacks().size() > 0) {\n+            // Remove feedbacks that the student should not see yet because of the due date.\n+            removeFeedbacksForAfterDueDateTests(result, testCasesForCurrentDate);\n+\n+            Set<ProgrammingExerciseTestCase> successfulTestCases = testCasesForCurrentDate.stream().filter(isSuccessful(result)).collect(Collectors.toSet());\n+\n+            // Add feedbacks for tests that were not executed (\"test was not executed\").\n+            createFeedbackForNotExecutedTests(result, testCasesForCurrentDate);\n+\n+            // Recalculate the achieved score by including the test cases individual weight.\n+            // The score is always calculated from ALL test cases, regardless of the current date!\n+            updateScore(result, successfulTestCases, testCases, exercise);\n+\n+            // Create a new result string that reflects passed, failed & not executed test cases.\n+            updateResultString(result, successfulTestCases, testCasesForCurrentDate);\n+        }\n+        // Case 2: There are no test cases that are executed before the due date has passed. We need to do this to differentiate this case from a build error.\n+        else if (testCases.size() > 0 && result.getFeedbacks().size() > 0 && testCaseFeedback.size() > 0) {\n+            removeAllTestCaseFeedbackAndSetScoreToZero(result, staticCodeAnalysisFeedback);\n+        }\n+        // Case 3: If there is no test case feedback, the build has failed or it has previously fallen under case 2. In this case we just return the original result without\n+        // changing it.\n+        return result;\n+    }\n+\n+    /**\n+     * Check which tests were not executed and add a new Feedback for them to the exercise.\n+     * @param result of the build run.\n+     * @param allTests of the given programming exercise.\n+     */\n+    private void createFeedbackForNotExecutedTests(Result result, Set<ProgrammingExerciseTestCase> allTests) {\n+        List<Feedback> feedbacksForNotExecutedTestCases = allTests.stream().filter(wasNotExecuted(result))\n+                .map(testCase -> new Feedback().type(FeedbackType.AUTOMATIC).text(testCase.getTestName()).detailText(\"Test was not executed.\")).collect(Collectors.toList());\n+        result.addFeedbacks(feedbacksForNotExecutedTestCases);\n+    }\n+\n+    /**\n+     * Check which tests were executed but which result should not be made public to the student yet.\n+     * @param result of the build run.\n+     * @param testCasesForCurrentDate of the given programming exercise.\n+     */\n+    private void removeFeedbacksForAfterDueDateTests(Result result, Set<ProgrammingExerciseTestCase> testCasesForCurrentDate) {\n+        // Find feedback which is not associated with test cases for the current date. Does not remove static code analysis feedback\n+        List<Feedback> feedbacksToFilterForCurrentDate = result.getFeedbacks().stream().filter(\n+                feedback -> !feedback.isStaticCodeAnalysisFeedback() && testCasesForCurrentDate.stream().noneMatch(testCase -> testCase.getTestName().equals(feedback.getText())))\n+                .collect(Collectors.toList());\n+        feedbacksToFilterForCurrentDate.forEach(result::removeFeedback);\n+        // If there are no feedbacks left after filtering those not valid for the current date, also setHasFeedback to false.\n+        if (result.getFeedbacks().stream().noneMatch(feedback -> feedback.isPositive() == Boolean.FALSE\n+                || feedback.getType() != null && (feedback.getType().equals(FeedbackType.MANUAL) || feedback.getType().equals(FeedbackType.MANUAL_UNREFERENCED))))\n+            result.setHasFeedback(false);\n+    }\n+\n+    /**\n+     * Update the score given the positive tests score divided by all tests's score.\n+     * Takes weight, bonus multiplier and absolute bonus points into account\n+     *\n+     * @param result of the build run.\n+     * @param successfulTestCases test cases with positive feedback.\n+     * @param allTests of a given programming exercise.\n+     */\n+    private void updateScore(Result result, Set<ProgrammingExerciseTestCase> successfulTestCases, Set<ProgrammingExerciseTestCase> allTests,\n+            ProgrammingExercise programmingExercise) {\n+        if (successfulTestCases.size() > 0) {\n+\n+            double weightSum = allTests.stream().mapToDouble(ProgrammingExerciseTestCase::getWeight).sum();\n+            double successfulTestPoints = successfulTestCases.stream().mapToDouble(test -> {\n+                double testWeight = test.getWeight() * test.getBonusMultiplier();\n+                double testPoints = testWeight / weightSum * programmingExercise.getMaxScore();\n+                double testPointsWithBonus = testPoints + test.getBonusPoints();\n+                // update credits of related feedback\n+                result.getFeedbacks().stream().filter(fb -> fb.getText().equals(test.getTestName())).findFirst().ifPresent(feedback -> feedback.setCredits(testPointsWithBonus));\n+                return testPointsWithBonus;\n+            }).sum();\n+            double maxPoints = programmingExercise.getMaxScore() + Optional.ofNullable(programmingExercise.getBonusPoints()).orElse(0.0);\n+            // The points are capped by the maximum achievable points\n+            if (successfulTestPoints > maxPoints) {\n+                successfulTestPoints = maxPoints;\n+            }\n+            // The score is calculated as a percentage of the maximum points\n+            long score = (long) (successfulTestPoints / programmingExercise.getMaxScore() * 100.0);\n+\n+            result.setScore(score);\n+        }\n+        else {\n+            result.setScore(0L);\n+        }\n+    }\n+\n+    /**\n+     * Update the result's result string given the successful tests vs. all tests (x of y passed).\n+     * @param result of the build run.\n+     * @param successfulTestCases test cases with positive feedback.\n+     * @param allTests of the given programming exercise.\n+     */\n+    private void updateResultString(Result result, Set<ProgrammingExerciseTestCase> successfulTestCases, Set<ProgrammingExerciseTestCase> allTests) {\n+        // Create a new result string that reflects passed, failed & not executed test cases.\n+        String newResultString = successfulTestCases.size() + \" of \" + allTests.size() + \" passed\";\n+        result.setResultString(newResultString);\n+    }\n+\n+    /**\n+     * Remove all test case feedback information from a result and treat it as if it has a score of 0.\n+     * @param result Result containing all feedback\n+     * @param staticCodeAnalysisFeedback Static code analysis feedback to keep\n+     */\n+    private void removeAllTestCaseFeedbackAndSetScoreToZero(Result result, List<Feedback> staticCodeAnalysisFeedback) {\n+        result.setFeedbacks(staticCodeAnalysisFeedback);\n+        result.hasFeedback(staticCodeAnalysisFeedback.size() > 0);\n+        result.setScore(0L);\n+        result.setResultString(\"0 of 0 passed\");\n+    }\n+\n+    /**\n+     * Check if the provided test was found in the result's feedbacks with positive = true.\n+     * @param result of the build run.\n+     * @return true if there is a positive feedback for a given test.\n+     */\n+    private Predicate<ProgrammingExerciseTestCase> isSuccessful(Result result) {\n+        return testCase -> result.getFeedbacks().stream()\n+                .anyMatch(feedback -> feedback.getText() != null && feedback.getText().equals(testCase.getTestName()) && feedback.isPositive() == Boolean.TRUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNTQyOA=="}, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 367}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzUxMjgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/ProgrammingExerciseGradingService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo1MDoxMVrOHb0oWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzo0Nzo1OVrOHb2UfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNTg5OA==", "bodyText": "See #1659\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (result.getFeedbacks().stream().noneMatch(feedback -> feedback.isPositive() == Boolean.FALSE\n          \n          \n            \n                    if (result.getFeedbacks().stream().noneMatch(feedback -> Boolean.FALSE.equals(feedback.isPositive())", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498935898", "createdAt": "2020-10-02T16:50:11Z", "author": {"login": "MaisiKoleni"}, "path": "src/main/java/de/tum/in/www1/artemis/service/ProgrammingExerciseGradingService.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.eclipse.jgit.lib.ObjectId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.messaging.simp.SimpMessageSendingOperations;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.*;\n+import de.tum.in.www1.artemis.domain.enumeration.FeedbackType;\n+import de.tum.in.www1.artemis.domain.enumeration.SubmissionType;\n+import de.tum.in.www1.artemis.domain.participation.*;\n+import de.tum.in.www1.artemis.exception.ContinousIntegrationException;\n+import de.tum.in.www1.artemis.repository.ResultRepository;\n+import de.tum.in.www1.artemis.service.connectors.ContinuousIntegrationService;\n+import de.tum.in.www1.artemis.web.rest.errors.EntityNotFoundException;\n+\n+@Service\n+public class ProgrammingExerciseGradingService {\n+\n+    private final Logger log = LoggerFactory.getLogger(ProgrammingExerciseGradingService.class);\n+\n+    private final Optional<ContinuousIntegrationService> continuousIntegrationService;\n+\n+    private final ProgrammingExerciseTestCaseService testCaseService;\n+\n+    private final ProgrammingExerciseService programmingExerciseService;\n+\n+    private final ProgrammingSubmissionService programmingSubmissionService;\n+\n+    private final SimpMessageSendingOperations messagingTemplate;\n+\n+    private final ResultRepository resultRepository;\n+\n+    private final ParticipationService participationService;\n+\n+    public ProgrammingExerciseGradingService(ProgrammingExerciseTestCaseService testCaseService, ProgrammingExerciseService programmingExerciseService,\n+            ProgrammingSubmissionService programmingSubmissionService, ParticipationService participationService, ResultRepository resultRepository,\n+            Optional<ContinuousIntegrationService> continuousIntegrationService, SimpMessageSendingOperations messagingTemplate) {\n+        this.testCaseService = testCaseService;\n+        this.programmingExerciseService = programmingExerciseService;\n+        this.programmingSubmissionService = programmingSubmissionService;\n+        this.participationService = participationService;\n+        this.continuousIntegrationService = continuousIntegrationService;\n+        this.resultRepository = resultRepository;\n+        this.messagingTemplate = messagingTemplate;\n+    }\n+\n+    /**\n+     * Use the given requestBody to extract the relevant information from it. Fetch and attach the result's feedback items to it. For programming exercises the test cases are\n+     * extracted from the feedbacks & the result is updated with the information from the test cases.\n+     *\n+     * @param participation the participation for which the build was finished\n+     * @param requestBody   RequestBody containing the build result and its feedback items\n+     * @return result after compilation\n+     */\n+    public Optional<Result> processNewProgrammingExerciseResult(@NotNull Participation participation, @NotNull Object requestBody) {\n+        log.debug(\"Received new build result (NEW) for participation \" + participation.getId());\n+\n+        if (!(participation instanceof ProgrammingExerciseParticipation)) {\n+            throw new EntityNotFoundException(\"Participation with id \" + participation.getId() + \" is not a programming exercise participation!\");\n+        }\n+\n+        Result result;\n+        try {\n+            result = continuousIntegrationService.get().onBuildCompleted((ProgrammingExerciseParticipation) participation, requestBody);\n+        }\n+        catch (ContinousIntegrationException ex) {\n+            log.error(\"Result for participation \" + participation.getId() + \" could not be created due to the following exception: \" + ex);\n+            return Optional.empty();\n+        }\n+\n+        if (result != null) {\n+            ProgrammingExercise programmingExercise = (ProgrammingExercise) participation.getExercise();\n+            boolean isSolutionParticipation = participation instanceof SolutionProgrammingExerciseParticipation;\n+            boolean isTemplateParticipation = participation instanceof TemplateProgrammingExerciseParticipation;\n+            // Find out which test cases were executed and calculate the score according to their status and weight.\n+            // This needs to be done as some test cases might not have been executed.\n+            // When the result is from a solution participation , extract the feedback items (= test cases) and store them in our database.\n+            if (isSolutionParticipation) {\n+                extractTestCasesFromResult(programmingExercise, result);\n+            }\n+            result = updateResult(result, programmingExercise, !isSolutionParticipation && !isTemplateParticipation);\n+            result = resultRepository.save(result);\n+            // workaround to prevent that result.submission suddenly turns into a proxy and cannot be used any more later after returning this method\n+\n+            // If the solution participation was updated, also trigger the template participation build.\n+            if (isSolutionParticipation) {\n+                // This method will return without triggering the build if the submission is not of type TEST.\n+                triggerTemplateBuildIfTestCasesChanged(programmingExercise.getId(), result.getId());\n+            }\n+        }\n+        return Optional.ofNullable(result);\n+    }\n+\n+    /**\n+     * Trigger the build of the template repository, if the submission of the provided result is of type TEST.\n+     * Will use the commitHash of the submission for triggering the template build.\n+     *\n+     * If the submission of the provided result is not of type TEST, the method will return without triggering the build.\n+     *\n+     * @param programmingExerciseId ProgrammingExercise id that belongs to the result.\n+     * @param resultId              Result id.\n+     */\n+    private void triggerTemplateBuildIfTestCasesChanged(long programmingExerciseId, long resultId) {\n+        ProgrammingSubmission submission;\n+        try {\n+            submission = programmingSubmissionService.findByResultId(resultId);\n+        }\n+        catch (EntityNotFoundException ex) {\n+            // This is an unlikely error that would mean that no submission could be created for the result. In this case we can only log and abort.\n+            log.error(\"Could not trigger the build of the template repository for the programming exercise id \" + programmingExerciseId\n+                    + \" because no submission could be found for the provided result id \" + resultId);\n+            return;\n+        }\n+        // We only trigger the template build when the test repository was changed.\n+        if (!submission.getType().equals(SubmissionType.TEST)) {\n+            return;\n+        }\n+        // We use the last commitHash of the test repository.\n+        ObjectId testCommitHash = ObjectId.fromString(submission.getCommitHash());\n+        try {\n+            programmingSubmissionService.triggerTemplateBuildAndNotifyUser(programmingExerciseId, testCommitHash, SubmissionType.TEST);\n+        }\n+        catch (EntityNotFoundException ex) {\n+            // If for some reason the programming exercise does not have a template participation, we can only log and abort.\n+            log.error(\"Could not trigger the build of the template repository for the programming exercise id \" + programmingExerciseId\n+                    + \" because no template participation could be found for the given exercise\");\n+        }\n+    }\n+\n+    /**\n+     * Generates test cases from the given result's feedbacks & notifies the subscribing users about the test cases if they have changed. Has the side effect of sending a message\n+     * through the websocket!\n+     *\n+     * @param exercise the programming exercise for which the test cases should be extracted from the new result\n+     * @param result   from which to extract the test cases.\n+     */\n+    private void extractTestCasesFromResult(ProgrammingExercise exercise, Result result) {\n+        boolean haveTestCasesChanged = testCaseService.generateTestCasesFromFeedbacks(result.getFeedbacks(), exercise);\n+        if (haveTestCasesChanged) {\n+            // Notify the client about the updated testCases\n+            Set<ProgrammingExerciseTestCase> testCases = testCaseService.findByExerciseId(exercise.getId());\n+            messagingTemplate.convertAndSend(\"/topic/programming-exercise/\" + exercise.getId() + \"/test-cases\", testCases);\n+        }\n+    }\n+\n+    /**\n+     * Updates an incoming result with the information of the exercises test cases. This update includes:\n+     * - Checking which test cases were not executed as this is not part of the bamboo build (not all test cases are executed in an exercise with sequential test runs)\n+     * - Checking the due date and the afterDueDate flag\n+     * - Recalculating the score based based on the successful test cases weight vs the total weight of all test cases.\n+     *\n+     * If there are no test cases stored in the database for the given exercise (i.e. we have a legacy exercise) or the weight has not been changed, then the result will not change\n+     *\n+     * @param result   to modify with new score, result string & added feedbacks (not executed tests)\n+     * @param exercise the result belongs to.\n+     * @param isStudentParticipation boolean flag indicating weather the participation of the result is not a solution/template participation.\n+     * @return Result with updated feedbacks, score and result string.\n+     */\n+    public Result updateResult(Result result, ProgrammingExercise exercise, boolean isStudentParticipation) {\n+        Set<ProgrammingExerciseTestCase> testCases = testCaseService.findActiveByExerciseId(exercise.getId());\n+        Set<ProgrammingExerciseTestCase> testCasesForCurrentDate = testCases;\n+        // We don't filter the test cases for the solution/template participation's results as they are used as indicators for the instructor!\n+        if (isStudentParticipation) {\n+            testCasesForCurrentDate = filterTestCasesForCurrentDate(exercise, testCases);\n+        }\n+        return updateResult(testCases, testCasesForCurrentDate, result, exercise);\n+    }\n+\n+    /**\n+     * Updates <b>all</b> latest automatic results of the given exercise with the information of the exercises test cases. This update includes:\n+     * - Checking which test cases were not executed as this is not part of the bamboo build (not all test cases are executed in an exercise with sequential test runs)\n+     * - Checking the due date and the afterDueDate flag\n+     * - Recalculating the score based based on the successful test cases weight vs the total weight of all test cases.\n+     *\n+     * If there are no test cases stored in the database for the given exercise (i.e. we have a legacy exercise) or the weight has not been changed, then the result will not change\n+     *\n+     * @param exercise the exercise whose results should be updated\n+     * @return the results of the exercise that have been updated\n+     */\n+    public List<Result> updateAllResults(ProgrammingExercise exercise) {\n+        Set<ProgrammingExerciseTestCase> testCases = testCaseService.findActiveByExerciseId(exercise.getId());\n+\n+        ArrayList<Result> updatedResults = new ArrayList<>();\n+\n+        Result templateResult = exercise.getTemplateParticipation().findLatestResult();\n+        Result solutionResult = exercise.getSolutionParticipation().findLatestResult();\n+        // template and solution are always updated using ALL test cases\n+        if (templateResult != null) {\n+            updateResult(testCases, testCases, templateResult, exercise);\n+            updatedResults.add(templateResult);\n+        }\n+        if (solutionResult != null) {\n+            updateResult(testCases, testCases, solutionResult, exercise);\n+            updatedResults.add(solutionResult);\n+        }\n+        // filter the test cases for the student results if necessary\n+        Set<ProgrammingExerciseTestCase> testCasesForCurrentDate = filterTestCasesForCurrentDate(exercise, testCases);\n+        // We only update the latest automatic results here, later manual assessments are not affected\n+        List<StudentParticipation> participations = participationService.findByExerciseIdWithLatestAutomaticResultAndFeedbacks(exercise.getId());\n+\n+        for (StudentParticipation studentParticipation : participations) {\n+            Result result = studentParticipation.findLatestResult();\n+            if (result != null) {\n+                updateResult(testCases, testCasesForCurrentDate, result, exercise);\n+                updatedResults.add(result);\n+            }\n+        }\n+        return updatedResults;\n+    }\n+\n+    private Set<ProgrammingExerciseTestCase> filterTestCasesForCurrentDate(ProgrammingExercise exercise, Set<ProgrammingExerciseTestCase> testCases) {\n+        boolean shouldTestsWithAfterDueDateFlagBeRemoved = exercise.getBuildAndTestStudentSubmissionsAfterDueDate() != null\n+                && ZonedDateTime.now().isBefore(exercise.getBuildAndTestStudentSubmissionsAfterDueDate());\n+        // Filter all test cases from the score calculation that are only executed after due date if the due date has not yet passed.\n+        return testCases.stream().filter(testCase -> !shouldTestsWithAfterDueDateFlagBeRemoved || !testCase.isAfterDueDate()).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * TODO: For now we are only concerned with not breaking existing functionality and not losing static code analysis feedback.\n+     * This method has to be extended/refactored when a grading concept for static code analysis has been created\n+     */\n+    private Result updateResult(Set<ProgrammingExerciseTestCase> testCases, Set<ProgrammingExerciseTestCase> testCasesForCurrentDate, @NotNull Result result,\n+            ProgrammingExercise exercise) {\n+\n+        // Distinguish between static code analysis feedback and test case feedback\n+        List<Feedback> testCaseFeedback = new ArrayList<>();\n+        List<Feedback> staticCodeAnalysisFeedback = new ArrayList<>();\n+        for (var feedback : result.getFeedbacks()) {\n+            if (feedback.isStaticCodeAnalysisFeedback()) {\n+                staticCodeAnalysisFeedback.add(feedback);\n+            }\n+            else {\n+                testCaseFeedback.add(feedback);\n+            }\n+        }\n+\n+        // Case 1: There are tests and test case feedback, find out which tests were not executed or should only count to the score after the due date.\n+        if (testCasesForCurrentDate.size() > 0 && testCaseFeedback.size() > 0 && result.getFeedbacks().size() > 0) {\n+            // Remove feedbacks that the student should not see yet because of the due date.\n+            removeFeedbacksForAfterDueDateTests(result, testCasesForCurrentDate);\n+\n+            Set<ProgrammingExerciseTestCase> successfulTestCases = testCasesForCurrentDate.stream().filter(isSuccessful(result)).collect(Collectors.toSet());\n+\n+            // Add feedbacks for tests that were not executed (\"test was not executed\").\n+            createFeedbackForNotExecutedTests(result, testCasesForCurrentDate);\n+\n+            // Recalculate the achieved score by including the test cases individual weight.\n+            // The score is always calculated from ALL test cases, regardless of the current date!\n+            updateScore(result, successfulTestCases, testCases, exercise);\n+\n+            // Create a new result string that reflects passed, failed & not executed test cases.\n+            updateResultString(result, successfulTestCases, testCasesForCurrentDate);\n+        }\n+        // Case 2: There are no test cases that are executed before the due date has passed. We need to do this to differentiate this case from a build error.\n+        else if (testCases.size() > 0 && result.getFeedbacks().size() > 0 && testCaseFeedback.size() > 0) {\n+            removeAllTestCaseFeedbackAndSetScoreToZero(result, staticCodeAnalysisFeedback);\n+        }\n+        // Case 3: If there is no test case feedback, the build has failed or it has previously fallen under case 2. In this case we just return the original result without\n+        // changing it.\n+        return result;\n+    }\n+\n+    /**\n+     * Check which tests were not executed and add a new Feedback for them to the exercise.\n+     * @param result of the build run.\n+     * @param allTests of the given programming exercise.\n+     */\n+    private void createFeedbackForNotExecutedTests(Result result, Set<ProgrammingExerciseTestCase> allTests) {\n+        List<Feedback> feedbacksForNotExecutedTestCases = allTests.stream().filter(wasNotExecuted(result))\n+                .map(testCase -> new Feedback().type(FeedbackType.AUTOMATIC).text(testCase.getTestName()).detailText(\"Test was not executed.\")).collect(Collectors.toList());\n+        result.addFeedbacks(feedbacksForNotExecutedTestCases);\n+    }\n+\n+    /**\n+     * Check which tests were executed but which result should not be made public to the student yet.\n+     * @param result of the build run.\n+     * @param testCasesForCurrentDate of the given programming exercise.\n+     */\n+    private void removeFeedbacksForAfterDueDateTests(Result result, Set<ProgrammingExerciseTestCase> testCasesForCurrentDate) {\n+        // Find feedback which is not associated with test cases for the current date. Does not remove static code analysis feedback\n+        List<Feedback> feedbacksToFilterForCurrentDate = result.getFeedbacks().stream().filter(\n+                feedback -> !feedback.isStaticCodeAnalysisFeedback() && testCasesForCurrentDate.stream().noneMatch(testCase -> testCase.getTestName().equals(feedback.getText())))\n+                .collect(Collectors.toList());\n+        feedbacksToFilterForCurrentDate.forEach(result::removeFeedback);\n+        // If there are no feedbacks left after filtering those not valid for the current date, also setHasFeedback to false.\n+        if (result.getFeedbacks().stream().noneMatch(feedback -> feedback.isPositive() == Boolean.FALSE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MzU4MQ==", "bodyText": "Changed this.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498963581", "createdAt": "2020-10-02T17:47:59Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/service/ProgrammingExerciseGradingService.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.eclipse.jgit.lib.ObjectId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.messaging.simp.SimpMessageSendingOperations;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.*;\n+import de.tum.in.www1.artemis.domain.enumeration.FeedbackType;\n+import de.tum.in.www1.artemis.domain.enumeration.SubmissionType;\n+import de.tum.in.www1.artemis.domain.participation.*;\n+import de.tum.in.www1.artemis.exception.ContinousIntegrationException;\n+import de.tum.in.www1.artemis.repository.ResultRepository;\n+import de.tum.in.www1.artemis.service.connectors.ContinuousIntegrationService;\n+import de.tum.in.www1.artemis.web.rest.errors.EntityNotFoundException;\n+\n+@Service\n+public class ProgrammingExerciseGradingService {\n+\n+    private final Logger log = LoggerFactory.getLogger(ProgrammingExerciseGradingService.class);\n+\n+    private final Optional<ContinuousIntegrationService> continuousIntegrationService;\n+\n+    private final ProgrammingExerciseTestCaseService testCaseService;\n+\n+    private final ProgrammingExerciseService programmingExerciseService;\n+\n+    private final ProgrammingSubmissionService programmingSubmissionService;\n+\n+    private final SimpMessageSendingOperations messagingTemplate;\n+\n+    private final ResultRepository resultRepository;\n+\n+    private final ParticipationService participationService;\n+\n+    public ProgrammingExerciseGradingService(ProgrammingExerciseTestCaseService testCaseService, ProgrammingExerciseService programmingExerciseService,\n+            ProgrammingSubmissionService programmingSubmissionService, ParticipationService participationService, ResultRepository resultRepository,\n+            Optional<ContinuousIntegrationService> continuousIntegrationService, SimpMessageSendingOperations messagingTemplate) {\n+        this.testCaseService = testCaseService;\n+        this.programmingExerciseService = programmingExerciseService;\n+        this.programmingSubmissionService = programmingSubmissionService;\n+        this.participationService = participationService;\n+        this.continuousIntegrationService = continuousIntegrationService;\n+        this.resultRepository = resultRepository;\n+        this.messagingTemplate = messagingTemplate;\n+    }\n+\n+    /**\n+     * Use the given requestBody to extract the relevant information from it. Fetch and attach the result's feedback items to it. For programming exercises the test cases are\n+     * extracted from the feedbacks & the result is updated with the information from the test cases.\n+     *\n+     * @param participation the participation for which the build was finished\n+     * @param requestBody   RequestBody containing the build result and its feedback items\n+     * @return result after compilation\n+     */\n+    public Optional<Result> processNewProgrammingExerciseResult(@NotNull Participation participation, @NotNull Object requestBody) {\n+        log.debug(\"Received new build result (NEW) for participation \" + participation.getId());\n+\n+        if (!(participation instanceof ProgrammingExerciseParticipation)) {\n+            throw new EntityNotFoundException(\"Participation with id \" + participation.getId() + \" is not a programming exercise participation!\");\n+        }\n+\n+        Result result;\n+        try {\n+            result = continuousIntegrationService.get().onBuildCompleted((ProgrammingExerciseParticipation) participation, requestBody);\n+        }\n+        catch (ContinousIntegrationException ex) {\n+            log.error(\"Result for participation \" + participation.getId() + \" could not be created due to the following exception: \" + ex);\n+            return Optional.empty();\n+        }\n+\n+        if (result != null) {\n+            ProgrammingExercise programmingExercise = (ProgrammingExercise) participation.getExercise();\n+            boolean isSolutionParticipation = participation instanceof SolutionProgrammingExerciseParticipation;\n+            boolean isTemplateParticipation = participation instanceof TemplateProgrammingExerciseParticipation;\n+            // Find out which test cases were executed and calculate the score according to their status and weight.\n+            // This needs to be done as some test cases might not have been executed.\n+            // When the result is from a solution participation , extract the feedback items (= test cases) and store them in our database.\n+            if (isSolutionParticipation) {\n+                extractTestCasesFromResult(programmingExercise, result);\n+            }\n+            result = updateResult(result, programmingExercise, !isSolutionParticipation && !isTemplateParticipation);\n+            result = resultRepository.save(result);\n+            // workaround to prevent that result.submission suddenly turns into a proxy and cannot be used any more later after returning this method\n+\n+            // If the solution participation was updated, also trigger the template participation build.\n+            if (isSolutionParticipation) {\n+                // This method will return without triggering the build if the submission is not of type TEST.\n+                triggerTemplateBuildIfTestCasesChanged(programmingExercise.getId(), result.getId());\n+            }\n+        }\n+        return Optional.ofNullable(result);\n+    }\n+\n+    /**\n+     * Trigger the build of the template repository, if the submission of the provided result is of type TEST.\n+     * Will use the commitHash of the submission for triggering the template build.\n+     *\n+     * If the submission of the provided result is not of type TEST, the method will return without triggering the build.\n+     *\n+     * @param programmingExerciseId ProgrammingExercise id that belongs to the result.\n+     * @param resultId              Result id.\n+     */\n+    private void triggerTemplateBuildIfTestCasesChanged(long programmingExerciseId, long resultId) {\n+        ProgrammingSubmission submission;\n+        try {\n+            submission = programmingSubmissionService.findByResultId(resultId);\n+        }\n+        catch (EntityNotFoundException ex) {\n+            // This is an unlikely error that would mean that no submission could be created for the result. In this case we can only log and abort.\n+            log.error(\"Could not trigger the build of the template repository for the programming exercise id \" + programmingExerciseId\n+                    + \" because no submission could be found for the provided result id \" + resultId);\n+            return;\n+        }\n+        // We only trigger the template build when the test repository was changed.\n+        if (!submission.getType().equals(SubmissionType.TEST)) {\n+            return;\n+        }\n+        // We use the last commitHash of the test repository.\n+        ObjectId testCommitHash = ObjectId.fromString(submission.getCommitHash());\n+        try {\n+            programmingSubmissionService.triggerTemplateBuildAndNotifyUser(programmingExerciseId, testCommitHash, SubmissionType.TEST);\n+        }\n+        catch (EntityNotFoundException ex) {\n+            // If for some reason the programming exercise does not have a template participation, we can only log and abort.\n+            log.error(\"Could not trigger the build of the template repository for the programming exercise id \" + programmingExerciseId\n+                    + \" because no template participation could be found for the given exercise\");\n+        }\n+    }\n+\n+    /**\n+     * Generates test cases from the given result's feedbacks & notifies the subscribing users about the test cases if they have changed. Has the side effect of sending a message\n+     * through the websocket!\n+     *\n+     * @param exercise the programming exercise for which the test cases should be extracted from the new result\n+     * @param result   from which to extract the test cases.\n+     */\n+    private void extractTestCasesFromResult(ProgrammingExercise exercise, Result result) {\n+        boolean haveTestCasesChanged = testCaseService.generateTestCasesFromFeedbacks(result.getFeedbacks(), exercise);\n+        if (haveTestCasesChanged) {\n+            // Notify the client about the updated testCases\n+            Set<ProgrammingExerciseTestCase> testCases = testCaseService.findByExerciseId(exercise.getId());\n+            messagingTemplate.convertAndSend(\"/topic/programming-exercise/\" + exercise.getId() + \"/test-cases\", testCases);\n+        }\n+    }\n+\n+    /**\n+     * Updates an incoming result with the information of the exercises test cases. This update includes:\n+     * - Checking which test cases were not executed as this is not part of the bamboo build (not all test cases are executed in an exercise with sequential test runs)\n+     * - Checking the due date and the afterDueDate flag\n+     * - Recalculating the score based based on the successful test cases weight vs the total weight of all test cases.\n+     *\n+     * If there are no test cases stored in the database for the given exercise (i.e. we have a legacy exercise) or the weight has not been changed, then the result will not change\n+     *\n+     * @param result   to modify with new score, result string & added feedbacks (not executed tests)\n+     * @param exercise the result belongs to.\n+     * @param isStudentParticipation boolean flag indicating weather the participation of the result is not a solution/template participation.\n+     * @return Result with updated feedbacks, score and result string.\n+     */\n+    public Result updateResult(Result result, ProgrammingExercise exercise, boolean isStudentParticipation) {\n+        Set<ProgrammingExerciseTestCase> testCases = testCaseService.findActiveByExerciseId(exercise.getId());\n+        Set<ProgrammingExerciseTestCase> testCasesForCurrentDate = testCases;\n+        // We don't filter the test cases for the solution/template participation's results as they are used as indicators for the instructor!\n+        if (isStudentParticipation) {\n+            testCasesForCurrentDate = filterTestCasesForCurrentDate(exercise, testCases);\n+        }\n+        return updateResult(testCases, testCasesForCurrentDate, result, exercise);\n+    }\n+\n+    /**\n+     * Updates <b>all</b> latest automatic results of the given exercise with the information of the exercises test cases. This update includes:\n+     * - Checking which test cases were not executed as this is not part of the bamboo build (not all test cases are executed in an exercise with sequential test runs)\n+     * - Checking the due date and the afterDueDate flag\n+     * - Recalculating the score based based on the successful test cases weight vs the total weight of all test cases.\n+     *\n+     * If there are no test cases stored in the database for the given exercise (i.e. we have a legacy exercise) or the weight has not been changed, then the result will not change\n+     *\n+     * @param exercise the exercise whose results should be updated\n+     * @return the results of the exercise that have been updated\n+     */\n+    public List<Result> updateAllResults(ProgrammingExercise exercise) {\n+        Set<ProgrammingExerciseTestCase> testCases = testCaseService.findActiveByExerciseId(exercise.getId());\n+\n+        ArrayList<Result> updatedResults = new ArrayList<>();\n+\n+        Result templateResult = exercise.getTemplateParticipation().findLatestResult();\n+        Result solutionResult = exercise.getSolutionParticipation().findLatestResult();\n+        // template and solution are always updated using ALL test cases\n+        if (templateResult != null) {\n+            updateResult(testCases, testCases, templateResult, exercise);\n+            updatedResults.add(templateResult);\n+        }\n+        if (solutionResult != null) {\n+            updateResult(testCases, testCases, solutionResult, exercise);\n+            updatedResults.add(solutionResult);\n+        }\n+        // filter the test cases for the student results if necessary\n+        Set<ProgrammingExerciseTestCase> testCasesForCurrentDate = filterTestCasesForCurrentDate(exercise, testCases);\n+        // We only update the latest automatic results here, later manual assessments are not affected\n+        List<StudentParticipation> participations = participationService.findByExerciseIdWithLatestAutomaticResultAndFeedbacks(exercise.getId());\n+\n+        for (StudentParticipation studentParticipation : participations) {\n+            Result result = studentParticipation.findLatestResult();\n+            if (result != null) {\n+                updateResult(testCases, testCasesForCurrentDate, result, exercise);\n+                updatedResults.add(result);\n+            }\n+        }\n+        return updatedResults;\n+    }\n+\n+    private Set<ProgrammingExerciseTestCase> filterTestCasesForCurrentDate(ProgrammingExercise exercise, Set<ProgrammingExerciseTestCase> testCases) {\n+        boolean shouldTestsWithAfterDueDateFlagBeRemoved = exercise.getBuildAndTestStudentSubmissionsAfterDueDate() != null\n+                && ZonedDateTime.now().isBefore(exercise.getBuildAndTestStudentSubmissionsAfterDueDate());\n+        // Filter all test cases from the score calculation that are only executed after due date if the due date has not yet passed.\n+        return testCases.stream().filter(testCase -> !shouldTestsWithAfterDueDateFlagBeRemoved || !testCase.isAfterDueDate()).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * TODO: For now we are only concerned with not breaking existing functionality and not losing static code analysis feedback.\n+     * This method has to be extended/refactored when a grading concept for static code analysis has been created\n+     */\n+    private Result updateResult(Set<ProgrammingExerciseTestCase> testCases, Set<ProgrammingExerciseTestCase> testCasesForCurrentDate, @NotNull Result result,\n+            ProgrammingExercise exercise) {\n+\n+        // Distinguish between static code analysis feedback and test case feedback\n+        List<Feedback> testCaseFeedback = new ArrayList<>();\n+        List<Feedback> staticCodeAnalysisFeedback = new ArrayList<>();\n+        for (var feedback : result.getFeedbacks()) {\n+            if (feedback.isStaticCodeAnalysisFeedback()) {\n+                staticCodeAnalysisFeedback.add(feedback);\n+            }\n+            else {\n+                testCaseFeedback.add(feedback);\n+            }\n+        }\n+\n+        // Case 1: There are tests and test case feedback, find out which tests were not executed or should only count to the score after the due date.\n+        if (testCasesForCurrentDate.size() > 0 && testCaseFeedback.size() > 0 && result.getFeedbacks().size() > 0) {\n+            // Remove feedbacks that the student should not see yet because of the due date.\n+            removeFeedbacksForAfterDueDateTests(result, testCasesForCurrentDate);\n+\n+            Set<ProgrammingExerciseTestCase> successfulTestCases = testCasesForCurrentDate.stream().filter(isSuccessful(result)).collect(Collectors.toSet());\n+\n+            // Add feedbacks for tests that were not executed (\"test was not executed\").\n+            createFeedbackForNotExecutedTests(result, testCasesForCurrentDate);\n+\n+            // Recalculate the achieved score by including the test cases individual weight.\n+            // The score is always calculated from ALL test cases, regardless of the current date!\n+            updateScore(result, successfulTestCases, testCases, exercise);\n+\n+            // Create a new result string that reflects passed, failed & not executed test cases.\n+            updateResultString(result, successfulTestCases, testCasesForCurrentDate);\n+        }\n+        // Case 2: There are no test cases that are executed before the due date has passed. We need to do this to differentiate this case from a build error.\n+        else if (testCases.size() > 0 && result.getFeedbacks().size() > 0 && testCaseFeedback.size() > 0) {\n+            removeAllTestCaseFeedbackAndSetScoreToZero(result, staticCodeAnalysisFeedback);\n+        }\n+        // Case 3: If there is no test case feedback, the build has failed or it has previously fallen under case 2. In this case we just return the original result without\n+        // changing it.\n+        return result;\n+    }\n+\n+    /**\n+     * Check which tests were not executed and add a new Feedback for them to the exercise.\n+     * @param result of the build run.\n+     * @param allTests of the given programming exercise.\n+     */\n+    private void createFeedbackForNotExecutedTests(Result result, Set<ProgrammingExerciseTestCase> allTests) {\n+        List<Feedback> feedbacksForNotExecutedTestCases = allTests.stream().filter(wasNotExecuted(result))\n+                .map(testCase -> new Feedback().type(FeedbackType.AUTOMATIC).text(testCase.getTestName()).detailText(\"Test was not executed.\")).collect(Collectors.toList());\n+        result.addFeedbacks(feedbacksForNotExecutedTestCases);\n+    }\n+\n+    /**\n+     * Check which tests were executed but which result should not be made public to the student yet.\n+     * @param result of the build run.\n+     * @param testCasesForCurrentDate of the given programming exercise.\n+     */\n+    private void removeFeedbacksForAfterDueDateTests(Result result, Set<ProgrammingExerciseTestCase> testCasesForCurrentDate) {\n+        // Find feedback which is not associated with test cases for the current date. Does not remove static code analysis feedback\n+        List<Feedback> feedbacksToFilterForCurrentDate = result.getFeedbacks().stream().filter(\n+                feedback -> !feedback.isStaticCodeAnalysisFeedback() && testCasesForCurrentDate.stream().noneMatch(testCase -> testCase.getTestName().equals(feedback.getText())))\n+                .collect(Collectors.toList());\n+        feedbacksToFilterForCurrentDate.forEach(result::removeFeedback);\n+        // If there are no feedbacks left after filtering those not valid for the current date, also setHasFeedback to false.\n+        if (result.getFeedbacks().stream().noneMatch(feedback -> feedback.isPositive() == Boolean.FALSE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNTg5OA=="}, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzU0OTMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/connectors/jenkins/JenkinsService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzowMjoxM1rOHb0_LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODowOToxMlrOHb27Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0MTc0MA==", "bodyText": "Is there a reason why we use two nested forEach calls here instead of the flatMap and collect that was there before?", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498941740", "createdAt": "2020-10-02T17:02:13Z", "author": {"login": "MaisiKoleni"}, "path": "src/main/java/de/tum/in/www1/artemis/service/connectors/jenkins/JenkinsService.java", "diffHunk": "@@ -361,64 +362,24 @@ public boolean buildPlanIdIsValid(String projectKey, String buildPlanId) {\n         }\n     }\n \n-    @Override\n-    public Optional<Result> retrieveLatestBuildResult(ProgrammingExerciseParticipation participation, ProgrammingSubmission submission) {\n-        final var report = fetchLatestBuildResultFromJenkins(participation);\n-\n-        // The retrieved build result must match the commitHash of the provided submission.\n-        if (report.getCommits().stream().map(CommitDTO::getHash).noneMatch(hash -> hash.equals(submission.getCommitHash()))) {\n-            return Optional.empty();\n-        }\n-\n-        final var result = createResultFromBuildResult(report, (Participation) participation);\n-        result.setRatedIfNotExceeded(report.getRunDate(), submission);\n-        result.setSubmission(submission);\n-\n-        submission.setBuildFailed(result.getResultString().equals(\"No tests found\"));\n-        programmingSubmissionRepository.save(submission);\n-\n-        return Optional.empty();\n-    }\n-\n     private void addFeedbackToResult(Result result, TestResultsDTO report) {\n         // No feedback for build errors\n         if (report.getResults() == null || report.getResults().isEmpty()) {\n             result.setHasFeedback(false);\n             return;\n         }\n \n-        final var feedbacks = report.getResults().stream().flatMap(testsuite -> testsuite.getTestCases().stream()).map(testCase -> {\n-            final var feedback = new Feedback();\n-            feedback.setPositive(testCase.getErrors() == null && testCase.getFailures() == null);\n-            feedback.setText(testCase.getName());\n-            String errorMessage = null;\n-            // If we have errors or failures, they will always be of length == 1 since JUnit (and the format itself)\n-            // should generally only report the first failure in a test case\n-            if (testCase.getErrors() != null) {\n-                errorMessage = testCase.getErrors().get(0).getMessage();\n-            }\n-            else if (testCase.getFailures() != null) {\n-                errorMessage = testCase.getFailures().get(0).getMessage();\n-            }\n-            // The assertion message can be longer than the allowed char limit, so we shorten it here if needed.\n-            if (errorMessage != null && errorMessage.length() > FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS) {\n-                errorMessage = errorMessage.substring(0, FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS);\n-            }\n-            feedback.setDetailText(errorMessage);\n+        final ProgrammingLanguage programmingLanguage = ((ProgrammingExercise) result.getParticipation().getExercise()).getProgrammingLanguage();\n \n-            return feedback;\n-        }).collect(Collectors.toList());\n+        report.getResults().forEach(testsuite -> testsuite.getTestCases().forEach(testCase -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2ODE3NA==", "bodyText": "Because of the result.addFeedback() method we don't need to .stream() anymore. I did this to be consistent with the BambooService", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498968174", "createdAt": "2020-10-02T17:57:52Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/service/connectors/jenkins/JenkinsService.java", "diffHunk": "@@ -361,64 +362,24 @@ public boolean buildPlanIdIsValid(String projectKey, String buildPlanId) {\n         }\n     }\n \n-    @Override\n-    public Optional<Result> retrieveLatestBuildResult(ProgrammingExerciseParticipation participation, ProgrammingSubmission submission) {\n-        final var report = fetchLatestBuildResultFromJenkins(participation);\n-\n-        // The retrieved build result must match the commitHash of the provided submission.\n-        if (report.getCommits().stream().map(CommitDTO::getHash).noneMatch(hash -> hash.equals(submission.getCommitHash()))) {\n-            return Optional.empty();\n-        }\n-\n-        final var result = createResultFromBuildResult(report, (Participation) participation);\n-        result.setRatedIfNotExceeded(report.getRunDate(), submission);\n-        result.setSubmission(submission);\n-\n-        submission.setBuildFailed(result.getResultString().equals(\"No tests found\"));\n-        programmingSubmissionRepository.save(submission);\n-\n-        return Optional.empty();\n-    }\n-\n     private void addFeedbackToResult(Result result, TestResultsDTO report) {\n         // No feedback for build errors\n         if (report.getResults() == null || report.getResults().isEmpty()) {\n             result.setHasFeedback(false);\n             return;\n         }\n \n-        final var feedbacks = report.getResults().stream().flatMap(testsuite -> testsuite.getTestCases().stream()).map(testCase -> {\n-            final var feedback = new Feedback();\n-            feedback.setPositive(testCase.getErrors() == null && testCase.getFailures() == null);\n-            feedback.setText(testCase.getName());\n-            String errorMessage = null;\n-            // If we have errors or failures, they will always be of length == 1 since JUnit (and the format itself)\n-            // should generally only report the first failure in a test case\n-            if (testCase.getErrors() != null) {\n-                errorMessage = testCase.getErrors().get(0).getMessage();\n-            }\n-            else if (testCase.getFailures() != null) {\n-                errorMessage = testCase.getFailures().get(0).getMessage();\n-            }\n-            // The assertion message can be longer than the allowed char limit, so we shorten it here if needed.\n-            if (errorMessage != null && errorMessage.length() > FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS) {\n-                errorMessage = errorMessage.substring(0, FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS);\n-            }\n-            feedback.setDetailText(errorMessage);\n+        final ProgrammingLanguage programmingLanguage = ((ProgrammingExercise) result.getParticipation().getExercise()).getProgrammingLanguage();\n \n-            return feedback;\n-        }).collect(Collectors.toList());\n+        report.getResults().forEach(testsuite -> testsuite.getTestCases().forEach(testCase -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0MTc0MA=="}, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MzQ0Nw==", "bodyText": "Changed it to normal for each loops.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498973447", "createdAt": "2020-10-02T18:09:12Z", "author": {"login": "schultek"}, "path": "src/main/java/de/tum/in/www1/artemis/service/connectors/jenkins/JenkinsService.java", "diffHunk": "@@ -361,64 +362,24 @@ public boolean buildPlanIdIsValid(String projectKey, String buildPlanId) {\n         }\n     }\n \n-    @Override\n-    public Optional<Result> retrieveLatestBuildResult(ProgrammingExerciseParticipation participation, ProgrammingSubmission submission) {\n-        final var report = fetchLatestBuildResultFromJenkins(participation);\n-\n-        // The retrieved build result must match the commitHash of the provided submission.\n-        if (report.getCommits().stream().map(CommitDTO::getHash).noneMatch(hash -> hash.equals(submission.getCommitHash()))) {\n-            return Optional.empty();\n-        }\n-\n-        final var result = createResultFromBuildResult(report, (Participation) participation);\n-        result.setRatedIfNotExceeded(report.getRunDate(), submission);\n-        result.setSubmission(submission);\n-\n-        submission.setBuildFailed(result.getResultString().equals(\"No tests found\"));\n-        programmingSubmissionRepository.save(submission);\n-\n-        return Optional.empty();\n-    }\n-\n     private void addFeedbackToResult(Result result, TestResultsDTO report) {\n         // No feedback for build errors\n         if (report.getResults() == null || report.getResults().isEmpty()) {\n             result.setHasFeedback(false);\n             return;\n         }\n \n-        final var feedbacks = report.getResults().stream().flatMap(testsuite -> testsuite.getTestCases().stream()).map(testCase -> {\n-            final var feedback = new Feedback();\n-            feedback.setPositive(testCase.getErrors() == null && testCase.getFailures() == null);\n-            feedback.setText(testCase.getName());\n-            String errorMessage = null;\n-            // If we have errors or failures, they will always be of length == 1 since JUnit (and the format itself)\n-            // should generally only report the first failure in a test case\n-            if (testCase.getErrors() != null) {\n-                errorMessage = testCase.getErrors().get(0).getMessage();\n-            }\n-            else if (testCase.getFailures() != null) {\n-                errorMessage = testCase.getFailures().get(0).getMessage();\n-            }\n-            // The assertion message can be longer than the allowed char limit, so we shorten it here if needed.\n-            if (errorMessage != null && errorMessage.length() > FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS) {\n-                errorMessage = errorMessage.substring(0, FEEDBACK_DETAIL_TEXT_MAX_CHARACTERS);\n-            }\n-            feedback.setDetailText(errorMessage);\n+        final ProgrammingLanguage programmingLanguage = ((ProgrammingExercise) result.getParticipation().getExercise()).getProgrammingLanguage();\n \n-            return feedback;\n-        }).collect(Collectors.toList());\n+        report.getResults().forEach(testsuite -> testsuite.getTestCases().forEach(testCase -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0MTc0MA=="}, "originalCommit": {"oid": "d95f63f837e0533617679e62bbc33234a97cb2a0"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzc1MjY5OnYy", "diffSide": "RIGHT", "path": "src/test/java/de/tum/in/www1/artemis/programmingexercise/ProgrammingExerciseTestCaseServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxMjoyNVrOHb3AbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxMjoyNVrOHb3AbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3NDgyOQ==", "bodyText": "Codacy found an issue: Avoid really long methods.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498974829", "createdAt": "2020-10-02T18:12:25Z", "author": {"login": "artemis-bot"}, "path": "src/test/java/de/tum/in/www1/artemis/programmingexercise/ProgrammingExerciseTestCaseServiceTest.java", "diffHunk": "@@ -492,7 +506,7 @@ public void shouldGenerateZeroScoreIfThereAreNoTestCasesBeforeDueDate() {\n \n     @Test\n     @WithMockUser(value = \"instructor1\", roles = \"INSTRUCTOR\")\n-    public void shouldReEvaluateScoreOfTheCorrectResults() {\n+    public void shouldReEvaluateScoreOfTheCorrectResults() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c3e58ccdabcb86203a96f6346763b1497107fb"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzc1Mjc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/ResultService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxMjoyNlrOHb3AeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxMjoyNlrOHb3AeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3NDg0MA==", "bodyText": "Codacy found an issue: Avoid long parameter lists.", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r498974840", "createdAt": "2020-10-02T18:12:26Z", "author": {"login": "artemis-bot"}, "path": "src/main/java/de/tum/in/www1/artemis/service/ResultService.java", "diffHunk": "@@ -62,19 +47,13 @@\n \n     private final ComplaintRepository complaintRepository;\n \n-    public ResultService(UserService userService, ResultRepository resultRepository, Optional<ContinuousIntegrationService> continuousIntegrationService, LtiService ltiService,\n-            SimpMessageSendingOperations messagingTemplate, ObjectMapper objectMapper, ProgrammingExerciseTestCaseService testCaseService,\n-            ProgrammingSubmissionService programmingSubmissionService, FeedbackRepository feedbackRepository, WebsocketMessagingService websocketMessagingService,\n-            ComplaintResponseRepository complaintResponseRepository, SubmissionRepository submissionRepository, ComplaintRepository complaintRepository,\n-            RatingRepository ratingRepository) {\n+    public ResultService(UserService userService, ResultRepository resultRepository, LtiService ltiService, ObjectMapper objectMapper, FeedbackRepository feedbackRepository,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c3e58ccdabcb86203a96f6346763b1497107fb"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDU5NzYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/ProgrammingExerciseGradingService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwMjowMzowMFrOHb_BRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwMjowMzowMFrOHb_BRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNjExOQ==", "bodyText": "I think the comment is misplaced here", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r499106119", "createdAt": "2020-10-03T02:03:00Z", "author": {"login": "fde312"}, "path": "src/main/java/de/tum/in/www1/artemis/service/ProgrammingExerciseGradingService.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.eclipse.jgit.lib.ObjectId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.messaging.simp.SimpMessageSendingOperations;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.*;\n+import de.tum.in.www1.artemis.domain.enumeration.FeedbackType;\n+import de.tum.in.www1.artemis.domain.enumeration.SubmissionType;\n+import de.tum.in.www1.artemis.domain.participation.*;\n+import de.tum.in.www1.artemis.exception.ContinousIntegrationException;\n+import de.tum.in.www1.artemis.repository.ResultRepository;\n+import de.tum.in.www1.artemis.service.connectors.ContinuousIntegrationService;\n+import de.tum.in.www1.artemis.web.rest.errors.EntityNotFoundException;\n+\n+@Service\n+public class ProgrammingExerciseGradingService {\n+\n+    private final Logger log = LoggerFactory.getLogger(ProgrammingExerciseGradingService.class);\n+\n+    private final Optional<ContinuousIntegrationService> continuousIntegrationService;\n+\n+    private final ProgrammingExerciseTestCaseService testCaseService;\n+\n+    private final ProgrammingExerciseService programmingExerciseService;\n+\n+    private final ProgrammingSubmissionService programmingSubmissionService;\n+\n+    private final SimpMessageSendingOperations messagingTemplate;\n+\n+    private final ResultRepository resultRepository;\n+\n+    private final ParticipationService participationService;\n+\n+    public ProgrammingExerciseGradingService(ProgrammingExerciseTestCaseService testCaseService, ProgrammingExerciseService programmingExerciseService,\n+            ProgrammingSubmissionService programmingSubmissionService, ParticipationService participationService, ResultRepository resultRepository,\n+            Optional<ContinuousIntegrationService> continuousIntegrationService, SimpMessageSendingOperations messagingTemplate) {\n+        this.testCaseService = testCaseService;\n+        this.programmingExerciseService = programmingExerciseService;\n+        this.programmingSubmissionService = programmingSubmissionService;\n+        this.participationService = participationService;\n+        this.continuousIntegrationService = continuousIntegrationService;\n+        this.resultRepository = resultRepository;\n+        this.messagingTemplate = messagingTemplate;\n+    }\n+\n+    /**\n+     * Use the given requestBody to extract the relevant information from it. Fetch and attach the result's feedback items to it. For programming exercises the test cases are\n+     * extracted from the feedbacks & the result is updated with the information from the test cases.\n+     *\n+     * @param participation the participation for which the build was finished\n+     * @param requestBody   RequestBody containing the build result and its feedback items\n+     * @return result after compilation\n+     */\n+    public Optional<Result> processNewProgrammingExerciseResult(@NotNull Participation participation, @NotNull Object requestBody) {\n+        log.debug(\"Received new build result (NEW) for participation \" + participation.getId());\n+\n+        if (!(participation instanceof ProgrammingExerciseParticipation)) {\n+            throw new EntityNotFoundException(\"Participation with id \" + participation.getId() + \" is not a programming exercise participation!\");\n+        }\n+\n+        Result result;\n+        try {\n+            result = continuousIntegrationService.get().onBuildCompleted((ProgrammingExerciseParticipation) participation, requestBody);\n+        }\n+        catch (ContinousIntegrationException ex) {\n+            log.error(\"Result for participation \" + participation.getId() + \" could not be created due to the following exception: \" + ex);\n+            return Optional.empty();\n+        }\n+\n+        if (result != null) {\n+            ProgrammingExercise programmingExercise = (ProgrammingExercise) participation.getExercise();\n+            boolean isSolutionParticipation = participation instanceof SolutionProgrammingExerciseParticipation;\n+            boolean isTemplateParticipation = participation instanceof TemplateProgrammingExerciseParticipation;\n+            // Find out which test cases were executed and calculate the score according to their status and weight.\n+            // This needs to be done as some test cases might not have been executed.\n+            // When the result is from a solution participation , extract the feedback items (= test cases) and store them in our database.\n+            if (isSolutionParticipation) {\n+                extractTestCasesFromResult(programmingExercise, result);\n+            }\n+            result = updateResult(result, programmingExercise, !isSolutionParticipation && !isTemplateParticipation);\n+            result = resultRepository.save(result);\n+            // workaround to prevent that result.submission suddenly turns into a proxy and cannot be used any more later after returning this method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c3e58ccdabcb86203a96f6346763b1497107fb"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDYxMDQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/connectors/bamboo/BambooService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwMjoyNzozOFrOHb_H6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwMjoyNzozOFrOHb_H6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNzgxOA==", "bodyText": "I would prefer to extract the service call and store it in one variable. It makes it more readable. You did the same a few lines below, or you change it there as well, then it is consistent. :)", "url": "https://github.com/ls1intum/Artemis/pull/2105#discussion_r499107818", "createdAt": "2020-10-03T02:27:38Z", "author": {"login": "fde312"}, "path": "src/main/java/de/tum/in/www1/artemis/service/connectors/bamboo/BambooService.java", "diffHunk": "@@ -705,26 +630,23 @@ private Result addFeedbackToResultNew(Result result, List<BambooBuildResultNotif\n \n                 // 1) add feedback for failed test cases\n                 for (final var failedTest : job.getFailedTests()) {\n-                    String methodName = failedTest.getName(); // in the attribute \"methodName\", bamboo seems to apply some unwanted logic\n-\n-                    final String errorMessageString = failedTest.getErrors().stream().map(errorString -> processResultErrorMessage(programmingLanguage, errorString)).reduce(\"\",\n-                            String::concat);\n-\n-                    log.debug(\"errorMSGString is {}\", errorMessageString);\n-\n-                    createAutomaticFeedback(result, methodName, false, errorMessageString);\n+                    result.addFeedback(feedbackService.createFeedbackFromTestCase(failedTest.getName(), failedTest.getErrors(), false, programmingLanguage));\n                 }\n \n                 // 2) add feedback for passed test cases\n                 for (final var successfulTest : job.getSuccessfulTests()) {\n-                    String methodName = successfulTest.getName(); // in the attribute \"methodName\", bamboo seems to apply some unwanted logic\n-\n-                    createAutomaticFeedback(result, methodName, true, null);\n+                    result.addFeedback(feedbackService.createFeedbackFromTestCase(successfulTest.getName(), successfulTest.getErrors(), true, programmingLanguage));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c3e58ccdabcb86203a96f6346763b1497107fb"}, "originalPosition": 146}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4689, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}