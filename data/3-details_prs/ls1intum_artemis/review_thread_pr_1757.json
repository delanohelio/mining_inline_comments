{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNjUwNjY4", "number": 1757, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTo0NTozMFrOEKcPYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzozMjowOFrOEK5exg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzgzOTA3OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/shared/server-date.service.ts", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTo0NTozMFrOGrez3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTozOTo0MVrOGriUIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI0Njc0OA==", "bodyText": "Is anyone working on this? Otherwise, I might give this a shot! This can be a significant factor and make the accuracy worse than it actually is!", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r448246748", "createdAt": "2020-07-01T09:45:30Z", "author": {"login": "jpbernius"}, "path": "src/main/webapp/app/shared/server-date.service.ts", "diffHunk": "@@ -24,11 +28,12 @@ export class ArtemisServerDateService {\n                 }\n             });\n         } else {\n-            // definitly sync if we do not have 5 elements yet\n+            // definitely sync if we do not have 5 elements yet\n             shouldSync = true;\n         }\n         // TODO: one additional optimization could be to take the duration for request -> response into account here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI0OTI4OQ==", "bodyText": "@jpbernius I'm not working on this TODO right now and I guess nobody else is working on this in general. So feel free to give this a shot! \ud83d\ude80", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r448249289", "createdAt": "2020-07-01T09:49:56Z", "author": {"login": "filip-gregurevic"}, "path": "src/main/webapp/app/shared/server-date.service.ts", "diffHunk": "@@ -24,11 +28,12 @@ export class ArtemisServerDateService {\n                 }\n             });\n         } else {\n-            // definitly sync if we do not have 5 elements yet\n+            // definitely sync if we do not have 5 elements yet\n             shouldSync = true;\n         }\n         // TODO: one additional optimization could be to take the duration for request -> response into account here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI0Njc0OA=="}, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI2MTA3NA==", "bodyText": "Please talk to @stefanwaldhauser: he wrote a seminar paper about how this works best. It can become quite complex though. He told me you, that you also need to send the client time to the server and you need at least 3 calls.\nWe actually designed a new REST endpoint /time, which is without access control and database access, so it should be super fast (even with a bad internet connection it should not take longer than a few ms, you can test this with the Edge profile in Chrome), so I am not sure if it makes sense to implement additional logic now. I would prefer that we do this in a follow up PR.\nWe should first test that the implementation of this PR is correct (especially the logic with the offset) and that a wrong time zone / wrong local clock at the start of the exam still shows the correct working time. Then we should merge this PR and if we find time, we can improve this in a follow up.", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r448261074", "createdAt": "2020-07-01T10:11:34Z", "author": {"login": "krusche"}, "path": "src/main/webapp/app/shared/server-date.service.ts", "diffHunk": "@@ -24,11 +28,12 @@ export class ArtemisServerDateService {\n                 }\n             });\n         } else {\n-            // definitly sync if we do not have 5 elements yet\n+            // definitely sync if we do not have 5 elements yet\n             shouldSync = true;\n         }\n         // TODO: one additional optimization could be to take the duration for request -> response into account here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI0Njc0OA=="}, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwNDE2Mw==", "bodyText": "OK, so we keep it as is for now. If we need additional logic, we can consider integrating the timesync library.", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r448304163", "createdAt": "2020-07-01T11:39:41Z", "author": {"login": "jpbernius"}, "path": "src/main/webapp/app/shared/server-date.service.ts", "diffHunk": "@@ -24,11 +28,12 @@ export class ArtemisServerDateService {\n                 }\n             });\n         } else {\n-            // definitly sync if we do not have 5 elements yet\n+            // definitely sync if we do not have 5 elements yet\n             shouldSync = true;\n         }\n         // TODO: one additional optimization could be to take the duration for request -> response into account here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI0Njc0OA=="}, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODU5NTk0OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/core/interceptor/artemis-version.interceptor.ts", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoyMzo0M1rOGsMsYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDoxOToxMVrOGsO_zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5ODQ5OA==", "bodyText": "Maybe make this more explicit? This could lead to unwanted behaviour if there are any other requests with \"time\" in the url path right?", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r448998498", "createdAt": "2020-07-02T13:23:43Z", "author": {"login": "schultek"}, "path": "src/main/webapp/app/core/interceptor/artemis-version.interceptor.ts", "diffHunk": "@@ -24,9 +22,9 @@ export class ArtemisVersionInterceptor implements HttpInterceptor {\n                     if (VERSION && serverVersion && VERSION !== serverVersion) {\n                         this.showAlert.next();\n                     }\n-                    const serverDate = response.headers.get(ARTEMIS_SERVER_DATE_HEADER);\n-                    if (serverDate) {\n-                        this.serverDate.next(serverDate);\n+                    // only invoke the time call if the call was not already the time call to prevent recursion here\n+                    if (!req.url.includes('time')) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAzNjIzOQ==", "bodyText": "Well for now there is only this call including 'time' but it should be changed to a more specific approach at some point", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r449036239", "createdAt": "2020-07-02T14:19:11Z", "author": {"login": "filip-gregurevic"}, "path": "src/main/webapp/app/core/interceptor/artemis-version.interceptor.ts", "diffHunk": "@@ -24,9 +22,9 @@ export class ArtemisVersionInterceptor implements HttpInterceptor {\n                     if (VERSION && serverVersion && VERSION !== serverVersion) {\n                         this.showAlert.next();\n                     }\n-                    const serverDate = response.headers.get(ARTEMIS_SERVER_DATE_HEADER);\n-                    if (serverDate) {\n-                        this.serverDate.next(serverDate);\n+                    // only invoke the time call if the call was not already the time call to prevent recursion here\n+                    if (!req.url.includes('time')) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5ODQ5OA=="}, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODYxMTM0OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/shared/server-date.service.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoyNzozN1rOGsM18A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoyNzozN1rOGsM18A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMDk0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.recentClientDates.forEach((recentClientDate) => {\n          \n          \n            \n                            // only if all recent client dates (i.e. recent syncs are older than 60s)\n          \n          \n            \n                            if (now.diff(recentClientDate, 's') > 60) {\n          \n          \n            \n                                shouldSync = true;\n          \n          \n            \n                            }\n          \n          \n            \n                        });\n          \n          \n            \n                         // only if some recent client dates (i.e. recent syncs) are older than 60s\n          \n          \n            \n                        shouldSync = this.recentClientDates.some((recentClientDate) => \n          \n          \n            \n                            now.diff(recentClientDate, 's') > 60);", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r449000944", "createdAt": "2020-07-02T13:27:37Z", "author": {"login": "schultek"}, "path": "src/main/webapp/app/shared/server-date.service.ts", "diffHunk": "@@ -1,36 +1,89 @@\n import { Injectable } from '@angular/core';\n-import { interval } from 'rxjs/observable/interval';\n import * as moment from 'moment';\n+import { HttpClient } from '@angular/common/http';\n+import { SERVER_API_URL } from 'app/app.constants';\n \n @Injectable({ providedIn: 'root' })\n export class ArtemisServerDateService {\n-    // date from the server saved in unix for easier calculation\n-    private serverDate: number;\n-    // interval firing every second to increment the server date\n-    private interval = interval(1000);\n+    private resourceUrl = SERVER_API_URL + 'time';\n \n-    constructor() {\n-        this.interval.subscribe(() => {\n-            // increment the server date by a second every second\n-            this.serverDate++;\n-        });\n+    // offsets of the last synchronizations in ms (max. 5)\n+    private recentOffsets = new Array<number>();\n+    // client (!) dates of the last synchronizations (max. 5)\n+    private recentClientDates = new Array<moment.Moment>();\n+\n+    constructor(private http: HttpClient) {}\n+\n+    /**\n+     * get a new server date if necessary\n+     */\n+    updateTime(): void {\n+        let shouldSync = false;\n+        const now = moment(new Date());\n+        if (this.recentClientDates.length > 4) {\n+            this.recentClientDates.forEach((recentClientDate) => {\n+                // only if all recent client dates (i.e. recent syncs are older than 60s)\n+                if (now.diff(recentClientDate, 's') > 60) {\n+                    shouldSync = true;\n+                }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODYyOTgyOnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/shared/server-date.service.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzozMjowOFrOGsNBrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDoxODoyOFrOGsO9wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMzk0OA==", "bodyText": "Array.sort in javascript is an in-place operation, which means this.recentOffsets would be modified too - also by the shift and pop operation - because offsetsSorted is just a reference, not a copy.", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r449003948", "createdAt": "2020-07-02T13:32:08Z", "author": {"login": "schultek"}, "path": "src/main/webapp/app/shared/server-date.service.ts", "diffHunk": "@@ -1,36 +1,89 @@\n import { Injectable } from '@angular/core';\n-import { interval } from 'rxjs/observable/interval';\n import * as moment from 'moment';\n+import { HttpClient } from '@angular/common/http';\n+import { SERVER_API_URL } from 'app/app.constants';\n \n @Injectable({ providedIn: 'root' })\n export class ArtemisServerDateService {\n-    // date from the server saved in unix for easier calculation\n-    private serverDate: number;\n-    // interval firing every second to increment the server date\n-    private interval = interval(1000);\n+    private resourceUrl = SERVER_API_URL + 'time';\n \n-    constructor() {\n-        this.interval.subscribe(() => {\n-            // increment the server date by a second every second\n-            this.serverDate++;\n-        });\n+    // offsets of the last synchronizations in ms (max. 5)\n+    private recentOffsets = new Array<number>();\n+    // client (!) dates of the last synchronizations (max. 5)\n+    private recentClientDates = new Array<moment.Moment>();\n+\n+    constructor(private http: HttpClient) {}\n+\n+    /**\n+     * get a new server date if necessary\n+     */\n+    updateTime(): void {\n+        let shouldSync = false;\n+        const now = moment(new Date());\n+        if (this.recentClientDates.length > 4) {\n+            this.recentClientDates.forEach((recentClientDate) => {\n+                // only if all recent client dates (i.e. recent syncs are older than 60s)\n+                if (now.diff(recentClientDate, 's') > 60) {\n+                    shouldSync = true;\n+                }\n+            });\n+        } else {\n+            // definitely sync if we do not have 5 elements yet\n+            shouldSync = true;\n+        }\n+        // TODO: one additional optimization could be to take the duration for request -> response into account here\n+        if (shouldSync) {\n+            // get new server date\n+            this.http.get<string>(this.resourceUrl).subscribe((serverDate) => {\n+                this.setServerDate(serverDate);\n+            });\n+        }\n     }\n \n     /**\n-     * sets the current server date as unix\n+     * adds the latest offset\n      *\n      * @param {string} date\n      */\n     setServerDate(date: string): void {\n-        this.serverDate = moment(date).unix();\n+        const serverDate = moment(date);\n+        const clientDate = moment();\n+        // save the most recent client date\n+        this.recentClientDates.push(clientDate);\n+        // calculate offset\n+        const offset = serverDate.diff(clientDate, 'ms');\n+        // save the most recent offset\n+        this.recentOffsets.push(offset);\n+        // remove oldest offset and client date if more than 5\n+        if (this.recentOffsets.length > 5) {\n+            this.recentOffsets.shift();\n+            this.recentClientDates.shift();\n+        }\n+        // This would be faster and more reliable than using an interceptor with arbitrary REST calls\n     }\n \n     /**\n      * returns the calculated current server date as moment\n      */\n-    now(): any {\n-        // return moment.unix(this.serverDate);\n-        // NOTE: quick fix which basically deactivates the calculation here until a better approach is implemented and tested\n-        return moment();\n+    now(): moment.Moment {\n+        const clientDate = moment();\n+        // return the client date if there are no offsets (e.g. when offline or before any api call was made)\n+        if (this.recentOffsets.length === 0) {\n+            return clientDate;\n+        }\n+        // take first offset if there are less than 5\n+        let offset = this.recentOffsets[0];\n+        // remove noise from offset if there are 5\n+        if (this.recentOffsets.length === 5) {\n+            const offsetsSorted = this.recentOffsets.sort((a, b) => b - a);\n+            // remove lowest\n+            offsetsSorted.shift();\n+            // remove highest\n+            offsetsSorted.pop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAzNTcxNA==", "bodyText": "I changed it to work on a copy now", "url": "https://github.com/ls1intum/Artemis/pull/1757#discussion_r449035714", "createdAt": "2020-07-02T14:18:28Z", "author": {"login": "filip-gregurevic"}, "path": "src/main/webapp/app/shared/server-date.service.ts", "diffHunk": "@@ -1,36 +1,89 @@\n import { Injectable } from '@angular/core';\n-import { interval } from 'rxjs/observable/interval';\n import * as moment from 'moment';\n+import { HttpClient } from '@angular/common/http';\n+import { SERVER_API_URL } from 'app/app.constants';\n \n @Injectable({ providedIn: 'root' })\n export class ArtemisServerDateService {\n-    // date from the server saved in unix for easier calculation\n-    private serverDate: number;\n-    // interval firing every second to increment the server date\n-    private interval = interval(1000);\n+    private resourceUrl = SERVER_API_URL + 'time';\n \n-    constructor() {\n-        this.interval.subscribe(() => {\n-            // increment the server date by a second every second\n-            this.serverDate++;\n-        });\n+    // offsets of the last synchronizations in ms (max. 5)\n+    private recentOffsets = new Array<number>();\n+    // client (!) dates of the last synchronizations (max. 5)\n+    private recentClientDates = new Array<moment.Moment>();\n+\n+    constructor(private http: HttpClient) {}\n+\n+    /**\n+     * get a new server date if necessary\n+     */\n+    updateTime(): void {\n+        let shouldSync = false;\n+        const now = moment(new Date());\n+        if (this.recentClientDates.length > 4) {\n+            this.recentClientDates.forEach((recentClientDate) => {\n+                // only if all recent client dates (i.e. recent syncs are older than 60s)\n+                if (now.diff(recentClientDate, 's') > 60) {\n+                    shouldSync = true;\n+                }\n+            });\n+        } else {\n+            // definitely sync if we do not have 5 elements yet\n+            shouldSync = true;\n+        }\n+        // TODO: one additional optimization could be to take the duration for request -> response into account here\n+        if (shouldSync) {\n+            // get new server date\n+            this.http.get<string>(this.resourceUrl).subscribe((serverDate) => {\n+                this.setServerDate(serverDate);\n+            });\n+        }\n     }\n \n     /**\n-     * sets the current server date as unix\n+     * adds the latest offset\n      *\n      * @param {string} date\n      */\n     setServerDate(date: string): void {\n-        this.serverDate = moment(date).unix();\n+        const serverDate = moment(date);\n+        const clientDate = moment();\n+        // save the most recent client date\n+        this.recentClientDates.push(clientDate);\n+        // calculate offset\n+        const offset = serverDate.diff(clientDate, 'ms');\n+        // save the most recent offset\n+        this.recentOffsets.push(offset);\n+        // remove oldest offset and client date if more than 5\n+        if (this.recentOffsets.length > 5) {\n+            this.recentOffsets.shift();\n+            this.recentClientDates.shift();\n+        }\n+        // This would be faster and more reliable than using an interceptor with arbitrary REST calls\n     }\n \n     /**\n      * returns the calculated current server date as moment\n      */\n-    now(): any {\n-        // return moment.unix(this.serverDate);\n-        // NOTE: quick fix which basically deactivates the calculation here until a better approach is implemented and tested\n-        return moment();\n+    now(): moment.Moment {\n+        const clientDate = moment();\n+        // return the client date if there are no offsets (e.g. when offline or before any api call was made)\n+        if (this.recentOffsets.length === 0) {\n+            return clientDate;\n+        }\n+        // take first offset if there are less than 5\n+        let offset = this.recentOffsets[0];\n+        // remove noise from offset if there are 5\n+        if (this.recentOffsets.length === 5) {\n+            const offsetsSorted = this.recentOffsets.sort((a, b) => b - a);\n+            // remove lowest\n+            offsetsSorted.shift();\n+            // remove highest\n+            offsetsSorted.pop();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMzk0OA=="}, "originalCommit": {"oid": "59706dee4d6d22e27f863d8f647cbf6e449941d1"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4940, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}