{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2NTQ2Nzk4", "number": 2240, "reviewThreads": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0Mjo1OFrOEvsLVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTozNjo1OVrOEwuWCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQyMzI3OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0Mjo1OFrOHkzx-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0Mjo1OFrOHkzx-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1OTE2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n          \n          \n            \n            Avoid code duplication. If we cannot reuse a method elsewhere, then the method is probably bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508359161", "createdAt": "2020-10-20T09:42:58Z", "author": {"login": "derLalla"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQyNTEwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0MzoyNlrOHkzzFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0MzoyNlrOHkzzFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1OTQ0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Encapsulate the code you feel might changed in future.\n          \n          \n            \n            * Encapsulate the code you feel might change in future.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508359446", "createdAt": "2020-10-20T09:43:26Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQzMjU4OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NTowOVrOHkz3fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NTowOVrOHkz3fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2MDU3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Write performant queries that can also deal with more 1000 objects in a reasonable time\n          \n          \n            \n            * Write performant queries that can also deal with more 1000 objects in a reasonable time.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508360572", "createdAt": "2020-10-20T09:45:09Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQzNDkwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NTo0MlrOHkz48g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NTo0MlrOHkz48g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2MDk0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n          \n          \n            \n            * Default packages are not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508360946", "createdAt": "2020-10-20T09:45:42Z", "author": {"login": "sjagla27"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQzNjIwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NTo1NFrOHkz5nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NTo1NFrOHkz5nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2MTExNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n          \n          \n            \n            * Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query no more than 3 associations at the same time.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508361117", "createdAt": "2020-10-20T09:45:54Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQzNjkyOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NjowN1rOHkz6FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NjowN1rOHkz6FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2MTIzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Think about lazy vs. eager fetching when modeling the data types\n          \n          \n            \n            * Think about lazy vs. eager fetching when modeling the data types.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508361236", "createdAt": "2020-10-20T09:46:07Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQzNzU0OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NjoxNlrOHkz6ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NjoxNlrOHkz6ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2MTMzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n          \n          \n            \n            * Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508361339", "createdAt": "2020-10-20T09:46:16Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQzODMwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NjoyNVrOHkz66A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0NjoyNVrOHkz66A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2MTQ0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Use ``Timestamp`` instead of ``Datetime``\n          \n          \n            \n            * Use ``Timestamp`` instead of ``Datetime``.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508361448", "createdAt": "2020-10-20T09:46:25Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ1NDY0OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MDoxN1rOHk0FAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MDoxN1rOHk0FAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NDAzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n          \n          \n            \n            Only write comments for complicated algorithms, to help other developers better understand them. We should only add a comment, if our code is not self-explanatory.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508364032", "createdAt": "2020-10-20T09:50:17Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ1OTExOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MToyNFrOHk0Hrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MToyNFrOHk0Hrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NDcxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n          \n          \n            \n            Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong in a related class.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508364719", "createdAt": "2020-10-20T09:51:24Z", "author": {"login": "sjagla27"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ2NDI2OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MjozOFrOHk0K1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MjozOFrOHk0K1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NTUyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n          \n          \n            \n            Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your `@Configuration` into a single class. The `@Import` annotation can be used to import additional configuration classes.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508365527", "createdAt": "2020-10-20T09:52:38Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ2NjgxOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MzoxN1rOHk0MfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MzoxN1rOHk0MfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NTk0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n          \n          \n            \n            Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources, it is generally not recommended. You do not need to put all your `@Configuration` into a single class. The `@Import` annotation can be used to import additional configuration classes.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508365948", "createdAt": "2020-10-20T09:53:17Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ3MTkyOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1NDozMlrOHk0PtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1NDozMlrOHk0PtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2Njc3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Always use @PreAuthorize tag to only allow certain roles to access the method.\n          \n          \n            \n            * Always use `@PreAuthorize` tag to only allow certain roles to access the method.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508366772", "createdAt": "2020-10-20T09:54:32Z", "author": {"login": "FuchsDominik"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ3ODgxOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1NjowNFrOHk0T1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1NjowNFrOHk0T1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NzgzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * ARCHITECTURE FIRST, writing code without thinking of its architecture is useless in the same way as dreaming about your desires without a plan of achieving them.\n          \n          \n            \n            * ARCHITECTURE FIRST, writing code without thinking of the system's architecture is useless, in the same way as dreaming about your desires without a plan of achieving them.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508367831", "createdAt": "2020-10-20T09:56:04Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.\n+* Never trust user input and check if the passed data exists in the database.\n+* Always use different response status codes to notify the client about errors on the server:\n+    * Forbidden - the user is not authorized to access the controller.\n+    * Bad Request - the request was wrong.\n+    * Not Found - can't find the requested data or it should be not accessible yet.\n+\n+12. Dependency injection:\n+=========================\n+\n+* Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.\n+* Use setter based DI only for optional dependencies.\n+* Avoid circular dependencies, try constructor and setter based DI for such cases.\n+\n+13. REST best practices:\n+========================\n+\n+* Verify that API endpoints perform appropriate authorization and authentication consistent with the rest of the code base.\n+* Check for other common weaknesses, e.g., weak configuration, malicious user input, missing log events, etc.\n+* Handle exceptions and errors with a standard response. Errors are very important in REST APIs. They inform clients that something went wrong, after all.\n+\n+14. Keep it simple and stupid:\n+==============================\n+\n+* Don\u2019t write complex code.\n+* Don\u2019t write code when you are tired or in a bad mood.\n+* Optimization vs Readability, always write code that is simple to read and which will be understandable for developers. Because time and resources that will be spent on hard readable code will be much higher than what you get from optimization.\n+* Commit messages should describe both what the commit changes and how it does it.\n+* ARCHITECTURE FIRST, writing code without thinking of its architecture is useless in the same way as dreaming about your desires without a plan of achieving them.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ4NDU1OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1NzoyNVrOHk0XWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1NzoyNVrOHk0XWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2ODcyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Previously we used transactions very random, now we have to avoid using Transactional, if not sure that they are needed. Transactions can kill performance, introduce locking issues and database concurrency problems, and add complexity to our application. Good read: https://codete.com/blog/5-common-spring-transactional-pitfalls/\n          \n          \n            \n            * Previously we used transactions very randomly, now we have to avoid using `@Transactional`, if we are not sure that they are needed. Transactions can kill performance, introduce locking issues and database concurrency problems, and add complexity to our application. Good read: https://codete.com/blog/5-common-spring-transactional-pitfalls/", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508368729", "createdAt": "2020-10-20T09:57:25Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.\n+* Never trust user input and check if the passed data exists in the database.\n+* Always use different response status codes to notify the client about errors on the server:\n+    * Forbidden - the user is not authorized to access the controller.\n+    * Bad Request - the request was wrong.\n+    * Not Found - can't find the requested data or it should be not accessible yet.\n+\n+12. Dependency injection:\n+=========================\n+\n+* Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.\n+* Use setter based DI only for optional dependencies.\n+* Avoid circular dependencies, try constructor and setter based DI for such cases.\n+\n+13. REST best practices:\n+========================\n+\n+* Verify that API endpoints perform appropriate authorization and authentication consistent with the rest of the code base.\n+* Check for other common weaknesses, e.g., weak configuration, malicious user input, missing log events, etc.\n+* Handle exceptions and errors with a standard response. Errors are very important in REST APIs. They inform clients that something went wrong, after all.\n+\n+14. Keep it simple and stupid:\n+==============================\n+\n+* Don\u2019t write complex code.\n+* Don\u2019t write code when you are tired or in a bad mood.\n+* Optimization vs Readability, always write code that is simple to read and which will be understandable for developers. Because time and resources that will be spent on hard readable code will be much higher than what you get from optimization.\n+* Commit messages should describe both what the commit changes and how it does it.\n+* ARCHITECTURE FIRST, writing code without thinking of its architecture is useless in the same way as dreaming about your desires without a plan of achieving them.\n+\n+15. General best practices:\n+===========================\n+\n+* Always use the least possible access level, prefer using private over public access modifier (protected can be used as well).\n+* Previously we used transactions very random, now we have to avoid using Transactional, if not sure that they are needed. Transactions can kill performance, introduce locking issues and database concurrency problems, and add complexity to our application. Good read: https://codete.com/blog/5-common-spring-transactional-pitfalls/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ4ODQwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1ODoxOFrOHk0Ztg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1ODoxOFrOHk0Ztg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2OTMzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Define a constant if the same value is used more than once. Constants allow to change code later a lot easier, instead of looking for the places where this variable was used, you only need to change it in only one place.\n          \n          \n            \n            * Define a constant if the same value is used more than once. Constants allow you to change code later a lot easier. Instead of looking for the places where this variable was used, you only need to change it in only one place.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508369334", "createdAt": "2020-10-20T09:58:18Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.\n+* Never trust user input and check if the passed data exists in the database.\n+* Always use different response status codes to notify the client about errors on the server:\n+    * Forbidden - the user is not authorized to access the controller.\n+    * Bad Request - the request was wrong.\n+    * Not Found - can't find the requested data or it should be not accessible yet.\n+\n+12. Dependency injection:\n+=========================\n+\n+* Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.\n+* Use setter based DI only for optional dependencies.\n+* Avoid circular dependencies, try constructor and setter based DI for such cases.\n+\n+13. REST best practices:\n+========================\n+\n+* Verify that API endpoints perform appropriate authorization and authentication consistent with the rest of the code base.\n+* Check for other common weaknesses, e.g., weak configuration, malicious user input, missing log events, etc.\n+* Handle exceptions and errors with a standard response. Errors are very important in REST APIs. They inform clients that something went wrong, after all.\n+\n+14. Keep it simple and stupid:\n+==============================\n+\n+* Don\u2019t write complex code.\n+* Don\u2019t write code when you are tired or in a bad mood.\n+* Optimization vs Readability, always write code that is simple to read and which will be understandable for developers. Because time and resources that will be spent on hard readable code will be much higher than what you get from optimization.\n+* Commit messages should describe both what the commit changes and how it does it.\n+* ARCHITECTURE FIRST, writing code without thinking of its architecture is useless in the same way as dreaming about your desires without a plan of achieving them.\n+\n+15. General best practices:\n+===========================\n+\n+* Always use the least possible access level, prefer using private over public access modifier (protected can be used as well).\n+* Previously we used transactions very random, now we have to avoid using Transactional, if not sure that they are needed. Transactions can kill performance, introduce locking issues and database concurrency problems, and add complexity to our application. Good read: https://codete.com/blog/5-common-spring-transactional-pitfalls/\n+* Define a constant if the same value is used more than once. Constants allow to change code later a lot easier, instead of looking for the places where this variable was used, you only need to change it in only one place.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ5MjA1OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1OToxMVrOHk0cAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1OToxMVrOHk0cAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2OTkyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Facilitate code reuse. Always move duplicated code to reusable methods. Intelij is very good at suggesting duplicated lines and even automatically extracting them. Also don't be shy to use Generics.\n          \n          \n            \n            * Facilitate code reuse. Always move duplicated code to reusable methods. IntelliJ is very good at suggesting duplicated lines and even automatically extracting them. Also don't be shy to use Generics.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508369923", "createdAt": "2020-10-20T09:59:11Z", "author": {"login": "anditurdiu"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.\n+* Never trust user input and check if the passed data exists in the database.\n+* Always use different response status codes to notify the client about errors on the server:\n+    * Forbidden - the user is not authorized to access the controller.\n+    * Bad Request - the request was wrong.\n+    * Not Found - can't find the requested data or it should be not accessible yet.\n+\n+12. Dependency injection:\n+=========================\n+\n+* Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.\n+* Use setter based DI only for optional dependencies.\n+* Avoid circular dependencies, try constructor and setter based DI for such cases.\n+\n+13. REST best practices:\n+========================\n+\n+* Verify that API endpoints perform appropriate authorization and authentication consistent with the rest of the code base.\n+* Check for other common weaknesses, e.g., weak configuration, malicious user input, missing log events, etc.\n+* Handle exceptions and errors with a standard response. Errors are very important in REST APIs. They inform clients that something went wrong, after all.\n+\n+14. Keep it simple and stupid:\n+==============================\n+\n+* Don\u2019t write complex code.\n+* Don\u2019t write code when you are tired or in a bad mood.\n+* Optimization vs Readability, always write code that is simple to read and which will be understandable for developers. Because time and resources that will be spent on hard readable code will be much higher than what you get from optimization.\n+* Commit messages should describe both what the commit changes and how it does it.\n+* ARCHITECTURE FIRST, writing code without thinking of its architecture is useless in the same way as dreaming about your desires without a plan of achieving them.\n+\n+15. General best practices:\n+===========================\n+\n+* Always use the least possible access level, prefer using private over public access modifier (protected can be used as well).\n+* Previously we used transactions very random, now we have to avoid using Transactional, if not sure that they are needed. Transactions can kill performance, introduce locking issues and database concurrency problems, and add complexity to our application. Good read: https://codete.com/blog/5-common-spring-transactional-pitfalls/\n+* Define a constant if the same value is used more than once. Constants allow to change code later a lot easier, instead of looking for the places where this variable was used, you only need to change it in only one place.\n+* Facilitate code reuse. Always move duplicated code to reusable methods. Intelij is very good at suggesting duplicated lines and even automatically extracting them. Also don't be shy to use Generics.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ5NzIzOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMDowMDoyMlrOHk0fIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMDowMDoyMlrOHk0fIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3MDcyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.\n          \n          \n            \n            * Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the `@Autowired` annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508370723", "createdAt": "2020-10-20T10:00:22Z", "author": {"login": "FuchsDominik"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.\n+* Never trust user input and check if the passed data exists in the database.\n+* Always use different response status codes to notify the client about errors on the server:\n+    * Forbidden - the user is not authorized to access the controller.\n+    * Bad Request - the request was wrong.\n+    * Not Found - can't find the requested data or it should be not accessible yet.\n+\n+12. Dependency injection:\n+=========================\n+\n+* Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjIwOTAwOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNTo1Nzo1OFrOHlFPmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNTo1Nzo1OFrOHlFPmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NTI3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n          \n          \n            \n            * Make variable and methods private by default and increasing access step by step like from a private to package-private or protected and not public.\n          \n      \n    \n    \n  \n\nI would always prefer package private if possible and when the class is not designed for inheritance.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508645275", "createdAt": "2020-10-20T15:57:58Z", "author": {"login": "MaisiKoleni"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjI0MDcyOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjowMzoxMVrOHlFjjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjowMzoxMVrOHlFjjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1MDM4MQ==", "bodyText": "This reads a bit strange, I guess a the/a is missing?", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508650381", "createdAt": "2020-10-20T16:03:11Z", "author": {"login": "MaisiKoleni"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjI2NjExOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjowNzozNlrOHlFz5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjowNzozNlrOHlFz5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1NDU2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n          \n          \n            \n            * Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises/{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508654567", "createdAt": "2020-10-20T16:07:36Z", "author": {"login": "MaisiKoleni"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjI5Mjc3OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoxMTo0OFrOHlGFQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoxMTo0OFrOHlGFQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1OTAwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Always use the least possible access level, prefer using private over public access modifier (protected can be used as well).\n          \n          \n            \n            * Always use the least possible access level, prefer using private over public access modifier (package-private or protected can be used as well).", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r508659008", "createdAt": "2020-10-20T16:11:48Z", "author": {"login": "MaisiKoleni"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.\n+* Never trust user input and check if the passed data exists in the database.\n+* Always use different response status codes to notify the client about errors on the server:\n+    * Forbidden - the user is not authorized to access the controller.\n+    * Bad Request - the request was wrong.\n+    * Not Found - can't find the requested data or it should be not accessible yet.\n+\n+12. Dependency injection:\n+=========================\n+\n+* Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.\n+* Use setter based DI only for optional dependencies.\n+* Avoid circular dependencies, try constructor and setter based DI for such cases.\n+\n+13. REST best practices:\n+========================\n+\n+* Verify that API endpoints perform appropriate authorization and authentication consistent with the rest of the code base.\n+* Check for other common weaknesses, e.g., weak configuration, malicious user input, missing log events, etc.\n+* Handle exceptions and errors with a standard response. Errors are very important in REST APIs. They inform clients that something went wrong, after all.\n+\n+14. Keep it simple and stupid:\n+==============================\n+\n+* Don\u2019t write complex code.\n+* Don\u2019t write code when you are tired or in a bad mood.\n+* Optimization vs Readability, always write code that is simple to read and which will be understandable for developers. Because time and resources that will be spent on hard readable code will be much higher than what you get from optimization.\n+* Commit messages should describe both what the commit changes and how it does it.\n+* ARCHITECTURE FIRST, writing code without thinking of its architecture is useless in the same way as dreaming about your desires without a plan of achieving them.\n+\n+15. General best practices:\n+===========================\n+\n+* Always use the least possible access level, prefer using private over public access modifier (protected can be used as well).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b098ee2e29da0b7e7d98f2fd0b55804e82665312"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODc1MTY4OnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzoxMDoxMFrOHldQxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzoxMDoxMFrOHldQxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzODc4OA==", "bodyText": "Codacy found an issue: [heading-increment] Heading levels should increment by one level at a time", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r509038788", "createdAt": "2020-10-21T07:10:10Z", "author": {"login": "artemis-bot"}, "path": "README.md", "diffHunk": "@@ -11,45 +11,45 @@ Artemis was initially generated using JHipster 6.10.3. ([Documentation and help]\n \n [![Latest version)](https://img.shields.io/github/v/tag/ls1intum/Artemis?label=%20Latest%20version&sort=semver)](https://github.com/ls1intum/Artemis/releases/latest)\n \n-## Main features\n+### Main features", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODc1MTY5OnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzoxMDoxMVrOHldQyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzoxMDoxMVrOHldQyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzODc5Mg==", "bodyText": "Codacy found an issue: [heading-increment] Heading levels should increment by one level at a time", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r509038792", "createdAt": "2020-10-21T07:10:11Z", "author": {"login": "artemis-bot"}, "path": "README.md", "diffHunk": "@@ -75,29 +75,38 @@ The following command can automate the deployment to a server. The example shows\n ./artemis-server-cli deploy username@artemistest.ase.in.tum.de -w build/libs/Artemis-4.4.5.war\n ```\n \n-## Deployment\n+## Architecture\n \n-The following UML deployment diagram shows a typical deployment of Artemis application server and application client. Student, Instructor and Teaching Assistant (TA) computers are all equipped equally with the Artemis application client being displayed in the browser.\n+The following diagram shows the top level design of Artemis which is decomposed into an application client (running as Angular web app in the browser) and an application server (based on Spring Boot). For programming exercises, the application server connects to a version control system (VCS) and a continuous integration system (CIS). Authentication is handled by an external user management system (UMS).\n \n-The Continuous Integration Server typically delegates the build jobs to local build agents within the university infrastructure or to remote build agents, e.g. hosted in the Amazon Cloud (AWS).\n+![Top-Level Design](docs/dev/system-design/TopLevelDesign.png \"Top-Level Design\")\n \n-![Deployment Overview](docs/dev/system-design/DeploymentOverview.svg \"Deployment Overview\")\n+While Artemis includes generic adapters to these three external systems with a defined protocol that can be instantiated to connect to any VCS, CIS or UMS, it also provides 3 concrete implementations for these adapters to connect to:\n \n+1. **VCS:** Atlassian Bitbucket Server\n+2. **CIS:** Atlassian Bamboo Server\n+3. **UMS:** Atlassian JIRA Server (more specifically Atlassian Crowd on the JIRA Server)\n \n-## Data Model\n+#### Server architecture", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDgzNzkyOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTozOToyM1rOHmZU8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTozOToyM1rOHmZU8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAyMjg5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n          \n          \n            \n                    * liquibase - contains the ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create a new changelog file you can check existing changelog files or read the documentation: https://www.liquibase.org/documentation/databasechangelog.html.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510022898", "createdAt": "2020-10-22T09:39:23Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDg3OTEyOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTo0OTowN1rOHmZt4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTo0OTowN1rOHmZt4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAyOTI4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n          \n          \n            \n                * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This can also be helpful when we want to provide specific exception handling logic.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510029283", "createdAt": "2020-10-22T09:49:07Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDkwMDc5OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTo1NDozOFrOHmZ7LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTo1NDozOFrOHmZ7LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzMjY4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n          \n          \n            \n                * repository - list of repositories that we use to access the database. There are several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510032685", "createdAt": "2020-10-22T09:54:38Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDkwMjU5OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTo1NTowNFrOHmZ8Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTo1NTowNFrOHmZ8Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzMjk5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * service - store Spring Boot services.\n          \n          \n            \n                * service - stores Spring Boot services.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510032991", "createdAt": "2020-10-22T09:55:04Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDkxMDU1OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTo1NzowMFrOHmaBVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTo1NzowMFrOHmaBVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzNDI2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n          \n          \n            \n            All variables, methods and classes should use CamelCase style. The only difference: the first letter of any class should be capital. Most importantly use intention-revealing, pronounceable names.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510034260", "createdAt": "2020-10-22T09:57:00Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDkyNjg3OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowMToyNlrOHmaLxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowMToyNlrOHmaLxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzNjkzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n          \n          \n            \n            One method should be responsible for only one action, it should do it well and do nothing else. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510036935", "createdAt": "2020-10-22T10:01:26Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDkyNzI5OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowMTozMlrOHmaMCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowMTozMlrOHmaMCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzNzAwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n          \n          \n            \n            There is no standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510037000", "createdAt": "2020-10-22T10:01:32Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDk0ODk3OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowNzo0MFrOHmaZdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowNzo0MFrOHmaZdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA0MDQzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n          \n          \n            \n            * Make variables and methods private by default and increase access step by step by changing them from private to protected first and not public right away.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510040438", "createdAt": "2020-10-22T10:07:40Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDk1MDE4OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowNzo1OFrOHmaaKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowNzo1OFrOHmaaKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA0MDYxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n          \n          \n            \n            * Classes, methods or functions should be Open for extension and Closed for modification (Open Closed Design Principle).", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510040618", "createdAt": "2020-10-22T10:07:58Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDk1NjU3OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowOTo0MFrOHmaeAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDowOTo0MFrOHmaeAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA0MTYwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * If variable is used only in one method then it would be better to declare it as a local variable of this method.\n          \n          \n            \n            * If a variable is used only in one method then it would be better to declare it as a local variable of this method.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510041600", "createdAt": "2020-10-22T10:09:40Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDk2MTg4OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDoxMDo1OFrOHmahLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDoxMDo1OFrOHmahLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA0MjQxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Write performant queries that can also deal with more 1000 objects in a reasonable time\n          \n          \n            \n            * Write performant queries that can also deal with more than 1000 objects in a reasonable time.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510042415", "createdAt": "2020-10-22T10:10:58Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDk3MjM3OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDoxMzoyOFrOHmanZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDoxMzoyOFrOHmanZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA0NDAwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n          \n          \n            \n            Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You don't have to put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510044004", "createdAt": "2020-10-22T10:13:28Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTE4NjQ4OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToxMzoyNFrOHmcqcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToxMzoyNFrOHmcqcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA3NzU1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Use plural for route's entities.\n          \n          \n            \n            * Use plural for a route's entities.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510077552", "createdAt": "2020-10-22T11:13:24Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTE5OTA3OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToxNzoxOVrOHmcyWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToxNzoxOVrOHmcyWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA3OTU3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.\n          \n          \n            \n            * Some of you may argue with this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510079577", "createdAt": "2020-10-22T11:17:19Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.\n+* Never trust user input and check if the passed data exists in the database.\n+* Always use different response status codes to notify the client about errors on the server:\n+    * Forbidden - the user is not authorized to access the controller.\n+    * Bad Request - the request was wrong.\n+    * Not Found - can't find the requested data or it should be not accessible yet.\n+\n+12. Dependency injection:\n+=========================\n+\n+* Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTIwNzI2OnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToxOTo0OFrOHmc3TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToxOTo0OFrOHmc3TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4MDg0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Optimization vs Readability, always write code that is simple to read and which will be understandable for developers. Because time and resources that will be spent on hard readable code will be much higher than what you get from optimization.\n          \n          \n            \n            * Optimization vs Readability, always write code that is simple to read and which will be understandable for developers. Because the time and resources spent on hard-to-read code cost much more than what we gain through optimization.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510080844", "createdAt": "2020-10-22T11:19:48Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:\n+==================================================\n+\n+* RestControllers should be stateless.\n+* RestControllers are by default singletons.\n+* RestControllers should not execute business logic but rely on delegation.\n+* RestControllers should deal with the HTTP layer of the application.\n+* RestControllers should be oriented around a use-case/business-capability.\n+\n+Route naming conventions:\n+\n+* Always use kebab-case (e.g. \"/exampleAssessment\" \u2192 \"/example-assessment\").\n+* The routes should follow the general structure entity > entityId > sub-entity ... (e.g. \"/exercises/{exerciseId}/participations\").\n+* Use plural for route's entities.\n+* Specify the key entity at the end of the route (e.g. \"text-editor/participations/{participationId}\" should be changed to \"participations/{participationId}/text-editor\").\n+* Never specify an id that is used only for consistency and not used in the code (e.g. GET \"/courses/{courseId}/exercises{exerciseId}/participations/{participationId}/submissions/{submissionId}\" can be simplified to GET \"/submissions/{submissionId}\" because all other entities than the submission are either not needed or can be loaded without the need to specify the id).\n+\n+Additional notes on the controller methods:\n+\n+* POST should return the newly created entity\n+* Always use @PreAuthorize tag to only allow certain roles to access the method.\n+* Never trust user input and check if the passed data exists in the database.\n+* Always use different response status codes to notify the client about errors on the server:\n+    * Forbidden - the user is not authorized to access the controller.\n+    * Bad Request - the request was wrong.\n+    * Not Found - can't find the requested data or it should be not accessible yet.\n+\n+12. Dependency injection:\n+=========================\n+\n+* Some of you may argue this, but by favoring constructor injection you can keep your business logic free from Spring. Not only is the @Autowired annotation optional on constructors, you also get the benefit of being able to easily instantiate your bean without Spring.\n+* Use setter based DI only for optional dependencies.\n+* Avoid circular dependencies, try constructor and setter based DI for such cases.\n+\n+13. REST best practices:\n+========================\n+\n+* Verify that API endpoints perform appropriate authorization and authentication consistent with the rest of the code base.\n+* Check for other common weaknesses, e.g., weak configuration, malicious user input, missing log events, etc.\n+* Handle exceptions and errors with a standard response. Errors are very important in REST APIs. They inform clients that something went wrong, after all.\n+\n+14. Keep it simple and stupid:\n+==============================\n+\n+* Don\u2019t write complex code.\n+* Don\u2019t write code when you are tired or in a bad mood.\n+* Optimization vs Readability, always write code that is simple to read and which will be understandable for developers. Because time and resources that will be spent on hard readable code will be much higher than what you get from optimization.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTIzNTkyOnYy", "diffSide": "RIGHT", "path": "docs/dev/guidelines/server.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToyODozMlrOHmdJmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToyODozMlrOHmdJmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4NTUzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            11. Keep your @RestController\u2019s clean and focused:\n          \n          \n            \n            11. Keep your ``@RestController``-s clean and focused:", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510085531", "createdAt": "2020-10-22T11:28:32Z", "author": {"login": "balazs-czopf"}, "path": "docs/dev/guidelines/server.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+*********************************************\n+Artemis server coding and design guidelines\n+*********************************************\n+\n+Folder structure\n+==================\n+\n+The main application is stored under ``/src/main`` and the main folders are:\n+\n+* resources - script, config files and templates are stored here.\n+    * config - different configurations (production, development, etc.) for application.\n+        * liquibase - contains ``master.xml`` file where all the changelogs from the changelog folder are specified. When you want to do some changes to the database, you will need to add a new changelog file here. To understand how to create new changelock file you can check existing changelog files or read documentation: https://www.liquibase.org/documentation/databasechangelog.html.\n+* java - Artemis Spring Boot application is located here. It contains the following folders:\n+    * config - different classes for configuring database, Sentry, Liquibase, etc.\n+    * domain - all the entities and data classes are located here.\n+    * exception - store custom types of exceptions here. We encourage to create custom exceptions to help other developers understand what problem exactly happened. This also can be helpful when we want to provide specific exception handling logic.\n+    * security - contains different POJOs (simple classes that don't implement/extend any interface/class and don't have annotations) and component classes related to security.\n+    * repository - list of repositories that are used to access the database. We use several techniques to query database: named queries, queries with SpEL expressions and Entity Graphs.\n+    * service - store Spring Boot services.\n+    * web - contains two folders:\n+        * rest - contains resources (REST controllers) represented by separate files.\n+        * websocket - contains files related to the Web Socket and you can use messagingTemplate to push data to the client from the server through them.\n+\n+1. Naming convention:\n+=====================\n+\n+All variables, methods and classes should use CamelCase style. The only difference: a first letter of class should be capital. Most importantly use intention-revealing, pronounceable names.\n+\n+2. Single responsibility principle:\n+===================================\n+\n+One method should be responsible only for one action, it should do it well and do it only. Reduce coupling, if our method does two or three different things at a time then we should consider splitting the functionality.\n+\n+3. Small methods:\n+=================\n+\n+There is not a standard pattern for method length among the developers. Someone can say 5, in some cases even 20 lines of code is okay. Just try to make methods as small as possible.\n+\n+4. Duplication:\n+===============\n+\n+Avoid code duplication. If we cannot reuse a method in other place then probably this method is bad and we should consider a better way to write this method. Use Abstraction to abstract common things in one place.\n+\n+5. Variables and methods declaration:\n+=================================\n+\n+* Encapsulate the code you feel might changed in future.\n+* Make variable and methods private by default and increasing access step by step like from a private to protected and not public.\n+* Classes, methods or functions should be Open for extension and Closed for modification(Open Closed Design Principle).\n+* Program for the interface and not for implementation, you should use interface type on variables, return types of a method or argument type of methods. Just like using SuperClass type to store object rather using SubClass.\n+* The use of interface is to facilitate polymorphism, client should not implement an interface method if its not needed.\n+\n+6. Structure your code correctly:\n+=================================\n+\n+* Default packages not allowed. It can cause particular problems for Spring Boot applications that use the ``@ComponentScan``, ``@EntityScan`` or ``@SpringBootApplication`` annotations since every class from every jar is read.\n+* All variables in the class should be declared at the top of the class.\n+* If variable is used only in one method then it would be better to declare it as a local variable of this method.\n+* Methods should be declared in the same order as they are used (from top to bottom).\n+* More important methods should be declared at the top of a class and minor methods at the end.\n+\n+7. Database:\n+============\n+\n+* Write performant queries that can also deal with more 1000 objects in a reasonable time\n+* Prefer one query that fetches additional data instead of many small queries, but don't overdo it. A good rule of thumb is to query not more than 3 associations at the same time.\n+* Think about lazy vs. eager fetching when modeling the data types\n+* Simple datatypes: immediately think about whether null should be supported as additional state or not. In most cases it is preferable to avoid null\n+* Use ``Timestamp`` instead of ``Datetime``\n+\n+8. Comments:\n+============\n+\n+Only if we are writing complicated algorithm and our comments will help other developers to better understand it. If we are adding a comment then our code is not self-explaining.\n+\n+9. Utility:\n+===========\n+\n+Utility methods can and should be placed in a class named for specific functionality, not \u201cmiscellaneous stuff related to project\u201d. Most of the time, our static methods belong on a related class.\n+\n+10. Auto configuration:\n+=======================\n+\n+Spring Boot favors Java-based configuration. Although it is possible to use Sprint Boot with XML sources but it\u2019s generally not recommended. You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes.\n+One of the flagship features of Spring Boot is its use of Auto-configuration. This is the part of Spring Boot that makes your code simply work. It gets activated when a particular jar file is detected on the classpath. The simplest way to make use of it is to rely on the Spring Boot Starters.\n+\n+11. Keep your @RestController\u2019s clean and focused:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTIzOTk0OnYy", "diffSide": "RIGHT", "path": "docs/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToyOTo0M1rOHmdMJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToyOTo0M1rOHmdMJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4NjE4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [Read the Docs] (RtD) hosts the [Artemis documentation] for `develop` (latest) branch, as well as for git tags. The latest tag is always the _stable_ version.\n          \n          \n            \n            [Read the Docs] (RtD) hosts the [Artemis documentation] for the `develop` (latest) branch, as well as for git tags. The latest tag is always the _stable_ version.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510086183", "createdAt": "2020-10-22T11:29:43Z", "author": {"login": "balazs-czopf"}, "path": "docs/README.md", "diffHunk": "@@ -1,12 +1,11 @@\n # Artemis Documentation\n \n-We use [Sphinx] for creating the Artemis documentation.\n-Documentation is written in [reStructuredText] (RST).\n+We use [Sphinx] for creating the Artemis documentation using [reStructuredText] (RST).\n To get started with RST, check out the [Quickstart] or this [cheatsheet].\n \n ## Documentation Hosting\n \n-The [Artemis documentation] is hosted on [Read the Docs] (RtD) for the `develop` (latest) branch, as well as for git tags. The latest tag is always linked as the as _stable_ version.\n+[Read the Docs] (RtD) hosts the [Artemis documentation] for `develop` (latest) branch, as well as for git tags. The latest tag is always the _stable_ version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTI2NDEwOnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTozNjo1OVrOHmdbOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTozNjo1OVrOHmdbOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MDA0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Find here a guide on [how to contribute](/CONTRIBUTING.md) to Artemis.\n          \n          \n            \n            Here you can find a guide on [how to contribute](/CONTRIBUTING.md) to Artemis.", "url": "https://github.com/ls1intum/Artemis/pull/2240#discussion_r510090043", "createdAt": "2020-10-22T11:36:59Z", "author": {"login": "balazs-czopf"}, "path": "README.md", "diffHunk": "@@ -11,45 +11,45 @@ Artemis was initially generated using JHipster 6.10.3. ([Documentation and help]\n \n [![Latest version)](https://img.shields.io/github/v/tag/ls1intum/Artemis?label=%20Latest%20version&sort=semver)](https://github.com/ls1intum/Artemis/releases/latest)\n \n-## Main features\n+### Main features\n Artemis supports the following exercises:\n 1. **[Programming exercises](docs/user/exercises/programming.rst)** with version control and automatic assessment with test cases and continuous integration\n 2. **[Quiz exercises](docs/user/exercises/quiz.rst)** with multiple choice, drag and drop and short answer quiz questions\n 3. **[Modeling exercises](docs/user/exercises/modeling.rst)** with semi-automatic assessment using machine learning concepts\n 4. **[Text exercises](docs/user/exercises/textual.rst)** with manual (and experimental semi-automatic) assessment\n 5. **[File upload exercises](docs/user/exercises/file-upload.rst)** with manual assessment\n \n-All these exercises are supposed to be run either live in the lecture with instant feedback or as homework. Students can submit their solutions multiple times within the due date and use the (semi-)automatically provided feedback to improve their solution.\n+Artemis supports all these exercises to run either live in the lecture with instant feedback or as homework. Students can submit their solutions multiple times within the due date and use the (semi-)automatically provided feedback to improve their solution.\n \n-## Development setup\n+Artemis also supports an exam mode now. You can find more information on [Exam mode student features](https://artemis.ase.in.tum.de/#/features/students) and on [Exam mode instructor features](https://artemis.ase.in.tum.de/#/features/instructors).\n \n-Find here a guide on [how to set up your local development environment](docs/dev/setup.rst).\n+### Setup, guides and contributing\n \n-## Server Setup for Programming Exercises\n+#### Development setup, coding and design guidelines\n \n-You can find the guide for setting up Artemis in conjunction with Jenkins and GitLab [here](docs/dev/setup/jenkins-gitlab.rst) and Bamboo/Bitbucket/Jira [here](docs/dev/setup/bamboo-bitbucket-jira.rst)\n+* [How to set up your local development environment](docs/dev/setup.rst)\n+* [Server coding and design guidelines](docs/dev/guidelines/server.rst)\n+* [Client coding and design guidelines](docs/dev/guidelines/client.rst)\n \n-## Administration setup\n+#### Documentation\n \n-You can find information on how to setup user registration [here](docs/admin/registration.rst)\n+[Read the Docs](https://readthedocs.org) hosts the [Artemis documentation](https://artemis-platform.readthedocs.io).\n+You can find a guide on [how to write documentation](docs/README.md).\n \n-## Contributing \n+#### Server setup\n \n-Find here a guide on [how to contribute](/CONTRIBUTING.md) to Artemis.\n-\n-## Top-Level Design\n+You can find the guide for setting up Artemis in conjunction with either `GitLab and Jenkins` [here](docs/dev/setup/jenkins-gitlab.rst) or with `Jira, Bitbucket and Bamboo` [here](docs/dev/setup/bamboo-bitbucket-jira.rst).\n+Artemis uses these external tools for user management and the configuration of programming exercises.\n \n-The following diagram shows the top-level design of Artemis which is decomposed into an application client (running as Angular web app in the browser) and an application server (based on Spring Boot). For programming exercises, the application server connects to a version control system (VCS) and a continuous integration system (CIS). Authentication is handled by an external user management system (UMS).\n+#### Administration setup\n \n-![Top-Level Design](docs/dev/system-design/TopLevelDesign.png \"Top-Level Design\")\n+You can find information on how to set up user registration [here](docs/admin/registration.rst)\n \n-While Artemis includes generic adapters to these three external systems with a defined protocol that can be instantiated to connect to any VCS, CIS or UMS, it also provides 3 concrete implementations for these adapters to connect to:\n+#### Contributing \n \n-1. **VCS:** Atlassian Bitbucket Server\n-2. **CIS:** Atlassian Bamboo Server\n-3. **UMS:** Atlassian JIRA Server (more specifically Atlassian Crowd on the JIRA Server)\n+Find here a guide on [how to contribute](/CONTRIBUTING.md) to Artemis.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd0fa09d1c19d4c2df6b3023d29d605edcf412e0"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4565, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}