{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0MDEzMjA3", "number": 1644, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOToxODozNVrOEGfA0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxOTowN1rOEIyB_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjM1MDI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOToxODozNVrOGlT_WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOToxODozNVrOGlT_WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3ODAwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Long id;\n          \n          \n            \n                private Long exerciseId;", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r441778008", "createdAt": "2020-06-17T19:18:35Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseCache.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package de.tum.in.www1.artemis.service.scheduled.quiz;\n+\n+import java.util.*;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;\n+\n+import de.tum.in.www1.artemis.domain.Result;\n+import de.tum.in.www1.artemis.domain.participation.StudentParticipation;\n+import de.tum.in.www1.artemis.domain.quiz.QuizExercise;\n+import de.tum.in.www1.artemis.domain.quiz.QuizSubmission;\n+\n+abstract class QuizExerciseCache {\n+\n+    private Long id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e8a2bdc1c340f757db046f9cfc447cd5be042c"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjM3MTY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizScheduleService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOToyNToxN1rOGlUMuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDowMDo0M1rOGlVUuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4MTQzMg==", "bodyText": "why is this coming so late now?", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r441781432", "createdAt": "2020-06-17T19:25:17Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizScheduleService.java", "diffHunk": "@@ -341,87 +464,101 @@ public void processCachedQuizSubmissions() {\n         log.debug(\"Process cached quiz submissions\");\n         // global try-catch for error logging\n         try {\n-            long start = System.nanoTime();\n-\n-            // create Participations and Results if the submission was submitted or if the quiz has ended and save them to Database (DB Write)\n-            for (long quizExerciseId : submissionHashMap.keySet()) {\n-\n-                QuizExercise quizExercise = quizExerciseService.findOneWithQuestions(quizExerciseId);\n+            for (QuizExerciseCache cachedQuiz : cachedQuizExercises.values()) {\n+                Long quizExerciseId = cachedQuiz.getId();\n+                // Get fresh QuizExercise from DB\n+                QuizExercise quizExercise = quizExerciseService.findOne(quizExerciseId);\n                 // check if quiz has been deleted\n                 if (quizExercise == null) {\n-                    submissionHashMap.remove(quizExerciseId);\n+                    log.debug(\"Remove quiz \" + quizExerciseId + \" from resultHashMap\");\n+                    cachedQuizExercises.remove(quizExerciseId);\n+                    cachedQuiz.destroy();\n                     continue;\n                 }\n \n-                // if quiz has ended, all submissions will be processed => we can remove the inner HashMap for this quiz\n-                // if quiz hasn't ended, some submissions (those that are not submitted) will stay in HashMap => keep inner HashMap\n-                Map<String, QuizSubmission> submissions;\n-                if (quizExercise.isEnded()) {\n-                    submissions = submissionHashMap.remove(quizExerciseId);\n-                }\n-                else {\n-                    submissions = submissionHashMap.get(quizExerciseId);\n+                // (Boolean wrapper is safe to auto-unbox here)\n+                boolean hasEnded = quizExercise.isEnded();\n+                // Note that those might not be true later on due to concurrency and a distributed system,\n+                // do not rely on that for actions upon the whole set, such as clear()\n+                boolean hasNewSubmissions = !cachedQuiz.getSubmissions().isEmpty();\n+                boolean hasNewParticipations = !cachedQuiz.getParticipations().isEmpty();\n+                boolean hasNewResults = !cachedQuiz.getResults().isEmpty();\n+\n+                // Skip quizzes with no cached changes\n+                if (!hasNewSubmissions && !hasNewParticipations && !hasNewResults) {\n+                    // Remove quiz if it is not scheduled for start\n+                    if (hasEnded && cachedQuiz.getQuizStart().isEmpty()) {\n+                        removeCachedQuiz(cachedQuiz);\n+                    }\n+                    continue;\n                 }\n \n-                int numberOfSubmittedSubmissions = saveQuizSubmissionWithParticipationAndResultToDatabase(quizExercise, submissions);\n+                // Update cached exercise object (use the expensive operation upfront)\n+                quizExercise = quizExerciseService.findOneWithQuestionsAndStatistics(quizExerciseId);\n+                cachedQuiz.setExercise(quizExercise);\n+                updateQuizExercise(quizExercise);\n \n-                if (numberOfSubmittedSubmissions > 0) {\n-                    log.info(\"Saved {} submissions to database in {} in quiz {}\", numberOfSubmittedSubmissions, printDuration(start), quizExercise.getTitle());\n-                }\n-            }\n+                // Save cached Submissions (this will also generate results and participations and place them in the cache)\n+                long start = System.nanoTime();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e8a2bdc1c340f757db046f9cfc447cd5be042c"}, "originalPosition": 531}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5OTg2Nw==", "bodyText": "I decided to move it there because it is first used as duration in Saved {} submissions to database in {} in quiz {}. I could also move it before Long quizExerciseId = cachedQuiz.getId(); at the beginning of the loop. It would then of course measure more than saving the submissions to DB.", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r441799867", "createdAt": "2020-06-17T20:00:43Z", "author": {"login": "MaisiKoleni"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizScheduleService.java", "diffHunk": "@@ -341,87 +464,101 @@ public void processCachedQuizSubmissions() {\n         log.debug(\"Process cached quiz submissions\");\n         // global try-catch for error logging\n         try {\n-            long start = System.nanoTime();\n-\n-            // create Participations and Results if the submission was submitted or if the quiz has ended and save them to Database (DB Write)\n-            for (long quizExerciseId : submissionHashMap.keySet()) {\n-\n-                QuizExercise quizExercise = quizExerciseService.findOneWithQuestions(quizExerciseId);\n+            for (QuizExerciseCache cachedQuiz : cachedQuizExercises.values()) {\n+                Long quizExerciseId = cachedQuiz.getId();\n+                // Get fresh QuizExercise from DB\n+                QuizExercise quizExercise = quizExerciseService.findOne(quizExerciseId);\n                 // check if quiz has been deleted\n                 if (quizExercise == null) {\n-                    submissionHashMap.remove(quizExerciseId);\n+                    log.debug(\"Remove quiz \" + quizExerciseId + \" from resultHashMap\");\n+                    cachedQuizExercises.remove(quizExerciseId);\n+                    cachedQuiz.destroy();\n                     continue;\n                 }\n \n-                // if quiz has ended, all submissions will be processed => we can remove the inner HashMap for this quiz\n-                // if quiz hasn't ended, some submissions (those that are not submitted) will stay in HashMap => keep inner HashMap\n-                Map<String, QuizSubmission> submissions;\n-                if (quizExercise.isEnded()) {\n-                    submissions = submissionHashMap.remove(quizExerciseId);\n-                }\n-                else {\n-                    submissions = submissionHashMap.get(quizExerciseId);\n+                // (Boolean wrapper is safe to auto-unbox here)\n+                boolean hasEnded = quizExercise.isEnded();\n+                // Note that those might not be true later on due to concurrency and a distributed system,\n+                // do not rely on that for actions upon the whole set, such as clear()\n+                boolean hasNewSubmissions = !cachedQuiz.getSubmissions().isEmpty();\n+                boolean hasNewParticipations = !cachedQuiz.getParticipations().isEmpty();\n+                boolean hasNewResults = !cachedQuiz.getResults().isEmpty();\n+\n+                // Skip quizzes with no cached changes\n+                if (!hasNewSubmissions && !hasNewParticipations && !hasNewResults) {\n+                    // Remove quiz if it is not scheduled for start\n+                    if (hasEnded && cachedQuiz.getQuizStart().isEmpty()) {\n+                        removeCachedQuiz(cachedQuiz);\n+                    }\n+                    continue;\n                 }\n \n-                int numberOfSubmittedSubmissions = saveQuizSubmissionWithParticipationAndResultToDatabase(quizExercise, submissions);\n+                // Update cached exercise object (use the expensive operation upfront)\n+                quizExercise = quizExerciseService.findOneWithQuestionsAndStatistics(quizExerciseId);\n+                cachedQuiz.setExercise(quizExercise);\n+                updateQuizExercise(quizExercise);\n \n-                if (numberOfSubmittedSubmissions > 0) {\n-                    log.info(\"Saved {} submissions to database in {} in quiz {}\", numberOfSubmittedSubmissions, printDuration(start), quizExercise.getTitle());\n-                }\n-            }\n+                // Save cached Submissions (this will also generate results and participations and place them in the cache)\n+                long start = System.nanoTime();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4MTQzMg=="}, "originalCommit": {"oid": "c3e8a2bdc1c340f757db046f9cfc447cd5be042c"}, "originalPosition": 531}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjM5MTAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseDistributedCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDowOTowNVrOGo8dsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDowOTowNVrOGo8dsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU4Njg2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                QuizExerciseDistributedCache(Long id, List<ScheduledTaskHandler> quizStart, QuizExercise exercise) {\n          \n          \n            \n                QuizExerciseDistributedCache(Long exerciseId, List<ScheduledTaskHandler> quizStart, QuizExercise exercise) {", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r445586865", "createdAt": "2020-06-25T14:09:05Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseDistributedCache.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package de.tum.in.www1.artemis.service.scheduled.quiz;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.SerializerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.internal.serialization.impl.SerializationServiceV1;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.StreamSerializer;\n+import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;\n+\n+import de.tum.in.www1.artemis.config.Constants;\n+import de.tum.in.www1.artemis.domain.Result;\n+import de.tum.in.www1.artemis.domain.participation.StudentParticipation;\n+import de.tum.in.www1.artemis.domain.quiz.QuizExercise;\n+import de.tum.in.www1.artemis.domain.quiz.QuizSubmission;\n+\n+final class QuizExerciseDistributedCache extends QuizExerciseCache implements HazelcastInstanceAware {\n+\n+    private static final Logger log = LoggerFactory.getLogger(QuizExerciseDistributedCache.class);\n+\n+    private static final String HAZELCAST_CACHE_PARTICIPATIONS = \"-participations\";\n+\n+    private static final String HAZELCAST_CACHE_SUBMISSIONS = \"-submissions\";\n+\n+    private static final String HAZELCAST_CACHE_RESULTS = \"-results\";\n+\n+    private static final Set<Class<?>> SUPPORTED_LIST_CLASSES = Set.of(ArrayList.class, LinkedList.class, CopyOnWriteArrayList.class);\n+\n+    /**\n+     * Make sure this is a class of SUPPORTED_LIST_CLASSES to make easy serialization possible, see {@link SerializationServiceV1}\n+     */\n+    List<ScheduledTaskHandler> quizStart;\n+\n+    private transient QuizExercise exercise;\n+\n+    private transient IMap<String, StudentParticipation> participations;\n+\n+    private transient IMap<String, QuizSubmission> submissions;\n+\n+    /**\n+     * Must be a Map because Hazelcast uses serialized objects for set operations and not hashCode()/equals()\n+     */\n+    private transient IMap<Long, Result> results;\n+\n+    QuizExerciseDistributedCache(Long id, List<ScheduledTaskHandler> quizStart, QuizExercise exercise) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e40eae6a5e9666d9e0ccbb518953521393abc2"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjQwMzg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseDistributedCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxMTo1OVrOGo8lwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxMTo1OVrOGo8lwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU4ODkyOQ==", "bodyText": "is automatically created if it does not exist yet", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r445588929", "createdAt": "2020-06-25T14:11:59Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseDistributedCache.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package de.tum.in.www1.artemis.service.scheduled.quiz;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.SerializerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.internal.serialization.impl.SerializationServiceV1;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.StreamSerializer;\n+import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;\n+\n+import de.tum.in.www1.artemis.config.Constants;\n+import de.tum.in.www1.artemis.domain.Result;\n+import de.tum.in.www1.artemis.domain.participation.StudentParticipation;\n+import de.tum.in.www1.artemis.domain.quiz.QuizExercise;\n+import de.tum.in.www1.artemis.domain.quiz.QuizSubmission;\n+\n+final class QuizExerciseDistributedCache extends QuizExerciseCache implements HazelcastInstanceAware {\n+\n+    private static final Logger log = LoggerFactory.getLogger(QuizExerciseDistributedCache.class);\n+\n+    private static final String HAZELCAST_CACHE_PARTICIPATIONS = \"-participations\";\n+\n+    private static final String HAZELCAST_CACHE_SUBMISSIONS = \"-submissions\";\n+\n+    private static final String HAZELCAST_CACHE_RESULTS = \"-results\";\n+\n+    private static final Set<Class<?>> SUPPORTED_LIST_CLASSES = Set.of(ArrayList.class, LinkedList.class, CopyOnWriteArrayList.class);\n+\n+    /**\n+     * Make sure this is a class of SUPPORTED_LIST_CLASSES to make easy serialization possible, see {@link SerializationServiceV1}\n+     */\n+    List<ScheduledTaskHandler> quizStart;\n+\n+    private transient QuizExercise exercise;\n+\n+    private transient IMap<String, StudentParticipation> participations;\n+\n+    private transient IMap<String, QuizSubmission> submissions;\n+\n+    /**\n+     * Must be a Map because Hazelcast uses serialized objects for set operations and not hashCode()/equals()\n+     */\n+    private transient IMap<Long, Result> results;\n+\n+    QuizExerciseDistributedCache(Long id, List<ScheduledTaskHandler> quizStart, QuizExercise exercise) {\n+        super(id);\n+        setQuizStart(quizStart);\n+        setExercise(exercise);\n+        log.debug(\"Creating new QuizExerciseDistributedCache, id {}\", getExerciseId());\n+    }\n+\n+    QuizExerciseDistributedCache(Long id, List<ScheduledTaskHandler> quizStart) {\n+        this(id, quizStart, null);\n+    }\n+\n+    QuizExerciseDistributedCache(Long id) {\n+        this(id, getEmptyQuizStartList());\n+    }\n+\n+    @Override\n+    QuizExercise getExercise() {\n+        return exercise;\n+    }\n+\n+    @Override\n+    Map<String, QuizSubmission> getSubmissions() {\n+        return submissions;\n+    }\n+\n+    @Override\n+    Map<String, StudentParticipation> getParticipations() {\n+        return participations;\n+    }\n+\n+    @Override\n+    List<ScheduledTaskHandler> getQuizStart() {\n+        return quizStart;\n+    }\n+\n+    @Override\n+    Map<Long, Result> getResults() {\n+        return results;\n+    }\n+\n+    @Override\n+    void setExercise(QuizExercise newExercise) {\n+        this.exercise = newExercise;\n+    }\n+\n+    @Override\n+    void setQuizStart(List<ScheduledTaskHandler> quizStart) {\n+        Objects.requireNonNull(quizStart);\n+        if (SUPPORTED_LIST_CLASSES.contains(quizStart.getClass())) {\n+            this.quizStart = quizStart;\n+        }\n+        else {\n+            this.quizStart = new ArrayList<>(quizStart);\n+        }\n+    }\n+\n+    @Override\n+    void clear() {\n+        int participationsSize = participations.size();\n+        int submissionsSize = submissions.size();\n+        int resultsSize = results.size();\n+        if (participationsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} participations cached\", getExerciseId(), participationsSize);\n+        if (submissionsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} submissions cached\", getExerciseId(), submissionsSize);\n+        if (resultsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} results cached\", getExerciseId(), resultsSize);\n+\n+        participations.destroy();\n+        submissions.destroy();\n+        results.destroy();\n+        exercise = null;\n+    }\n+\n+    @Override\n+    public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {\n+        participations = hazelcastInstance.getMap(Constants.HAZELCAST_QUIZ_PREFIX + getExerciseId() + HAZELCAST_CACHE_PARTICIPATIONS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e40eae6a5e9666d9e0ccbb518953521393abc2"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjQwNDkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseDistributedCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxMjoxN1rOGo8mfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxMjoxN1rOGo8mfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU4OTExOQ==", "bodyText": "rename", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r445589119", "createdAt": "2020-06-25T14:12:17Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseDistributedCache.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package de.tum.in.www1.artemis.service.scheduled.quiz;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.SerializerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.internal.serialization.impl.SerializationServiceV1;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.StreamSerializer;\n+import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;\n+\n+import de.tum.in.www1.artemis.config.Constants;\n+import de.tum.in.www1.artemis.domain.Result;\n+import de.tum.in.www1.artemis.domain.participation.StudentParticipation;\n+import de.tum.in.www1.artemis.domain.quiz.QuizExercise;\n+import de.tum.in.www1.artemis.domain.quiz.QuizSubmission;\n+\n+final class QuizExerciseDistributedCache extends QuizExerciseCache implements HazelcastInstanceAware {\n+\n+    private static final Logger log = LoggerFactory.getLogger(QuizExerciseDistributedCache.class);\n+\n+    private static final String HAZELCAST_CACHE_PARTICIPATIONS = \"-participations\";\n+\n+    private static final String HAZELCAST_CACHE_SUBMISSIONS = \"-submissions\";\n+\n+    private static final String HAZELCAST_CACHE_RESULTS = \"-results\";\n+\n+    private static final Set<Class<?>> SUPPORTED_LIST_CLASSES = Set.of(ArrayList.class, LinkedList.class, CopyOnWriteArrayList.class);\n+\n+    /**\n+     * Make sure this is a class of SUPPORTED_LIST_CLASSES to make easy serialization possible, see {@link SerializationServiceV1}\n+     */\n+    List<ScheduledTaskHandler> quizStart;\n+\n+    private transient QuizExercise exercise;\n+\n+    private transient IMap<String, StudentParticipation> participations;\n+\n+    private transient IMap<String, QuizSubmission> submissions;\n+\n+    /**\n+     * Must be a Map because Hazelcast uses serialized objects for set operations and not hashCode()/equals()\n+     */\n+    private transient IMap<Long, Result> results;\n+\n+    QuizExerciseDistributedCache(Long id, List<ScheduledTaskHandler> quizStart, QuizExercise exercise) {\n+        super(id);\n+        setQuizStart(quizStart);\n+        setExercise(exercise);\n+        log.debug(\"Creating new QuizExerciseDistributedCache, id {}\", getExerciseId());\n+    }\n+\n+    QuizExerciseDistributedCache(Long id, List<ScheduledTaskHandler> quizStart) {\n+        this(id, quizStart, null);\n+    }\n+\n+    QuizExerciseDistributedCache(Long id) {\n+        this(id, getEmptyQuizStartList());\n+    }\n+\n+    @Override\n+    QuizExercise getExercise() {\n+        return exercise;\n+    }\n+\n+    @Override\n+    Map<String, QuizSubmission> getSubmissions() {\n+        return submissions;\n+    }\n+\n+    @Override\n+    Map<String, StudentParticipation> getParticipations() {\n+        return participations;\n+    }\n+\n+    @Override\n+    List<ScheduledTaskHandler> getQuizStart() {\n+        return quizStart;\n+    }\n+\n+    @Override\n+    Map<Long, Result> getResults() {\n+        return results;\n+    }\n+\n+    @Override\n+    void setExercise(QuizExercise newExercise) {\n+        this.exercise = newExercise;\n+    }\n+\n+    @Override\n+    void setQuizStart(List<ScheduledTaskHandler> quizStart) {\n+        Objects.requireNonNull(quizStart);\n+        if (SUPPORTED_LIST_CLASSES.contains(quizStart.getClass())) {\n+            this.quizStart = quizStart;\n+        }\n+        else {\n+            this.quizStart = new ArrayList<>(quizStart);\n+        }\n+    }\n+\n+    @Override\n+    void clear() {\n+        int participationsSize = participations.size();\n+        int submissionsSize = submissions.size();\n+        int resultsSize = results.size();\n+        if (participationsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} participations cached\", getExerciseId(), participationsSize);\n+        if (submissionsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} submissions cached\", getExerciseId(), submissionsSize);\n+        if (resultsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} results cached\", getExerciseId(), resultsSize);\n+\n+        participations.destroy();\n+        submissions.destroy();\n+        results.destroy();\n+        exercise = null;\n+    }\n+\n+    @Override\n+    public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {\n+        participations = hazelcastInstance.getMap(Constants.HAZELCAST_QUIZ_PREFIX + getExerciseId() + HAZELCAST_CACHE_PARTICIPATIONS);\n+        submissions = hazelcastInstance.getMap(Constants.HAZELCAST_QUIZ_PREFIX + getExerciseId() + HAZELCAST_CACHE_SUBMISSIONS);\n+        results = hazelcastInstance.getMap(Constants.HAZELCAST_QUIZ_PREFIX + getExerciseId() + HAZELCAST_CACHE_RESULTS);\n+    }\n+\n+    static class QuizExerciseCacheImplStreamSerializer implements StreamSerializer<QuizExerciseDistributedCache> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e40eae6a5e9666d9e0ccbb518953521393abc2"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjQwNjI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseDistributedCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxMjozM1rOGo8nTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxMjozM1rOGo8nTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU4OTMyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Long id = in.readLong();\n          \n          \n            \n                        Long exerciseId = in.readLong();", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r445589324", "createdAt": "2020-06-25T14:12:33Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizExerciseDistributedCache.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package de.tum.in.www1.artemis.service.scheduled.quiz;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.SerializerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.internal.serialization.impl.SerializationServiceV1;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.StreamSerializer;\n+import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;\n+\n+import de.tum.in.www1.artemis.config.Constants;\n+import de.tum.in.www1.artemis.domain.Result;\n+import de.tum.in.www1.artemis.domain.participation.StudentParticipation;\n+import de.tum.in.www1.artemis.domain.quiz.QuizExercise;\n+import de.tum.in.www1.artemis.domain.quiz.QuizSubmission;\n+\n+final class QuizExerciseDistributedCache extends QuizExerciseCache implements HazelcastInstanceAware {\n+\n+    private static final Logger log = LoggerFactory.getLogger(QuizExerciseDistributedCache.class);\n+\n+    private static final String HAZELCAST_CACHE_PARTICIPATIONS = \"-participations\";\n+\n+    private static final String HAZELCAST_CACHE_SUBMISSIONS = \"-submissions\";\n+\n+    private static final String HAZELCAST_CACHE_RESULTS = \"-results\";\n+\n+    private static final Set<Class<?>> SUPPORTED_LIST_CLASSES = Set.of(ArrayList.class, LinkedList.class, CopyOnWriteArrayList.class);\n+\n+    /**\n+     * Make sure this is a class of SUPPORTED_LIST_CLASSES to make easy serialization possible, see {@link SerializationServiceV1}\n+     */\n+    List<ScheduledTaskHandler> quizStart;\n+\n+    private transient QuizExercise exercise;\n+\n+    private transient IMap<String, StudentParticipation> participations;\n+\n+    private transient IMap<String, QuizSubmission> submissions;\n+\n+    /**\n+     * Must be a Map because Hazelcast uses serialized objects for set operations and not hashCode()/equals()\n+     */\n+    private transient IMap<Long, Result> results;\n+\n+    QuizExerciseDistributedCache(Long id, List<ScheduledTaskHandler> quizStart, QuizExercise exercise) {\n+        super(id);\n+        setQuizStart(quizStart);\n+        setExercise(exercise);\n+        log.debug(\"Creating new QuizExerciseDistributedCache, id {}\", getExerciseId());\n+    }\n+\n+    QuizExerciseDistributedCache(Long id, List<ScheduledTaskHandler> quizStart) {\n+        this(id, quizStart, null);\n+    }\n+\n+    QuizExerciseDistributedCache(Long id) {\n+        this(id, getEmptyQuizStartList());\n+    }\n+\n+    @Override\n+    QuizExercise getExercise() {\n+        return exercise;\n+    }\n+\n+    @Override\n+    Map<String, QuizSubmission> getSubmissions() {\n+        return submissions;\n+    }\n+\n+    @Override\n+    Map<String, StudentParticipation> getParticipations() {\n+        return participations;\n+    }\n+\n+    @Override\n+    List<ScheduledTaskHandler> getQuizStart() {\n+        return quizStart;\n+    }\n+\n+    @Override\n+    Map<Long, Result> getResults() {\n+        return results;\n+    }\n+\n+    @Override\n+    void setExercise(QuizExercise newExercise) {\n+        this.exercise = newExercise;\n+    }\n+\n+    @Override\n+    void setQuizStart(List<ScheduledTaskHandler> quizStart) {\n+        Objects.requireNonNull(quizStart);\n+        if (SUPPORTED_LIST_CLASSES.contains(quizStart.getClass())) {\n+            this.quizStart = quizStart;\n+        }\n+        else {\n+            this.quizStart = new ArrayList<>(quizStart);\n+        }\n+    }\n+\n+    @Override\n+    void clear() {\n+        int participationsSize = participations.size();\n+        int submissionsSize = submissions.size();\n+        int resultsSize = results.size();\n+        if (participationsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} participations cached\", getExerciseId(), participationsSize);\n+        if (submissionsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} submissions cached\", getExerciseId(), submissionsSize);\n+        if (resultsSize > 0)\n+            log.warn(\"Cache for Quiz {} destroyed with {} results cached\", getExerciseId(), resultsSize);\n+\n+        participations.destroy();\n+        submissions.destroy();\n+        results.destroy();\n+        exercise = null;\n+    }\n+\n+    @Override\n+    public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {\n+        participations = hazelcastInstance.getMap(Constants.HAZELCAST_QUIZ_PREFIX + getExerciseId() + HAZELCAST_CACHE_PARTICIPATIONS);\n+        submissions = hazelcastInstance.getMap(Constants.HAZELCAST_QUIZ_PREFIX + getExerciseId() + HAZELCAST_CACHE_SUBMISSIONS);\n+        results = hazelcastInstance.getMap(Constants.HAZELCAST_QUIZ_PREFIX + getExerciseId() + HAZELCAST_CACHE_RESULTS);\n+    }\n+\n+    static class QuizExerciseCacheImplStreamSerializer implements StreamSerializer<QuizExerciseDistributedCache> {\n+\n+        @Override\n+        public int getTypeId() {\n+            return Constants.HAZELCAST_QUIZ_EXERCISE_CACHE_SERIALIZER_ID;\n+        }\n+\n+        @Override\n+        public void write(ObjectDataOutput out, QuizExerciseDistributedCache exerciseCacheImpl) throws IOException {\n+            out.writeLong(exerciseCacheImpl.getExerciseId());\n+            out.writeObject(exerciseCacheImpl.quizStart);\n+            out.writeObject(exerciseCacheImpl.exercise);\n+        }\n+\n+        @Override\n+        public QuizExerciseDistributedCache read(ObjectDataInput in) throws IOException {\n+            Long id = in.readLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e40eae6a5e9666d9e0ccbb518953521393abc2"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjQzNTA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizScheduleService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxODoyOVrOGo85JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxODoyOVrOGo85JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5Mzg5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (cachedQuiz != null)\n          \n          \n            \n                        return cachedQuiz;\n          \n          \n            \n                    if (cachedQuiz != null) {\n          \n          \n            \n                        return cachedQuiz;\n          \n          \n            \n                    }", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r445593893", "createdAt": "2020-06-25T14:18:29Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizScheduleService.java", "diffHunk": "@@ -0,0 +1,743 @@\n+package de.tum.in.www1.artemis.service.scheduled.quiz;\n+\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.Map.Entry;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.UnaryOperator;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.messaging.simp.SimpMessageSendingOperations;\n+import org.springframework.stereotype.Service;\n+\n+import com.hazelcast.config.*;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.cp.IAtomicReference;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.scheduledexecutor.*;\n+import com.hazelcast.topic.ITopic;\n+\n+import de.tum.in.www1.artemis.config.Constants;\n+import de.tum.in.www1.artemis.domain.Result;\n+import de.tum.in.www1.artemis.domain.SubmittedAnswer;\n+import de.tum.in.www1.artemis.domain.User;\n+import de.tum.in.www1.artemis.domain.enumeration.AssessmentType;\n+import de.tum.in.www1.artemis.domain.enumeration.InitializationState;\n+import de.tum.in.www1.artemis.domain.enumeration.SubmissionType;\n+import de.tum.in.www1.artemis.domain.participation.StudentParticipation;\n+import de.tum.in.www1.artemis.domain.quiz.QuizExercise;\n+import de.tum.in.www1.artemis.domain.quiz.QuizSubmission;\n+import de.tum.in.www1.artemis.repository.QuizSubmissionRepository;\n+import de.tum.in.www1.artemis.repository.ResultRepository;\n+import de.tum.in.www1.artemis.repository.StudentParticipationRepository;\n+import de.tum.in.www1.artemis.service.QuizExerciseService;\n+import de.tum.in.www1.artemis.service.QuizStatisticService;\n+import de.tum.in.www1.artemis.service.UserService;\n+\n+@Service\n+public class QuizScheduleService {\n+\n+    static final Logger log = LoggerFactory.getLogger(QuizScheduleService.class);\n+\n+    private static final String HAZELCAST_PROCESS_CACHE_HANDLER = QuizProcessCacheTask.HAZELCAST_PROCESS_CACHE_TASK + \"-handler\";\n+\n+    private static final String HAZELCAST_CACHED_EXERCISE_UPDATE_TOPIC = Constants.HAZELCAST_QUIZ_PREFIX + \"cached-exercise-invalidation\";\n+\n+    private IMap<Long, QuizExerciseCache> cachedQuizExercises;\n+\n+    private ITopic<QuizExercise> cachedQuizExerciseUpdates;\n+\n+    private volatile IScheduledExecutorService threadPoolTaskScheduler;\n+\n+    private IAtomicReference<ScheduledTaskHandler> scheduledProcessQuizSubmissions;\n+\n+    private final StudentParticipationRepository studentParticipationRepository;\n+\n+    private final ResultRepository resultRepository;\n+\n+    private final UserService userService;\n+\n+    private final QuizSubmissionRepository quizSubmissionRepository;\n+\n+    private QuizExerciseService quizExerciseService;\n+\n+    private QuizStatisticService quizStatisticService;\n+\n+    private SimpMessageSendingOperations messagingTemplate;\n+\n+    private HazelcastInstance hazelcastInstance;\n+\n+    public QuizScheduleService(SimpMessageSendingOperations messagingTemplate, StudentParticipationRepository studentParticipationRepository, ResultRepository resultRepository,\n+            UserService userService, QuizSubmissionRepository quizSubmissionRepository, HazelcastInstance hazelcastInstance) {\n+        this.messagingTemplate = messagingTemplate;\n+        this.studentParticipationRepository = studentParticipationRepository;\n+        this.resultRepository = resultRepository;\n+        this.userService = userService;\n+        this.quizSubmissionRepository = quizSubmissionRepository;\n+        this.hazelcastInstance = hazelcastInstance;\n+        this.scheduledProcessQuizSubmissions = hazelcastInstance.getCPSubsystem().getAtomicReference(HAZELCAST_PROCESS_CACHE_HANDLER);\n+        this.cachedQuizExercises = hazelcastInstance.getMap(Constants.HAZELCAST_EXERCISE_CACHE);\n+        this.threadPoolTaskScheduler = hazelcastInstance.getScheduledExecutorService(Constants.HAZELCAST_QUIZ_SCHEDULER);\n+        this.cachedQuizExerciseUpdates = hazelcastInstance.getTopic(HAZELCAST_CACHED_EXERCISE_UPDATE_TOPIC);\n+        this.cachedQuizExerciseUpdates.addMessageListener(newQuizExerciseMessage -> updateQuizExerciseLocally(newQuizExerciseMessage.getMessageObject()));\n+    }\n+\n+    /**\n+     * Configures Hazelcast for the QuizScheduleService before the HazelcastInstance is created.\n+     *\n+     * @param config the {@link Config} the QuizScheduleService-specific configuration should be added to\n+     */\n+    public static void configureHazelcast(Config config) {\n+        QuizExerciseCache.registerSerializers(config);\n+        // Pool size default 16, increased capacity (as we could have many quizzes) and default durability for now\n+        config.getScheduledExecutorConfig(Constants.HAZELCAST_QUIZ_SCHEDULER).setPoolSize(16).setCapacity(1000).setDurability(1);\n+        // Important to avoid continuous serialization and de-serialization and the implications on transient fields of QuizExerciseCache\n+        EvictionConfig evictionConfig = new EvictionConfig() //\n+                .setEvictionPolicy(EvictionPolicy.NONE);\n+        NearCacheConfig nearCacheConfig = new NearCacheConfig() //\n+                .setName(Constants.HAZELCAST_EXERCISE_CACHE + \"-local\") //\n+                .setInMemoryFormat(InMemoryFormat.OBJECT) //\n+                .setSerializeKeys(true) //\n+                .setInvalidateOnChange(true) //\n+                .setTimeToLiveSeconds(0) //\n+                .setMaxIdleSeconds(0) //\n+                .setEvictionConfig(evictionConfig) //\n+                .setCacheLocalEntries(true);\n+        config.getMapConfig(Constants.HAZELCAST_EXERCISE_CACHE).setNearCacheConfig(nearCacheConfig);\n+    }\n+\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void applicationReady() {\n+        // activate Quiz Schedule Service\n+        startSchedule(5 * 1000);                          // every 5 seconds\n+    }\n+\n+    @Autowired\n+    // break the dependency cycle\n+    public void setQuizExerciseService(QuizExerciseService quizExerciseService) {\n+        this.quizExerciseService = quizExerciseService;\n+    }\n+\n+    @Autowired\n+    // break the dependency cycle\n+    public void setQuizStatisticService(QuizStatisticService quizStatisticService) {\n+        this.quizStatisticService = quizStatisticService;\n+    }\n+\n+    /**\n+     * Only for reading from QuizExerciseCache\n+     *\n+     * @param quizExerciseId the id of the quiz exercise, must not be null\n+     */\n+    private QuizExerciseCache getReadCacheFor(Long quizExerciseId) {\n+        return cachedQuizExercises.getOrDefault(quizExerciseId, QuizExerciseCache.empty());\n+    }\n+\n+    /**\n+     * Only for the modification of transient properties, e.g. the exercise and the maps.\n+     * <p>\n+     * Creates new QuizExerciseCache if required.\n+     *\n+     * @param quizExerciseId the id of the quiz exercise, must not be null\n+     */\n+    private QuizExerciseCache getTransientWriteCacheFor(Long quizExerciseId) {\n+        var cachedQuiz = cachedQuizExercises.get(quizExerciseId);\n+        if (cachedQuiz != null)\n+            return cachedQuiz;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e40eae6a5e9666d9e0ccbb518953521393abc2"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjQzNzcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizScheduleService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxOTowN1rOGo863A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoxOTowN1rOGo863A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5NDMzMg==", "bodyText": "explain in java doc why we need to lock", "url": "https://github.com/ls1intum/Artemis/pull/1644#discussion_r445594332", "createdAt": "2020-06-25T14:19:07Z", "author": {"login": "krusche"}, "path": "src/main/java/de/tum/in/www1/artemis/service/scheduled/quiz/QuizScheduleService.java", "diffHunk": "@@ -0,0 +1,743 @@\n+package de.tum.in.www1.artemis.service.scheduled.quiz;\n+\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.Map.Entry;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.UnaryOperator;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.messaging.simp.SimpMessageSendingOperations;\n+import org.springframework.stereotype.Service;\n+\n+import com.hazelcast.config.*;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.cp.IAtomicReference;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.scheduledexecutor.*;\n+import com.hazelcast.topic.ITopic;\n+\n+import de.tum.in.www1.artemis.config.Constants;\n+import de.tum.in.www1.artemis.domain.Result;\n+import de.tum.in.www1.artemis.domain.SubmittedAnswer;\n+import de.tum.in.www1.artemis.domain.User;\n+import de.tum.in.www1.artemis.domain.enumeration.AssessmentType;\n+import de.tum.in.www1.artemis.domain.enumeration.InitializationState;\n+import de.tum.in.www1.artemis.domain.enumeration.SubmissionType;\n+import de.tum.in.www1.artemis.domain.participation.StudentParticipation;\n+import de.tum.in.www1.artemis.domain.quiz.QuizExercise;\n+import de.tum.in.www1.artemis.domain.quiz.QuizSubmission;\n+import de.tum.in.www1.artemis.repository.QuizSubmissionRepository;\n+import de.tum.in.www1.artemis.repository.ResultRepository;\n+import de.tum.in.www1.artemis.repository.StudentParticipationRepository;\n+import de.tum.in.www1.artemis.service.QuizExerciseService;\n+import de.tum.in.www1.artemis.service.QuizStatisticService;\n+import de.tum.in.www1.artemis.service.UserService;\n+\n+@Service\n+public class QuizScheduleService {\n+\n+    static final Logger log = LoggerFactory.getLogger(QuizScheduleService.class);\n+\n+    private static final String HAZELCAST_PROCESS_CACHE_HANDLER = QuizProcessCacheTask.HAZELCAST_PROCESS_CACHE_TASK + \"-handler\";\n+\n+    private static final String HAZELCAST_CACHED_EXERCISE_UPDATE_TOPIC = Constants.HAZELCAST_QUIZ_PREFIX + \"cached-exercise-invalidation\";\n+\n+    private IMap<Long, QuizExerciseCache> cachedQuizExercises;\n+\n+    private ITopic<QuizExercise> cachedQuizExerciseUpdates;\n+\n+    private volatile IScheduledExecutorService threadPoolTaskScheduler;\n+\n+    private IAtomicReference<ScheduledTaskHandler> scheduledProcessQuizSubmissions;\n+\n+    private final StudentParticipationRepository studentParticipationRepository;\n+\n+    private final ResultRepository resultRepository;\n+\n+    private final UserService userService;\n+\n+    private final QuizSubmissionRepository quizSubmissionRepository;\n+\n+    private QuizExerciseService quizExerciseService;\n+\n+    private QuizStatisticService quizStatisticService;\n+\n+    private SimpMessageSendingOperations messagingTemplate;\n+\n+    private HazelcastInstance hazelcastInstance;\n+\n+    public QuizScheduleService(SimpMessageSendingOperations messagingTemplate, StudentParticipationRepository studentParticipationRepository, ResultRepository resultRepository,\n+            UserService userService, QuizSubmissionRepository quizSubmissionRepository, HazelcastInstance hazelcastInstance) {\n+        this.messagingTemplate = messagingTemplate;\n+        this.studentParticipationRepository = studentParticipationRepository;\n+        this.resultRepository = resultRepository;\n+        this.userService = userService;\n+        this.quizSubmissionRepository = quizSubmissionRepository;\n+        this.hazelcastInstance = hazelcastInstance;\n+        this.scheduledProcessQuizSubmissions = hazelcastInstance.getCPSubsystem().getAtomicReference(HAZELCAST_PROCESS_CACHE_HANDLER);\n+        this.cachedQuizExercises = hazelcastInstance.getMap(Constants.HAZELCAST_EXERCISE_CACHE);\n+        this.threadPoolTaskScheduler = hazelcastInstance.getScheduledExecutorService(Constants.HAZELCAST_QUIZ_SCHEDULER);\n+        this.cachedQuizExerciseUpdates = hazelcastInstance.getTopic(HAZELCAST_CACHED_EXERCISE_UPDATE_TOPIC);\n+        this.cachedQuizExerciseUpdates.addMessageListener(newQuizExerciseMessage -> updateQuizExerciseLocally(newQuizExerciseMessage.getMessageObject()));\n+    }\n+\n+    /**\n+     * Configures Hazelcast for the QuizScheduleService before the HazelcastInstance is created.\n+     *\n+     * @param config the {@link Config} the QuizScheduleService-specific configuration should be added to\n+     */\n+    public static void configureHazelcast(Config config) {\n+        QuizExerciseCache.registerSerializers(config);\n+        // Pool size default 16, increased capacity (as we could have many quizzes) and default durability for now\n+        config.getScheduledExecutorConfig(Constants.HAZELCAST_QUIZ_SCHEDULER).setPoolSize(16).setCapacity(1000).setDurability(1);\n+        // Important to avoid continuous serialization and de-serialization and the implications on transient fields of QuizExerciseCache\n+        EvictionConfig evictionConfig = new EvictionConfig() //\n+                .setEvictionPolicy(EvictionPolicy.NONE);\n+        NearCacheConfig nearCacheConfig = new NearCacheConfig() //\n+                .setName(Constants.HAZELCAST_EXERCISE_CACHE + \"-local\") //\n+                .setInMemoryFormat(InMemoryFormat.OBJECT) //\n+                .setSerializeKeys(true) //\n+                .setInvalidateOnChange(true) //\n+                .setTimeToLiveSeconds(0) //\n+                .setMaxIdleSeconds(0) //\n+                .setEvictionConfig(evictionConfig) //\n+                .setCacheLocalEntries(true);\n+        config.getMapConfig(Constants.HAZELCAST_EXERCISE_CACHE).setNearCacheConfig(nearCacheConfig);\n+    }\n+\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void applicationReady() {\n+        // activate Quiz Schedule Service\n+        startSchedule(5 * 1000);                          // every 5 seconds\n+    }\n+\n+    @Autowired\n+    // break the dependency cycle\n+    public void setQuizExerciseService(QuizExerciseService quizExerciseService) {\n+        this.quizExerciseService = quizExerciseService;\n+    }\n+\n+    @Autowired\n+    // break the dependency cycle\n+    public void setQuizStatisticService(QuizStatisticService quizStatisticService) {\n+        this.quizStatisticService = quizStatisticService;\n+    }\n+\n+    /**\n+     * Only for reading from QuizExerciseCache\n+     *\n+     * @param quizExerciseId the id of the quiz exercise, must not be null\n+     */\n+    private QuizExerciseCache getReadCacheFor(Long quizExerciseId) {\n+        return cachedQuizExercises.getOrDefault(quizExerciseId, QuizExerciseCache.empty());\n+    }\n+\n+    /**\n+     * Only for the modification of transient properties, e.g. the exercise and the maps.\n+     * <p>\n+     * Creates new QuizExerciseCache if required.\n+     *\n+     * @param quizExerciseId the id of the quiz exercise, must not be null\n+     */\n+    private QuizExerciseCache getTransientWriteCacheFor(Long quizExerciseId) {\n+        var cachedQuiz = cachedQuizExercises.get(quizExerciseId);\n+        if (cachedQuiz != null)\n+            return cachedQuiz;\n+        cachedQuizExercises.lock(quizExerciseId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e40eae6a5e9666d9e0ccbb518953521393abc2"}, "originalPosition": 154}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 71, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}