{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MzE3ODI4", "number": 1665, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MDoyNlrOEGfb2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDoxNzoxMFrOEG5i6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQxOTQ0OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/exam/participate/exercises/quiz/quiz-exam-participation.component.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MDoyNlrOGlUrQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNzozMzoxNFrOGljEWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTI0OQ==", "bodyText": "I think we should rename this method as the participation is probably not coming from the server directly", "url": "https://github.com/ls1intum/Artemis/pull/1665#discussion_r441789249", "createdAt": "2020-06-17T19:40:26Z", "author": {"login": "krusche"}, "path": "src/main/webapp/app/exam/participate/exercises/quiz/quiz-exam-participation.component.ts", "diffHunk": "@@ -0,0 +1,235 @@\n+import { Component, OnInit, QueryList, ViewChildren, Input } from '@angular/core';\n+import { ParticipationService } from 'app/exercises/shared/participation/participation.service';\n+import { QuizQuestionType } from 'app/entities/quiz/quiz-question.model';\n+import { MultipleChoiceQuestionComponent } from 'app/exercises/quiz/shared/questions/multiple-choice-question/multiple-choice-question.component';\n+import { DragAndDropQuestionComponent } from 'app/exercises/quiz/shared/questions/drag-and-drop-question/drag-and-drop-question.component';\n+import { ShortAnswerQuestionComponent } from 'app/exercises/quiz/shared/questions/short-answer-question/short-answer-question.component';\n+import { ButtonSize, ButtonType } from 'app/shared/components/button.component';\n+import { QuizExercise } from 'app/entities/quiz/quiz-exercise.model';\n+import * as smoothscroll from 'smoothscroll-polyfill';\n+import { AnswerOption } from 'app/entities/quiz/answer-option.model';\n+import { DragAndDropMapping } from 'app/entities/quiz/drag-and-drop-mapping.model';\n+import { ShortAnswerSubmittedText } from 'app/entities/quiz/short-answer-submitted-text.model';\n+import { MultipleChoiceSubmittedAnswer } from 'app/entities/quiz/multiple-choice-submitted-answer.model';\n+import { DragAndDropSubmittedAnswer } from 'app/entities/quiz/drag-and-drop-submitted-answer.model';\n+import { ShortAnswerSubmittedAnswer } from 'app/entities/quiz/short-answer-submitted-answer.model';\n+import { QuizSubmission } from 'app/entities/quiz/quiz-submission.model';\n+import { StudentParticipation } from 'app/entities/participation/student-participation.model';\n+\n+@Component({\n+    selector: 'jhi-exam-quiz',\n+    templateUrl: './quiz-exam-participation.component.html',\n+    providers: [ParticipationService],\n+    styleUrls: ['../../../../exercises/quiz/participate/quiz-participation.component.scss'],\n+})\n+export class QuizExamParticipationComponent implements OnInit {\n+    // make constants available to html for comparison\n+    readonly DRAG_AND_DROP = QuizQuestionType.DRAG_AND_DROP;\n+    readonly MULTIPLE_CHOICE = QuizQuestionType.MULTIPLE_CHOICE;\n+    readonly SHORT_ANSWER = QuizQuestionType.SHORT_ANSWER;\n+    readonly ButtonSize = ButtonSize;\n+    readonly ButtonType = ButtonType;\n+\n+    @ViewChildren(MultipleChoiceQuestionComponent)\n+    mcQuestionComponents: QueryList<MultipleChoiceQuestionComponent>;\n+\n+    @ViewChildren(DragAndDropQuestionComponent)\n+    dndQuestionComponents: QueryList<DragAndDropQuestionComponent>;\n+\n+    @ViewChildren(ShortAnswerQuestionComponent)\n+    shortAnswerQuestionComponents: QueryList<ShortAnswerQuestionComponent>;\n+\n+    @Input() studentParticipation: StudentParticipation;\n+\n+    quizExercise: QuizExercise;\n+    selectedAnswerOptions = new Map<number, AnswerOption[]>();\n+    dragAndDropMappings = new Map<number, DragAndDropMapping[]>();\n+    shortAnswerSubmittedTexts = new Map<number, ShortAnswerSubmittedText[]>();\n+    submission = new QuizSubmission();\n+\n+    constructor() {\n+        smoothscroll.polyfill();\n+    }\n+\n+    ngOnInit(): void {\n+        this.quizExercise = this.studentParticipation.exercise as QuizExercise;\n+        this.updateParticipationFromServer(this.studentParticipation);\n+    }\n+\n+    /**\n+     * Initialize the selections / mappings for each question with an empty array\n+     */\n+    initQuiz() {\n+        // prepare selection arrays for each question\n+        this.selectedAnswerOptions = new Map<number, AnswerOption[]>();\n+        this.dragAndDropMappings = new Map<number, DragAndDropMapping[]>();\n+        this.shortAnswerSubmittedTexts = new Map<number, ShortAnswerSubmittedText[]>();\n+\n+        if (this.quizExercise.quizQuestions) {\n+            this.quizExercise.quizQuestions.forEach((question) => {\n+                if (question.type === QuizQuestionType.MULTIPLE_CHOICE) {\n+                    // add the array of selected options to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    this.selectedAnswerOptions[question.id] = [];\n+                } else if (question.type === QuizQuestionType.DRAG_AND_DROP) {\n+                    // add the array of mappings to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    this.dragAndDropMappings[question.id] = [];\n+                } else if (question.type === QuizQuestionType.SHORT_ANSWER) {\n+                    // add the array of submitted texts to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    this.shortAnswerSubmittedTexts[question.id] = [];\n+                } else {\n+                    console.error('Unknown question type: ' + question);\n+                }\n+            }, this);\n+        }\n+    }\n+\n+    /**\n+     * By clicking on the bubble of the progress navigation towards the corresponding question of the quiz is triggered\n+     * @param questionIndex\n+     */\n+    navigateToQuestion(questionIndex: number): void {\n+        document.getElementById('question' + questionIndex)!.scrollIntoView({\n+            behavior: 'smooth',\n+        });\n+    }\n+\n+    onSelectionChanged() {\n+        this.applySelection();\n+    }\n+\n+    /**\n+     * applies the data from the model to the UI (reverse of applySelection):\n+     *\n+     * Sets the checkmarks (selected answers) for all questions according to the submission data\n+     * this needs to be done when we get new submission data, e.g. through the websocket connection\n+     */\n+    applySubmission() {\n+        // create dictionaries (key: questionID, value: Array of selected answerOptions / mappings)\n+        // for the submittedAnswers to hand the selected options / mappings in individual arrays to the question components\n+        this.selectedAnswerOptions = new Map<number, AnswerOption[]>();\n+        this.dragAndDropMappings = new Map<number, DragAndDropMapping[]>();\n+        this.shortAnswerSubmittedTexts = new Map<number, ShortAnswerSubmittedText[]>();\n+\n+        if (this.quizExercise.quizQuestions) {\n+            // iterate through all questions of this quiz\n+            this.quizExercise.quizQuestions.forEach((question) => {\n+                // find the submitted answer that belongs to this question, only when submitted answers already exist\n+                const submittedAnswer = this.submission.submittedAnswers\n+                    ? this.submission.submittedAnswers.find((answer) => {\n+                          return answer.quizQuestion.id === question.id;\n+                      })\n+                    : null;\n+\n+                if (question.type === QuizQuestionType.MULTIPLE_CHOICE) {\n+                    // add the array of selected options to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    if (submittedAnswer) {\n+                        const selectedOptions = (submittedAnswer as MultipleChoiceSubmittedAnswer).selectedOptions;\n+                        this.selectedAnswerOptions[question.id] = selectedOptions ? selectedOptions : [];\n+                    } else {\n+                        // not found, set to empty array\n+                        this.selectedAnswerOptions[question.id] = [];\n+                    }\n+                } else if (question.type === QuizQuestionType.DRAG_AND_DROP) {\n+                    // add the array of mappings to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    if (submittedAnswer) {\n+                        const mappings = (submittedAnswer as DragAndDropSubmittedAnswer).mappings;\n+                        this.dragAndDropMappings[question.id] = mappings ? mappings : [];\n+                    } else {\n+                        // not found, set to empty array\n+                        this.dragAndDropMappings[question.id] = [];\n+                    }\n+                } else if (question.type === QuizQuestionType.SHORT_ANSWER) {\n+                    // add the array of submitted texts to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    if (submittedAnswer) {\n+                        const submittedTexts = (submittedAnswer as ShortAnswerSubmittedAnswer).submittedTexts;\n+                        this.shortAnswerSubmittedTexts[question.id] = submittedTexts ? submittedTexts : [];\n+                    } else {\n+                        // not found, set to empty array\n+                        this.shortAnswerSubmittedTexts[question.id] = [];\n+                    }\n+                } else {\n+                    console.error('Unknown question type: ' + question);\n+                }\n+            }, this);\n+        }\n+    }\n+\n+    /**\n+     * updates the model according to UI state (reverse of applySubmission):\n+     *\n+     * Creates the submission from the user's selection\n+     * this needs to be done when we want to send the submission\n+     * either for saving (through websocket)\n+     * or for submitting (through REST call)\n+     */\n+    applySelection() {\n+        // convert the selection dictionary (key: questionID, value: Array of selected answerOptions / mappings)\n+        // into an array of submittedAnswer objects and save it as the submittedAnswers of the submission\n+        this.submission.submittedAnswers = [];\n+\n+        // for multiple-choice questions\n+        Object.keys(this.selectedAnswerOptions).forEach((questionID) => {\n+            // find the question object for the given question id\n+            const question = this.quizExercise.quizQuestions.find(function (selectedQuestion) {\n+                return selectedQuestion.id === Number(questionID);\n+            });\n+            if (!question) {\n+                console.error('question not found for ID: ' + questionID);\n+                return;\n+            }\n+            // generate the submittedAnswer object\n+            const mcSubmittedAnswer = new MultipleChoiceSubmittedAnswer();\n+            mcSubmittedAnswer.quizQuestion = question;\n+            mcSubmittedAnswer.selectedOptions = this.selectedAnswerOptions[questionID];\n+            this.submission.submittedAnswers.push(mcSubmittedAnswer);\n+        }, this);\n+\n+        // for drag-and-drop questions\n+        Object.keys(this.dragAndDropMappings).forEach((questionID) => {\n+            // find the question object for the given question id\n+            const question = this.quizExercise.quizQuestions.find(function (localQuestion) {\n+                return localQuestion.id === Number(questionID);\n+            });\n+            if (!question) {\n+                console.error('question not found for ID: ' + questionID);\n+                return;\n+            }\n+            // generate the submittedAnswer object\n+            const dndSubmittedAnswer = new DragAndDropSubmittedAnswer();\n+            dndSubmittedAnswer.quizQuestion = question;\n+            dndSubmittedAnswer.mappings = this.dragAndDropMappings[questionID];\n+            this.submission.submittedAnswers.push(dndSubmittedAnswer);\n+        }, this);\n+        // for short-answer questions\n+        Object.keys(this.shortAnswerSubmittedTexts).forEach((questionID) => {\n+            // find the question object for the given question id\n+            const question = this.quizExercise.quizQuestions.find(function (localQuestion) {\n+                return localQuestion.id === Number(questionID);\n+            });\n+            if (!question) {\n+                console.error('question not found for ID: ' + questionID);\n+                return;\n+            }\n+            // generate the submittedAnswer object\n+            const shortAnswerSubmittedAnswer = new ShortAnswerSubmittedAnswer();\n+            shortAnswerSubmittedAnswer.quizQuestion = question;\n+            shortAnswerSubmittedAnswer.submittedTexts = this.shortAnswerSubmittedTexts[questionID];\n+            this.submission.submittedAnswers.push(shortAnswerSubmittedAnswer);\n+        }, this);\n+    }\n+\n+    /**\n+     * Apply the data of the participation, replacing all old data\n+     */\n+    updateParticipationFromServer(participation: StudentParticipation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "128dbc251f420f944cf141c98045cafe3fc232f1"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAyNTA1MQ==", "bodyText": "I renamed the method now to only updateParticipation", "url": "https://github.com/ls1intum/Artemis/pull/1665#discussion_r442025051", "createdAt": "2020-06-18T07:33:14Z", "author": {"login": "filip-gregurevic"}, "path": "src/main/webapp/app/exam/participate/exercises/quiz/quiz-exam-participation.component.ts", "diffHunk": "@@ -0,0 +1,235 @@\n+import { Component, OnInit, QueryList, ViewChildren, Input } from '@angular/core';\n+import { ParticipationService } from 'app/exercises/shared/participation/participation.service';\n+import { QuizQuestionType } from 'app/entities/quiz/quiz-question.model';\n+import { MultipleChoiceQuestionComponent } from 'app/exercises/quiz/shared/questions/multiple-choice-question/multiple-choice-question.component';\n+import { DragAndDropQuestionComponent } from 'app/exercises/quiz/shared/questions/drag-and-drop-question/drag-and-drop-question.component';\n+import { ShortAnswerQuestionComponent } from 'app/exercises/quiz/shared/questions/short-answer-question/short-answer-question.component';\n+import { ButtonSize, ButtonType } from 'app/shared/components/button.component';\n+import { QuizExercise } from 'app/entities/quiz/quiz-exercise.model';\n+import * as smoothscroll from 'smoothscroll-polyfill';\n+import { AnswerOption } from 'app/entities/quiz/answer-option.model';\n+import { DragAndDropMapping } from 'app/entities/quiz/drag-and-drop-mapping.model';\n+import { ShortAnswerSubmittedText } from 'app/entities/quiz/short-answer-submitted-text.model';\n+import { MultipleChoiceSubmittedAnswer } from 'app/entities/quiz/multiple-choice-submitted-answer.model';\n+import { DragAndDropSubmittedAnswer } from 'app/entities/quiz/drag-and-drop-submitted-answer.model';\n+import { ShortAnswerSubmittedAnswer } from 'app/entities/quiz/short-answer-submitted-answer.model';\n+import { QuizSubmission } from 'app/entities/quiz/quiz-submission.model';\n+import { StudentParticipation } from 'app/entities/participation/student-participation.model';\n+\n+@Component({\n+    selector: 'jhi-exam-quiz',\n+    templateUrl: './quiz-exam-participation.component.html',\n+    providers: [ParticipationService],\n+    styleUrls: ['../../../../exercises/quiz/participate/quiz-participation.component.scss'],\n+})\n+export class QuizExamParticipationComponent implements OnInit {\n+    // make constants available to html for comparison\n+    readonly DRAG_AND_DROP = QuizQuestionType.DRAG_AND_DROP;\n+    readonly MULTIPLE_CHOICE = QuizQuestionType.MULTIPLE_CHOICE;\n+    readonly SHORT_ANSWER = QuizQuestionType.SHORT_ANSWER;\n+    readonly ButtonSize = ButtonSize;\n+    readonly ButtonType = ButtonType;\n+\n+    @ViewChildren(MultipleChoiceQuestionComponent)\n+    mcQuestionComponents: QueryList<MultipleChoiceQuestionComponent>;\n+\n+    @ViewChildren(DragAndDropQuestionComponent)\n+    dndQuestionComponents: QueryList<DragAndDropQuestionComponent>;\n+\n+    @ViewChildren(ShortAnswerQuestionComponent)\n+    shortAnswerQuestionComponents: QueryList<ShortAnswerQuestionComponent>;\n+\n+    @Input() studentParticipation: StudentParticipation;\n+\n+    quizExercise: QuizExercise;\n+    selectedAnswerOptions = new Map<number, AnswerOption[]>();\n+    dragAndDropMappings = new Map<number, DragAndDropMapping[]>();\n+    shortAnswerSubmittedTexts = new Map<number, ShortAnswerSubmittedText[]>();\n+    submission = new QuizSubmission();\n+\n+    constructor() {\n+        smoothscroll.polyfill();\n+    }\n+\n+    ngOnInit(): void {\n+        this.quizExercise = this.studentParticipation.exercise as QuizExercise;\n+        this.updateParticipationFromServer(this.studentParticipation);\n+    }\n+\n+    /**\n+     * Initialize the selections / mappings for each question with an empty array\n+     */\n+    initQuiz() {\n+        // prepare selection arrays for each question\n+        this.selectedAnswerOptions = new Map<number, AnswerOption[]>();\n+        this.dragAndDropMappings = new Map<number, DragAndDropMapping[]>();\n+        this.shortAnswerSubmittedTexts = new Map<number, ShortAnswerSubmittedText[]>();\n+\n+        if (this.quizExercise.quizQuestions) {\n+            this.quizExercise.quizQuestions.forEach((question) => {\n+                if (question.type === QuizQuestionType.MULTIPLE_CHOICE) {\n+                    // add the array of selected options to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    this.selectedAnswerOptions[question.id] = [];\n+                } else if (question.type === QuizQuestionType.DRAG_AND_DROP) {\n+                    // add the array of mappings to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    this.dragAndDropMappings[question.id] = [];\n+                } else if (question.type === QuizQuestionType.SHORT_ANSWER) {\n+                    // add the array of submitted texts to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    this.shortAnswerSubmittedTexts[question.id] = [];\n+                } else {\n+                    console.error('Unknown question type: ' + question);\n+                }\n+            }, this);\n+        }\n+    }\n+\n+    /**\n+     * By clicking on the bubble of the progress navigation towards the corresponding question of the quiz is triggered\n+     * @param questionIndex\n+     */\n+    navigateToQuestion(questionIndex: number): void {\n+        document.getElementById('question' + questionIndex)!.scrollIntoView({\n+            behavior: 'smooth',\n+        });\n+    }\n+\n+    onSelectionChanged() {\n+        this.applySelection();\n+    }\n+\n+    /**\n+     * applies the data from the model to the UI (reverse of applySelection):\n+     *\n+     * Sets the checkmarks (selected answers) for all questions according to the submission data\n+     * this needs to be done when we get new submission data, e.g. through the websocket connection\n+     */\n+    applySubmission() {\n+        // create dictionaries (key: questionID, value: Array of selected answerOptions / mappings)\n+        // for the submittedAnswers to hand the selected options / mappings in individual arrays to the question components\n+        this.selectedAnswerOptions = new Map<number, AnswerOption[]>();\n+        this.dragAndDropMappings = new Map<number, DragAndDropMapping[]>();\n+        this.shortAnswerSubmittedTexts = new Map<number, ShortAnswerSubmittedText[]>();\n+\n+        if (this.quizExercise.quizQuestions) {\n+            // iterate through all questions of this quiz\n+            this.quizExercise.quizQuestions.forEach((question) => {\n+                // find the submitted answer that belongs to this question, only when submitted answers already exist\n+                const submittedAnswer = this.submission.submittedAnswers\n+                    ? this.submission.submittedAnswers.find((answer) => {\n+                          return answer.quizQuestion.id === question.id;\n+                      })\n+                    : null;\n+\n+                if (question.type === QuizQuestionType.MULTIPLE_CHOICE) {\n+                    // add the array of selected options to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    if (submittedAnswer) {\n+                        const selectedOptions = (submittedAnswer as MultipleChoiceSubmittedAnswer).selectedOptions;\n+                        this.selectedAnswerOptions[question.id] = selectedOptions ? selectedOptions : [];\n+                    } else {\n+                        // not found, set to empty array\n+                        this.selectedAnswerOptions[question.id] = [];\n+                    }\n+                } else if (question.type === QuizQuestionType.DRAG_AND_DROP) {\n+                    // add the array of mappings to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    if (submittedAnswer) {\n+                        const mappings = (submittedAnswer as DragAndDropSubmittedAnswer).mappings;\n+                        this.dragAndDropMappings[question.id] = mappings ? mappings : [];\n+                    } else {\n+                        // not found, set to empty array\n+                        this.dragAndDropMappings[question.id] = [];\n+                    }\n+                } else if (question.type === QuizQuestionType.SHORT_ANSWER) {\n+                    // add the array of submitted texts to the dictionary (add an empty array, if there is no submittedAnswer for this question)\n+                    if (submittedAnswer) {\n+                        const submittedTexts = (submittedAnswer as ShortAnswerSubmittedAnswer).submittedTexts;\n+                        this.shortAnswerSubmittedTexts[question.id] = submittedTexts ? submittedTexts : [];\n+                    } else {\n+                        // not found, set to empty array\n+                        this.shortAnswerSubmittedTexts[question.id] = [];\n+                    }\n+                } else {\n+                    console.error('Unknown question type: ' + question);\n+                }\n+            }, this);\n+        }\n+    }\n+\n+    /**\n+     * updates the model according to UI state (reverse of applySubmission):\n+     *\n+     * Creates the submission from the user's selection\n+     * this needs to be done when we want to send the submission\n+     * either for saving (through websocket)\n+     * or for submitting (through REST call)\n+     */\n+    applySelection() {\n+        // convert the selection dictionary (key: questionID, value: Array of selected answerOptions / mappings)\n+        // into an array of submittedAnswer objects and save it as the submittedAnswers of the submission\n+        this.submission.submittedAnswers = [];\n+\n+        // for multiple-choice questions\n+        Object.keys(this.selectedAnswerOptions).forEach((questionID) => {\n+            // find the question object for the given question id\n+            const question = this.quizExercise.quizQuestions.find(function (selectedQuestion) {\n+                return selectedQuestion.id === Number(questionID);\n+            });\n+            if (!question) {\n+                console.error('question not found for ID: ' + questionID);\n+                return;\n+            }\n+            // generate the submittedAnswer object\n+            const mcSubmittedAnswer = new MultipleChoiceSubmittedAnswer();\n+            mcSubmittedAnswer.quizQuestion = question;\n+            mcSubmittedAnswer.selectedOptions = this.selectedAnswerOptions[questionID];\n+            this.submission.submittedAnswers.push(mcSubmittedAnswer);\n+        }, this);\n+\n+        // for drag-and-drop questions\n+        Object.keys(this.dragAndDropMappings).forEach((questionID) => {\n+            // find the question object for the given question id\n+            const question = this.quizExercise.quizQuestions.find(function (localQuestion) {\n+                return localQuestion.id === Number(questionID);\n+            });\n+            if (!question) {\n+                console.error('question not found for ID: ' + questionID);\n+                return;\n+            }\n+            // generate the submittedAnswer object\n+            const dndSubmittedAnswer = new DragAndDropSubmittedAnswer();\n+            dndSubmittedAnswer.quizQuestion = question;\n+            dndSubmittedAnswer.mappings = this.dragAndDropMappings[questionID];\n+            this.submission.submittedAnswers.push(dndSubmittedAnswer);\n+        }, this);\n+        // for short-answer questions\n+        Object.keys(this.shortAnswerSubmittedTexts).forEach((questionID) => {\n+            // find the question object for the given question id\n+            const question = this.quizExercise.quizQuestions.find(function (localQuestion) {\n+                return localQuestion.id === Number(questionID);\n+            });\n+            if (!question) {\n+                console.error('question not found for ID: ' + questionID);\n+                return;\n+            }\n+            // generate the submittedAnswer object\n+            const shortAnswerSubmittedAnswer = new ShortAnswerSubmittedAnswer();\n+            shortAnswerSubmittedAnswer.quizQuestion = question;\n+            shortAnswerSubmittedAnswer.submittedTexts = this.shortAnswerSubmittedTexts[questionID];\n+            this.submission.submittedAnswers.push(shortAnswerSubmittedAnswer);\n+        }, this);\n+    }\n+\n+    /**\n+     * Apply the data of the participation, replacing all old data\n+     */\n+    updateParticipationFromServer(participation: StudentParticipation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTI0OQ=="}, "originalCommit": {"oid": "128dbc251f420f944cf141c98045cafe3fc232f1"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjY5NzM5OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/exam/participate/exercises/quiz/quiz-exam-participation.component.scss", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDoxNzoxMFrOGl-xlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDoxNzoxMFrOGl-xlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3ODk5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                z-index: 10;\n          \n          \n            \n                z-index: 8;", "url": "https://github.com/ls1intum/Artemis/pull/1665#discussion_r442478997", "createdAt": "2020-06-18T20:17:10Z", "author": {"login": "fde312"}, "path": "src/main/webapp/app/exam/participate/exercises/quiz/quiz-exam-participation.component.scss", "diffHunk": "@@ -0,0 +1,180 @@\n+.quiz-content {\n+    margin-top: 6px;\n+    margin-bottom: 110px;\n+    min-height: calc(100vh - 400px);\n+    padding-left: 40px;\n+\n+    .question-index {\n+        padding: 2px 6px;\n+    }\n+}\n+\n+.quiz-footer {\n+    width: 60px;\n+    height: 100%;\n+    position: absolute;\n+    padding: 0 10px;\n+    bottom: 0;\n+    left: 0;\n+    right: 0;\n+    z-index: 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c4a1287f1cdc952876f04c5821c1d53cdf927cf"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4887, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}