{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2Mzk3NjAx", "number": 1549, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNzozOToxNVrOEDv2OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTowNzo0OVrOEEVrlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzY1MTEzOnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/shared/notification/connection-notification/connection-notification.component.ts", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNzozOToxNVrOGg8gsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNzozOToxNVrOGg8gsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5OTAyNA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/ls1intum/Artemis/pull/1549#discussion_r437199024", "createdAt": "2020-06-09T07:39:15Z", "author": {"login": "sascha11110"}, "path": "src/main/webapp/app/shared/notification/connection-notification/connection-notification.component.ts", "diffHunk": "@@ -2,7 +2,7 @@ import { Component, OnDestroy, OnInit } from '@angular/core';\n import { AccountService } from 'app/core/auth/account.service';\n import { JhiWebsocketService } from 'app/core/websocket/websocket.service';\n import { User } from 'app/core/user/user.model';\n-import { ConnectionNotification, ConnectionNotificationType } from 'app/shared/layouts/connection-notification/connection-notification.model';\n+import { ConnectionNotification, ConnectionNotificationType } from 'app/shared/notification/connection-notification/connection-notification.model';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c89f51515fe5181bd6a22bdbe55214c0c9b14a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTg0OTgwOnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/shared/notification/loading-notification/loading-notification.interceptor.ts", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTowNzo0OVrOGh5bqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxOTowNDoxN1rOGj--HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzE2Mg==", "bodyText": "what happens if finalize() is never called for one request? Then the counter activeRequests is always > 0 and the spinner will always be shown.\nFor example, when the internet connection breaks or when we get into a timeout or when the user changes the page too quickly? Or any other weird cases", "url": "https://github.com/ls1intum/Artemis/pull/1549#discussion_r438197162", "createdAt": "2020-06-10T15:07:49Z", "author": {"login": "krusche"}, "path": "src/main/webapp/app/shared/notification/loading-notification/loading-notification.interceptor.ts", "diffHunk": "@@ -0,0 +1,36 @@\n+import { Injectable } from '@angular/core';\n+import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';\n+import { Observable } from 'rxjs';\n+import { finalize } from 'rxjs/operators';\n+import { LoadingNotificationService } from 'app/shared/notification/loading-notification/loading-notification.service';\n+\n+@Injectable()\n+export class LoadingNotificationInterceptor implements HttpInterceptor {\n+    activeRequests = 0;\n+\n+    constructor(private loadingNotificationService: LoadingNotificationService) {}\n+\n+    /**\n+     * Identifies and handles a given HTTP request. If any HTTP request is sent we enable the loading screen and count up the active requests.\n+     * While all HTTP request complete we count down the active requests and when all HTTP requests are completed we disable the loading screen.\n+     * @param request The outgoing request object to handle.\n+     * @param next The next interceptor in the chain, or the backend\n+     * if no interceptors remain in the chain.\n+     * @returns An observable of the event stream.\n+     */\n+    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n+        if (this.activeRequests === 0) {\n+            this.loadingNotificationService.startLoading();\n+        }\n+        this.activeRequests++;\n+\n+        return next.handle(request).pipe(\n+            finalize(() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c89f51515fe5181bd6a22bdbe55214c0c9b14a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4NTA1Mw==", "bodyText": "@krusche I tested this today with @tessaRuckstuhl and we did not find any case on where this did not work. finalize() is always called when a request terminates on success or on error, therefore activeRequests will always go back to 0", "url": "https://github.com/ls1intum/Artemis/pull/1549#discussion_r440385053", "createdAt": "2020-06-15T19:04:17Z", "author": {"login": "fde312"}, "path": "src/main/webapp/app/shared/notification/loading-notification/loading-notification.interceptor.ts", "diffHunk": "@@ -0,0 +1,36 @@\n+import { Injectable } from '@angular/core';\n+import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';\n+import { Observable } from 'rxjs';\n+import { finalize } from 'rxjs/operators';\n+import { LoadingNotificationService } from 'app/shared/notification/loading-notification/loading-notification.service';\n+\n+@Injectable()\n+export class LoadingNotificationInterceptor implements HttpInterceptor {\n+    activeRequests = 0;\n+\n+    constructor(private loadingNotificationService: LoadingNotificationService) {}\n+\n+    /**\n+     * Identifies and handles a given HTTP request. If any HTTP request is sent we enable the loading screen and count up the active requests.\n+     * While all HTTP request complete we count down the active requests and when all HTTP requests are completed we disable the loading screen.\n+     * @param request The outgoing request object to handle.\n+     * @param next The next interceptor in the chain, or the backend\n+     * if no interceptors remain in the chain.\n+     * @returns An observable of the event stream.\n+     */\n+    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n+        if (this.activeRequests === 0) {\n+            this.loadingNotificationService.startLoading();\n+        }\n+        this.activeRequests++;\n+\n+        return next.handle(request).pipe(\n+            finalize(() => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzE2Mg=="}, "originalCommit": {"oid": "06c89f51515fe5181bd6a22bdbe55214c0c9b14a"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 10, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}