{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDY0OTM1", "number": 1177, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMzo1ODo1NVrODZgCNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzowMDowNlrODZkRkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDY1ODQ1OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMzo1ODo1NVrOFf65Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxNDoxN1rOFiGOlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxNTA5MQ==", "bodyText": "Would be nice to wrap the subtract and add operations with closures. It is quite hard to follow, when you add another statement with &&", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r369015091", "createdAt": "2020-01-21T13:58:55Z", "author": {"login": "maxr96"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "diffHunk": "@@ -173,68 +178,191 @@ export class GuidedTourComponent implements AfterViewInit, OnDestroy {\n     /**\n      * Scroll to and set highlighted element\n      */\n-    public scrollToAndSetElement(): void {\n+    private scrollToAndSetElement(): void {\n         this.selectedElementRect = this.updateStepLocation(this.getSelectedElement(), false);\n         this.observeSelectedRectPosition();\n \n         // Set timeout to allow things to render in order to scroll to the correct location\n         setTimeout(() => {\n-            if (this.isTourOnScreen()) {\n+            if (this.isTourOnScreen(Direction.VERTICAL) && this.isTourOnScreen(Direction.HORIZONTAL)) {\n                 return;\n             }\n-            const topPosition = this.getTopScrollingPosition();\n-            try {\n-                window.scrollTo({\n-                    left: 0,\n-                    top: topPosition,\n-                    behavior: 'smooth',\n-                });\n-            } catch (err) {\n-                if (err instanceof TypeError) {\n-                    window.scroll(0, topPosition);\n-                } else {\n-                    throw err;\n+            if (!this.isTourOnScreen(Direction.VERTICAL)) {\n+                const topPosition = this.getTopScrollingPosition();\n+                try {\n+                    window.scrollTo({ left: 0, top: topPosition, behavior: 'smooth' });\n+                } catch (err) {\n+                    if (err instanceof TypeError) {\n+                        window.scroll(0, topPosition);\n+                    } else {\n+                        throw err;\n+                    }\n                 }\n             }\n+            setTimeout(() => {\n+                if (!this.isTourOnScreen(Direction.HORIZONTAL)) {\n+                    this.flipOrientation();\n+                }\n+            }, 300);\n         }, 0);\n     }\n \n+    /**\n+     * Check if the current tour step has a bottom orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isBottom(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.BOTTOM ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMLEFT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a top orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isTop(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.TOP ||\n+                this.currentTourStep.orientation === Orientation.TOPLEFT ||\n+                this.currentTourStep.orientation === Orientation.TOPRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a left orientation\n+     * @return true if the current tour step orientation is left, otherwise false\n+     */\n+    private isLeft(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.LEFT ||\n+                this.currentTourStep.orientation === Orientation.TOPLEFT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMLEFT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a right orientation\n+     * @return true if the current tour step orientation is right, otherwise false\n+     */\n+    private isRight(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.RIGHT ||\n+                this.currentTourStep.orientation === Orientation.TOPRIGHT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Check if the tour step element would be visible on screen\n      * @return true if tour step is visible on screen, otherwise false\n      */\n-    public isTourOnScreen(): boolean {\n+    private isTourOnScreen(direction: Direction): boolean {\n         if (!this.currentTourStep) {\n             return false;\n         }\n-        return !this.currentTourStep.highlightSelector || (this.elementInViewport(this.getSelectedElement()) && this.elementInViewport(this.tourStep.nativeElement));\n+        switch (direction) {\n+            case Direction.HORIZONTAL: {\n+                return !this.currentTourStep.highlightSelector || this.elementInViewport(this.getSelectedElement(), direction);\n+            }\n+            case Direction.VERTICAL: {\n+                return (\n+                    !this.currentTourStep.highlightSelector ||\n+                    (this.elementInViewport(this.getSelectedElement(), direction) && this.elementInViewport(this.tourStep.nativeElement, direction))\n+                );\n+            }\n+        }\n     }\n \n     /**\n      * Define if HTMLElement is visible in current viewport\n      * Modified from https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport\n      * @param element that should be checked\n+     * @param direction it should be checked if the tour step is horizontally or vertically in the viewport\n      * @return true if element is in viewport, otherwise false\n      */\n-    public elementInViewport(element: HTMLElement | null): boolean {\n+    private elementInViewport(element: HTMLElement | null, direction: Direction): boolean {\n         if (!element) {\n             return false;\n         }\n-        let top = element.offsetTop;\n-        const height = element.offsetHeight;\n \n-        while (element.offsetParent) {\n-            element = element.offsetParent as HTMLElement;\n-            top += element.offsetTop;\n-        }\n+        let elementInViewPort = true;\n \n-        const scrollAdjustment = this.currentTourStep && this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n-        const stepScreenAdjustment = this.getStepScreenAdjustment();\n+        switch (direction) {\n+            case Direction.HORIZONTAL: {\n+                const width = element.offsetWidth;\n+                const left = calculateLeftOffset(element);\n+                const tourStepWidth = this.tourStep.nativeElement.offsetWidth;\n+                elementInViewPort = isElementInViewPortHorizontally(this.currentTourStep.orientation, left, width, tourStepWidth);\n+                break;\n+            }\n+            case Direction.VERTICAL: {\n+                const scrollAdjustment = this.currentTourStep && this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n+                const stepScreenAdjustment = this.getStepScreenAdjustment();\n+                const top = calculateTopOffset(element);\n+                const height = element.offsetHeight;\n+\n+                if (this.isBottom()) {\n+                    elementInViewPort =\n+                        top >= window.pageYOffset + this.topOfPageAdjustment + scrollAdjustment + stepScreenAdjustment && top + height <= window.innerHeight + window.pageYOffset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5Nzk0MQ==", "bodyText": "Unfortunately this is not possible because of the typescript formatting guideline given by the prettier config. I received an error for the formatting and after running prettier the closures are removed.", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r371297941", "createdAt": "2020-01-27T15:14:17Z", "author": {"login": "lovaiible"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "diffHunk": "@@ -173,68 +178,191 @@ export class GuidedTourComponent implements AfterViewInit, OnDestroy {\n     /**\n      * Scroll to and set highlighted element\n      */\n-    public scrollToAndSetElement(): void {\n+    private scrollToAndSetElement(): void {\n         this.selectedElementRect = this.updateStepLocation(this.getSelectedElement(), false);\n         this.observeSelectedRectPosition();\n \n         // Set timeout to allow things to render in order to scroll to the correct location\n         setTimeout(() => {\n-            if (this.isTourOnScreen()) {\n+            if (this.isTourOnScreen(Direction.VERTICAL) && this.isTourOnScreen(Direction.HORIZONTAL)) {\n                 return;\n             }\n-            const topPosition = this.getTopScrollingPosition();\n-            try {\n-                window.scrollTo({\n-                    left: 0,\n-                    top: topPosition,\n-                    behavior: 'smooth',\n-                });\n-            } catch (err) {\n-                if (err instanceof TypeError) {\n-                    window.scroll(0, topPosition);\n-                } else {\n-                    throw err;\n+            if (!this.isTourOnScreen(Direction.VERTICAL)) {\n+                const topPosition = this.getTopScrollingPosition();\n+                try {\n+                    window.scrollTo({ left: 0, top: topPosition, behavior: 'smooth' });\n+                } catch (err) {\n+                    if (err instanceof TypeError) {\n+                        window.scroll(0, topPosition);\n+                    } else {\n+                        throw err;\n+                    }\n                 }\n             }\n+            setTimeout(() => {\n+                if (!this.isTourOnScreen(Direction.HORIZONTAL)) {\n+                    this.flipOrientation();\n+                }\n+            }, 300);\n         }, 0);\n     }\n \n+    /**\n+     * Check if the current tour step has a bottom orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isBottom(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.BOTTOM ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMLEFT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a top orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isTop(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.TOP ||\n+                this.currentTourStep.orientation === Orientation.TOPLEFT ||\n+                this.currentTourStep.orientation === Orientation.TOPRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a left orientation\n+     * @return true if the current tour step orientation is left, otherwise false\n+     */\n+    private isLeft(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.LEFT ||\n+                this.currentTourStep.orientation === Orientation.TOPLEFT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMLEFT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a right orientation\n+     * @return true if the current tour step orientation is right, otherwise false\n+     */\n+    private isRight(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.RIGHT ||\n+                this.currentTourStep.orientation === Orientation.TOPRIGHT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Check if the tour step element would be visible on screen\n      * @return true if tour step is visible on screen, otherwise false\n      */\n-    public isTourOnScreen(): boolean {\n+    private isTourOnScreen(direction: Direction): boolean {\n         if (!this.currentTourStep) {\n             return false;\n         }\n-        return !this.currentTourStep.highlightSelector || (this.elementInViewport(this.getSelectedElement()) && this.elementInViewport(this.tourStep.nativeElement));\n+        switch (direction) {\n+            case Direction.HORIZONTAL: {\n+                return !this.currentTourStep.highlightSelector || this.elementInViewport(this.getSelectedElement(), direction);\n+            }\n+            case Direction.VERTICAL: {\n+                return (\n+                    !this.currentTourStep.highlightSelector ||\n+                    (this.elementInViewport(this.getSelectedElement(), direction) && this.elementInViewport(this.tourStep.nativeElement, direction))\n+                );\n+            }\n+        }\n     }\n \n     /**\n      * Define if HTMLElement is visible in current viewport\n      * Modified from https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport\n      * @param element that should be checked\n+     * @param direction it should be checked if the tour step is horizontally or vertically in the viewport\n      * @return true if element is in viewport, otherwise false\n      */\n-    public elementInViewport(element: HTMLElement | null): boolean {\n+    private elementInViewport(element: HTMLElement | null, direction: Direction): boolean {\n         if (!element) {\n             return false;\n         }\n-        let top = element.offsetTop;\n-        const height = element.offsetHeight;\n \n-        while (element.offsetParent) {\n-            element = element.offsetParent as HTMLElement;\n-            top += element.offsetTop;\n-        }\n+        let elementInViewPort = true;\n \n-        const scrollAdjustment = this.currentTourStep && this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n-        const stepScreenAdjustment = this.getStepScreenAdjustment();\n+        switch (direction) {\n+            case Direction.HORIZONTAL: {\n+                const width = element.offsetWidth;\n+                const left = calculateLeftOffset(element);\n+                const tourStepWidth = this.tourStep.nativeElement.offsetWidth;\n+                elementInViewPort = isElementInViewPortHorizontally(this.currentTourStep.orientation, left, width, tourStepWidth);\n+                break;\n+            }\n+            case Direction.VERTICAL: {\n+                const scrollAdjustment = this.currentTourStep && this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n+                const stepScreenAdjustment = this.getStepScreenAdjustment();\n+                const top = calculateTopOffset(element);\n+                const height = element.offsetHeight;\n+\n+                if (this.isBottom()) {\n+                    elementInViewPort =\n+                        top >= window.pageYOffset + this.topOfPageAdjustment + scrollAdjustment + stepScreenAdjustment && top + height <= window.innerHeight + window.pageYOffset;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxNTA5MQ=="}, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDY4MzUyOnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNDowNTo1N1rOFf7ISg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxODozOFrOFiGZfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxODk1NA==", "bodyText": "Hm here you are accessing orientation directly on the class and below you do it on currentTourStep. If I understand correctly it should be only accessed with the first approach.", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r369018954", "createdAt": "2020-01-21T14:05:57Z", "author": {"login": "maxr96"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "diffHunk": "@@ -173,68 +178,191 @@ export class GuidedTourComponent implements AfterViewInit, OnDestroy {\n     /**\n      * Scroll to and set highlighted element\n      */\n-    public scrollToAndSetElement(): void {\n+    private scrollToAndSetElement(): void {\n         this.selectedElementRect = this.updateStepLocation(this.getSelectedElement(), false);\n         this.observeSelectedRectPosition();\n \n         // Set timeout to allow things to render in order to scroll to the correct location\n         setTimeout(() => {\n-            if (this.isTourOnScreen()) {\n+            if (this.isTourOnScreen(Direction.VERTICAL) && this.isTourOnScreen(Direction.HORIZONTAL)) {\n                 return;\n             }\n-            const topPosition = this.getTopScrollingPosition();\n-            try {\n-                window.scrollTo({\n-                    left: 0,\n-                    top: topPosition,\n-                    behavior: 'smooth',\n-                });\n-            } catch (err) {\n-                if (err instanceof TypeError) {\n-                    window.scroll(0, topPosition);\n-                } else {\n-                    throw err;\n+            if (!this.isTourOnScreen(Direction.VERTICAL)) {\n+                const topPosition = this.getTopScrollingPosition();\n+                try {\n+                    window.scrollTo({ left: 0, top: topPosition, behavior: 'smooth' });\n+                } catch (err) {\n+                    if (err instanceof TypeError) {\n+                        window.scroll(0, topPosition);\n+                    } else {\n+                        throw err;\n+                    }\n                 }\n             }\n+            setTimeout(() => {\n+                if (!this.isTourOnScreen(Direction.HORIZONTAL)) {\n+                    this.flipOrientation();\n+                }\n+            }, 300);\n         }, 0);\n     }\n \n+    /**\n+     * Check if the current tour step has a bottom orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isBottom(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.BOTTOM ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMLEFT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a top orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isTop(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.TOP ||\n+                this.currentTourStep.orientation === Orientation.TOPLEFT ||\n+                this.currentTourStep.orientation === Orientation.TOPRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a left orientation\n+     * @return true if the current tour step orientation is left, otherwise false\n+     */\n+    private isLeft(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.LEFT ||\n+                this.currentTourStep.orientation === Orientation.TOPLEFT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMLEFT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a right orientation\n+     * @return true if the current tour step orientation is right, otherwise false\n+     */\n+    private isRight(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.RIGHT ||\n+                this.currentTourStep.orientation === Orientation.TOPRIGHT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Check if the tour step element would be visible on screen\n      * @return true if tour step is visible on screen, otherwise false\n      */\n-    public isTourOnScreen(): boolean {\n+    private isTourOnScreen(direction: Direction): boolean {\n         if (!this.currentTourStep) {\n             return false;\n         }\n-        return !this.currentTourStep.highlightSelector || (this.elementInViewport(this.getSelectedElement()) && this.elementInViewport(this.tourStep.nativeElement));\n+        switch (direction) {\n+            case Direction.HORIZONTAL: {\n+                return !this.currentTourStep.highlightSelector || this.elementInViewport(this.getSelectedElement(), direction);\n+            }\n+            case Direction.VERTICAL: {\n+                return (\n+                    !this.currentTourStep.highlightSelector ||\n+                    (this.elementInViewport(this.getSelectedElement(), direction) && this.elementInViewport(this.tourStep.nativeElement, direction))\n+                );\n+            }\n+        }\n     }\n \n     /**\n      * Define if HTMLElement is visible in current viewport\n      * Modified from https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport\n      * @param element that should be checked\n+     * @param direction it should be checked if the tour step is horizontally or vertically in the viewport\n      * @return true if element is in viewport, otherwise false\n      */\n-    public elementInViewport(element: HTMLElement | null): boolean {\n+    private elementInViewport(element: HTMLElement | null, direction: Direction): boolean {\n         if (!element) {\n             return false;\n         }\n-        let top = element.offsetTop;\n-        const height = element.offsetHeight;\n \n-        while (element.offsetParent) {\n-            element = element.offsetParent as HTMLElement;\n-            top += element.offsetTop;\n-        }\n+        let elementInViewPort = true;\n \n-        const scrollAdjustment = this.currentTourStep && this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n-        const stepScreenAdjustment = this.getStepScreenAdjustment();\n+        switch (direction) {\n+            case Direction.HORIZONTAL: {\n+                const width = element.offsetWidth;\n+                const left = calculateLeftOffset(element);\n+                const tourStepWidth = this.tourStep.nativeElement.offsetWidth;\n+                elementInViewPort = isElementInViewPortHorizontally(this.currentTourStep.orientation, left, width, tourStepWidth);\n+                break;\n+            }\n+            case Direction.VERTICAL: {\n+                const scrollAdjustment = this.currentTourStep && this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n+                const stepScreenAdjustment = this.getStepScreenAdjustment();\n+                const top = calculateTopOffset(element);\n+                const height = element.offsetHeight;\n+\n+                if (this.isBottom()) {\n+                    elementInViewPort =\n+                        top >= window.pageYOffset + this.topOfPageAdjustment + scrollAdjustment + stepScreenAdjustment && top + height <= window.innerHeight + window.pageYOffset;\n+                } else {\n+                    elementInViewPort =\n+                        top >= window.pageYOffset + this.topOfPageAdjustment - stepScreenAdjustment && top + height + scrollAdjustment <= window.innerHeight + window.pageYOffset;\n+                }\n+                break;\n+            }\n+        }\n+        return elementInViewPort;\n+    }\n \n-        if (this.isBottom()) {\n-            return top >= window.pageYOffset + this.topOfPageAdjustment + scrollAdjustment + stepScreenAdjustment && top + height <= window.innerHeight;\n-        } else {\n-            return top >= window.pageYOffset + this.topOfPageAdjustment - stepScreenAdjustment && top + height + scrollAdjustment <= window.innerHeight;\n+    /**\n+     * Flips the orientation of the current tour step horizontally\n+     */\n+    private flipOrientation(): void {\n+        if (this.isLeft()) {\n+            switch (this.orientation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMwMDczNQ==", "bodyText": "You are right, I missed that part. I changed the code to switch (this.currentTourStep.orientation) now", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r371300735", "createdAt": "2020-01-27T15:18:38Z", "author": {"login": "lovaiible"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "diffHunk": "@@ -173,68 +178,191 @@ export class GuidedTourComponent implements AfterViewInit, OnDestroy {\n     /**\n      * Scroll to and set highlighted element\n      */\n-    public scrollToAndSetElement(): void {\n+    private scrollToAndSetElement(): void {\n         this.selectedElementRect = this.updateStepLocation(this.getSelectedElement(), false);\n         this.observeSelectedRectPosition();\n \n         // Set timeout to allow things to render in order to scroll to the correct location\n         setTimeout(() => {\n-            if (this.isTourOnScreen()) {\n+            if (this.isTourOnScreen(Direction.VERTICAL) && this.isTourOnScreen(Direction.HORIZONTAL)) {\n                 return;\n             }\n-            const topPosition = this.getTopScrollingPosition();\n-            try {\n-                window.scrollTo({\n-                    left: 0,\n-                    top: topPosition,\n-                    behavior: 'smooth',\n-                });\n-            } catch (err) {\n-                if (err instanceof TypeError) {\n-                    window.scroll(0, topPosition);\n-                } else {\n-                    throw err;\n+            if (!this.isTourOnScreen(Direction.VERTICAL)) {\n+                const topPosition = this.getTopScrollingPosition();\n+                try {\n+                    window.scrollTo({ left: 0, top: topPosition, behavior: 'smooth' });\n+                } catch (err) {\n+                    if (err instanceof TypeError) {\n+                        window.scroll(0, topPosition);\n+                    } else {\n+                        throw err;\n+                    }\n                 }\n             }\n+            setTimeout(() => {\n+                if (!this.isTourOnScreen(Direction.HORIZONTAL)) {\n+                    this.flipOrientation();\n+                }\n+            }, 300);\n         }, 0);\n     }\n \n+    /**\n+     * Check if the current tour step has a bottom orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isBottom(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.BOTTOM ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMLEFT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a top orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isTop(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.TOP ||\n+                this.currentTourStep.orientation === Orientation.TOPLEFT ||\n+                this.currentTourStep.orientation === Orientation.TOPRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a left orientation\n+     * @return true if the current tour step orientation is left, otherwise false\n+     */\n+    private isLeft(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.LEFT ||\n+                this.currentTourStep.orientation === Orientation.TOPLEFT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMLEFT\n+            );\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if the current tour step has a right orientation\n+     * @return true if the current tour step orientation is right, otherwise false\n+     */\n+    private isRight(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.RIGHT ||\n+                this.currentTourStep.orientation === Orientation.TOPRIGHT ||\n+                this.currentTourStep.orientation === Orientation.BOTTOMRIGHT\n+            );\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Check if the tour step element would be visible on screen\n      * @return true if tour step is visible on screen, otherwise false\n      */\n-    public isTourOnScreen(): boolean {\n+    private isTourOnScreen(direction: Direction): boolean {\n         if (!this.currentTourStep) {\n             return false;\n         }\n-        return !this.currentTourStep.highlightSelector || (this.elementInViewport(this.getSelectedElement()) && this.elementInViewport(this.tourStep.nativeElement));\n+        switch (direction) {\n+            case Direction.HORIZONTAL: {\n+                return !this.currentTourStep.highlightSelector || this.elementInViewport(this.getSelectedElement(), direction);\n+            }\n+            case Direction.VERTICAL: {\n+                return (\n+                    !this.currentTourStep.highlightSelector ||\n+                    (this.elementInViewport(this.getSelectedElement(), direction) && this.elementInViewport(this.tourStep.nativeElement, direction))\n+                );\n+            }\n+        }\n     }\n \n     /**\n      * Define if HTMLElement is visible in current viewport\n      * Modified from https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport\n      * @param element that should be checked\n+     * @param direction it should be checked if the tour step is horizontally or vertically in the viewport\n      * @return true if element is in viewport, otherwise false\n      */\n-    public elementInViewport(element: HTMLElement | null): boolean {\n+    private elementInViewport(element: HTMLElement | null, direction: Direction): boolean {\n         if (!element) {\n             return false;\n         }\n-        let top = element.offsetTop;\n-        const height = element.offsetHeight;\n \n-        while (element.offsetParent) {\n-            element = element.offsetParent as HTMLElement;\n-            top += element.offsetTop;\n-        }\n+        let elementInViewPort = true;\n \n-        const scrollAdjustment = this.currentTourStep && this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n-        const stepScreenAdjustment = this.getStepScreenAdjustment();\n+        switch (direction) {\n+            case Direction.HORIZONTAL: {\n+                const width = element.offsetWidth;\n+                const left = calculateLeftOffset(element);\n+                const tourStepWidth = this.tourStep.nativeElement.offsetWidth;\n+                elementInViewPort = isElementInViewPortHorizontally(this.currentTourStep.orientation, left, width, tourStepWidth);\n+                break;\n+            }\n+            case Direction.VERTICAL: {\n+                const scrollAdjustment = this.currentTourStep && this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n+                const stepScreenAdjustment = this.getStepScreenAdjustment();\n+                const top = calculateTopOffset(element);\n+                const height = element.offsetHeight;\n+\n+                if (this.isBottom()) {\n+                    elementInViewPort =\n+                        top >= window.pageYOffset + this.topOfPageAdjustment + scrollAdjustment + stepScreenAdjustment && top + height <= window.innerHeight + window.pageYOffset;\n+                } else {\n+                    elementInViewPort =\n+                        top >= window.pageYOffset + this.topOfPageAdjustment - stepScreenAdjustment && top + height + scrollAdjustment <= window.innerHeight + window.pageYOffset;\n+                }\n+                break;\n+            }\n+        }\n+        return elementInViewPort;\n+    }\n \n-        if (this.isBottom()) {\n-            return top >= window.pageYOffset + this.topOfPageAdjustment + scrollAdjustment + stepScreenAdjustment && top + height <= window.innerHeight;\n-        } else {\n-            return top >= window.pageYOffset + this.topOfPageAdjustment - stepScreenAdjustment && top + height + scrollAdjustment <= window.innerHeight;\n+    /**\n+     * Flips the orientation of the current tour step horizontally\n+     */\n+    private flipOrientation(): void {\n+        if (this.isLeft()) {\n+            switch (this.orientation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxODk1NA=="}, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDY5MDE3OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNDowODowMVrOFf7McA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxNjowMlrOFiGTEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyMDAxNg==", "bodyText": "You should be able to use just this.orientation here since you already assign it in the beginning", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r369020016", "createdAt": "2020-01-21T14:08:01Z", "author": {"login": "maxr96"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "diffHunk": "@@ -173,68 +178,191 @@ export class GuidedTourComponent implements AfterViewInit, OnDestroy {\n     /**\n      * Scroll to and set highlighted element\n      */\n-    public scrollToAndSetElement(): void {\n+    private scrollToAndSetElement(): void {\n         this.selectedElementRect = this.updateStepLocation(this.getSelectedElement(), false);\n         this.observeSelectedRectPosition();\n \n         // Set timeout to allow things to render in order to scroll to the correct location\n         setTimeout(() => {\n-            if (this.isTourOnScreen()) {\n+            if (this.isTourOnScreen(Direction.VERTICAL) && this.isTourOnScreen(Direction.HORIZONTAL)) {\n                 return;\n             }\n-            const topPosition = this.getTopScrollingPosition();\n-            try {\n-                window.scrollTo({\n-                    left: 0,\n-                    top: topPosition,\n-                    behavior: 'smooth',\n-                });\n-            } catch (err) {\n-                if (err instanceof TypeError) {\n-                    window.scroll(0, topPosition);\n-                } else {\n-                    throw err;\n+            if (!this.isTourOnScreen(Direction.VERTICAL)) {\n+                const topPosition = this.getTopScrollingPosition();\n+                try {\n+                    window.scrollTo({ left: 0, top: topPosition, behavior: 'smooth' });\n+                } catch (err) {\n+                    if (err instanceof TypeError) {\n+                        window.scroll(0, topPosition);\n+                    } else {\n+                        throw err;\n+                    }\n                 }\n             }\n+            setTimeout(() => {\n+                if (!this.isTourOnScreen(Direction.HORIZONTAL)) {\n+                    this.flipOrientation();\n+                }\n+            }, 300);\n         }, 0);\n     }\n \n+    /**\n+     * Check if the current tour step has a bottom orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isBottom(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.BOTTOM ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5OTA4OQ==", "bodyText": "Yes, but it refers to the orientation of the step, therefore it should refer to this.currentTourStep.orientation", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r371299089", "createdAt": "2020-01-27T15:16:02Z", "author": {"login": "lovaiible"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "diffHunk": "@@ -173,68 +178,191 @@ export class GuidedTourComponent implements AfterViewInit, OnDestroy {\n     /**\n      * Scroll to and set highlighted element\n      */\n-    public scrollToAndSetElement(): void {\n+    private scrollToAndSetElement(): void {\n         this.selectedElementRect = this.updateStepLocation(this.getSelectedElement(), false);\n         this.observeSelectedRectPosition();\n \n         // Set timeout to allow things to render in order to scroll to the correct location\n         setTimeout(() => {\n-            if (this.isTourOnScreen()) {\n+            if (this.isTourOnScreen(Direction.VERTICAL) && this.isTourOnScreen(Direction.HORIZONTAL)) {\n                 return;\n             }\n-            const topPosition = this.getTopScrollingPosition();\n-            try {\n-                window.scrollTo({\n-                    left: 0,\n-                    top: topPosition,\n-                    behavior: 'smooth',\n-                });\n-            } catch (err) {\n-                if (err instanceof TypeError) {\n-                    window.scroll(0, topPosition);\n-                } else {\n-                    throw err;\n+            if (!this.isTourOnScreen(Direction.VERTICAL)) {\n+                const topPosition = this.getTopScrollingPosition();\n+                try {\n+                    window.scrollTo({ left: 0, top: topPosition, behavior: 'smooth' });\n+                } catch (err) {\n+                    if (err instanceof TypeError) {\n+                        window.scroll(0, topPosition);\n+                    } else {\n+                        throw err;\n+                    }\n                 }\n             }\n+            setTimeout(() => {\n+                if (!this.isTourOnScreen(Direction.HORIZONTAL)) {\n+                    this.flipOrientation();\n+                }\n+            }, 300);\n         }, 0);\n     }\n \n+    /**\n+     * Check if the current tour step has a bottom orientation\n+     * @return true if the current tour step orientation is bottom, otherwise false\n+     */\n+    private isBottom(): boolean {\n+        if (this.currentTourStep && this.currentTourStep.orientation) {\n+            return (\n+                this.currentTourStep.orientation === Orientation.BOTTOM ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyMDAxNg=="}, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDcwNDIyOnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/guided-tour/guided-tour.constants.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNDoxMjowMVrOFf7VQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxNjoyMFrOFiGT5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyMjI3Mw==", "bodyText": "Why do you need @ts-ignore here?", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r369022273", "createdAt": "2020-01-21T14:12:01Z", "author": {"login": "maxr96"}, "path": "src/main/webapp/app/guided-tour/guided-tour.constants.ts", "diffHunk": "@@ -38,8 +31,17 @@ export enum OverlayPosition {\n }\n \n export enum UserInteractionEvent {\n+    // @ts-ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5OTMwMA==", "bodyText": "I removed it :)", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r371299300", "createdAt": "2020-01-27T15:16:20Z", "author": {"login": "lovaiible"}, "path": "src/main/webapp/app/guided-tour/guided-tour.constants.ts", "diffHunk": "@@ -38,8 +31,17 @@ export enum OverlayPosition {\n }\n \n export enum UserInteractionEvent {\n+    // @ts-ignore", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyMjI3Mw=="}, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTMwMDM3OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/guided-tour/guided-tour.component.html", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjo0NjowNVrOFgBG6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxODo1MVrOFiGaCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTExNjkwNQ==", "bodyText": "this. should be redundant here.", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r369116905", "createdAt": "2020-01-21T16:46:05Z", "author": {"login": "madwau"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.html", "diffHunk": "@@ -7,7 +7,7 @@\n     <div\n         #tourStep\n         *ngIf=\"currentTourStep\"\n-        class=\"tour-step tour-{{ currentTourStep.orientation }}\"\n+        class=\"tour-step tour-{{ this.orientation }}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMwMDg3Mw==", "bodyText": "Changed that :)", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r371300873", "createdAt": "2020-01-27T15:18:51Z", "author": {"login": "lovaiible"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.html", "diffHunk": "@@ -7,7 +7,7 @@\n     <div\n         #tourStep\n         *ngIf=\"currentTourStep\"\n-        class=\"tour-step tour-{{ currentTourStep.orientation }}\"\n+        class=\"tour-step tour-{{ this.orientation }}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTExNjkwNQ=="}, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTM1MzEyOnYy", "diffSide": "RIGHT", "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzowMDowNlrOFgBn1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxOToyOVrOFiGbdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyNTMzNA==", "bodyText": "I assume this timeout is needed to let the previously triggered scrolling finish? Is it not possible to move the flip orientation before the scrolling without timeout since the scrolling should not affect whether the tour is in the viewport horizontally?\nCurrently, the 300ms are noticeable and the user can see the popup jumping into the flipped orientation. Not super serious but if this could be avoided, even better.", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r369125334", "createdAt": "2020-01-21T17:00:06Z", "author": {"login": "madwau"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "diffHunk": "@@ -173,68 +178,191 @@ export class GuidedTourComponent implements AfterViewInit, OnDestroy {\n     /**\n      * Scroll to and set highlighted element\n      */\n-    public scrollToAndSetElement(): void {\n+    private scrollToAndSetElement(): void {\n         this.selectedElementRect = this.updateStepLocation(this.getSelectedElement(), false);\n         this.observeSelectedRectPosition();\n \n         // Set timeout to allow things to render in order to scroll to the correct location\n         setTimeout(() => {\n-            if (this.isTourOnScreen()) {\n+            if (this.isTourOnScreen(Direction.VERTICAL) && this.isTourOnScreen(Direction.HORIZONTAL)) {\n                 return;\n             }\n-            const topPosition = this.getTopScrollingPosition();\n-            try {\n-                window.scrollTo({\n-                    left: 0,\n-                    top: topPosition,\n-                    behavior: 'smooth',\n-                });\n-            } catch (err) {\n-                if (err instanceof TypeError) {\n-                    window.scroll(0, topPosition);\n-                } else {\n-                    throw err;\n+            if (!this.isTourOnScreen(Direction.VERTICAL)) {\n+                const topPosition = this.getTopScrollingPosition();\n+                try {\n+                    window.scrollTo({ left: 0, top: topPosition, behavior: 'smooth' });\n+                } catch (err) {\n+                    if (err instanceof TypeError) {\n+                        window.scroll(0, topPosition);\n+                    } else {\n+                        throw err;\n+                    }\n                 }\n             }\n+            setTimeout(() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMwMTIzNw==", "bodyText": "I changed the logic a little bit and now it's possible without the delay of 300ms :)", "url": "https://github.com/ls1intum/Artemis/pull/1177#discussion_r371301237", "createdAt": "2020-01-27T15:19:29Z", "author": {"login": "lovaiible"}, "path": "src/main/webapp/app/guided-tour/guided-tour.component.ts", "diffHunk": "@@ -173,68 +178,191 @@ export class GuidedTourComponent implements AfterViewInit, OnDestroy {\n     /**\n      * Scroll to and set highlighted element\n      */\n-    public scrollToAndSetElement(): void {\n+    private scrollToAndSetElement(): void {\n         this.selectedElementRect = this.updateStepLocation(this.getSelectedElement(), false);\n         this.observeSelectedRectPosition();\n \n         // Set timeout to allow things to render in order to scroll to the correct location\n         setTimeout(() => {\n-            if (this.isTourOnScreen()) {\n+            if (this.isTourOnScreen(Direction.VERTICAL) && this.isTourOnScreen(Direction.HORIZONTAL)) {\n                 return;\n             }\n-            const topPosition = this.getTopScrollingPosition();\n-            try {\n-                window.scrollTo({\n-                    left: 0,\n-                    top: topPosition,\n-                    behavior: 'smooth',\n-                });\n-            } catch (err) {\n-                if (err instanceof TypeError) {\n-                    window.scroll(0, topPosition);\n-                } else {\n-                    throw err;\n+            if (!this.isTourOnScreen(Direction.VERTICAL)) {\n+                const topPosition = this.getTopScrollingPosition();\n+                try {\n+                    window.scrollTo({ left: 0, top: topPosition, behavior: 'smooth' });\n+                } catch (err) {\n+                    if (err instanceof TypeError) {\n+                        window.scroll(0, topPosition);\n+                    } else {\n+                        throw err;\n+                    }\n                 }\n             }\n+            setTimeout(() => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyNTMzNA=="}, "originalCommit": {"oid": "175921648f169ab6a11c1153e5f3f0aabb024559"}, "originalPosition": 123}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 179, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}