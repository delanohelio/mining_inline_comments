{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3MzcyMzc3", "number": 1977, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMToxNjozOVrOEoQvsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMToxNjo0MVrOEoQvug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjUyODQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/AutomaticTextAssessmentConflictService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMToxNjozOVrOHZP7rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMToxNjozOVrOHZP7rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzNzQ4Nw==", "bodyText": "Codacy found an issue: Useless parentheses.", "url": "https://github.com/ls1intum/Artemis/pull/1977#discussion_r496237487", "createdAt": "2020-09-28T21:16:39Z", "author": {"login": "artemis-bot"}, "path": "src/main/java/de/tum/in/www1/artemis/service/AutomaticTextAssessmentConflictService.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Profile;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.Feedback;\n+import de.tum.in.www1.artemis.domain.TextAssessmentConflict;\n+import de.tum.in.www1.artemis.domain.TextBlock;\n+import de.tum.in.www1.artemis.exception.NetworkingError;\n+import de.tum.in.www1.artemis.repository.FeedbackRepository;\n+import de.tum.in.www1.artemis.repository.TextAssessmentConflictRepository;\n+import de.tum.in.www1.artemis.repository.TextBlockRepository;\n+import de.tum.in.www1.artemis.service.connectors.TextAssessmentConflictService;\n+import de.tum.in.www1.artemis.service.dto.TextAssessmentConflictRequestDTO;\n+import de.tum.in.www1.artemis.service.dto.TextAssessmentConflictResponseDTO;\n+\n+@Service\n+@Profile(\"automaticText\")\n+public class AutomaticTextAssessmentConflictService {\n+\n+    private final Logger log = LoggerFactory.getLogger(AutomaticTextAssessmentConflictService.class);\n+\n+    private final TextAssessmentConflictRepository textAssessmentConflictRepository;\n+\n+    private final FeedbackRepository feedbackRepository;\n+\n+    private final TextBlockRepository textBlockRepository;\n+\n+    private final TextAssessmentConflictService textAssessmentConflictService;\n+\n+    public AutomaticTextAssessmentConflictService(TextAssessmentConflictRepository textAssessmentConflictRepository, FeedbackRepository feedbackRepository,\n+            TextBlockRepository textBlockRepository, TextAssessmentConflictService textAssessmentConflictService) {\n+        this.textAssessmentConflictRepository = textAssessmentConflictRepository;\n+        this.feedbackRepository = feedbackRepository;\n+        this.textBlockRepository = textBlockRepository;\n+        this.textAssessmentConflictService = textAssessmentConflictService;\n+    }\n+\n+    /**\n+     *  This function asynchronously calls remote Athene service to check feedback consistency for the assessed submission.\n+     *  The call is made if the automatic assessments are enabled and the passed text blocks belong to any cluster.\n+     *\n+     * @param textBlocks - all text blocks in the text assessment\n+     * @param feedbackList - all feedback in the text assessment\n+     * @param exerciseId - exercise id of the assessed text exercise\n+     */\n+    @Async\n+    public void asyncCheckFeedbackConsistency(List<TextBlock> textBlocks, List<Feedback> feedbackList, long exerciseId) {\n+        // remove the feedback that does not belong to any text block\n+        feedbackList.removeIf(f -> !f.hasReference());\n+\n+        // If text block doesn't have a cluster id don't create an object\n+        List<TextAssessmentConflictRequestDTO> textAssessmentConflictRequestDTOS = feedbackList.stream().flatMap(feedback -> {\n+            Optional<TextBlock> textBlock = textBlockRepository\n+                    .findById(textBlocks.stream().filter(block -> block.getId().equals(feedback.getReference())).findFirst().get().getId());\n+            if (textBlock.isPresent() && textBlock.get().getCluster() != null) {\n+                return Stream.of(new TextAssessmentConflictRequestDTO(textBlock.get().getId(), textBlock.get().getText(), textBlock.get().getCluster().getId(), feedback.getId(),\n+                        feedback.getDetailText(), feedback.getCredits()));\n+            }\n+            else {\n+                return Stream.empty();\n+            }\n+        }).collect(toList());\n+\n+        if (textAssessmentConflictRequestDTOS.isEmpty()) {\n+            return;\n+        }\n+\n+        // remote service call to athene\n+        final List<TextAssessmentConflictResponseDTO> textAssessmentConflictResponseDTOS;\n+        try {\n+            textAssessmentConflictResponseDTOS = textAssessmentConflictService.checkFeedbackConsistencies(textAssessmentConflictRequestDTOS, exerciseId, 0);\n+        }\n+        catch (NetworkingError networkingError) {\n+            log.error(networkingError.getMessage(), networkingError);\n+            return;\n+        }\n+\n+        // create an array to store conflicts\n+        List<TextAssessmentConflict> textAssessmentConflicts = new ArrayList<>();\n+\n+        // look for new conflicts\n+        // Athene may find conflicts with feedback ids that are not in the feedback repository any more. So check for them. (May happen if the feedback is deleted in Artemis but\n+        // already stored in Athene)\n+        textAssessmentConflictResponseDTOS.forEach(conflict -> {\n+            Optional<Feedback> firstFeedback = feedbackRepository.findById(conflict.getFirstFeedbackId());\n+            Optional<Feedback> secondFeedback = feedbackRepository.findById(conflict.getSecondFeedbackId());\n+            List<TextAssessmentConflict> storedConflicts = this.textAssessmentConflictRepository.findByFirstAndSecondFeedback(conflict.getFirstFeedbackId(),\n+                    conflict.getSecondFeedbackId());\n+            // if the found conflict is present but its type has changed, update it\n+            if (!storedConflicts.isEmpty() && !storedConflicts.get(0).getType().equals(conflict.getType())) {\n+                storedConflicts.get(0).setType(conflict.getType());\n+                textAssessmentConflicts.add(storedConflicts.get(0));\n+            }\n+\n+            // new conflict\n+            if (firstFeedback.isPresent() && secondFeedback.isPresent() && storedConflicts.isEmpty()) {\n+                TextAssessmentConflict textAssessmentConflict = new TextAssessmentConflict();\n+                textAssessmentConflict.setConflict(true);\n+                textAssessmentConflict.setFirstFeedback(firstFeedback.get());\n+                textAssessmentConflict.setSecondFeedback(secondFeedback.get());\n+                textAssessmentConflict.setType(conflict.getType());\n+                textAssessmentConflict.setCreatedAt(ZonedDateTime.now());\n+                textAssessmentConflicts.add(textAssessmentConflict);\n+            }\n+        });\n+\n+        // find solved conflicts and add them to list\n+        textAssessmentConflicts.addAll(this.findSolvedConflicts(textAssessmentConflictRequestDTOS, textAssessmentConflictResponseDTOS));\n+\n+        textAssessmentConflictRepository.saveAll(textAssessmentConflicts);\n+    }\n+\n+    /**\n+     * Searches if the feedback that are sent to Athene already have conflicts in the database(storedConflicts),\n+     * If the stored conflicts are not returned from Athene after the consistency check, it means that they are solved and set as solved.\n+     *\n+     * @param textAssessmentConflictRequestDTOS the list sent to Athene for check\n+     * @param textAssessmentConflictResponseDTOS returned list with found conflicts.\n+     * @return solved conflicts\n+     */\n+    private List<TextAssessmentConflict> findSolvedConflicts(List<TextAssessmentConflictRequestDTO> textAssessmentConflictRequestDTOS,\n+            List<TextAssessmentConflictResponseDTO> textAssessmentConflictResponseDTOS) {\n+        List<Long> feedbackIds = textAssessmentConflictRequestDTOS.stream().map(TextAssessmentConflictRequestDTO::getFeedbackId).collect(toList());\n+        List<TextAssessmentConflict> storedConflicts = this.textAssessmentConflictRepository.findAllByFeedbackList(feedbackIds);\n+\n+        storedConflicts.forEach(conflict -> {\n+            boolean isPresent = textAssessmentConflictResponseDTOS.stream().anyMatch(newConflicts -> (newConflicts.getFirstFeedbackId() == conflict.getFirstFeedback().getId()\n+                    && newConflicts.getSecondFeedbackId() == conflict.getSecondFeedback().getId())\n+                    || (newConflicts.getFirstFeedbackId() == conflict.getSecondFeedback().getId() && newConflicts.getSecondFeedbackId() == conflict.getFirstFeedback().getId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52da7b644d26412e05f43379e1868f8d4dccc081"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjUyODUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/tum/in/www1/artemis/service/AutomaticTextAssessmentConflictService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMToxNjo0MFrOHZP7tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMToxNjo0MFrOHZP7tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzNzQ5Mw==", "bodyText": "Codacy found an issue: Useless parentheses.", "url": "https://github.com/ls1intum/Artemis/pull/1977#discussion_r496237493", "createdAt": "2020-09-28T21:16:40Z", "author": {"login": "artemis-bot"}, "path": "src/main/java/de/tum/in/www1/artemis/service/AutomaticTextAssessmentConflictService.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Profile;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.Feedback;\n+import de.tum.in.www1.artemis.domain.TextAssessmentConflict;\n+import de.tum.in.www1.artemis.domain.TextBlock;\n+import de.tum.in.www1.artemis.exception.NetworkingError;\n+import de.tum.in.www1.artemis.repository.FeedbackRepository;\n+import de.tum.in.www1.artemis.repository.TextAssessmentConflictRepository;\n+import de.tum.in.www1.artemis.repository.TextBlockRepository;\n+import de.tum.in.www1.artemis.service.connectors.TextAssessmentConflictService;\n+import de.tum.in.www1.artemis.service.dto.TextAssessmentConflictRequestDTO;\n+import de.tum.in.www1.artemis.service.dto.TextAssessmentConflictResponseDTO;\n+\n+@Service\n+@Profile(\"automaticText\")\n+public class AutomaticTextAssessmentConflictService {\n+\n+    private final Logger log = LoggerFactory.getLogger(AutomaticTextAssessmentConflictService.class);\n+\n+    private final TextAssessmentConflictRepository textAssessmentConflictRepository;\n+\n+    private final FeedbackRepository feedbackRepository;\n+\n+    private final TextBlockRepository textBlockRepository;\n+\n+    private final TextAssessmentConflictService textAssessmentConflictService;\n+\n+    public AutomaticTextAssessmentConflictService(TextAssessmentConflictRepository textAssessmentConflictRepository, FeedbackRepository feedbackRepository,\n+            TextBlockRepository textBlockRepository, TextAssessmentConflictService textAssessmentConflictService) {\n+        this.textAssessmentConflictRepository = textAssessmentConflictRepository;\n+        this.feedbackRepository = feedbackRepository;\n+        this.textBlockRepository = textBlockRepository;\n+        this.textAssessmentConflictService = textAssessmentConflictService;\n+    }\n+\n+    /**\n+     *  This function asynchronously calls remote Athene service to check feedback consistency for the assessed submission.\n+     *  The call is made if the automatic assessments are enabled and the passed text blocks belong to any cluster.\n+     *\n+     * @param textBlocks - all text blocks in the text assessment\n+     * @param feedbackList - all feedback in the text assessment\n+     * @param exerciseId - exercise id of the assessed text exercise\n+     */\n+    @Async\n+    public void asyncCheckFeedbackConsistency(List<TextBlock> textBlocks, List<Feedback> feedbackList, long exerciseId) {\n+        // remove the feedback that does not belong to any text block\n+        feedbackList.removeIf(f -> !f.hasReference());\n+\n+        // If text block doesn't have a cluster id don't create an object\n+        List<TextAssessmentConflictRequestDTO> textAssessmentConflictRequestDTOS = feedbackList.stream().flatMap(feedback -> {\n+            Optional<TextBlock> textBlock = textBlockRepository\n+                    .findById(textBlocks.stream().filter(block -> block.getId().equals(feedback.getReference())).findFirst().get().getId());\n+            if (textBlock.isPresent() && textBlock.get().getCluster() != null) {\n+                return Stream.of(new TextAssessmentConflictRequestDTO(textBlock.get().getId(), textBlock.get().getText(), textBlock.get().getCluster().getId(), feedback.getId(),\n+                        feedback.getDetailText(), feedback.getCredits()));\n+            }\n+            else {\n+                return Stream.empty();\n+            }\n+        }).collect(toList());\n+\n+        if (textAssessmentConflictRequestDTOS.isEmpty()) {\n+            return;\n+        }\n+\n+        // remote service call to athene\n+        final List<TextAssessmentConflictResponseDTO> textAssessmentConflictResponseDTOS;\n+        try {\n+            textAssessmentConflictResponseDTOS = textAssessmentConflictService.checkFeedbackConsistencies(textAssessmentConflictRequestDTOS, exerciseId, 0);\n+        }\n+        catch (NetworkingError networkingError) {\n+            log.error(networkingError.getMessage(), networkingError);\n+            return;\n+        }\n+\n+        // create an array to store conflicts\n+        List<TextAssessmentConflict> textAssessmentConflicts = new ArrayList<>();\n+\n+        // look for new conflicts\n+        // Athene may find conflicts with feedback ids that are not in the feedback repository any more. So check for them. (May happen if the feedback is deleted in Artemis but\n+        // already stored in Athene)\n+        textAssessmentConflictResponseDTOS.forEach(conflict -> {\n+            Optional<Feedback> firstFeedback = feedbackRepository.findById(conflict.getFirstFeedbackId());\n+            Optional<Feedback> secondFeedback = feedbackRepository.findById(conflict.getSecondFeedbackId());\n+            List<TextAssessmentConflict> storedConflicts = this.textAssessmentConflictRepository.findByFirstAndSecondFeedback(conflict.getFirstFeedbackId(),\n+                    conflict.getSecondFeedbackId());\n+            // if the found conflict is present but its type has changed, update it\n+            if (!storedConflicts.isEmpty() && !storedConflicts.get(0).getType().equals(conflict.getType())) {\n+                storedConflicts.get(0).setType(conflict.getType());\n+                textAssessmentConflicts.add(storedConflicts.get(0));\n+            }\n+\n+            // new conflict\n+            if (firstFeedback.isPresent() && secondFeedback.isPresent() && storedConflicts.isEmpty()) {\n+                TextAssessmentConflict textAssessmentConflict = new TextAssessmentConflict();\n+                textAssessmentConflict.setConflict(true);\n+                textAssessmentConflict.setFirstFeedback(firstFeedback.get());\n+                textAssessmentConflict.setSecondFeedback(secondFeedback.get());\n+                textAssessmentConflict.setType(conflict.getType());\n+                textAssessmentConflict.setCreatedAt(ZonedDateTime.now());\n+                textAssessmentConflicts.add(textAssessmentConflict);\n+            }\n+        });\n+\n+        // find solved conflicts and add them to list\n+        textAssessmentConflicts.addAll(this.findSolvedConflicts(textAssessmentConflictRequestDTOS, textAssessmentConflictResponseDTOS));\n+\n+        textAssessmentConflictRepository.saveAll(textAssessmentConflicts);\n+    }\n+\n+    /**\n+     * Searches if the feedback that are sent to Athene already have conflicts in the database(storedConflicts),\n+     * If the stored conflicts are not returned from Athene after the consistency check, it means that they are solved and set as solved.\n+     *\n+     * @param textAssessmentConflictRequestDTOS the list sent to Athene for check\n+     * @param textAssessmentConflictResponseDTOS returned list with found conflicts.\n+     * @return solved conflicts\n+     */\n+    private List<TextAssessmentConflict> findSolvedConflicts(List<TextAssessmentConflictRequestDTO> textAssessmentConflictRequestDTOS,\n+            List<TextAssessmentConflictResponseDTO> textAssessmentConflictResponseDTOS) {\n+        List<Long> feedbackIds = textAssessmentConflictRequestDTOS.stream().map(TextAssessmentConflictRequestDTO::getFeedbackId).collect(toList());\n+        List<TextAssessmentConflict> storedConflicts = this.textAssessmentConflictRepository.findAllByFeedbackList(feedbackIds);\n+\n+        storedConflicts.forEach(conflict -> {\n+            boolean isPresent = textAssessmentConflictResponseDTOS.stream().anyMatch(newConflicts -> (newConflicts.getFirstFeedbackId() == conflict.getFirstFeedback().getId()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52da7b644d26412e05f43379e1868f8d4dccc081"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjUyODU4OnYy", "diffSide": "RIGHT", "path": "src/test/java/de/tum/in/www1/artemis/util/ModelFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMToxNjo0MVrOHZP7vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMToxNjo0MVrOHZP7vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzNzUwMA==", "bodyText": "Codacy found an issue: Missing a Javadoc comment.", "url": "https://github.com/ls1intum/Artemis/pull/1977#discussion_r496237500", "createdAt": "2020-09-28T21:16:41Z", "author": {"login": "artemis-bot"}, "path": "src/test/java/de/tum/in/www1/artemis/util/ModelFactory.java", "diffHunk": "@@ -483,6 +483,16 @@ private static Feedback generateStaticCodeAnalysisFeedback(int index) {\n         return feedbacks; // total score should be 3P\n     }\n \n+    public static TextAssessmentConflict generateTextAssessmentConflictWithFeedback(Feedback firstFeedback, Feedback secondFeedback) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52da7b644d26412e05f43379e1868f8d4dccc081"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4820, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}