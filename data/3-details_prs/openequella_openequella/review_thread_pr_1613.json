{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMzMyOTE2", "number": 1613, "reviewThreads": {"totalCount": 60, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzowMToyOFrODx8IoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzoxNDoxN1rOD0BT8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjkyMDY0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzowMToyOFrOGFsUMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODozOToxMVrOGFvmrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyMjEyOA==", "bodyText": "Help wanted here. The key should be unique, but items displayed in this list are possible to have no key (e.g. User creates a new filter and does not click save button). So I am not entirely sure what value should I put here. I don't think name is a good choice.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408622128", "createdAt": "2020-04-15T07:01:28Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableOwnerFilter}\n+                setValue={value => {\n+                  setOwnerFilter(value);\n+                }}\n+                id={\"disable_owner_filter_toggle\"}\n+              />\n+            }\n+          />\n+          <SettingsListControl\n+            primaryText={searchFilterStrings.disabledatemodifiedfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableDateModifiedFilter}\n+                setValue={value => {\n+                  setDateModifiedFilter(value);\n+                }}\n+                id={\"disable_date_modified_filter_toggle\"}\n+              />\n+            }\n+          />\n+        </SettingsList>\n+      </Card>\n+\n+      {/* MIME type filters */}\n+      <Card className={classes.spacedCards}>\n+        <List\n+          subheader={\n+            <ListSubheader disableGutters>\n+              {searchFilterStrings.mimetypefiltertitle}\n+            </ListSubheader>\n+          }\n+        >\n+          {mimeTypeFilters.map(filter => {\n+            return (\n+              <ListItem divider={true} key={filter.name}>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3NjAxMg==", "bodyText": "You could just use the index, it normally covers most bases unless the list is changing in odd ways.\n{mimeTypeFilters.map((filter, filterIdx) => (<ListItem divider key={filterIdx}.....", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408676012", "createdAt": "2020-04-15T08:39:11Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableOwnerFilter}\n+                setValue={value => {\n+                  setOwnerFilter(value);\n+                }}\n+                id={\"disable_owner_filter_toggle\"}\n+              />\n+            }\n+          />\n+          <SettingsListControl\n+            primaryText={searchFilterStrings.disabledatemodifiedfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableDateModifiedFilter}\n+                setValue={value => {\n+                  setDateModifiedFilter(value);\n+                }}\n+                id={\"disable_date_modified_filter_toggle\"}\n+              />\n+            }\n+          />\n+        </SettingsList>\n+      </Card>\n+\n+      {/* MIME type filters */}\n+      <Card className={classes.spacedCards}>\n+        <List\n+          subheader={\n+            <ListSubheader disableGutters>\n+              {searchFilterStrings.mimetypefiltertitle}\n+            </ListSubheader>\n+          }\n+        >\n+          {mimeTypeFilters.map(filter => {\n+            return (\n+              <ListItem divider={true} key={filter.name}>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyMjEyOA=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjkzNDQzOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzowNjoxNlrOGFsckw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzoxNDozN1rOGHCjvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDI3NQ==", "bodyText": "Help wanted again...Now we have a JSON body in this endpoint. One problem is if I put some unrecognised properties into the body, the Resteasy will return 500 directly because the marshalling Resteasy does fails. Many thanks to Resteasy, but can I handle this by myself without significant changes (e.g. change the value of FAIL_ON_UNKNOWN_PROPERTIES in RestEasyServlet) ?  I want to return 400 to client rather than 500.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408624275", "createdAt": "2020-04-15T07:06:16Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -111,58 +105,136 @@ class SearchFilterResource {\n       \"This endpoint is used to update a search filter. A JSON object representing the updated filter is returned if operation is successful.\",\n     response = classOf[SearchFilter]\n   )\n-  def updateSearchFilter(\n-      @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n-      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n-      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n-        String]): Response = {\n+  def updateSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n+                         searchFilter: SearchFilter): Response = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4NTIwMg==", "bodyText": "Not sure, it does sound odd and I would have thought Resteasy would have some global exception handling for unmarshalling to support responding with a 400", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408685202", "createdAt": "2020-04-15T08:54:32Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -111,58 +105,136 @@ class SearchFilterResource {\n       \"This endpoint is used to update a search filter. A JSON object representing the updated filter is returned if operation is successful.\",\n     response = classOf[SearchFilter]\n   )\n-  def updateSearchFilter(\n-      @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n-      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n-      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n-        String]): Response = {\n+  def updateSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n+                         searchFilter: SearchFilter): Response = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDI3NQ=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMTI4NQ==", "bodyText": "Didn't we do some RestEasy customisation recently - possibly even in the marshalling space? Do you recall @PenghaiZhang ?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409221285", "createdAt": "2020-04-16T01:06:39Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -111,58 +105,136 @@ class SearchFilterResource {\n       \"This endpoint is used to update a search filter. A JSON object representing the updated filter is returned if operation is successful.\",\n     response = classOf[SearchFilter]\n   )\n-  def updateSearchFilter(\n-      @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n-      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n-      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n-        String]): Response = {\n+  def updateSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n+                         searchFilter: SearchFilter): Response = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDI3NQ=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyNDIwOQ==", "bodyText": "Ahhh, I think I've found it... com.tle.web.remoting.resteasy.RestEasyExceptionMapper\nCan we do what you're after there abouts?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409224209", "createdAt": "2020-04-16T01:17:09Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -111,58 +105,136 @@ class SearchFilterResource {\n       \"This endpoint is used to update a search filter. A JSON object representing the updated filter is returned if operation is successful.\",\n     response = classOf[SearchFilter]\n   )\n-  def updateSearchFilter(\n-      @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n-      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n-      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n-        String]): Response = {\n+  def updateSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n+                         searchFilter: SearchFilter): Response = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDI3NQ=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzNTEzMg==", "bodyText": "As I recall,  when we were fixing the resource-centre log issue, we came across this file but we did not make any changes. But in this PR, I add one change to handle unmarshalling failure", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410035132", "createdAt": "2020-04-17T07:14:37Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -111,58 +105,136 @@ class SearchFilterResource {\n       \"This endpoint is used to update a search filter. A JSON object representing the updated filter is returned if operation is successful.\",\n     response = classOf[SearchFilter]\n   )\n-  def updateSearchFilter(\n-      @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n-      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n-      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n-        String]): Response = {\n+  def updateSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n+                         searchFilter: SearchFilter): Response = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDI3NQ=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk2MDUxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNDozNVrOGFsscQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNDozNVrOGFsscQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyODMzNw==", "bodyText": "Recommend JS doc be added to the props and component", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408628337", "createdAt": "2020-04-15T07:14:35Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk2Mjk2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNToyNVrOGFst-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzo0NjowNlrOGGPcwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyODcyOA==", "bodyText": "Double import, this can be done in the initial import", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408628728", "createdAt": "2020-04-15T07:15:25Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5Nzc2MA==", "bodyText": "I need to add  \"allowSyntheticDefaultImports\": true to tsconfig in order to do this, otherwise I have a TS1259 error", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409197760", "createdAt": "2020-04-15T23:46:06Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyODcyOA=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk2NTg0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNjoyMVrOGFsvqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNjoyMVrOGFsvqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyOTE2MA==", "bodyText": "JS doc would be good here to identify it's cleaning up on close", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408629160", "createdAt": "2020-04-15T07:16:21Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({\n+  open,\n+  onClose,\n+  mimeTypeFilter,\n+  addOrUpdate,\n+  updateTemplate\n+}: MimeTypeFilterEditorProps) => {\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  const [mimeTypeEntries, setMimeTypeEntries] = useState<MimeTypeEntry[]>([]);\n+  // Used to store the name of a MIME type filter\n+  const [filterName, setFilterName] = useState<string>(\"\");\n+  // Used to store the MIME types of a MIME type filter\n+  const [selectedMimeTypes, setSelectedMimeTypes] = useState<string[]>([]);\n+\n+  useEffect(() => {\n+    getMIMETypesFromServer()\n+      .then(mimeTypes => setMimeTypeEntries(mimeTypes))\n+      .catch(error => updateTemplate(templateError(fromAxiosError(error))));\n+  }, []);\n+\n+  useEffect(() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk3MDkyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxODowMFrOGFsyxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxODowMFrOGFsyxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyOTk1OQ==", "bodyText": "Not sure the semicolon is valid here", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408629959", "createdAt": "2020-04-15T07:18:00Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({\n+  open,\n+  onClose,\n+  mimeTypeFilter,\n+  addOrUpdate,\n+  updateTemplate\n+}: MimeTypeFilterEditorProps) => {\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  const [mimeTypeEntries, setMimeTypeEntries] = useState<MimeTypeEntry[]>([]);\n+  // Used to store the name of a MIME type filter\n+  const [filterName, setFilterName] = useState<string>(\"\");\n+  // Used to store the MIME types of a MIME type filter\n+  const [selectedMimeTypes, setSelectedMimeTypes] = useState<string[]>([]);\n+\n+  useEffect(() => {\n+    getMIMETypesFromServer()\n+      .then(mimeTypes => setMimeTypeEntries(mimeTypes))\n+      .catch(error => updateTemplate(templateError(fromAxiosError(error))));\n+  }, []);\n+\n+  useEffect(() => {\n+    setFilterName(mimeTypeFilter ? mimeTypeFilter.name : \"\");\n+    setSelectedMimeTypes(mimeTypeFilter ? mimeTypeFilter.mimeTypes : []);\n+  }, [onClose]);\n+\n+  /**\n+   * If a MIME type is selected and it doesn't exist in the collection of selected MIME types,\n+   * then add it to the collection;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk3MTM3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxODowOFrOGFszEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDo0MjoyMVrOGGQeTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzMDAzMg==", "bodyText": "Help wanted here. The issue is how to make a MUI list in a MUI dialog scrollable, rather than the dialog itself scrollable.\nI had a discussion with Tom regarding this, but did not have any luck with MUI Grid and Flexbox styles so in the end I had to use this old approach. Does anybody have suggestions?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408630032", "createdAt": "2020-04-15T07:18:08Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,70 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNDU0MA==", "bodyText": "I'm fine with this for now.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409214540", "createdAt": "2020-04-16T00:42:21Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,70 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzMDAzMg=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAwOTUxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyOTozNlrOGFtK5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyOTozNlrOGFtK5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNjEzNQ==", "bodyText": "Just a musing but it's possible checked is true and item is in list in which case the else if will be called but there's no harm as the else if condition will be false.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408636135", "createdAt": "2020-04-15T07:29:36Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({\n+  open,\n+  onClose,\n+  mimeTypeFilter,\n+  addOrUpdate,\n+  updateTemplate\n+}: MimeTypeFilterEditorProps) => {\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  const [mimeTypeEntries, setMimeTypeEntries] = useState<MimeTypeEntry[]>([]);\n+  // Used to store the name of a MIME type filter\n+  const [filterName, setFilterName] = useState<string>(\"\");\n+  // Used to store the MIME types of a MIME type filter\n+  const [selectedMimeTypes, setSelectedMimeTypes] = useState<string[]>([]);\n+\n+  useEffect(() => {\n+    getMIMETypesFromServer()\n+      .then(mimeTypes => setMimeTypeEntries(mimeTypes))\n+      .catch(error => updateTemplate(templateError(fromAxiosError(error))));\n+  }, []);\n+\n+  useEffect(() => {\n+    setFilterName(mimeTypeFilter ? mimeTypeFilter.name : \"\");\n+    setSelectedMimeTypes(mimeTypeFilter ? mimeTypeFilter.mimeTypes : []);\n+  }, [onClose]);\n+\n+  /**\n+   * If a MIME type is selected and it doesn't exist in the collection of selected MIME types,\n+   * then add it to the collection;\n+   * if a MIME type is unselected and it exists in the collection of selected MIME types,\n+   * then remove it from the collection.\n+   */\n+  const updateMimeTypeSelections = React.useCallback(\n+    (checked: boolean, mimeType: string) => {\n+      if (checked && selectedMimeTypes.indexOf(mimeType) < 0) {\n+        setSelectedMimeTypes([...selectedMimeTypes, mimeType]);\n+      } else if (!checked && selectedMimeTypes.indexOf(mimeType) > -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAxMzI2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozMDozM1rOGFtNDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozMDozM1rOGFtNDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNjY4Ng==", "bodyText": "Not sure there's any value in this, the setFilterName can be used directly", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408636686", "createdAt": "2020-04-15T07:30:33Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({\n+  open,\n+  onClose,\n+  mimeTypeFilter,\n+  addOrUpdate,\n+  updateTemplate\n+}: MimeTypeFilterEditorProps) => {\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  const [mimeTypeEntries, setMimeTypeEntries] = useState<MimeTypeEntry[]>([]);\n+  // Used to store the name of a MIME type filter\n+  const [filterName, setFilterName] = useState<string>(\"\");\n+  // Used to store the MIME types of a MIME type filter\n+  const [selectedMimeTypes, setSelectedMimeTypes] = useState<string[]>([]);\n+\n+  useEffect(() => {\n+    getMIMETypesFromServer()\n+      .then(mimeTypes => setMimeTypeEntries(mimeTypes))\n+      .catch(error => updateTemplate(templateError(fromAxiosError(error))));\n+  }, []);\n+\n+  useEffect(() => {\n+    setFilterName(mimeTypeFilter ? mimeTypeFilter.name : \"\");\n+    setSelectedMimeTypes(mimeTypeFilter ? mimeTypeFilter.mimeTypes : []);\n+  }, [onClose]);\n+\n+  /**\n+   * If a MIME type is selected and it doesn't exist in the collection of selected MIME types,\n+   * then add it to the collection;\n+   * if a MIME type is unselected and it exists in the collection of selected MIME types,\n+   * then remove it from the collection.\n+   */\n+  const updateMimeTypeSelections = React.useCallback(\n+    (checked: boolean, mimeType: string) => {\n+      if (checked && selectedMimeTypes.indexOf(mimeType) < 0) {\n+        setSelectedMimeTypes([...selectedMimeTypes, mimeType]);\n+      } else if (!checked && selectedMimeTypes.indexOf(mimeType) > -1) {\n+        setSelectedMimeTypes(\n+          selectedMimeTypes.filter(selection => selection !== mimeType)\n+        );\n+      }\n+    },\n+    [selectedMimeTypes]\n+  );\n+\n+  const updateFilterName = (name: string) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAxOTYwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozMjoyNVrOGFtQ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozMjoyNVrOGFtQ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNzY3OQ==", "bodyText": "The ={true} shoudn't be needed (just like the fullWidth attribute), it can just be\n<Dialog open={open} onClose={onClose} disableBackdropClick disableEscapeKeyDown fullWidth>", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408637679", "createdAt": "2020-04-15T07:32:25Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({\n+  open,\n+  onClose,\n+  mimeTypeFilter,\n+  addOrUpdate,\n+  updateTemplate\n+}: MimeTypeFilterEditorProps) => {\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  const [mimeTypeEntries, setMimeTypeEntries] = useState<MimeTypeEntry[]>([]);\n+  // Used to store the name of a MIME type filter\n+  const [filterName, setFilterName] = useState<string>(\"\");\n+  // Used to store the MIME types of a MIME type filter\n+  const [selectedMimeTypes, setSelectedMimeTypes] = useState<string[]>([]);\n+\n+  useEffect(() => {\n+    getMIMETypesFromServer()\n+      .then(mimeTypes => setMimeTypeEntries(mimeTypes))\n+      .catch(error => updateTemplate(templateError(fromAxiosError(error))));\n+  }, []);\n+\n+  useEffect(() => {\n+    setFilterName(mimeTypeFilter ? mimeTypeFilter.name : \"\");\n+    setSelectedMimeTypes(mimeTypeFilter ? mimeTypeFilter.mimeTypes : []);\n+  }, [onClose]);\n+\n+  /**\n+   * If a MIME type is selected and it doesn't exist in the collection of selected MIME types,\n+   * then add it to the collection;\n+   * if a MIME type is unselected and it exists in the collection of selected MIME types,\n+   * then remove it from the collection.\n+   */\n+  const updateMimeTypeSelections = React.useCallback(\n+    (checked: boolean, mimeType: string) => {\n+      if (checked && selectedMimeTypes.indexOf(mimeType) < 0) {\n+        setSelectedMimeTypes([...selectedMimeTypes, mimeType]);\n+      } else if (!checked && selectedMimeTypes.indexOf(mimeType) > -1) {\n+        setSelectedMimeTypes(\n+          selectedMimeTypes.filter(selection => selection !== mimeType)\n+        );\n+      }\n+    },\n+    [selectedMimeTypes]\n+  );\n+\n+  const updateFilterName = (name: string) => {\n+    setFilterName(name);\n+  };\n+\n+  const onAddOrUpdate = () => {\n+    addOrUpdate({\n+      id: mimeTypeFilter?.id,\n+      name: filterName,\n+      mimeTypes: selectedMimeTypes\n+    });\n+    onClose();\n+  };\n+\n+  const isNameValid = vaidateMimeTypeName(filterName);\n+  const DIALOG_TITLE = mimeTypeFilter\n+    ? searchFilterStrings.edit\n+    : searchFilterStrings.add;\n+\n+  return (\n+    <Dialog\n+      open={open}\n+      onClose={onClose}\n+      disableBackdropClick={true}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAyODQ5OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozNTowN1rOGFtWcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDoxODoyNVrOGGQD9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTA5MA==", "bodyText": "Is the intention this text will always be shown?  or only on an error?\nI'd normally expect this to become the error text for the control", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408639090", "createdAt": "2020-04-15T07:35:07Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({\n+  open,\n+  onClose,\n+  mimeTypeFilter,\n+  addOrUpdate,\n+  updateTemplate\n+}: MimeTypeFilterEditorProps) => {\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  const [mimeTypeEntries, setMimeTypeEntries] = useState<MimeTypeEntry[]>([]);\n+  // Used to store the name of a MIME type filter\n+  const [filterName, setFilterName] = useState<string>(\"\");\n+  // Used to store the MIME types of a MIME type filter\n+  const [selectedMimeTypes, setSelectedMimeTypes] = useState<string[]>([]);\n+\n+  useEffect(() => {\n+    getMIMETypesFromServer()\n+      .then(mimeTypes => setMimeTypeEntries(mimeTypes))\n+      .catch(error => updateTemplate(templateError(fromAxiosError(error))));\n+  }, []);\n+\n+  useEffect(() => {\n+    setFilterName(mimeTypeFilter ? mimeTypeFilter.name : \"\");\n+    setSelectedMimeTypes(mimeTypeFilter ? mimeTypeFilter.mimeTypes : []);\n+  }, [onClose]);\n+\n+  /**\n+   * If a MIME type is selected and it doesn't exist in the collection of selected MIME types,\n+   * then add it to the collection;\n+   * if a MIME type is unselected and it exists in the collection of selected MIME types,\n+   * then remove it from the collection.\n+   */\n+  const updateMimeTypeSelections = React.useCallback(\n+    (checked: boolean, mimeType: string) => {\n+      if (checked && selectedMimeTypes.indexOf(mimeType) < 0) {\n+        setSelectedMimeTypes([...selectedMimeTypes, mimeType]);\n+      } else if (!checked && selectedMimeTypes.indexOf(mimeType) > -1) {\n+        setSelectedMimeTypes(\n+          selectedMimeTypes.filter(selection => selection !== mimeType)\n+        );\n+      }\n+    },\n+    [selectedMimeTypes]\n+  );\n+\n+  const updateFilterName = (name: string) => {\n+    setFilterName(name);\n+  };\n+\n+  const onAddOrUpdate = () => {\n+    addOrUpdate({\n+      id: mimeTypeFilter?.id,\n+      name: filterName,\n+      mimeTypes: selectedMimeTypes\n+    });\n+    onClose();\n+  };\n+\n+  const isNameValid = vaidateMimeTypeName(filterName);\n+  const DIALOG_TITLE = mimeTypeFilter\n+    ? searchFilterStrings.edit\n+    : searchFilterStrings.add;\n+\n+  return (\n+    <Dialog\n+      open={open}\n+      onClose={onClose}\n+      disableBackdropClick={true}\n+      disableEscapeKeyDown={true}\n+      fullWidth\n+    >\n+      <DialogTitle>{DIALOG_TITLE}</DialogTitle>\n+      <DialogContent>\n+        <TextField\n+          margin=\"dense\"\n+          label={searchFilterStrings.filternamelabel}\n+          value={filterName}\n+          required\n+          fullWidth\n+          helperText={searchFilterStrings.helptext}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNzc5OA==", "bodyText": "No, I will remove it.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409207798", "createdAt": "2020-04-16T00:18:25Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({\n+  open,\n+  onClose,\n+  mimeTypeFilter,\n+  addOrUpdate,\n+  updateTemplate\n+}: MimeTypeFilterEditorProps) => {\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  const [mimeTypeEntries, setMimeTypeEntries] = useState<MimeTypeEntry[]>([]);\n+  // Used to store the name of a MIME type filter\n+  const [filterName, setFilterName] = useState<string>(\"\");\n+  // Used to store the MIME types of a MIME type filter\n+  const [selectedMimeTypes, setSelectedMimeTypes] = useState<string[]>([]);\n+\n+  useEffect(() => {\n+    getMIMETypesFromServer()\n+      .then(mimeTypes => setMimeTypeEntries(mimeTypes))\n+      .catch(error => updateTemplate(templateError(fromAxiosError(error))));\n+  }, []);\n+\n+  useEffect(() => {\n+    setFilterName(mimeTypeFilter ? mimeTypeFilter.name : \"\");\n+    setSelectedMimeTypes(mimeTypeFilter ? mimeTypeFilter.mimeTypes : []);\n+  }, [onClose]);\n+\n+  /**\n+   * If a MIME type is selected and it doesn't exist in the collection of selected MIME types,\n+   * then add it to the collection;\n+   * if a MIME type is unselected and it exists in the collection of selected MIME types,\n+   * then remove it from the collection.\n+   */\n+  const updateMimeTypeSelections = React.useCallback(\n+    (checked: boolean, mimeType: string) => {\n+      if (checked && selectedMimeTypes.indexOf(mimeType) < 0) {\n+        setSelectedMimeTypes([...selectedMimeTypes, mimeType]);\n+      } else if (!checked && selectedMimeTypes.indexOf(mimeType) > -1) {\n+        setSelectedMimeTypes(\n+          selectedMimeTypes.filter(selection => selection !== mimeType)\n+        );\n+      }\n+    },\n+    [selectedMimeTypes]\n+  );\n+\n+  const updateFilterName = (name: string) => {\n+    setFilterName(name);\n+  };\n+\n+  const onAddOrUpdate = () => {\n+    addOrUpdate({\n+      id: mimeTypeFilter?.id,\n+      name: filterName,\n+      mimeTypes: selectedMimeTypes\n+    });\n+    onClose();\n+  };\n+\n+  const isNameValid = vaidateMimeTypeName(filterName);\n+  const DIALOG_TITLE = mimeTypeFilter\n+    ? searchFilterStrings.edit\n+    : searchFilterStrings.add;\n+\n+  return (\n+    <Dialog\n+      open={open}\n+      onClose={onClose}\n+      disableBackdropClick={true}\n+      disableEscapeKeyDown={true}\n+      fullWidth\n+    >\n+      <DialogTitle>{DIALOG_TITLE}</DialogTitle>\n+      <DialogContent>\n+        <TextField\n+          margin=\"dense\"\n+          label={searchFilterStrings.filternamelabel}\n+          value={filterName}\n+          required\n+          fullWidth\n+          helperText={searchFilterStrings.helptext}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTA5MA=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAzMTY4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozNjowOVrOGFtYjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDoxNTo1NFrOGGQBFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTYzMA==", "bodyText": "Mixed thoughts on this but any thoughts on whether the component name should include Dialog to indicate it's a dialog?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408639630", "createdAt": "2020-04-15T07:36:09Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNzA2Mw==", "bodyText": "What about MimeTypeFilterEditingDialog ?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409207063", "createdAt": "2020-04-16T00:15:54Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditor.tsx", "diffHunk": "@@ -0,0 +1,139 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { MimeTypeList } from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+\n+interface MimeTypeFilterEditorProps {\n+  open: boolean;\n+  onClose: () => void;\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  mimeTypeFilter?: MimeTypeFilter;\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+const MimeTypeFilterEditor = ({", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTYzMA=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA0MTA2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozODo1MVrOGFteSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozODo1MVrOGFteSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MTA5Nw==", "bodyText": "Recommend a default export be added and the React.memo be added to the default export rather than the component function declaration", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408641097", "createdAt": "2020-04-15T07:38:51Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,70 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,\n+    overflow: \"auto\"\n+  },\n+  listTitle: {\n+    marginTop: 20\n+  }\n+});\n+\n+interface MimeTypeFilterListProps {\n+  entries: MimeTypeEntry[];\n+  onChange(check: boolean, mimeType: string): void;\n+  selected?: string[];\n+}\n+\n+export const MimeTypeList = React.memo(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA0NzQ3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0MDoyN1rOGFth7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0MDoyN1rOGFth7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjAzMA==", "bodyText": "Barring getting this working with flexbox (or go insane with CSS grid), can the max height be set on the List component instead?  That'd remove the need for the div.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408642030", "createdAt": "2020-04-15T07:40:27Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,70 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,\n+    overflow: \"auto\"\n+  },\n+  listTitle: {\n+    marginTop: 20\n+  }\n+});\n+\n+interface MimeTypeFilterListProps {\n+  entries: MimeTypeEntry[];\n+  onChange(check: boolean, mimeType: string): void;\n+  selected?: string[];\n+}\n+\n+export const MimeTypeList = React.memo(\n+  ({ entries, onChange, selected }: MimeTypeFilterListProps) => {\n+    const classes = useStyles();\n+    const searchFilterStrings =\n+      languageStrings.settings.searching.searchfiltersettings;\n+\n+    return (\n+      <div className={classes.list}>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA1MjQwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0MTo0OVrOGFtkvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0MTo0OVrOGFtkvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0Mjc0OA==", "bodyText": "I take it the subtitle2 is by design?  If it is then it should be part of the global MUI theme with an override entry in the theme.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408642748", "createdAt": "2020-04-15T07:41:49Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,70 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,\n+    overflow: \"auto\"\n+  },\n+  listTitle: {\n+    marginTop: 20\n+  }\n+});\n+\n+interface MimeTypeFilterListProps {\n+  entries: MimeTypeEntry[];\n+  onChange(check: boolean, mimeType: string): void;\n+  selected?: string[];\n+}\n+\n+export const MimeTypeList = React.memo(\n+  ({ entries, onChange, selected }: MimeTypeFilterListProps) => {\n+    const classes = useStyles();\n+    const searchFilterStrings =\n+      languageStrings.settings.searching.searchfiltersettings;\n+\n+    return (\n+      <div className={classes.list}>\n+        <List\n+          subheader={\n+            <Typography\n+              variant={\"subtitle2\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA1NDQyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0MjozMlrOGFtmHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0MjozMlrOGFtmHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MzEwMA==", "bodyText": "This should have a key attribute", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408643100", "createdAt": "2020-04-15T07:42:32Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,70 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,\n+    overflow: \"auto\"\n+  },\n+  listTitle: {\n+    marginTop: 20\n+  }\n+});\n+\n+interface MimeTypeFilterListProps {\n+  entries: MimeTypeEntry[];\n+  onChange(check: boolean, mimeType: string): void;\n+  selected?: string[];\n+}\n+\n+export const MimeTypeList = React.memo(\n+  ({ entries, onChange, selected }: MimeTypeFilterListProps) => {\n+    const classes = useStyles();\n+    const searchFilterStrings =\n+      languageStrings.settings.searching.searchfiltersettings;\n+\n+    return (\n+      <div className={classes.list}>\n+        <List\n+          subheader={\n+            <Typography\n+              variant={\"subtitle2\"}\n+              color={\"textSecondary\"}\n+              className={classes.listTitle}\n+            >\n+              {searchFilterStrings.mimetypelistlabel}\n+            </Typography>\n+          }\n+        >\n+          {entries.map(entry => {\n+            let checked = false;\n+            if (selected && selected.indexOf(entry.mimeType) >= 0) {\n+              checked = true;\n+            }\n+            return (\n+              <ListItem key={entry.mimeType} className={classes.item}>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA2NTAzOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0NToxMlrOGFtsVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0NToxMlrOGFtsVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDY5Mg==", "bodyText": "Not sure on the benefits of having a dedicated variable for the checked flag, it could just be checked={selected?.indexOf(entry.mimeType) >= 0}.\nThere's a bit of indexOf handling so far, you could have a helper function that takes a nullable/undefinable array to do this sort of check", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408644692", "createdAt": "2020-04-15T07:45:12Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,70 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,\n+    overflow: \"auto\"\n+  },\n+  listTitle: {\n+    marginTop: 20\n+  }\n+});\n+\n+interface MimeTypeFilterListProps {\n+  entries: MimeTypeEntry[];\n+  onChange(check: boolean, mimeType: string): void;\n+  selected?: string[];\n+}\n+\n+export const MimeTypeList = React.memo(\n+  ({ entries, onChange, selected }: MimeTypeFilterListProps) => {\n+    const classes = useStyles();\n+    const searchFilterStrings =\n+      languageStrings.settings.searching.searchfiltersettings;\n+\n+    return (\n+      <div className={classes.list}>\n+        <List\n+          subheader={\n+            <Typography\n+              variant={\"subtitle2\"}\n+              color={\"textSecondary\"}\n+              className={classes.listTitle}\n+            >\n+              {searchFilterStrings.mimetypelistlabel}\n+            </Typography>\n+          }\n+        >\n+          {entries.map(entry => {\n+            let checked = false;\n+            if (selected && selected.indexOf(entry.mimeType) >= 0) {\n+              checked = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA2ODQ4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0NjowNlrOGFtuZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0NjowNlrOGFtuZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NTIyMQ==", "bodyText": "The checked variable name is shadowed, surprised TS lint didn't complain about it", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408645221", "createdAt": "2020-04-15T07:46:06Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,70 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,\n+    overflow: \"auto\"\n+  },\n+  listTitle: {\n+    marginTop: 20\n+  }\n+});\n+\n+interface MimeTypeFilterListProps {\n+  entries: MimeTypeEntry[];\n+  onChange(check: boolean, mimeType: string): void;\n+  selected?: string[];\n+}\n+\n+export const MimeTypeList = React.memo(\n+  ({ entries, onChange, selected }: MimeTypeFilterListProps) => {\n+    const classes = useStyles();\n+    const searchFilterStrings =\n+      languageStrings.settings.searching.searchfiltersettings;\n+\n+    return (\n+      <div className={classes.list}>\n+        <List\n+          subheader={\n+            <Typography\n+              variant={\"subtitle2\"}\n+              color={\"textSecondary\"}\n+              className={classes.listTitle}\n+            >\n+              {searchFilterStrings.mimetypelistlabel}\n+            </Typography>\n+          }\n+        >\n+          {entries.map(entry => {\n+            let checked = false;\n+            if (selected && selected.indexOf(entry.mimeType) >= 0) {\n+              checked = true;\n+            }\n+            return (\n+              <ListItem key={entry.mimeType} className={classes.item}>\n+                <Checkbox\n+                  checked={checked}\n+                  onChange={(_, checked) => onChange(checked, entry.mimeType)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA3NTkzOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0ODoyOFrOGFtzKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0ODoyOFrOGFtzKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NjQ0MQ==", "bodyText": "Can save some lines\nexport const vaidateMimeTypeName = (name: string | undefined): boolean => !!names?.trim();", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408646441", "createdAt": "2020-04-15T07:48:28Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsModule.ts", "diffHunk": "@@ -0,0 +1,43 @@\n+import Axios from \"axios\";\n+import { encodeQuery } from \"../../../util/encodequery\";\n+\n+export interface MimeTypeFilter {\n+  id?: string;\n+  name: string;\n+  mimeTypes: string[];\n+}\n+\n+export interface MimeTypeEntry {\n+  mimeType: string;\n+  desc: string;\n+}\n+\n+const MIME_TYPE_FILTERS_URL = \"api/settings/search/filter\";\n+const MIME_TYPE_URL = \"api/settings/mimetype\";\n+\n+export const getMimeTypeFiltersFromServer = (): Promise<MimeTypeFilter[]> =>\n+  Axios.get(MIME_TYPE_FILTERS_URL).then(res => res.data);\n+\n+export const getMIMETypesFromServer = (): Promise<MimeTypeEntry[]> =>\n+  Axios.get(MIME_TYPE_URL).then(res => res.data);\n+\n+export const batchUpdateOrAdd = (filters: MimeTypeFilter[]) =>\n+  Axios.put(MIME_TYPE_FILTERS_URL, filters);\n+\n+export const batchDelete = (ids: string[]) =>\n+  Axios.delete(`${MIME_TYPE_FILTERS_URL}/${encodeQuery({ ids: ids })}`);\n+\n+export const getMimeTypeDetail = (entry: MimeTypeEntry) => {\n+  const { mimeType, desc } = entry;\n+  if (desc) {\n+    return `${desc} (${mimeType})`;\n+  }\n+  return mimeType;\n+};\n+\n+export const vaidateMimeTypeName = (name: string | undefined): boolean => {\n+  if (name?.trim()) {\n+    return true;\n+  }\n+  return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA3OTA1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0OToyNVrOGFt1Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0OToyNVrOGFt1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0Njk2Nw==", "bodyText": "Has this been repeated somewhere?  I thought Sam had done something similar", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408646967", "createdAt": "2020-04-15T07:49:25Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA4ODM4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo1MjoxMFrOGFt7Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo1MjoxMFrOGFt7Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0ODUwNw==", "bodyText": "Multiple effects listening for the same change ([]), a single effect can be used", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408648507", "createdAt": "2020-04-15T07:52:10Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzEwNDQyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo1NjozNVrOGFuFPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo1NjozNVrOGFuFPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1MTA2OQ==", "bodyText": "Hard to tell without testing it but it looks like the setChangedMimeTypeFilters may be called twice (once here and previously in initial if else).\nA replace in index helper function may help reduce the bloat on this page, there's repeated checks to find something in an array, clone the array, change the element at the index, call a set", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408651069", "createdAt": "2020-04-15T07:56:35Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzEyNDAzOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowMTo1N1rOGFuRkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNjo1MTo0NVrOGHB8Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NDIyNA==", "bodyText": "This approach is hard to track and seems cumbersome.\nAn alternate approach is to add another interface that extends the MimeTypeFilter with flags to indicate whether they're deleted or dirty, would reduce the number of state and handlers but would mean the handlers that remain would be more complex", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408654224", "createdAt": "2020-04-15T08:01:57Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAyNTAxMA==", "bodyText": "As discussed, let me keep this for now.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410025010", "createdAt": "2020-04-17T06:51:45Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NDIyNA=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzEzNDQ4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowNDo1OFrOGFuYFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowNDo1OFrOGFuYFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NTg5NA==", "bodyText": "Not sure on the benefits of having a dedicated function to do this as it's only done once, makes the SettingsListControl attributes look nicer but adds bloat to the page\nThe name of the function doesn't really explain what it's doing, it's seems more like disableOwnerFilter or toggleOwnerFilter", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408655894", "createdAt": "2020-04-15T08:04:58Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE0NjUwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowODozNlrOGFufwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowODozNlrOGFufwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1Nzg1Nw==", "bodyText": "Personal preference but it looks like there's some overuse of state, it may be simpler to just keep the initial search settings rather than pick pieces out of it", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408657857", "createdAt": "2020-04-15T08:08:36Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE3MzU4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxNjoxOFrOGFuwkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1NjoxMFrOGGVpug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2MjE2MA==", "bodyText": "I haven't used the indexOf a lot outside of arrays of primitives, I take it this is doing a pointer check or a shallow equality check?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408662160", "createdAt": "2020-04-15T08:16:18Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTM4Ng==", "bodyText": "Yes, indexOf does strict equality comparison, I think.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409299386", "createdAt": "2020-04-16T05:56:10Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2MjE2MA=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE4MDEwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxODowNVrOGFu0yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxODowNVrOGFu0yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2MzI0Mg==", "bodyText": "again a helper function to deal with arrays would reduce the bloat and simplify testing a bit", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408663242", "createdAt": "2020-04-15T08:18:05Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE4NzU2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxOTo1NFrOGFu5VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxOTo1NFrOGFu5VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NDQwNA==", "bodyText": "Flipping between functions and variable declarations, may be better to move the variable constants to above the functions (below the hooks and state).", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408664404", "createdAt": "2020-04-15T08:19:54Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE5ODE0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoyMjo1NlrOGFvAHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoyMjo1NlrOGFvAHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NjE0MA==", "bodyText": "Seek and destroy commented out code", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408666140", "createdAt": "2020-04-15T08:22:56Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzIwNzg4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoyNToyNlrOGFvGFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoyNToyNlrOGFvGFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NzY2OA==", "bodyText": "I take it there's no concerns that this isn't an equality check of the values but a check of the instance pointer?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408667668", "createdAt": "2020-04-15T08:25:26Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzIxMjM4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoyNjozOFrOGFvI6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoyNjozOFrOGFvI6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2ODM5NA==", "bodyText": "If this if condition is false then this function does nothing.  It could be flipped to check that nothing has changed and if so then return early, saving having logic nested in the if statement", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408668394", "createdAt": "2020-04-15T08:26:38Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzIzNTE3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODozMjo0MlrOGFvXQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNjozMToyNlrOGHBfqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3MjA2Ng==", "bodyText": "Repeating pattern, a helper function could be added to reduce the noise.\nI can't tell if the error handling will indicate what went wrong.  What does the page look like if you click save while offline?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408672066", "createdAt": "2020-04-15T08:32:42Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAxNzcwNA==", "bodyText": "As discussed, let me leave this repeating pattern at the moment.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410017704", "createdAt": "2020-04-17T06:31:26Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3MjA2Ng=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzI0NTgxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODozNToyM1rOGFvdzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODozNToyM1rOGFvdzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3Mzc0Mw==", "bodyText": "This looks familiar, I recommend MUI Grids to handle the layouts and spacing rather than spacedCards styling as it seems to be a standard layout", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408673743", "createdAt": "2020-04-15T08:35:23Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzI0ODgwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODozNjoxNFrOGFvfoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDo1MzowMVrOGGQqFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3NDIwOA==", "bodyText": "This looks odd, the SettingsListControl should support undefined secondaryText rather than needing to defined a blank string.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408674208", "createdAt": "2020-04-15T08:36:14Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNzU1OQ==", "bodyText": "Heh, I was about to make the same comment. So let's definitely sort this.\nAlternatively, add some test. e.g. \"Hides the owner filter on search pages.\" (And then similar for the below date modified filter.)", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409217559", "createdAt": "2020-04-16T00:53:01Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3NDIwOA=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzI1MzE3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODozNzoyM1rOGFviTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMjoxNDo1MFrOGGSCWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3NDg5Mg==", "bodyText": "Personal preference, but this can be reduced to one line rather than three lines (which are adding to the length of the code).\nsetValue={setOwnerFilter}", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408674892", "createdAt": "2020-04-15T08:37:23Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableOwnerFilter}\n+                setValue={value => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI0MDE1NA==", "bodyText": "As you mentioned above, the benefit of having setOwnerFilter is to make the attributes of SettingsToggleSwitch look nicer, but it's only used once in here. So I removed it.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409240154", "createdAt": "2020-04-16T02:14:50Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableOwnerFilter}\n+                setValue={value => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3NDg5Mg=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzI2NTE4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo0MDoyNVrOGFvpog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo0MDoyNVrOGFvpog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3Njc3MA==", "bodyText": "Trivial point but seeing a bit of flip flopping with curly brackets around attribute names and handlers\ncolor={\"secondary\"} versus color=\"secondary\"\nonClick={() => ....} versus onClick={() => { return.....}}", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408676770", "createdAt": "2020-04-15T08:40:25Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableOwnerFilter}\n+                setValue={value => {\n+                  setOwnerFilter(value);\n+                }}\n+                id={\"disable_owner_filter_toggle\"}\n+              />\n+            }\n+          />\n+          <SettingsListControl\n+            primaryText={searchFilterStrings.disabledatemodifiedfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableDateModifiedFilter}\n+                setValue={value => {\n+                  setDateModifiedFilter(value);\n+                }}\n+                id={\"disable_date_modified_filter_toggle\"}\n+              />\n+            }\n+          />\n+        </SettingsList>\n+      </Card>\n+\n+      {/* MIME type filters */}\n+      <Card className={classes.spacedCards}>\n+        <List\n+          subheader={\n+            <ListSubheader disableGutters>\n+              {searchFilterStrings.mimetypefiltertitle}\n+            </ListSubheader>\n+          }\n+        >\n+          {mimeTypeFilters.map(filter => {\n+            return (\n+              <ListItem divider={true} key={filter.name}>\n+                <ListItemText primary={filter.name} />\n+                <ListItemSecondaryAction>\n+                  <IconButton\n+                    onClick={() => {\n+                      openMimeTypeFilterDialog(filter);\n+                    }}\n+                    aria-label={`${searchFilterStrings.edit} ${filter.name}`}\n+                    color=\"secondary\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 341}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzI3OTE3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo0Mzo1NFrOGFvx8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDo1NDoxMlrOGGQrfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3ODg5OQ==", "bodyText": "Common save button should be a separate component, reduces what this page needs to style (i.e. which should be one offs specific to this page)", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408678899", "createdAt": "2020-04-15T08:43:54Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableOwnerFilter}\n+                setValue={value => {\n+                  setOwnerFilter(value);\n+                }}\n+                id={\"disable_owner_filter_toggle\"}\n+              />\n+            }\n+          />\n+          <SettingsListControl\n+            primaryText={searchFilterStrings.disabledatemodifiedfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableDateModifiedFilter}\n+                setValue={value => {\n+                  setDateModifiedFilter(value);\n+                }}\n+                id={\"disable_date_modified_filter_toggle\"}\n+              />\n+            }\n+          />\n+        </SettingsList>\n+      </Card>\n+\n+      {/* MIME type filters */}\n+      <Card className={classes.spacedCards}>\n+        <List\n+          subheader={\n+            <ListSubheader disableGutters>\n+              {searchFilterStrings.mimetypefiltertitle}\n+            </ListSubheader>\n+          }\n+        >\n+          {mimeTypeFilters.map(filter => {\n+            return (\n+              <ListItem divider={true} key={filter.name}>\n+                <ListItemText primary={filter.name} />\n+                <ListItemSecondaryAction>\n+                  <IconButton\n+                    onClick={() => {\n+                      openMimeTypeFilterDialog(filter);\n+                    }}\n+                    aria-label={`${searchFilterStrings.edit} ${filter.name}`}\n+                    color=\"secondary\"\n+                  >\n+                    <EditIcon />\n+                  </IconButton>\n+                  |\n+                  <IconButton\n+                    onClick={() => deleteMimeTypeFilter(filter)}\n+                    aria-label={`${searchFilterStrings.delete} ${filter.name}`}\n+                    color=\"secondary\"\n+                  >\n+                    <DeleteIcon />\n+                  </IconButton>\n+                </ListItemSecondaryAction>\n+              </ListItem>\n+            );\n+          })}\n+        </List>\n+        <CardActions className={classes.cardAction}>\n+          <IconButton\n+            onClick={() => openMimeTypeFilterDialog()}\n+            aria-label={searchFilterStrings.add}\n+            color={\"primary\"}\n+          >\n+            <AddCircleIcon fontSize={\"large\"} />\n+          </IconButton>\n+        </CardActions>\n+      </Card>\n+\n+      {/* SAVE button*/}\n+      <Button\n+        color={\"primary\"}\n+        className={classes.floatingButton}\n+        variant=\"contained\"\n+        size=\"large\"\n+        onClick={save}\n+        aria-label={searchFilterStrings.save}\n+      >\n+        <Save />\n+        {commonString.action.save}\n+      </Button>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 380}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNzkxNw==", "bodyText": "Yup, we've got a plan ahead to refactor these pages to pull out this common area (Save Button, Snackbar, etc).", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409217917", "createdAt": "2020-04-16T00:54:12Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableOwnerFilter}\n+                setValue={value => {\n+                  setOwnerFilter(value);\n+                }}\n+                id={\"disable_owner_filter_toggle\"}\n+              />\n+            }\n+          />\n+          <SettingsListControl\n+            primaryText={searchFilterStrings.disabledatemodifiedfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableDateModifiedFilter}\n+                setValue={value => {\n+                  setDateModifiedFilter(value);\n+                }}\n+                id={\"disable_date_modified_filter_toggle\"}\n+              />\n+            }\n+          />\n+        </SettingsList>\n+      </Card>\n+\n+      {/* MIME type filters */}\n+      <Card className={classes.spacedCards}>\n+        <List\n+          subheader={\n+            <ListSubheader disableGutters>\n+              {searchFilterStrings.mimetypefiltertitle}\n+            </ListSubheader>\n+          }\n+        >\n+          {mimeTypeFilters.map(filter => {\n+            return (\n+              <ListItem divider={true} key={filter.name}>\n+                <ListItemText primary={filter.name} />\n+                <ListItemSecondaryAction>\n+                  <IconButton\n+                    onClick={() => {\n+                      openMimeTypeFilterDialog(filter);\n+                    }}\n+                    aria-label={`${searchFilterStrings.edit} ${filter.name}`}\n+                    color=\"secondary\"\n+                  >\n+                    <EditIcon />\n+                  </IconButton>\n+                  |\n+                  <IconButton\n+                    onClick={() => deleteMimeTypeFilter(filter)}\n+                    aria-label={`${searchFilterStrings.delete} ${filter.name}`}\n+                    color=\"secondary\"\n+                  >\n+                    <DeleteIcon />\n+                  </IconButton>\n+                </ListItemSecondaryAction>\n+              </ListItem>\n+            );\n+          })}\n+        </List>\n+        <CardActions className={classes.cardAction}>\n+          <IconButton\n+            onClick={() => openMimeTypeFilterDialog()}\n+            aria-label={searchFilterStrings.add}\n+            color={\"primary\"}\n+          >\n+            <AddCircleIcon fontSize={\"large\"} />\n+          </IconButton>\n+        </CardActions>\n+      </Card>\n+\n+      {/* SAVE button*/}\n+      <Button\n+        color={\"primary\"}\n+        className={classes.floatingButton}\n+        variant=\"contained\"\n+        size=\"large\"\n+        onClick={save}\n+        aria-label={searchFilterStrings.save}\n+      >\n+        <Save />\n+        {commonString.action.save}\n+      </Button>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3ODg5OQ=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzMwMzg3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo1MDo0MlrOGFwBgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMTowNDo0OVrOGGQ2oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Mjg4MA==", "bodyText": "Not sure on the explicitly mentioning MIME type versus search", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408682880", "createdAt": "2020-04-15T08:50:42Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -67,33 +67,27 @@ class SearchFilterResource {\n   def getSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID): Response = {\n     searchPrivProvider.checkAuthorised()\n     val searchSettings = loadSettings(new SearchSettings)\n-\n-    getFilterById(uuid, searchSettings) match {\n+    val filterId       = uuid.toString\n+    getFilterById(filterId, searchSettings) match {\n       case Some(filter) => Response.ok().entity(filter).build()\n-      case None         => ApiErrorResponse.resourceNotFound(uuidNotFound(uuid))\n+      case None         => ApiErrorResponse.resourceNotFound(uuidNotFound(filterId))\n     }\n   }\n \n   @POST\n   @Path(\"search/filter\")\n   @ApiOperation(\n-    value = \"Add a search filter\",\n+    value = \"Add a MIME type filter\",\n     notes =\n-      \"This endpoint is used to add a search filter. A JSON object representing the new filter is returned if operation is successful.\",\n+      \"This endpoint is used to add a MIME type filter. A JSON object representing the new filter is returned if operation is successful.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMDc2OA==", "bodyText": "I think it's a good idea, as they're a specific type of filter - there are others.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409220768", "createdAt": "2020-04-16T01:04:49Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -67,33 +67,27 @@ class SearchFilterResource {\n   def getSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID): Response = {\n     searchPrivProvider.checkAuthorised()\n     val searchSettings = loadSettings(new SearchSettings)\n-\n-    getFilterById(uuid, searchSettings) match {\n+    val filterId       = uuid.toString\n+    getFilterById(filterId, searchSettings) match {\n       case Some(filter) => Response.ok().entity(filter).build()\n-      case None         => ApiErrorResponse.resourceNotFound(uuidNotFound(uuid))\n+      case None         => ApiErrorResponse.resourceNotFound(uuidNotFound(filterId))\n     }\n   }\n \n   @POST\n   @Path(\"search/filter\")\n   @ApiOperation(\n-    value = \"Add a search filter\",\n+    value = \"Add a MIME type filter\",\n     notes =\n-      \"This endpoint is used to add a search filter. A JSON object representing the new filter is returned if operation is successful.\",\n+      \"This endpoint is used to add a MIME type filter. A JSON object representing the new filter is returned if operation is successful.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Mjg4MA=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzM1MzA0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowMzoyNlrOGFwgSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowMzoyNlrOGFwgSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MDc2Mg==", "bodyText": "A quick glance at the API docs page seems to indicate we don't define the HTTP response codes + response data, the annotations are just setting a default response but no indication of 200 versus 202.  This only matters if there's an intention a oEQ client could be generated from the swagger contract or if it's just to render a docs page.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408690762", "createdAt": "2020-04-15T09:03:26Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -111,58 +105,136 @@ class SearchFilterResource {\n       \"This endpoint is used to update a search filter. A JSON object representing the updated filter is returned if operation is successful.\",\n     response = classOf[SearchFilter]\n   )\n-  def updateSearchFilter(\n-      @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n-      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n-      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n-        String]): Response = {\n+  def updateSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n+                         searchFilter: SearchFilter): Response = {\n     searchPrivProvider.checkAuthorised()\n     val searchSettings = loadSettings(new SearchSettings)\n+    val filterId       = uuid.toString\n \n-    getFilterById(uuid, searchSettings) match {\n+    getFilterById(filterId, searchSettings) match {\n       case Some(filter) =>\n-        validate(name, mimeTypes) match {\n+        validate(searchFilter) match {\n           case Left(errors) => ApiErrorResponse.badRequest(errors: _*)\n           case Right(_) =>\n-            filter.setMimeTypes(mimeTypes)\n-            filter.setName(name)\n+            filter.setMimeTypes(searchFilter.getMimeTypes)\n+            filter.setName(searchFilter.getName)\n             updateSettings(searchSettings)\n             Response.ok().entity(filter).build()\n         }\n-      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(uuid))\n+      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(filterId))\n     }\n   }\n \n+  @PUT\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"Update multiple MIME type filters\",\n+    notes =\n+      \"This endpoint is used to update multipe MIME type filters. A JSON object representing a collection of updated filters is returned if operation is successful.\",\n+    response = classOf[ApiBatchOperationResponse],\n+    responseContainer = \"List\"\n+  )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzM1ODE1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowNDo0N1rOGFwjiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMToxNTo1MlrOGGRCrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MTU5Mg==", "bodyText": "Is the 207 being handled by the client?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408691592", "createdAt": "2020-04-15T09:04:47Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -111,58 +105,136 @@ class SearchFilterResource {\n       \"This endpoint is used to update a search filter. A JSON object representing the updated filter is returned if operation is successful.\",\n     response = classOf[SearchFilter]\n   )\n-  def updateSearchFilter(\n-      @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n-      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n-      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n-        String]): Response = {\n+  def updateSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n+                         searchFilter: SearchFilter): Response = {\n     searchPrivProvider.checkAuthorised()\n     val searchSettings = loadSettings(new SearchSettings)\n+    val filterId       = uuid.toString\n \n-    getFilterById(uuid, searchSettings) match {\n+    getFilterById(filterId, searchSettings) match {\n       case Some(filter) =>\n-        validate(name, mimeTypes) match {\n+        validate(searchFilter) match {\n           case Left(errors) => ApiErrorResponse.badRequest(errors: _*)\n           case Right(_) =>\n-            filter.setMimeTypes(mimeTypes)\n-            filter.setName(name)\n+            filter.setMimeTypes(searchFilter.getMimeTypes)\n+            filter.setName(searchFilter.getName)\n             updateSettings(searchSettings)\n             Response.ok().entity(filter).build()\n         }\n-      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(uuid))\n+      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(filterId))\n     }\n   }\n \n+  @PUT\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"Update multiple MIME type filters\",\n+    notes =\n+      \"This endpoint is used to update multipe MIME type filters. A JSON object representing a collection of updated filters is returned if operation is successful.\",\n+    response = classOf[ApiBatchOperationResponse],\n+    responseContainer = \"List\"\n+  )\n+  def batchUpdate(searchFilters: Array[SearchFilter]): Response = {\n+    val searchSettings = loadSettings(new SearchSettings)\n+    val batchResponses = ListBuffer[ApiBatchOperationResponse]()\n+\n+    searchFilters.foreach(searchFilter => {\n+      val response = validate(searchFilter) match {\n+        case Left(errors) =>\n+          ApiBatchOperationResponse(isFilterIdNull(searchFilter.getId), 400, errors.mkString(\"\"))\n+        case Right(_) =>\n+          if (searchFilter.getId == null) {\n+            val filterId = UUID.randomUUID().toString\n+            searchFilter.setId(filterId)\n+            searchSettings.getFilters.add(searchFilter)\n+            ApiBatchOperationResponse(filterId,\n+                                      200,\n+                                      s\"A new filter has been created. ID: $filterId\")\n+          } else {\n+            val filterId = searchFilter.getId\n+            getFilterById(filterId, searchSettings) match {\n+              case Some(filter) =>\n+                filter.setMimeTypes(searchFilter.getMimeTypes)\n+                filter.setName(searchFilter.getName)\n+                ApiBatchOperationResponse(filterId,\n+                                          200,\n+                                          s\"MIME type filter $filterId has been updated.\")\n+              case None =>\n+                ApiBatchOperationResponse(filterId, 404, uuidNotFound(filterId))\n+            }\n+          }\n+      }\n+      batchResponses += response\n+    })\n+    updateSettings(searchSettings)\n+    Response.status(207).entity(batchResponses).build()\n+  }\n+\n   @DELETE\n   @Path(\"search/filter/{uuid}\")\n   @ApiOperation(\n-    value = \"Delete a search filter\",\n-    notes = \"This endpoint is used to delete a search filter.\",\n+    value = \"Delete a MIME type filter\",\n+    notes = \"This endpoint is used to delete a MIME type filter.\",\n   )\n   def deleteSearchFilters(\n       @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID): Response = {\n     searchPrivProvider.checkAuthorised()\n     val searchSettings = loadSettings(new SearchSettings)\n-\n-    getFilterById(uuid, searchSettings) match {\n+    val filterId       = uuid.toString\n+    getFilterById(filterId, searchSettings) match {\n       case Some(filter) =>\n         searchSettings.getFilters.remove(filter)\n         updateSettings(searchSettings)\n         Response.ok().build()\n-      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(uuid))\n+      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(filterId))\n     }\n   }\n \n-  private def getFilterById(filterId: UUID,\n+  @DELETE\n+  @Path(\"search/filter/\")\n+  @ApiOperation(\n+    value = \"Delete multiple MIME type filter\",\n+    notes = \"This endpoint is used to delete multiple MIME type filter.\",\n+    response = classOf[ApiBatchOperationResponse],\n+    responseContainer = \"List\"\n+  )\n+  def batchDelete(\n+      @ApiParam(value = \"filter UUID\") @QueryParam(\"ids\") ids: Array[UUID]): Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val searchSettings = loadSettings(new SearchSettings)\n+    val batchResponses = ListBuffer[ApiBatchOperationResponse]()\n+\n+    ids.foreach(id => {\n+      val filterId = id.toString\n+      val response = getFilterById(filterId, searchSettings) match {\n+        case Some(filter) =>\n+          searchSettings.getFilters.remove(filter)\n+          ApiBatchOperationResponse(filterId, 200, s\"MIME type filter $filterId has been deleted.\")\n+        case None => ApiBatchOperationResponse(filterId, 404, uuidNotFound(filterId))\n+      }\n+      batchResponses += response\n+    })\n+\n+    updateSettings(searchSettings)\n+    Response.status(207).entity(batchResponses).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMzg1Mg==", "bodyText": "Nope. I've added a comment to this effect @PenghaiZhang .\nAlso, I think we need to document the approach to handling of batching - i.e. how we're using 207 responses. Either as part of this PR, or as a side PR off develop could you please add some into Dev/docs/restendpoint.md?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409223852", "createdAt": "2020-04-16T01:15:52Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -111,58 +105,136 @@ class SearchFilterResource {\n       \"This endpoint is used to update a search filter. A JSON object representing the updated filter is returned if operation is successful.\",\n     response = classOf[SearchFilter]\n   )\n-  def updateSearchFilter(\n-      @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n-      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n-      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n-        String]): Response = {\n+  def updateSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID,\n+                         searchFilter: SearchFilter): Response = {\n     searchPrivProvider.checkAuthorised()\n     val searchSettings = loadSettings(new SearchSettings)\n+    val filterId       = uuid.toString\n \n-    getFilterById(uuid, searchSettings) match {\n+    getFilterById(filterId, searchSettings) match {\n       case Some(filter) =>\n-        validate(name, mimeTypes) match {\n+        validate(searchFilter) match {\n           case Left(errors) => ApiErrorResponse.badRequest(errors: _*)\n           case Right(_) =>\n-            filter.setMimeTypes(mimeTypes)\n-            filter.setName(name)\n+            filter.setMimeTypes(searchFilter.getMimeTypes)\n+            filter.setName(searchFilter.getName)\n             updateSettings(searchSettings)\n             Response.ok().entity(filter).build()\n         }\n-      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(uuid))\n+      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(filterId))\n     }\n   }\n \n+  @PUT\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"Update multiple MIME type filters\",\n+    notes =\n+      \"This endpoint is used to update multipe MIME type filters. A JSON object representing a collection of updated filters is returned if operation is successful.\",\n+    response = classOf[ApiBatchOperationResponse],\n+    responseContainer = \"List\"\n+  )\n+  def batchUpdate(searchFilters: Array[SearchFilter]): Response = {\n+    val searchSettings = loadSettings(new SearchSettings)\n+    val batchResponses = ListBuffer[ApiBatchOperationResponse]()\n+\n+    searchFilters.foreach(searchFilter => {\n+      val response = validate(searchFilter) match {\n+        case Left(errors) =>\n+          ApiBatchOperationResponse(isFilterIdNull(searchFilter.getId), 400, errors.mkString(\"\"))\n+        case Right(_) =>\n+          if (searchFilter.getId == null) {\n+            val filterId = UUID.randomUUID().toString\n+            searchFilter.setId(filterId)\n+            searchSettings.getFilters.add(searchFilter)\n+            ApiBatchOperationResponse(filterId,\n+                                      200,\n+                                      s\"A new filter has been created. ID: $filterId\")\n+          } else {\n+            val filterId = searchFilter.getId\n+            getFilterById(filterId, searchSettings) match {\n+              case Some(filter) =>\n+                filter.setMimeTypes(searchFilter.getMimeTypes)\n+                filter.setName(searchFilter.getName)\n+                ApiBatchOperationResponse(filterId,\n+                                          200,\n+                                          s\"MIME type filter $filterId has been updated.\")\n+              case None =>\n+                ApiBatchOperationResponse(filterId, 404, uuidNotFound(filterId))\n+            }\n+          }\n+      }\n+      batchResponses += response\n+    })\n+    updateSettings(searchSettings)\n+    Response.status(207).entity(batchResponses).build()\n+  }\n+\n   @DELETE\n   @Path(\"search/filter/{uuid}\")\n   @ApiOperation(\n-    value = \"Delete a search filter\",\n-    notes = \"This endpoint is used to delete a search filter.\",\n+    value = \"Delete a MIME type filter\",\n+    notes = \"This endpoint is used to delete a MIME type filter.\",\n   )\n   def deleteSearchFilters(\n       @ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID): Response = {\n     searchPrivProvider.checkAuthorised()\n     val searchSettings = loadSettings(new SearchSettings)\n-\n-    getFilterById(uuid, searchSettings) match {\n+    val filterId       = uuid.toString\n+    getFilterById(filterId, searchSettings) match {\n       case Some(filter) =>\n         searchSettings.getFilters.remove(filter)\n         updateSettings(searchSettings)\n         Response.ok().build()\n-      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(uuid))\n+      case None => ApiErrorResponse.resourceNotFound(uuidNotFound(filterId))\n     }\n   }\n \n-  private def getFilterById(filterId: UUID,\n+  @DELETE\n+  @Path(\"search/filter/\")\n+  @ApiOperation(\n+    value = \"Delete multiple MIME type filter\",\n+    notes = \"This endpoint is used to delete multiple MIME type filter.\",\n+    response = classOf[ApiBatchOperationResponse],\n+    responseContainer = \"List\"\n+  )\n+  def batchDelete(\n+      @ApiParam(value = \"filter UUID\") @QueryParam(\"ids\") ids: Array[UUID]): Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val searchSettings = loadSettings(new SearchSettings)\n+    val batchResponses = ListBuffer[ApiBatchOperationResponse]()\n+\n+    ids.foreach(id => {\n+      val filterId = id.toString\n+      val response = getFilterById(filterId, searchSettings) match {\n+        case Some(filter) =>\n+          searchSettings.getFilters.remove(filter)\n+          ApiBatchOperationResponse(filterId, 200, s\"MIME type filter $filterId has been deleted.\")\n+        case None => ApiBatchOperationResponse(filterId, 404, uuidNotFound(filterId))\n+      }\n+      batchResponses += response\n+    })\n+\n+    updateSettings(searchSettings)\n+    Response.status(207).entity(batchResponses).build()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MTU5Mg=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzM4ODk2OnYy", "diffSide": "RIGHT", "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOToxMzowMFrOGFw2hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMToyNzozNFrOGGRPpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NjQ1Mw==", "bodyText": "Misc notes about the tests:\n\nSome of them are covering more than one scenario rather than having a test per scenario\nno usage of soft asserts, the first assert failure will prevent the remainder from being tested.  This is a pain point when you fix one assert only to find another, and another and another....\nrepeating assert structures rather than helper methods to do common asserts,  e.g. http response codes with response message", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r408696453", "createdAt": "2020-04-15T09:13:00Z", "author": {"login": "nmkae"}, "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "diffHunk": "@@ -290,4 +274,117 @@ public void testDeleteSearchFilter() throws Exception {\n   private String searchFilterUri(String filterId) {\n     return PathUtils.urlPath(context.getBaseUrl(), API_SEARCH_FILTER_PATH, filterId);\n   }\n+\n+  @Test\n+  public void testBatchUpdateSearchFilter() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyNzE3Mw==", "bodyText": "Yes, I agree that this test should be split up, and some helper methods would help - I think we did some of them in the recent work on the tests for the updated Taxonomy endpoints. \ud83e\udd14\nAs for the soft asserts, I'm not too concerned there and happy for it stay with this at the moment - also matches what's done everywhere else currently.\nOne further consideration is whether going through the verbosity of using objects to create your JSON is necessary. In this kind of testing - as opposed to writing core integration code - I'm not against straight up strings (possibly read from a resource file - especially with Java's limitations of support for multi-line strings and having to escape double quotes). But I see you're also using the objects you're creating to slightly tweak, so... it depends.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409227173", "createdAt": "2020-04-16T01:27:34Z", "author": {"login": "edalex-ian"}, "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "diffHunk": "@@ -290,4 +274,117 @@ public void testDeleteSearchFilter() throws Exception {\n   private String searchFilterUri(String filterId) {\n     return PathUtils.urlPath(context.getBaseUrl(), API_SEARCH_FILTER_PATH, filterId);\n   }\n+\n+  @Test\n+  public void testBatchUpdateSearchFilter() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NjQ1Mw=="}, "originalCommit": {"oid": "079a0ccc7a4e4d91bcc6ac968785bd8619553abf"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MDY1MTUxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDo0OTo0OVrOGGQmiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDo0OTo0OVrOGGQmiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNjY1MQ==", "bodyText": "For these batch processes which are working with the response code of 207, I believe here you should process the body and look at the encapsulated response codes. Then, if there are any non 2xx codes you will need to group and throw an error.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409216651", "createdAt": "2020-04-16T00:49:49Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsModule.ts", "diffHunk": "@@ -0,0 +1,43 @@\n+import Axios from \"axios\";\n+import { encodeQuery } from \"../../../util/encodequery\";\n+\n+export interface MimeTypeFilter {\n+  id?: string;\n+  name: string;\n+  mimeTypes: string[];\n+}\n+\n+export interface MimeTypeEntry {\n+  mimeType: string;\n+  desc: string;\n+}\n+\n+const MIME_TYPE_FILTERS_URL = \"api/settings/search/filter\";\n+const MIME_TYPE_URL = \"api/settings/mimetype\";\n+\n+export const getMimeTypeFiltersFromServer = (): Promise<MimeTypeFilter[]> =>\n+  Axios.get(MIME_TYPE_FILTERS_URL).then(res => res.data);\n+\n+export const getMIMETypesFromServer = (): Promise<MimeTypeEntry[]> =>\n+  Axios.get(MIME_TYPE_URL).then(res => res.data);\n+\n+export const batchUpdateOrAdd = (filters: MimeTypeFilter[]) =>\n+  Axios.put(MIME_TYPE_FILTERS_URL, filters);\n+\n+export const batchDelete = (ids: string[]) =>\n+  Axios.delete(`${MIME_TYPE_FILTERS_URL}/${encodeQuery({ ids: ids })}`);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc6d4e60b220532e74c3ff9e515fd41277d817a"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MDY2MTk0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDo1NTowMFrOGGQscQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMDo1NTowMFrOGGQscQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxODE2MQ==", "bodyText": "For consistency, I'd say have this above the Save and Snackbar. (It'll also make it clearer when the later refactor is done.)", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409218161", "createdAt": "2020-04-16T00:55:00Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,402 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditor from \"./MimeTypeFilterEditor\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial values of the two filters and compare if values are changed or not when saving\n+  const [initialOwnerFilter, setInitialOwnerFilter] = useState<boolean>(false);\n+  const [initialDateModifiedFilter, setInitialDateModifiedFilter] = useState<\n+    boolean\n+  >(false);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);\n+\n+  useEffect(() => {\n+    getSearchSettings();\n+  }, []);\n+\n+  useEffect(() => {\n+    getMimeTypeFilters();\n+  }, []);\n+\n+  const setOwnerFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableOwnerFilter: disabled\n+    });\n+  };\n+\n+  const setDateModifiedFilter = (disabled: boolean) => {\n+    setSearchSettings({\n+      ...searchSettings,\n+      searchingDisableDateModifiedFilter: disabled\n+    });\n+  };\n+\n+  /**\n+   * Fetch the general Search Settings from the Server;\n+   * Set the initial values of the Owner filter and Date modified filter to state.\n+   */\n+  const getSearchSettings = () => {\n+    getSearchSettingsFromServer()\n+      .then(settings => {\n+        setSearchSettings(settings);\n+        setInitialOwnerFilter(settings.searchingDisableOwnerFilter);\n+        setInitialDateModifiedFilter(\n+          settings.searchingDisableDateModifiedFilter\n+        );\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Fetch MIME type filters from the Server and set them to state;\n+   * Clear the two collections of changed and deleted MIME type filters.\n+   */\n+  const getMimeTypeFilters = () => {\n+    getMimeTypeFiltersFromServer()\n+      .then((filters: MimeTypeFilter[]) => {\n+        setMimeTypeFilters(filters);\n+        setDeletedMimeTypeFilters([]);\n+        setChangedMimeTypeFilters([]);\n+      })\n+      .catch((error: AxiosError) => handleError(error));\n+  };\n+\n+  /**\n+   * Visually add or update a filter;\n+   * Add this filter into the collection of changed MIME type filters\n+   */\n+  const addOrUpdateMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list first\n+    if (!selectedMimeTypeFilter) {\n+      setMimeTypeFilters([...mimeTypeFilters, filter]);\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    } else {\n+      const index = mimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...mimeTypeFilters];\n+      filters[index] = filter;\n+      setMimeTypeFilters(filters);\n+    }\n+\n+    // Update the collection of changed MIME type filters\n+    // if 'filter' comes from the editing of 'selectedMimeTypeFilter' and 'selectedMimeTypeFilter'\n+    // exists in 'changedMimeTypeFilters', then replace 'selectedMimeTypeFilter' with 'filter';\n+    // otherwise add 'filter' to 'changedMimeTypeFilters'\n+    if (\n+      selectedMimeTypeFilter &&\n+      changedMimeTypeFilters.indexOf(selectedMimeTypeFilter) > -1\n+    ) {\n+      const index = changedMimeTypeFilters.indexOf(selectedMimeTypeFilter);\n+      const filters = [...changedMimeTypeFilters];\n+      filters[index] = filter;\n+      setChangedMimeTypeFilters(filters);\n+    } else {\n+      setChangedMimeTypeFilters([...changedMimeTypeFilters, filter]);\n+    }\n+  };\n+\n+  /**\n+   * Visually delete a filter;\n+   * Add this filter into the collection of deleted MIME type filters.\n+   */\n+  const deleteMimeTypeFilter = (filter: MimeTypeFilter) => {\n+    // Update the list of filters\n+    setMimeTypeFilters(\n+      mimeTypeFilters.filter(mimeTypeFilter => mimeTypeFilter !== filter)\n+    );\n+\n+    // Only put filters that already have an id into deletedMimeTypeFilters\n+    if (filter.id) {\n+      setDeletedMimeTypeFilters([...deletedMimeTypeFilters, filter]);\n+    }\n+\n+    // If this filter is also in changedMimeTypeFilters then remove it from changedMimeTypeFilters\n+    const indexInChangedMimeTypeFilters = changedMimeTypeFilters.indexOf(\n+      filter\n+    );\n+    if (indexInChangedMimeTypeFilters > -1) {\n+      const filters = [...changedMimeTypeFilters];\n+      filters.splice(indexInChangedMimeTypeFilters, 1);\n+      setChangedMimeTypeFilters(filters);\n+    }\n+  };\n+\n+  const openMimeTypeFilterDialog = (filter?: MimeTypeFilter) => {\n+    setOpenMimeTypeFilterEditor(true);\n+    setSelectedMimeTypeFilter(filter);\n+  };\n+\n+  const closeMimeTypeFilterDialog = () => {\n+    setOpenMimeTypeFilterEditor(false);\n+    //setSelectedMimeTypeFilter(undefined);\n+  };\n+\n+  const mimeTypeFilterchanged =\n+    deletedMimeTypeFilters.length || changedMimeTypeFilters.length;\n+\n+  const generalSearchSettingChanged =\n+    initialOwnerFilter !== searchSettings.searchingDisableOwnerFilter ||\n+    initialDateModifiedFilter !==\n+      searchSettings.searchingDisableDateModifiedFilter;\n+\n+  /**\n+   * Save general Search setting only when the configuration of Owner filter or Date modified filter has been changed;\n+   * Save MIME type filters only when they have been updated, delete or just created.\n+   */\n+  const save = () => {\n+    if (mimeTypeFilterchanged || generalSearchSettingChanged) {\n+      (generalSearchSettingChanged\n+        ? saveSearchSettingsToServer(searchSettings).catch(error =>\n+            handleError(error)\n+          )\n+        : Promise.resolve()\n+      )\n+        .then(\n+          (): Promise<any> =>\n+            changedMimeTypeFilters.length\n+              ? batchUpdateOrAdd(changedMimeTypeFilters).catch(error =>\n+                  handleError(error)\n+                )\n+              : Promise.resolve()\n+        )\n+        .then(\n+          (): Promise<any> =>\n+            // Filters stored in 'deletedMimeTypeFilters' always have an id\n+            deletedMimeTypeFilters.length\n+              ? batchDelete(\n+                  deletedMimeTypeFilters.map(filter => filter.id!)\n+                ).catch(error => handleError(error))\n+              : Promise.resolve()\n+        )\n+        .then(() => setShowSnackBar(true))\n+        .catch(() => {}) // Errors have been handled and subsequent promises have skipped\n+        .finally(() => {\n+          getMimeTypeFilters();\n+          getSearchSettings();\n+        });\n+    }\n+  };\n+\n+  const handleError = (error: AxiosError) => {\n+    updateTemplate(templateError(fromAxiosError(error)));\n+    // The reason for throwing an error again is to prevent subsequent REST calls\n+    throw new Error(error.message);\n+  };\n+\n+  return (\n+    <>\n+      {/* Owner filter and Date modified filter*/}\n+      <Card className={classes.spacedCards}>\n+        <SettingsList subHeading={searchFilterStrings.visibilityconfigtitle}>\n+          <SettingsListControl\n+            divider\n+            primaryText={searchFilterStrings.disableownerfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableOwnerFilter}\n+                setValue={value => {\n+                  setOwnerFilter(value);\n+                }}\n+                id={\"disable_owner_filter_toggle\"}\n+              />\n+            }\n+          />\n+          <SettingsListControl\n+            primaryText={searchFilterStrings.disabledatemodifiedfilter}\n+            secondaryText={\"\"}\n+            control={\n+              <SettingsToggleSwitch\n+                value={searchSettings.searchingDisableDateModifiedFilter}\n+                setValue={value => {\n+                  setDateModifiedFilter(value);\n+                }}\n+                id={\"disable_date_modified_filter_toggle\"}\n+              />\n+            }\n+          />\n+        </SettingsList>\n+      </Card>\n+\n+      {/* MIME type filters */}\n+      <Card className={classes.spacedCards}>\n+        <List\n+          subheader={\n+            <ListSubheader disableGutters>\n+              {searchFilterStrings.mimetypefiltertitle}\n+            </ListSubheader>\n+          }\n+        >\n+          {mimeTypeFilters.map(filter => {\n+            return (\n+              <ListItem divider={true} key={filter.name}>\n+                <ListItemText primary={filter.name} />\n+                <ListItemSecondaryAction>\n+                  <IconButton\n+                    onClick={() => {\n+                      openMimeTypeFilterDialog(filter);\n+                    }}\n+                    aria-label={`${searchFilterStrings.edit} ${filter.name}`}\n+                    color=\"secondary\"\n+                  >\n+                    <EditIcon />\n+                  </IconButton>\n+                  |\n+                  <IconButton\n+                    onClick={() => deleteMimeTypeFilter(filter)}\n+                    aria-label={`${searchFilterStrings.delete} ${filter.name}`}\n+                    color=\"secondary\"\n+                  >\n+                    <DeleteIcon />\n+                  </IconButton>\n+                </ListItemSecondaryAction>\n+              </ListItem>\n+            );\n+          })}\n+        </List>\n+        <CardActions className={classes.cardAction}>\n+          <IconButton\n+            onClick={() => openMimeTypeFilterDialog()}\n+            aria-label={searchFilterStrings.add}\n+            color={\"primary\"}\n+          >\n+            <AddCircleIcon fontSize={\"large\"} />\n+          </IconButton>\n+        </CardActions>\n+      </Card>\n+\n+      {/* SAVE button*/}\n+      <Button\n+        color={\"primary\"}\n+        className={classes.floatingButton}\n+        variant=\"contained\"\n+        size=\"large\"\n+        onClick={save}\n+        aria-label={searchFilterStrings.save}\n+      >\n+        <Save />\n+        {commonString.action.save}\n+      </Button>\n+\n+      {/* Snackbar */}\n+      <MessageInfo\n+        title={searchFilterStrings.changesaved}\n+        open={showSnackBar}\n+        onClose={() => setShowSnackBar(false)}\n+        variant={\"success\"}\n+      />\n+\n+      {/* MIME type filter dialog */}\n+      <MimeTypeFilterEditor\n+        open={openMimeTypeFilterEditor}\n+        onClose={closeMimeTypeFilterDialog}\n+        addOrUpdate={addOrUpdateMimeTypeFilter}\n+        mimeTypeFilter={selectedMimeTypeFilter}\n+        updateTemplate={updateTemplate}\n+      />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc6d4e60b220532e74c3ff9e515fd41277d817a"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MDY4NTY5OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/MimeTypeResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMTowODozMFrOGGQ6lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMTowODozMFrOGGQ6lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMTc4Mg==", "bodyText": "These really are their own top level resource - indeed they have their own table.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409221782", "createdAt": "2020-04-16T01:08:30Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/MimeTypeResource.scala", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.settings\n+\n+import com.dytech.edge.common.Constants\n+import com.tle.legacy.LegacyGuice\n+import io.swagger.annotations.{Api, ApiOperation}\n+import javax.ws.rs.core.Response\n+import javax.ws.rs.{GET, Path, Produces}\n+import org.jboss.resteasy.annotations.cache.NoCache\n+import scala.collection.JavaConverters._\n+\n+case class MimeTypeDetail(mimeType: String, desc: String)\n+\n+@NoCache\n+@Path(\"settings/\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc6d4e60b220532e74c3ff9e515fd41277d817a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MDY4OTEwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/MimeTypeResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMToxMDoxOFrOGGQ8jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMToxMDoxOFrOGGQ8jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMjI4Ng==", "bodyText": "If at a minimum (for now) you add a POST endpoint, then it'll make wrapping it in the test easy. Or, unless you're testing it already with an existing set of mimetypes from an institution import.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409222286", "createdAt": "2020-04-16T01:10:18Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/MimeTypeResource.scala", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.settings\n+\n+import com.dytech.edge.common.Constants\n+import com.tle.legacy.LegacyGuice\n+import io.swagger.annotations.{Api, ApiOperation}\n+import javax.ws.rs.core.Response\n+import javax.ws.rs.{GET, Path, Produces}\n+import org.jboss.resteasy.annotations.cache.NoCache\n+import scala.collection.JavaConverters._\n+\n+case class MimeTypeDetail(mimeType: String, desc: String)\n+\n+@NoCache\n+@Path(\"settings/\")\n+@Produces(value = Array(\"application/json\"))\n+@Api(value = \"Settings\")\n+class MimeTypeResource {\n+\n+  @GET\n+  @Path(\"mimetype\")\n+  @ApiOperation(\n+    value = \"List available MIME types\",\n+    notes = \"This endpoint is used to retrieve MIME types.\",\n+    response = classOf[MimeTypeDetail],\n+    responseContainer = \"List\"\n+  )\n+  def listMimeTypes: Response = {\n+    LegacyGuice.mimePrivProvider.checkAuthorised()\n+    val mimeEntries =\n+      LegacyGuice.mimeTypeService.searchByMimeType(Constants.BLANK, 0, -1).getResults.asScala\n+    val mimeTypes = mimeEntries.map(entry => {\n+      MimeTypeDetail(entry.getType, entry.getDescription)\n+    })\n+    Response.ok().entity(mimeTypes).build()\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc6d4e60b220532e74c3ff9e515fd41277d817a"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MDcxMTQ4OnYy", "diffSide": "RIGHT", "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMToyMjowN1rOGGRJgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMToyMjowN1rOGGRJgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyNTYwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // The batch update endpoint supports creating and updating, so create one filter firstly\n          \n          \n            \n                // The batch update endpoint supports creating and updating, so create one filter first", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409225600", "createdAt": "2020-04-16T01:22:07Z", "author": {"login": "edalex-ian"}, "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "diffHunk": "@@ -290,4 +274,124 @@ public void testDeleteSearchFilter() throws Exception {\n   private String searchFilterUri(String filterId) {\n     return PathUtils.urlPath(context.getBaseUrl(), API_SEARCH_FILTER_PATH, filterId);\n   }\n+\n+  @Test\n+  public void testBatchUpdateSearchFilter() throws Exception {\n+    final String uri = searchFilterUri(\"\");\n+\n+    ArrayNode jsonBody = mapper.createArrayNode();\n+    // The batch update endpoint supports creating and updating, so create one filter firstly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc6d4e60b220532e74c3ff9e515fd41277d817a"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MDcxNzY3OnYy", "diffSide": "RIGHT", "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMToyNTowMVrOGGRM7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMToyNTowMVrOGGRM7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyNjQ3OQ==", "bodyText": "This is not specifically related to Search Settings - and so should be in it's own class.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r409226479", "createdAt": "2020-04-16T01:25:01Z", "author": {"login": "edalex-ian"}, "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "diffHunk": "@@ -290,4 +274,124 @@ public void testDeleteSearchFilter() throws Exception {\n   private String searchFilterUri(String filterId) {\n     return PathUtils.urlPath(context.getBaseUrl(), API_SEARCH_FILTER_PATH, filterId);\n   }\n+\n+  @Test\n+  public void testBatchUpdateSearchFilter() throws Exception {\n+    final String uri = searchFilterUri(\"\");\n+\n+    ArrayNode jsonBody = mapper.createArrayNode();\n+    // The batch update endpoint supports creating and updating, so create one filter firstly\n+    ObjectNode filterOne = mapper.createObjectNode();\n+    filterOne.put(FILTER_NAME, IMAGE_FILTER);\n+    ArrayNode filterOneMimeTypes = filterOne.putArray(FILTER_MIME_TYPES);\n+    filterOneMimeTypes.add(JPEG);\n+    jsonBody.add(filterOne);\n+\n+    HttpResponse response = putEntity(jsonBody.toString(), uri, getToken(), false);\n+    JsonNode updateResults = mapper.readTree(response.getEntity().getContent());\n+    JsonNode returnedFilterOne = updateResults.get(0);\n+    newFilterId = returnedFilterOne.get(FILTER_ID).asText();\n+    assertNotNull(newFilterId);\n+    assertEquals(200, returnedFilterOne.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\n+        \"A new filter has been created. ID: \" + newFilterId,\n+        returnedFilterOne.get(RESPONSE_MESSAGE).asText());\n+\n+    // Now update this filter and create one more\n+    filterOne.put(FILTER_NAME, PDF_FILTER);\n+    filterOne.put(FILTER_ID, newFilterId);\n+    filterOneMimeTypes.add(PDF);\n+\n+    ObjectNode filterTwo = mapper.createObjectNode();\n+    filterTwo.put(FILTER_NAME, IMAGE_FILTER);\n+    ArrayNode filterTwoMimeTypes = filterTwo.putArray(FILTER_MIME_TYPES);\n+    filterTwoMimeTypes.add(JPEG);\n+    filterTwoMimeTypes.add(PNG);\n+    jsonBody.add(filterTwo);\n+\n+    response = putEntity(jsonBody.toString(), uri, getToken(), false);\n+    updateResults = mapper.readTree(response.getEntity().getContent());\n+    assertEquals(2, updateResults.size());\n+\n+    returnedFilterOne = updateResults.get(0);\n+    assertEquals(200, returnedFilterOne.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\n+        \"MIME type filter \" + newFilterId + \" has been updated.\",\n+        returnedFilterOne.get(RESPONSE_MESSAGE).asText());\n+\n+    JsonNode returnedFilterTwo = updateResults.get(1);\n+    secondeNewFilterId = returnedFilterTwo.get(FILTER_ID).asText();\n+    assertNotNull(secondeNewFilterId);\n+    assertEquals(200, returnedFilterTwo.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\n+        \"A new filter has been created. ID: \" + secondeNewFilterId,\n+        returnedFilterTwo.get(RESPONSE_MESSAGE).asText());\n+\n+    // Update without filter name and MIME types\n+    filterOne.remove(FILTER_NAME);\n+    filterTwo.remove(FILTER_MIME_TYPES);\n+\n+    filterTwo.put(FILTER_ID, BAD_FILTER_ID);\n+    response = putEntity(jsonBody.toString(), uri, getToken(), false);\n+    updateResults = mapper.readTree(response.getEntity().getContent());\n+    assertEquals(2, updateResults.size());\n+\n+    returnedFilterOne = updateResults.get(0);\n+    assertEquals(400, returnedFilterOne.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\"Filter name cannot be empty.\", returnedFilterOne.get(RESPONSE_MESSAGE).asText());\n+\n+    returnedFilterTwo = updateResults.get(1);\n+    assertEquals(400, returnedFilterTwo.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\"Need at least one MIME type.\", returnedFilterTwo.get(RESPONSE_MESSAGE).asText());\n+\n+    // Update with invalid ID\n+    filterOne.put(FILTER_NAME, PDF_FILTER);\n+    filterOne.put(FILTER_ID, BAD_FILTER_ID);\n+    response = putEntity(jsonBody.toString(), uri, getToken(), false);\n+    updateResults = mapper.readTree(response.getEntity().getContent());\n+    returnedFilterOne = updateResults.get(0);\n+    assertEquals(404, returnedFilterOne.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\n+        \"No Search filters matching UUID: \" + BAD_FILTER_ID,\n+        returnedFilterOne.get(RESPONSE_MESSAGE).asText());\n+  }\n+\n+  @Test(dependsOnMethods = \"testBatchUpdateSearchFilter\")\n+  public void testBatchDeleteSearchFilter() throws Exception {\n+    final String uri = searchFilterUri(\"\");\n+\n+    // Delete the two filters created\n+    HttpResponse response =\n+        deleteResource(uri, getToken(), \"ids\", newFilterId, \"ids\", secondeNewFilterId);\n+    JsonNode updateResults = mapper.readTree(response.getEntity().getContent());\n+    assertEquals(2, updateResults.size());\n+\n+    JsonNode filterOne = updateResults.get(0);\n+    assertEquals(200, filterOne.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\n+        \"MIME type filter \" + newFilterId + \" has been deleted.\",\n+        filterOne.get(RESPONSE_MESSAGE).asText());\n+\n+    JsonNode filterTwo = updateResults.get(1);\n+    assertEquals(200, filterTwo.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\n+        \"MIME type filter \" + secondeNewFilterId + \" has been deleted.\",\n+        filterTwo.get(RESPONSE_MESSAGE).asText());\n+\n+    // Delete again with the deleted IDs\n+    response = deleteResource(uri, getToken(), \"ids\", newFilterId);\n+    updateResults = mapper.readTree(response.getEntity().getContent());\n+    filterOne = updateResults.get(0);\n+    assertEquals(404, filterOne.get(RESPONSE_STATUS).asInt());\n+    assertEquals(\n+        \"No Search filters matching UUID: \" + newFilterId,\n+        filterOne.get(RESPONSE_MESSAGE).asText());\n+  }\n+\n+  @Test\n+  public void testRetrieveMimeTypes() throws Exception {\n+    final JsonNode initialFilters =\n+        getEntity(context.getBaseUrl() + \"api/settings/mimetype\", getToken());\n+    assertEquals(153, initialFilters.size());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc6d4e60b220532e74c3ff9e515fd41277d817a"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTkwMjQ5OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/api/BatchOperationResponse.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozMjo0MlrOGHDD4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozMjo0MlrOGHDD4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0MzM2MA==", "bodyText": "JS doc mismatch with the filter which is not non-200, it's anything above 400.\nShould this be the 2xx range?  Or are 3xx considered OK as well?", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410043360", "createdAt": "2020-04-17T07:32:42Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/api/BatchOperationResponse.ts", "diffHunk": "@@ -0,0 +1,16 @@\n+export interface BatchOperationResponse {\n+  id: string;\n+  status: number;\n+  message: string;\n+}\n+\n+/**\n+ * Group responses that have non 2xx codes and return their messages", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271a7ab7ddbf1ca02b41024269774923f860aa22"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTkwNTcwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditingDialog.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozMzo0NlrOGHDF6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozMzo0NlrOGHDF6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0Mzg4MA==", "bodyText": "Interface no longer matches component name", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410043880", "createdAt": "2020-04-17T07:33:46Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditingDialog.tsx", "diffHunk": "@@ -0,0 +1,156 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import MimeTypeList from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { addElement, deleteElement } from \"../../../util/ImmutableArrayUtil\";\n+\n+interface MimeTypeFilterEditorProps {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271a7ab7ddbf1ca02b41024269774923f860aa22"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTkyMDk5OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditingDialog.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozOToxOFrOGHDP0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozOToxOFrOGHDP0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0NjQxOQ==", "bodyText": "Not sure this needs to be uppercase (or exist at all)", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410046419", "createdAt": "2020-04-17T07:39:18Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditingDialog.tsx", "diffHunk": "@@ -0,0 +1,156 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import MimeTypeList from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { templateError, TemplateUpdate } from \"../../../mainui/Template\";\n+import { fromAxiosError } from \"../../../api/errors\";\n+import { addElement, deleteElement } from \"../../../util/ImmutableArrayUtil\";\n+\n+interface MimeTypeFilterEditorProps {\n+  /**\n+   * If true, the dialog will be shown.\n+   */\n+  open: boolean;\n+  /**\n+   * Fired when the dialog is closed.\n+   */\n+  onClose: () => void;\n+  /**\n+   * Fired when clicking the ADD or OK button\n+   * @param filter The filter that has been added or edited\n+   */\n+  addOrUpdate: (filter: MimeTypeFilter) => void;\n+  /**\n+   * The filter to be edited, or undefined if the action is to add a new filter\n+   */\n+  mimeTypeFilter?: MimeTypeFilter;\n+  /**\n+   * Update the LegacyContent template when required\n+   * @param the template to be rendered\n+   */\n+  updateTemplate: (update: TemplateUpdate) => void;\n+}\n+\n+/**\n+ * Component for showing a dialog where users can add/edit a MIME type filter\n+ */\n+const MimeTypeFilterEditingDialog = ({\n+  open,\n+  onClose,\n+  mimeTypeFilter,\n+  addOrUpdate,\n+  updateTemplate\n+}: MimeTypeFilterEditorProps) => {\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  const [mimeTypeEntries, setMimeTypeEntries] = useState<MimeTypeEntry[]>([]);\n+  // Used to store the name of a MIME type filter\n+  const [filterName, setFilterName] = useState<string>(\"\");\n+  // Used to store the MIME types of a MIME type filter\n+  const [selectedMimeTypes, setSelectedMimeTypes] = useState<string[]>([]);\n+\n+  useEffect(() => {\n+    getMIMETypesFromServer()\n+      .then(mimeTypes => setMimeTypeEntries(mimeTypes))\n+      .catch(error => updateTemplate(templateError(fromAxiosError(error))));\n+  }, []);\n+\n+  /**\n+   * Clean up previously edited filter, depending on 'onClose'\n+   */\n+  useEffect(() => {\n+    setFilterName(mimeTypeFilter ? mimeTypeFilter.name : \"\");\n+    setSelectedMimeTypes(mimeTypeFilter ? mimeTypeFilter.mimeTypes : []);\n+  }, [onClose]);\n+\n+  /**\n+   * If a MIME type is selected and it doesn't exist in the collection of selected MIME types,\n+   * then add it to the collection.\n+   * if a MIME type is unselected and it exists in the collection of selected MIME types,\n+   * then remove it from the collection.\n+   */\n+  const updateMimeTypeSelections = React.useCallback(\n+    (checked: boolean, mimeType: string) => {\n+      if (checked && selectedMimeTypes.indexOf(mimeType) < 0) {\n+        setSelectedMimeTypes(addElement(selectedMimeTypes, mimeType));\n+      } else if (!checked && selectedMimeTypes.indexOf(mimeType) > -1) {\n+        setSelectedMimeTypes(deleteElement(selectedMimeTypes, mimeType, 1));\n+      }\n+    },\n+    [selectedMimeTypes]\n+  );\n+\n+  const onAddOrUpdate = () => {\n+    addOrUpdate({\n+      id: mimeTypeFilter?.id,\n+      name: filterName,\n+      mimeTypes: selectedMimeTypes\n+    });\n+    onClose();\n+  };\n+\n+  const isNameValid = vaidateMimeTypeName(filterName);\n+  const DIALOG_TITLE = mimeTypeFilter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271a7ab7ddbf1ca02b41024269774923f860aa22"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTkyNDQ1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0MDoyM1rOGHDR8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0MDoyM1rOGHDR8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0Njk2MQ==", "bodyText": "JS doc missing.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410046961", "createdAt": "2020-04-17T07:40:23Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,69 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,\n+    overflow: \"auto\"\n+  },\n+  listTitle: {\n+    marginTop: 20\n+  }\n+});\n+\n+interface MimeTypeFilterListProps {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271a7ab7ddbf1ca02b41024269774923f860aa22"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTkyNTU1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0MDo0MVrOGHDSkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0MDo0MVrOGHDSkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0NzEyMQ==", "bodyText": "JS doc missing", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410047121", "createdAt": "2020-04-17T07:40:41Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsModule.ts", "diffHunk": "@@ -0,0 +1,48 @@\n+import Axios from \"axios\";\n+import { encodeQuery } from \"../../../util/encodequery\";\n+import {\n+  BatchOperationResponse,\n+  groupErrorMessages\n+} from \"../../../api/BatchOperationResponse\";\n+\n+export interface MimeTypeFilter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271a7ab7ddbf1ca02b41024269774923f860aa22"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTk0MjgzOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/util/ImmutableArrayUtil.ts", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0NjowNlrOGHDdWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0NjowNlrOGHDdWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0OTg4MQ==", "bodyText": "I think this may cause some confusion as it's not doing an value equality check for complex objects, it'll add a duplicate object if the reference to the new element is slightly different but the object has exactly the same values", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410049881", "createdAt": "2020-04-17T07:46:06Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/util/ImmutableArrayUtil.ts", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Return a new array concatenating the provided array and new element\n+ */\n+export function addElement<T>(objects: Array<T>, element: T): Array<T> {\n+  return [...objects, element];\n+}\n+\n+/**\n+ * If an element is found in the provided array, then replace it with a new element,\n+ * and return a new array; otherwise call 'addElement'.\n+ */\n+export function replaceElement<T>(\n+  objects: Array<T>,\n+  element: T,\n+  replaceElement: T\n+): Array<T> {\n+  const index = objects.indexOf(element);\n+  if (index < 0) {\n+    return addElement(objects, replaceElement);\n+  }\n+  const newObjects = [...objects];\n+  newObjects[index] = replaceElement;\n+  return newObjects;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271a7ab7ddbf1ca02b41024269774923f860aa22"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTk0ODEyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/util/ImmutableArrayUtil.ts", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0Nzo1N1rOGHDgsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0Nzo1N1rOGHDgsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MDczNg==", "bodyText": "I'd be weary of stating these are immutable arrays, I would a immutable array utility to deep clone arrays, this is just shallow clones?\nIf this is intended to be a commonly used utility then it should have tests to sanity check variations", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410050736", "createdAt": "2020-04-17T07:47:57Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/util/ImmutableArrayUtil.ts", "diffHunk": "@@ -0,0 +1,42 @@\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271a7ab7ddbf1ca02b41024269774923f860aa22"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTk1MDI5OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/util/ImmutableArrayUtil.ts", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0ODo0MVrOGHDiHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0ODo0MVrOGHDiHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MTEwMg==", "bodyText": "Again this checking references rather than a value equality check, it may be misleading", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r410051102", "createdAt": "2020-04-17T07:48:41Z", "author": {"login": "nmkae"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/util/ImmutableArrayUtil.ts", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Return a new array concatenating the provided array and new element\n+ */\n+export function addElement<T>(objects: Array<T>, element: T): Array<T> {\n+  return [...objects, element];\n+}\n+\n+/**\n+ * If an element is found in the provided array, then replace it with a new element,\n+ * and return a new array; otherwise call 'addElement'.\n+ */\n+export function replaceElement<T>(\n+  objects: Array<T>,\n+  element: T,\n+  replaceElement: T\n+): Array<T> {\n+  const index = objects.indexOf(element);\n+  if (index < 0) {\n+    return addElement(objects, replaceElement);\n+  }\n+  const newObjects = [...objects];\n+  newObjects[index] = replaceElement;\n+  return newObjects;\n+}\n+\n+/**\n+ * If an element is found in the provided array, then remove this element,\n+ * and return a new array; otherwise return the provided array.\n+ */\n+export function deleteElement<T>(\n+  objects: Array<T>,\n+  element: T,\n+  deleteCount: number\n+): Array<T> {\n+  const index = objects.indexOf(element);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271a7ab7ddbf1ca02b41024269774923f860aa22"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODcyNDA2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditingDialog.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzowNjo1NFrOGIwZkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzo0Nzo0MlrOGIxJkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgzNDc2OQ==", "bodyText": "These comments show up in storybook as documentation, so its best to be consistent with punctuation - ensure each of these interface and component comments ends with a full stop.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r411834769", "createdAt": "2020-04-21T03:06:54Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditingDialog.tsx", "diffHunk": "@@ -0,0 +1,157 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import MimeTypeList from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { addElement, deleteElement } from \"../../../util/ImmutableArrayUtil\";\n+\n+interface MimeTypeFilterEditingDialogProps {\n+  /**\n+   * If true, the dialog will be shown.\n+   */\n+  open: boolean;\n+  /**\n+   * Fired when the dialog is closed.\n+   */\n+  onClose: () => void;\n+  /**\n+   * Fired when clicking the ADD or OK button", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1addd5249df9851887949e8376ef6ae059471fb3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg0NzA1OQ==", "bodyText": "Thank you Sam for reminding me of this issue!", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r411847059", "createdAt": "2020-04-21T03:47:42Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeFilterEditingDialog.tsx", "diffHunk": "@@ -0,0 +1,157 @@\n+import * as React from \"react\";\n+import {\n+  Button,\n+  Dialog,\n+  DialogActions,\n+  DialogContent,\n+  DialogTitle,\n+  TextField\n+} from \"@material-ui/core\";\n+import {\n+  getMIMETypesFromServer,\n+  MimeTypeFilter,\n+  MimeTypeEntry,\n+  vaidateMimeTypeName\n+} from \"./SearchFilterSettingsModule\";\n+import { useEffect, useState } from \"react\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import MimeTypeList from \"./MimeTypeList\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import { addElement, deleteElement } from \"../../../util/ImmutableArrayUtil\";\n+\n+interface MimeTypeFilterEditingDialogProps {\n+  /**\n+   * If true, the dialog will be shown.\n+   */\n+  open: boolean;\n+  /**\n+   * Fired when the dialog is closed.\n+   */\n+  onClose: () => void;\n+  /**\n+   * Fired when clicking the ADD or OK button", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgzNDc2OQ=="}, "originalCommit": {"oid": "1addd5249df9851887949e8376ef6ae059471fb3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODcyODk0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzowOToxOVrOGIwcSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzowOToxOVrOGIwcSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgzNTQ2Ng==", "bodyText": "Unnecessary whitespace.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r411835466", "createdAt": "2020-04-21T03:09:19Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/MimeTypeList.tsx", "diffHunk": "@@ -0,0 +1,79 @@\n+import * as React from \"react\";\n+import {\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Checkbox,\n+  Typography\n+} from \"@material-ui/core\";\n+import { getMimeTypeDetail, MimeTypeEntry } from \"./SearchFilterSettingsModule\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  item: {\n+    padding: 0\n+  },\n+  list: {\n+    maxHeight: 400,\n+    overflow: \"auto\"\n+  },\n+  listTitle: {\n+    marginTop: 20\n+  }\n+});\n+\n+interface MimeTypeFilterListProps {\n+  /**\n+   * A list of MIME types to be displayed\n+   */\n+  entries: MimeTypeEntry[];\n+  /**\n+   * Fired when the value of each Checkbox is changed\n+   */\n+  onChange(check: boolean, mimeType: string): void;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1addd5249df9851887949e8376ef6ae059471fb3"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODczMjEzOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzoxMDo0NFrOGIwd8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzoxMDo0NFrOGIwd8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgzNTg5MQ==", "bodyText": "Import this from @material-ui/core instead.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r411835891", "createdAt": "2020-04-21T03:10:44Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,389 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1addd5249df9851887949e8376ef6ae059471fb3"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODczNDM5OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzoxMTozM1rOGIwfHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzoxMTozM1rOGIwfHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgzNjE4OA==", "bodyText": "All these icon imports could go in a single import.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r411836188", "createdAt": "2020-04-21T03:11:33Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,389 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1addd5249df9851887949e8376ef6ae059471fb3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODc0MDMzOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzoxNDoxN1rOGIwiWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzoxNDoxN1rOGIwiWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgzNzAxNg==", "bodyText": "Rather than have multiple dependency-less useEffect hooks, consider just consolidating this one and the one below into one hook.", "url": "https://github.com/openequella/openEQUELLA/pull/1613#discussion_r411837016", "createdAt": "2020-04-21T03:14:17Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/searchfilter/SearchFilterSettingsPage.tsx", "diffHunk": "@@ -0,0 +1,389 @@\n+import * as React from \"react\";\n+import {\n+  templateDefaults,\n+  templateError,\n+  TemplateUpdateProps\n+} from \"../../../mainui/Template\";\n+import { routes } from \"../../../mainui/routes\";\n+import {\n+  Button,\n+  Card,\n+  CardActions,\n+  ListItem,\n+  ListItemSecondaryAction,\n+  ListItemText,\n+  ListSubheader,\n+  IconButton,\n+  List\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/styles\";\n+import EditIcon from \"@material-ui/icons/Edit\";\n+import DeleteIcon from \"@material-ui/icons/Delete\";\n+import AddCircleIcon from \"@material-ui/icons/AddCircle\";\n+import { languageStrings } from \"../../../util/langstrings\";\n+import SettingsList from \"../../../components/SettingsList\";\n+import SettingsListControl from \"../../../components/SettingsListControl\";\n+import SettingsToggleSwitch from \"../../../components/SettingsToggleSwitch\";\n+import { useEffect, useState } from \"react\";\n+import {\n+  defaultSearchSettings,\n+  getSearchSettingsFromServer,\n+  saveSearchSettingsToServer,\n+  SearchSettings\n+} from \"../SearchSettingsModule\";\n+import { Save } from \"@material-ui/icons\";\n+import MessageInfo from \"../../../components/MessageInfo\";\n+import {\n+  batchDelete,\n+  batchUpdateOrAdd,\n+  getMimeTypeFiltersFromServer,\n+  MimeTypeFilter\n+} from \"./SearchFilterSettingsModule\";\n+import MimeTypeFilterEditingDialog from \"./MimeTypeFilterEditingDialog\";\n+import { commonString } from \"../../../util/commonstrings\";\n+import { generateFromError } from \"../../../api/errors\";\n+import { AxiosError } from \"axios\";\n+import {\n+  addElement,\n+  deleteElement,\n+  replaceElement\n+} from \"../../../util/ImmutableArrayUtil\";\n+import MessageDialog from \"../../../components/MessageDialog\";\n+\n+const useStyles = makeStyles({\n+  spacedCards: {\n+    margin: \"16px\",\n+    width: \"75%\",\n+    padding: \"16px\",\n+    float: \"left\"\n+  },\n+  cardAction: {\n+    display: \"flex\",\n+    justifyContent: \"flex-end\"\n+  },\n+  floatingButton: {\n+    position: \"fixed\",\n+    top: 0,\n+    right: 0,\n+    marginTop: \"80px\",\n+    marginRight: \"16px\",\n+    width: \"calc(25% - 112px)\"\n+  }\n+});\n+\n+const SearchFilterPage = ({ updateTemplate }: TemplateUpdateProps) => {\n+  const classes = useStyles();\n+  const searchFilterStrings =\n+    languageStrings.settings.searching.searchfiltersettings;\n+\n+  // The general Search settings. Here only configure searchingDisableOwnerFilter and searchingDisableDateModifiedFilter\n+  const [searchSettings, setSearchSettings] = useState<SearchSettings>(\n+    defaultSearchSettings\n+  );\n+\n+  // Used to record the initial Search settings and compare if values are changed or not when saving\n+  const [initialSearchSettings, setInitialSearchSettings] = useState<\n+    SearchSettings\n+  >(defaultSearchSettings);\n+\n+  // mimeTypeFilters contains all filters displayed in the list, including those saved in the Server and visually added/deleted\n+  const [mimeTypeFilters, setMimeTypeFilters] = useState<MimeTypeFilter[]>([]);\n+\n+  // changedMimeTypeFilters contains filters to be added or edited on the Server\n+  const [changedMimeTypeFilters, setChangedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // deletedMimeTypeFilters contains filters to be deleted from the Server\n+  const [deletedMimeTypeFilters, setDeletedMimeTypeFilters] = useState<\n+    MimeTypeFilter[]\n+  >([]);\n+\n+  // selectedMimeTypeFilter refers to the filter to be edited in the dialog\n+  const [selectedMimeTypeFilter, setSelectedMimeTypeFilter] = useState<\n+    MimeTypeFilter | undefined\n+  >();\n+\n+  const [showSnackBar, setShowSnackBar] = useState<boolean>(false);\n+  const [openMimeTypeFilterEditor, setOpenMimeTypeFilterEditor] = useState<\n+    boolean\n+  >(false);\n+  const [openMessageDialog, setOpenMessageDialog] = useState<boolean>(false);\n+  const [messageDialogMessages, setMessageDialogMessages] = useState<string[]>(\n+    []\n+  );\n+\n+  useEffect(() => {\n+    updateTemplate(tp => ({\n+      ...templateDefaults(searchFilterStrings.name)(tp),\n+      backRoute: routes.Settings.to\n+    }));\n+  }, []);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1addd5249df9851887949e8376ef6ae059471fb3"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1533, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}