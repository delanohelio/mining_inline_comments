{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2NTE1MjU4", "number": 2172, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjoyMTo0NFrOEXfJIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjo0MzoxOFrOEXffPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDYyOTQ1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjoyMTo0NFrOG_TUlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NDoyNlrOG_Z8UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMDAzNw==", "bodyText": "We have mixed use of  toHaveBeenCalledWith and toHaveBeenLastCalledWith ? Is it something we want to unify ?\nAlso I noted a small difference. This function checks mockSearch whereas others check SearchModule.searchItems, but I think the result is the same.", "url": "https://github.com/openequella/openEQUELLA/pull/2172#discussion_r469030037", "createdAt": "2020-08-12T06:21:44Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "diffHunk": "@@ -75,36 +81,112 @@ const defaultSearchPageOptions: SearchPageOptions = {\n };\n const defaultCollectionPrivileges = [\"SEARCH_COLLECTION\"];\n \n+/**\n+ * Simple helper to wrap the process of waiting for the execution of a search based on checking the\n+ * `searchPromise`. Being that it is abstracted out, in the future could change as needed to be\n+ * something other than the `searchPromise`.\n+ */\n+const waitForSearch = async () =>\n+  await act(async () => {\n+    await searchPromise;\n+  });\n+\n+/**\n+ * Helper function for the initial render of the `<SearchPage>` for tests below. Also includes\n+ * the wait for the initial search call.\n+ *\n+ * @returns The RenderResult from the `render` of the `<SearchPage>`\n+ */\n+const renderSearchPage = async (): Promise<RenderResult> => {\n+  window.history.replaceState({}, \"Clean history state\");\n+  const page = render(\n+    <BrowserRouter>\n+      <SearchPage updateTemplate={jest.fn()} />{\" \"}\n+    </BrowserRouter>\n+  );\n+  // Wait for the first completion of initial search\n+  await waitForSearch();\n+\n+  return page;\n+};\n+\n+/**\n+ * Helper function to find individual Refine Search components based on the their `idSuffix`.\n+ *\n+ * @param container The root container to start the search from\n+ * @param componentSuffix Typically the `idSuffix` provided in `SearchPage.tsx`\n+ */\n+const getRefineSearchComponent = (\n+  container: Element,\n+  componentSuffix: string\n+) => {\n+  const id = `#RefineSearchPanel-${componentSuffix}`;\n+  const e = container.querySelector(id);\n+  if (!e) {\n+    throw new Error(`Failed to find ${id}`);\n+  }\n+\n+  return e as HTMLElement;\n+};\n+\n+describe(\"Refine search by status\", () => {\n+  const {\n+    live: liveButtonLabel,\n+    all: allButtonLabel,\n+  } = languageStrings.searchpage.statusSelector;\n+\n+  const expectSearchItemsCalledWithStatus = (status: OEQ.Common.ItemStatus[]) =>\n+    expect(mockSearch).toHaveBeenCalledWith({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a829f3ae75f900592949910a033743009e358963"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NDYxNg==", "bodyText": "I guess it depends on context. Here I'm not concerned with whether it was first, last or otherwise. Just that it was called with that value at one point.\nI decided to go with the mockSearch here as we do have that variable capturing the situation, and indeed it provides us an abstraction - should the search function used by SearchPage change later. I think arguably we should use these constants in place of the explicit function reference when we've mocked them out. Maybe as part of the refactor we standardise on that. Thoughts?", "url": "https://github.com/openequella/openEQUELLA/pull/2172#discussion_r469054616", "createdAt": "2020-08-12T07:18:16Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "diffHunk": "@@ -75,36 +81,112 @@ const defaultSearchPageOptions: SearchPageOptions = {\n };\n const defaultCollectionPrivileges = [\"SEARCH_COLLECTION\"];\n \n+/**\n+ * Simple helper to wrap the process of waiting for the execution of a search based on checking the\n+ * `searchPromise`. Being that it is abstracted out, in the future could change as needed to be\n+ * something other than the `searchPromise`.\n+ */\n+const waitForSearch = async () =>\n+  await act(async () => {\n+    await searchPromise;\n+  });\n+\n+/**\n+ * Helper function for the initial render of the `<SearchPage>` for tests below. Also includes\n+ * the wait for the initial search call.\n+ *\n+ * @returns The RenderResult from the `render` of the `<SearchPage>`\n+ */\n+const renderSearchPage = async (): Promise<RenderResult> => {\n+  window.history.replaceState({}, \"Clean history state\");\n+  const page = render(\n+    <BrowserRouter>\n+      <SearchPage updateTemplate={jest.fn()} />{\" \"}\n+    </BrowserRouter>\n+  );\n+  // Wait for the first completion of initial search\n+  await waitForSearch();\n+\n+  return page;\n+};\n+\n+/**\n+ * Helper function to find individual Refine Search components based on the their `idSuffix`.\n+ *\n+ * @param container The root container to start the search from\n+ * @param componentSuffix Typically the `idSuffix` provided in `SearchPage.tsx`\n+ */\n+const getRefineSearchComponent = (\n+  container: Element,\n+  componentSuffix: string\n+) => {\n+  const id = `#RefineSearchPanel-${componentSuffix}`;\n+  const e = container.querySelector(id);\n+  if (!e) {\n+    throw new Error(`Failed to find ${id}`);\n+  }\n+\n+  return e as HTMLElement;\n+};\n+\n+describe(\"Refine search by status\", () => {\n+  const {\n+    live: liveButtonLabel,\n+    all: allButtonLabel,\n+  } = languageStrings.searchpage.statusSelector;\n+\n+  const expectSearchItemsCalledWithStatus = (status: OEQ.Common.ItemStatus[]) =>\n+    expect(mockSearch).toHaveBeenCalledWith({", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMDAzNw=="}, "originalCommit": {"oid": "a829f3ae75f900592949910a033743009e358963"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzODUxMw==", "bodyText": "Actually, I am concerned here that it was the last one, as due to all the effects I can't be sure. Fixed. \ud83d\udc4d", "url": "https://github.com/openequella/openEQUELLA/pull/2172#discussion_r469138513", "createdAt": "2020-08-12T09:44:26Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "diffHunk": "@@ -75,36 +81,112 @@ const defaultSearchPageOptions: SearchPageOptions = {\n };\n const defaultCollectionPrivileges = [\"SEARCH_COLLECTION\"];\n \n+/**\n+ * Simple helper to wrap the process of waiting for the execution of a search based on checking the\n+ * `searchPromise`. Being that it is abstracted out, in the future could change as needed to be\n+ * something other than the `searchPromise`.\n+ */\n+const waitForSearch = async () =>\n+  await act(async () => {\n+    await searchPromise;\n+  });\n+\n+/**\n+ * Helper function for the initial render of the `<SearchPage>` for tests below. Also includes\n+ * the wait for the initial search call.\n+ *\n+ * @returns The RenderResult from the `render` of the `<SearchPage>`\n+ */\n+const renderSearchPage = async (): Promise<RenderResult> => {\n+  window.history.replaceState({}, \"Clean history state\");\n+  const page = render(\n+    <BrowserRouter>\n+      <SearchPage updateTemplate={jest.fn()} />{\" \"}\n+    </BrowserRouter>\n+  );\n+  // Wait for the first completion of initial search\n+  await waitForSearch();\n+\n+  return page;\n+};\n+\n+/**\n+ * Helper function to find individual Refine Search components based on the their `idSuffix`.\n+ *\n+ * @param container The root container to start the search from\n+ * @param componentSuffix Typically the `idSuffix` provided in `SearchPage.tsx`\n+ */\n+const getRefineSearchComponent = (\n+  container: Element,\n+  componentSuffix: string\n+) => {\n+  const id = `#RefineSearchPanel-${componentSuffix}`;\n+  const e = container.querySelector(id);\n+  if (!e) {\n+    throw new Error(`Failed to find ${id}`);\n+  }\n+\n+  return e as HTMLElement;\n+};\n+\n+describe(\"Refine search by status\", () => {\n+  const {\n+    live: liveButtonLabel,\n+    all: allButtonLabel,\n+  } = languageStrings.searchpage.statusSelector;\n+\n+  const expectSearchItemsCalledWithStatus = (status: OEQ.Common.ItemStatus[]) =>\n+    expect(mockSearch).toHaveBeenCalledWith({", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMDAzNw=="}, "originalCommit": {"oid": "a829f3ae75f900592949910a033743009e358963"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDY0MDA1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjoyNTo1M1rOG_TawA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoxNTo1M1rOG_UwBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTYxNg==", "bodyText": "According to the doco of render, it might be good to call cleanup here.", "url": "https://github.com/openequella/openEQUELLA/pull/2172#discussion_r469031616", "createdAt": "2020-08-12T06:25:53Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "diffHunk": "@@ -75,36 +81,112 @@ const defaultSearchPageOptions: SearchPageOptions = {\n };\n const defaultCollectionPrivileges = [\"SEARCH_COLLECTION\"];\n \n+/**\n+ * Simple helper to wrap the process of waiting for the execution of a search based on checking the\n+ * `searchPromise`. Being that it is abstracted out, in the future could change as needed to be\n+ * something other than the `searchPromise`.\n+ */\n+const waitForSearch = async () =>\n+  await act(async () => {\n+    await searchPromise;\n+  });\n+\n+/**\n+ * Helper function for the initial render of the `<SearchPage>` for tests below. Also includes\n+ * the wait for the initial search call.\n+ *\n+ * @returns The RenderResult from the `render` of the `<SearchPage>`\n+ */\n+const renderSearchPage = async (): Promise<RenderResult> => {\n+  window.history.replaceState({}, \"Clean history state\");\n+  const page = render(\n+    <BrowserRouter>\n+      <SearchPage updateTemplate={jest.fn()} />{\" \"}\n+    </BrowserRouter>\n+  );\n+  // Wait for the first completion of initial search\n+  await waitForSearch();\n+\n+  return page;\n+};\n+\n+/**\n+ * Helper function to find individual Refine Search components based on the their `idSuffix`.\n+ *\n+ * @param container The root container to start the search from\n+ * @param componentSuffix Typically the `idSuffix` provided in `SearchPage.tsx`\n+ */\n+const getRefineSearchComponent = (\n+  container: Element,\n+  componentSuffix: string\n+) => {\n+  const id = `#RefineSearchPanel-${componentSuffix}`;\n+  const e = container.querySelector(id);\n+  if (!e) {\n+    throw new Error(`Failed to find ${id}`);\n+  }\n+\n+  return e as HTMLElement;\n+};\n+\n+describe(\"Refine search by status\", () => {\n+  const {\n+    live: liveButtonLabel,\n+    all: allButtonLabel,\n+  } = languageStrings.searchpage.statusSelector;\n+\n+  const expectSearchItemsCalledWithStatus = (status: OEQ.Common.ItemStatus[]) =>\n+    expect(mockSearch).toHaveBeenCalledWith({\n+      ...defaultSearchPageOptions,\n+      status: status,\n+    });\n+\n+  const getStatusSelector = (container: Element): HTMLElement =>\n+    getRefineSearchComponent(container, \"StatusSelector\");\n+\n+  const selectStatus = (container: Element, status: string) =>\n+    fireEvent.click(getByText(getStatusSelector(container), status));\n+\n+  afterEach(() => {\n+    // Needed to keep Enzyme tests below happy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a829f3ae75f900592949910a033743009e358963"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzQ0Ng==", "bodyText": "Heh, I don't know. Funny you mention it, as I queried it over in your PR:\n#2171 (comment)\nBe interested to hear your thoughts. \ud83e\udd14", "url": "https://github.com/openequella/openEQUELLA/pull/2172#discussion_r469053446", "createdAt": "2020-08-12T07:15:53Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "diffHunk": "@@ -75,36 +81,112 @@ const defaultSearchPageOptions: SearchPageOptions = {\n };\n const defaultCollectionPrivileges = [\"SEARCH_COLLECTION\"];\n \n+/**\n+ * Simple helper to wrap the process of waiting for the execution of a search based on checking the\n+ * `searchPromise`. Being that it is abstracted out, in the future could change as needed to be\n+ * something other than the `searchPromise`.\n+ */\n+const waitForSearch = async () =>\n+  await act(async () => {\n+    await searchPromise;\n+  });\n+\n+/**\n+ * Helper function for the initial render of the `<SearchPage>` for tests below. Also includes\n+ * the wait for the initial search call.\n+ *\n+ * @returns The RenderResult from the `render` of the `<SearchPage>`\n+ */\n+const renderSearchPage = async (): Promise<RenderResult> => {\n+  window.history.replaceState({}, \"Clean history state\");\n+  const page = render(\n+    <BrowserRouter>\n+      <SearchPage updateTemplate={jest.fn()} />{\" \"}\n+    </BrowserRouter>\n+  );\n+  // Wait for the first completion of initial search\n+  await waitForSearch();\n+\n+  return page;\n+};\n+\n+/**\n+ * Helper function to find individual Refine Search components based on the their `idSuffix`.\n+ *\n+ * @param container The root container to start the search from\n+ * @param componentSuffix Typically the `idSuffix` provided in `SearchPage.tsx`\n+ */\n+const getRefineSearchComponent = (\n+  container: Element,\n+  componentSuffix: string\n+) => {\n+  const id = `#RefineSearchPanel-${componentSuffix}`;\n+  const e = container.querySelector(id);\n+  if (!e) {\n+    throw new Error(`Failed to find ${id}`);\n+  }\n+\n+  return e as HTMLElement;\n+};\n+\n+describe(\"Refine search by status\", () => {\n+  const {\n+    live: liveButtonLabel,\n+    all: allButtonLabel,\n+  } = languageStrings.searchpage.statusSelector;\n+\n+  const expectSearchItemsCalledWithStatus = (status: OEQ.Common.ItemStatus[]) =>\n+    expect(mockSearch).toHaveBeenCalledWith({\n+      ...defaultSearchPageOptions,\n+      status: status,\n+    });\n+\n+  const getStatusSelector = (container: Element): HTMLElement =>\n+    getRefineSearchComponent(container, \"StatusSelector\");\n+\n+  const selectStatus = (container: Element, status: string) =>\n+    fireEvent.click(getByText(getStatusSelector(container), status));\n+\n+  afterEach(() => {\n+    // Needed to keep Enzyme tests below happy", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTYxNg=="}, "originalCommit": {"oid": "a829f3ae75f900592949910a033743009e358963"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDY4NjA0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjo0MzoxOFrOG_T1eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyNzozOVrOG_VHfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzODQ1Ng==", "bodyText": "May I ask why we want a const representing non-live Statuses rather than all Statuses ? If we have something like allStatuses then we can skip some array concatenation.", "url": "https://github.com/openequella/openEQUELLA/pull/2172#discussion_r469038456", "createdAt": "2020-08-12T06:43:18Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -22,11 +22,31 @@ import { Collection } from \"./CollectionsModule\";\n import { DateRange } from \"../components/DateRangeSelector\";\n import { getISODateString } from \"../util/Date\";\n \n+/**\n+ * List of status which are considered 'live'.\n+ */\n+export const liveStatuses: OEQ.Common.ItemStatus[] = [\"LIVE\", \"REVIEW\"];\n+\n+/**\n+ * Predicate for checking if a provided status is not one of `liveStatuses`.\n+ * @param status a status to check for liveliness\n+ */\n+export const nonLiveStatus = (status: OEQ.Common.ItemStatus): boolean =>\n+  !liveStatuses.find((liveStatus) => status === liveStatus);\n+\n+/**\n+ * List of statuses which are considered non-live.\n+ */\n+export const nonLiveStatuses: OEQ.Common.ItemStatus[] = OEQ.Common.ItemStatuses.alternatives", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a829f3ae75f900592949910a033743009e358963"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTQ1Mw==", "bodyText": "I was wondering if anyone would pick this up, as I'm not sure either way. But here goes my thinking...\nIf you have have one subset on hand, it'd be useful to have the complement too. As in this case now I can readily say here are the 'live' status, and here are the 'non-live' statuses for any business logic we need to implement. And then if we need all I can be explicit and say here are all the live and non-live statuses. (But I've probably over thought it at this point.)\nThen as an aside, we do now technically have all the status on hand thanks to runtypes - via OEQ.Common.ItemStatuses.alternatives.map( i => i.value).\nBut so that is the thinking. What do you think? Should I drop the nonLiveStatuses and just use the above code snippet where we need all?", "url": "https://github.com/openequella/openEQUELLA/pull/2172#discussion_r469059453", "createdAt": "2020-08-12T07:27:39Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -22,11 +22,31 @@ import { Collection } from \"./CollectionsModule\";\n import { DateRange } from \"../components/DateRangeSelector\";\n import { getISODateString } from \"../util/Date\";\n \n+/**\n+ * List of status which are considered 'live'.\n+ */\n+export const liveStatuses: OEQ.Common.ItemStatus[] = [\"LIVE\", \"REVIEW\"];\n+\n+/**\n+ * Predicate for checking if a provided status is not one of `liveStatuses`.\n+ * @param status a status to check for liveliness\n+ */\n+export const nonLiveStatus = (status: OEQ.Common.ItemStatus): boolean =>\n+  !liveStatuses.find((liveStatus) => status === liveStatus);\n+\n+/**\n+ * List of statuses which are considered non-live.\n+ */\n+export const nonLiveStatuses: OEQ.Common.ItemStatus[] = OEQ.Common.ItemStatuses.alternatives", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzODQ1Ng=="}, "originalCommit": {"oid": "a829f3ae75f900592949910a033743009e358963"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1222, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}