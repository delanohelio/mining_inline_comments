{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMTQ3NzAx", "number": 1516, "title": "REST API for Search Filter", "bodyText": "#1337\nChecklist\n\n the [contributor license agreement] is signed\n commit message follows [commit guidelines]\n tests are included\n screenshots are included showing significant UI changes\n\nDescription of change\nREST APIs for SearchFilter.", "createdAt": "2020-03-02T03:00:12Z", "url": "https://github.com/openequella/openEQUELLA/pull/1516", "merged": true, "mergeCommit": {"oid": "c418e36b398c5c90762ba0477e2145c5116a8844"}, "closed": true, "closedAt": "2020-03-10T22:13:18Z", "author": {"login": "PenghaiZhang"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJkj71AH2gAyMzgyMTQ3NzAxOjYyMGFlYTg1MDA0MjdjYjQzOGNmNGIzMjdjYTYzYjUwNTk5MWI3MjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMMJBGgFqTM3MTY5Nzc3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "620aea8500427cb438cf4b327ca63b505991b723", "author": {"user": {"login": "PenghaiZhang", "name": null}}, "url": "https://github.com/openequella/openEQUELLA/commit/620aea8500427cb438cf4b327ca63b505991b723", "committedDate": "2020-03-02T02:47:14Z", "message": "REST API for Search Filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "696c6d0f13f6e5f87b321ef0e4ebcef820114f70", "author": {"user": {"login": "PenghaiZhang", "name": null}}, "url": "https://github.com/openequella/openEQUELLA/commit/696c6d0f13f6e5f87b321ef0e4ebcef820114f70", "committedDate": "2020-03-02T05:22:29Z", "message": "Change some wording."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MzU1ODg3", "url": "https://github.com/openequella/openEQUELLA/pull/1516#pullrequestreview-368355887", "createdAt": "2020-03-03T21:58:05Z", "commit": {"oid": "696c6d0f13f6e5f87b321ef0e4ebcef820114f70"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1ODowNVrOFxYD-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowMzo0NVrOFxYPEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODc3Ng==", "bodyText": "For REST APIs, it's rather handy to return the id of the new entity.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r387318776", "createdAt": "2020-03-03T21:58:05Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.settings\n+\n+import java.util.UUID\n+import com.tle.common.settings.standard.SearchSettings\n+import com.tle.common.settings.standard.SearchSettings.SearchFilter\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.settings.SettingsApiHelper.{loadSettings, updateSettings}\n+import io.swagger.annotations.{Api, ApiOperation, ApiParam}\n+import javax.ws.rs.core.Response\n+import javax.ws.rs.{DELETE, GET, POST, PUT, Path, PathParam, Produces, QueryParam}\n+import org.jboss.resteasy.annotations.cache.NoCache\n+\n+@NoCache\n+@Path(\"settings/\")\n+@Produces(value = Array(\"application/json\"))\n+@Api(value = \"Settings\")\n+class SearchFilterResource {\n+\n+  val searchPrivProvider = LegacyGuice.searchPrivProvider\n+\n+  @GET\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"List search filters\",\n+    notes = \"This endpoint is used to retrieve all search filters.\",\n+    response = classOf[SearchFilter],\n+    responseContainer = \"List\"\n+  )\n+  def listSearchFilters: Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val filters = loadSettings(new SearchSettings).getFilters\n+    Response.ok().entity(filters).build()\n+  }\n+\n+  @GET\n+  @Path(\"search/filter/{uuid}\")\n+  @ApiOperation(\n+    value = \"Retrieve a search filter\",\n+    notes = \"This endpoint is used to retrieve one search filter.\",\n+    response = classOf[SearchFilter]\n+  )\n+  def getSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID): Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val searchSettings = loadSettings(new SearchSettings)\n+\n+    getFilterById(uuid, searchSettings) match {\n+      case Some(filter) => Response.ok().entity(filter).build()\n+      case None         => Response.status(404).build()\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"Add a search filter\",\n+    notes = \"This endpoint is used to add a search filter.\",\n+  )\n+  def addSearchFilter(\n+      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n+      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n+        String]): Response = {\n+    val searchFilter = new SearchFilter\n+    searchFilter.setId(UUID.randomUUID().toString)\n+    searchFilter.setName(name)\n+    searchFilter.setMimeTypes(mimeTypes)\n+    loadSettings(new SearchSettings).getFilters.add(searchFilter)\n+    Response.status(201).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "696c6d0f13f6e5f87b321ef0e4ebcef820114f70"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxOTIwNQ==", "bodyText": "What gets fired back at the client if there's a constraint violation? Ideally I'd expect a 4xx error, but I'm fearing it'll be a 500.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r387319205", "createdAt": "2020-03-03T21:58:53Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.settings\n+\n+import java.util.UUID\n+import com.tle.common.settings.standard.SearchSettings\n+import com.tle.common.settings.standard.SearchSettings.SearchFilter\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.settings.SettingsApiHelper.{loadSettings, updateSettings}\n+import io.swagger.annotations.{Api, ApiOperation, ApiParam}\n+import javax.ws.rs.core.Response\n+import javax.ws.rs.{DELETE, GET, POST, PUT, Path, PathParam, Produces, QueryParam}\n+import org.jboss.resteasy.annotations.cache.NoCache\n+\n+@NoCache\n+@Path(\"settings/\")\n+@Produces(value = Array(\"application/json\"))\n+@Api(value = \"Settings\")\n+class SearchFilterResource {\n+\n+  val searchPrivProvider = LegacyGuice.searchPrivProvider\n+\n+  @GET\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"List search filters\",\n+    notes = \"This endpoint is used to retrieve all search filters.\",\n+    response = classOf[SearchFilter],\n+    responseContainer = \"List\"\n+  )\n+  def listSearchFilters: Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val filters = loadSettings(new SearchSettings).getFilters\n+    Response.ok().entity(filters).build()\n+  }\n+\n+  @GET\n+  @Path(\"search/filter/{uuid}\")\n+  @ApiOperation(\n+    value = \"Retrieve a search filter\",\n+    notes = \"This endpoint is used to retrieve one search filter.\",\n+    response = classOf[SearchFilter]\n+  )\n+  def getSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID): Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val searchSettings = loadSettings(new SearchSettings)\n+\n+    getFilterById(uuid, searchSettings) match {\n+      case Some(filter) => Response.ok().entity(filter).build()\n+      case None         => Response.status(404).build()\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"Add a search filter\",\n+    notes = \"This endpoint is used to add a search filter.\",\n+  )\n+  def addSearchFilter(\n+      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n+      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n+        String]): Response = {\n+    val searchFilter = new SearchFilter\n+    searchFilter.setId(UUID.randomUUID().toString)\n+    searchFilter.setName(name)\n+    searchFilter.setMimeTypes(mimeTypes)\n+    loadSettings(new SearchSettings).getFilters.add(searchFilter)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "696c6d0f13f6e5f87b321ef0e4ebcef820114f70"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMTYxOQ==", "bodyText": "Be good to add a couple of negative tests:\n\nAttempt to update a non-existent filter (i.e. wrong UUID)\nAttempt to delete a non-existent filter\nAttempt to use the end-points when not authenticated", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r387321619", "createdAt": "2020-03-03T22:03:45Z", "author": {"login": "edalex-ian"}, "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "diffHunk": "@@ -115,4 +117,49 @@ public void testCloudSettings() throws Exception {\n     final JsonNode updatedCloudSettings = getEntity(uri, token);\n     assertTrue(updatedCloudSettings.get(DISABLE_CLOUD).asBoolean());\n   }\n+\n+  @Test\n+  public void testSearchFilter() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "696c6d0f13f6e5f87b321ef0e4ebcef820114f70"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf", "author": {"user": {"login": "PenghaiZhang", "name": null}}, "url": "https://github.com/openequella/openEQUELLA/commit/0250bc183bc7c9ad2982f8a00785fb217b4c8ddf", "committedDate": "2020-03-05T04:22:25Z", "message": "Add data validation for Search filters;\nAdd more negative tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMDI2ODY0", "url": "https://github.com/openequella/openEQUELLA/pull/1516#pullrequestreview-370026864", "createdAt": "2020-03-06T01:19:10Z", "commit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMToxOToxMVrOFyqQAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozNDowN1rOFyqf7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NTM0NQ==", "bodyText": "I'm thinking we probably want to stick with JSON for all responses.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388665345", "createdAt": "2020-03-06T01:19:11Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -68,24 +73,32 @@ class SearchFilterResource {\n   }\n \n   @POST\n+  @Produces(value = Array(\"text/html\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NzAwMA==", "bodyText": "To keep things simple, it'd be fine to return the new SearchFilter.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388667000", "createdAt": "2020-03-06T01:25:05Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -68,24 +73,32 @@ class SearchFilterResource {\n   }\n \n   @POST\n+  @Produces(value = Array(\"text/html\"))\n   @Path(\"search/filter\")\n   @ApiOperation(\n     value = \"Add a search filter\",\n-    notes = \"This endpoint is used to add a search filter.\",\n+    notes =\n+      \"This endpoint is used to add a search filter. The new filter's ID is returned if operation is successful.\",\n   )\n   def addSearchFilter(\n       @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n       @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n         String]): Response = {\n-    val searchFilter = new SearchFilter\n-    searchFilter.setId(UUID.randomUUID().toString)\n-    searchFilter.setName(name)\n-    searchFilter.setMimeTypes(mimeTypes)\n-    loadSettings(new SearchSettings).getFilters.add(searchFilter)\n-    Response.status(201).build()\n+    searchPrivProvider.checkAuthorised()\n+    validate(name, mimeTypes) match {\n+      case Left(error) => Response.status(400).entity(error).build()\n+      case Right(_) =>\n+        val searchFilter = new SearchFilter\n+        searchFilter.setId(UUID.randomUUID().toString)\n+        searchFilter.setName(name)\n+        searchFilter.setMimeTypes(mimeTypes)\n+        loadSettings(new SearchSettings).getFilters.add(searchFilter)\n+        Response.status(201).entity(searchFilter.getId).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2ODU1OQ==", "bodyText": "It'd be nice if we had a standard error response model - especially as we move forward with these REST APIs. Something like seen in say Twitter API - see 'Error Messages' section @ https://developer.twitter.com/en/docs/basics/response-codes\nI reckon if we get such a thing setup here, we can then use it for all our future endpoints.\nI do also wonder what general error handling the current framework offers us though - such as when an unchecked exception is triggered.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388668559", "createdAt": "2020-03-06T01:30:54Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -68,24 +73,32 @@ class SearchFilterResource {\n   }\n \n   @POST\n+  @Produces(value = Array(\"text/html\"))\n   @Path(\"search/filter\")\n   @ApiOperation(\n     value = \"Add a search filter\",\n-    notes = \"This endpoint is used to add a search filter.\",\n+    notes =\n+      \"This endpoint is used to add a search filter. The new filter's ID is returned if operation is successful.\",\n   )\n   def addSearchFilter(\n       @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n       @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n         String]): Response = {\n-    val searchFilter = new SearchFilter\n-    searchFilter.setId(UUID.randomUUID().toString)\n-    searchFilter.setName(name)\n-    searchFilter.setMimeTypes(mimeTypes)\n-    loadSettings(new SearchSettings).getFilters.add(searchFilter)\n-    Response.status(201).build()\n+    searchPrivProvider.checkAuthorised()\n+    validate(name, mimeTypes) match {\n+      case Left(error) => Response.status(400).entity(error).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2ODk0Ng==", "bodyText": "I'm thinking if in the POST we're going to return the SearchFilter, it could be useful to do the same here.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388668946", "createdAt": "2020-03-06T01:32:20Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -101,10 +114,14 @@ class SearchFilterResource {\n \n     getFilterById(uuid, searchSettings) match {\n       case Some(filter) =>\n-        filter.setMimeTypes(mimeTypes)\n-        filter.setName(name)\n-        updateSettings(searchSettings)\n-        Response.status(204).build()\n+        validate(name, mimeTypes) match {\n+          case Left(error) => Response.status(400).entity(error).build()\n+          case Right(_) =>\n+            filter.setMimeTypes(mimeTypes)\n+            filter.setName(name)\n+            updateSettings(searchSettings)\n+            Response.status(204).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2OTA3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  errorMessages += \"Need at least one MIMEType.\"\n          \n          \n            \n                  errorMessages += \"Need at least one MIME type.\"", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388669071", "createdAt": "2020-03-06T01:32:52Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -133,4 +150,35 @@ class SearchFilterResource {\n                             searchSettings: SearchSettings): Option[SearchFilter] = {\n     Option(searchSettings.getSearchFilter(filterId.toString))\n   }\n+\n+  private def validate(filterName: String,\n+                       mimeTypes: java.util.List[String]): Either[String, Unit] = {\n+    val errorMessages = ArrayBuffer[String]()\n+\n+    if (Check.isEmpty(filterName)) {\n+      errorMessages += \"Filter name cannot be empty.\"\n+    }\n+\n+    if (Check.isEmpty(mimeTypes)) {\n+      errorMessages += \"Need at least one MIMEType.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2OTQyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    errorMessages += \"Value of MIMEType cannot be empty.\"\n          \n          \n            \n                    errorMessages += \"Value of MIME type cannot be empty.\"", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388669420", "createdAt": "2020-03-06T01:34:07Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -133,4 +150,35 @@ class SearchFilterResource {\n                             searchSettings: SearchSettings): Option[SearchFilter] = {\n     Option(searchSettings.getSearchFilter(filterId.toString))\n   }\n+\n+  private def validate(filterName: String,\n+                       mimeTypes: java.util.List[String]): Either[String, Unit] = {\n+    val errorMessages = ArrayBuffer[String]()\n+\n+    if (Check.isEmpty(filterName)) {\n+      errorMessages += \"Filter name cannot be empty.\"\n+    }\n+\n+    if (Check.isEmpty(mimeTypes)) {\n+      errorMessages += \"Need at least one MIMEType.\"\n+    } else {\n+      if (mimeTypes.asScala.exists(_.isEmpty)) {\n+        errorMessages += \"Value of MIMEType cannot be empty.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c5df51d684996f2335b134bf7380571665c9c29", "author": {"user": {"login": "PenghaiZhang", "name": null}}, "url": "https://github.com/openequella/openEQUELLA/commit/2c5df51d684996f2335b134bf7380571665c9c29", "committedDate": "2020-03-10T05:23:33Z", "message": "Create a standard error response for REST calls;\nReturn more meaningful response to front-end;\nImprove test coverage."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNjk3Nzc5", "url": "https://github.com/openequella/openEQUELLA/pull/1516#pullrequestreview-371697779", "createdAt": "2020-03-10T06:01:53Z", "commit": {"oid": "2c5df51d684996f2335b134bf7380571665c9c29"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 152, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}