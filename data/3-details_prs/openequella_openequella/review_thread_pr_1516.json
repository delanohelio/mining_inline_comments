{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMTQ3NzAx", "number": 1516, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1ODowNVrODk1Lcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozNDowN1rODlpxuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQ2NjExOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1ODowNVrOFxYD-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1ODowNVrOFxYD-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODc3Ng==", "bodyText": "For REST APIs, it's rather handy to return the id of the new entity.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r387318776", "createdAt": "2020-03-03T21:58:05Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.settings\n+\n+import java.util.UUID\n+import com.tle.common.settings.standard.SearchSettings\n+import com.tle.common.settings.standard.SearchSettings.SearchFilter\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.settings.SettingsApiHelper.{loadSettings, updateSettings}\n+import io.swagger.annotations.{Api, ApiOperation, ApiParam}\n+import javax.ws.rs.core.Response\n+import javax.ws.rs.{DELETE, GET, POST, PUT, Path, PathParam, Produces, QueryParam}\n+import org.jboss.resteasy.annotations.cache.NoCache\n+\n+@NoCache\n+@Path(\"settings/\")\n+@Produces(value = Array(\"application/json\"))\n+@Api(value = \"Settings\")\n+class SearchFilterResource {\n+\n+  val searchPrivProvider = LegacyGuice.searchPrivProvider\n+\n+  @GET\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"List search filters\",\n+    notes = \"This endpoint is used to retrieve all search filters.\",\n+    response = classOf[SearchFilter],\n+    responseContainer = \"List\"\n+  )\n+  def listSearchFilters: Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val filters = loadSettings(new SearchSettings).getFilters\n+    Response.ok().entity(filters).build()\n+  }\n+\n+  @GET\n+  @Path(\"search/filter/{uuid}\")\n+  @ApiOperation(\n+    value = \"Retrieve a search filter\",\n+    notes = \"This endpoint is used to retrieve one search filter.\",\n+    response = classOf[SearchFilter]\n+  )\n+  def getSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID): Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val searchSettings = loadSettings(new SearchSettings)\n+\n+    getFilterById(uuid, searchSettings) match {\n+      case Some(filter) => Response.ok().entity(filter).build()\n+      case None         => Response.status(404).build()\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"Add a search filter\",\n+    notes = \"This endpoint is used to add a search filter.\",\n+  )\n+  def addSearchFilter(\n+      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n+      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n+        String]): Response = {\n+    val searchFilter = new SearchFilter\n+    searchFilter.setId(UUID.randomUUID().toString)\n+    searchFilter.setName(name)\n+    searchFilter.setMimeTypes(mimeTypes)\n+    loadSettings(new SearchSettings).getFilters.add(searchFilter)\n+    Response.status(201).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "696c6d0f13f6e5f87b321ef0e4ebcef820114f70"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQ2ODczOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1ODo1M1rOFxYFpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1ODo1M1rOFxYFpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxOTIwNQ==", "bodyText": "What gets fired back at the client if there's a constraint violation? Ideally I'd expect a 4xx error, but I'm fearing it'll be a 500.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r387319205", "createdAt": "2020-03-03T21:58:53Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.settings\n+\n+import java.util.UUID\n+import com.tle.common.settings.standard.SearchSettings\n+import com.tle.common.settings.standard.SearchSettings.SearchFilter\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.settings.SettingsApiHelper.{loadSettings, updateSettings}\n+import io.swagger.annotations.{Api, ApiOperation, ApiParam}\n+import javax.ws.rs.core.Response\n+import javax.ws.rs.{DELETE, GET, POST, PUT, Path, PathParam, Produces, QueryParam}\n+import org.jboss.resteasy.annotations.cache.NoCache\n+\n+@NoCache\n+@Path(\"settings/\")\n+@Produces(value = Array(\"application/json\"))\n+@Api(value = \"Settings\")\n+class SearchFilterResource {\n+\n+  val searchPrivProvider = LegacyGuice.searchPrivProvider\n+\n+  @GET\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"List search filters\",\n+    notes = \"This endpoint is used to retrieve all search filters.\",\n+    response = classOf[SearchFilter],\n+    responseContainer = \"List\"\n+  )\n+  def listSearchFilters: Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val filters = loadSettings(new SearchSettings).getFilters\n+    Response.ok().entity(filters).build()\n+  }\n+\n+  @GET\n+  @Path(\"search/filter/{uuid}\")\n+  @ApiOperation(\n+    value = \"Retrieve a search filter\",\n+    notes = \"This endpoint is used to retrieve one search filter.\",\n+    response = classOf[SearchFilter]\n+  )\n+  def getSearchFilter(@ApiParam(value = \"filter UUID\") @PathParam(\"uuid\") uuid: UUID): Response = {\n+    searchPrivProvider.checkAuthorised()\n+    val searchSettings = loadSettings(new SearchSettings)\n+\n+    getFilterById(uuid, searchSettings) match {\n+      case Some(filter) => Response.ok().entity(filter).build()\n+      case None         => Response.status(404).build()\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"search/filter\")\n+  @ApiOperation(\n+    value = \"Add a search filter\",\n+    notes = \"This endpoint is used to add a search filter.\",\n+  )\n+  def addSearchFilter(\n+      @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n+      @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n+        String]): Response = {\n+    val searchFilter = new SearchFilter\n+    searchFilter.setId(UUID.randomUUID().toString)\n+    searchFilter.setName(name)\n+    searchFilter.setMimeTypes(mimeTypes)\n+    loadSettings(new SearchSettings).getFilters.add(searchFilter)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "696c6d0f13f6e5f87b321ef0e4ebcef820114f70"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQ4Mzc3OnYy", "diffSide": "RIGHT", "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowMzo0NVrOFxYPEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowMzo0NVrOFxYPEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMTYxOQ==", "bodyText": "Be good to add a couple of negative tests:\n\nAttempt to update a non-existent filter (i.e. wrong UUID)\nAttempt to delete a non-existent filter\nAttempt to use the end-points when not authenticated", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r387321619", "createdAt": "2020-03-03T22:03:45Z", "author": {"login": "edalex-ian"}, "path": "autotest/OldTests/src/test/java/com/tle/webtests/test/webservices/rest/SearchSettingApiTest.java", "diffHunk": "@@ -115,4 +117,49 @@ public void testCloudSettings() throws Exception {\n     final JsonNode updatedCloudSettings = getEntity(uri, token);\n     assertTrue(updatedCloudSettings.get(DISABLE_CLOUD).asBoolean());\n   }\n+\n+  @Test\n+  public void testSearchFilter() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "696c6d0f13f6e5f87b321ef0e4ebcef820114f70"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODA1NzUxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMToxOToxMVrOFyqQAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMToxOToxMVrOFyqQAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NTM0NQ==", "bodyText": "I'm thinking we probably want to stick with JSON for all responses.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388665345", "createdAt": "2020-03-06T01:19:11Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -68,24 +73,32 @@ class SearchFilterResource {\n   }\n \n   @POST\n+  @Produces(value = Array(\"text/html\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODA2ODA3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMToyNTowNVrOFyqWeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMToyNTowNVrOFyqWeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NzAwMA==", "bodyText": "To keep things simple, it'd be fine to return the new SearchFilter.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388667000", "createdAt": "2020-03-06T01:25:05Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -68,24 +73,32 @@ class SearchFilterResource {\n   }\n \n   @POST\n+  @Produces(value = Array(\"text/html\"))\n   @Path(\"search/filter\")\n   @ApiOperation(\n     value = \"Add a search filter\",\n-    notes = \"This endpoint is used to add a search filter.\",\n+    notes =\n+      \"This endpoint is used to add a search filter. The new filter's ID is returned if operation is successful.\",\n   )\n   def addSearchFilter(\n       @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n       @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n         String]): Response = {\n-    val searchFilter = new SearchFilter\n-    searchFilter.setId(UUID.randomUUID().toString)\n-    searchFilter.setName(name)\n-    searchFilter.setMimeTypes(mimeTypes)\n-    loadSettings(new SearchSettings).getFilters.add(searchFilter)\n-    Response.status(201).build()\n+    searchPrivProvider.checkAuthorised()\n+    validate(name, mimeTypes) match {\n+      case Left(error) => Response.status(400).entity(error).build()\n+      case Right(_) =>\n+        val searchFilter = new SearchFilter\n+        searchFilter.setId(UUID.randomUUID().toString)\n+        searchFilter.setName(name)\n+        searchFilter.setMimeTypes(mimeTypes)\n+        loadSettings(new SearchSettings).getFilters.add(searchFilter)\n+        Response.status(201).entity(searchFilter.getId).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODA3ODM1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozMDo1NFrOFyqcjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozMDo1NFrOFyqcjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2ODU1OQ==", "bodyText": "It'd be nice if we had a standard error response model - especially as we move forward with these REST APIs. Something like seen in say Twitter API - see 'Error Messages' section @ https://developer.twitter.com/en/docs/basics/response-codes\nI reckon if we get such a thing setup here, we can then use it for all our future endpoints.\nI do also wonder what general error handling the current framework offers us though - such as when an unchecked exception is triggered.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388668559", "createdAt": "2020-03-06T01:30:54Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -68,24 +73,32 @@ class SearchFilterResource {\n   }\n \n   @POST\n+  @Produces(value = Array(\"text/html\"))\n   @Path(\"search/filter\")\n   @ApiOperation(\n     value = \"Add a search filter\",\n-    notes = \"This endpoint is used to add a search filter.\",\n+    notes =\n+      \"This endpoint is used to add a search filter. The new filter's ID is returned if operation is successful.\",\n   )\n   def addSearchFilter(\n       @ApiParam(value = \"filter name\", required = true) @QueryParam(\"name\") name: String,\n       @ApiParam(value = \"filter types\", required = true) @QueryParam(\"mimeTypes\") mimeTypes: java.util.List[\n         String]): Response = {\n-    val searchFilter = new SearchFilter\n-    searchFilter.setId(UUID.randomUUID().toString)\n-    searchFilter.setName(name)\n-    searchFilter.setMimeTypes(mimeTypes)\n-    loadSettings(new SearchSettings).getFilters.add(searchFilter)\n-    Response.status(201).build()\n+    searchPrivProvider.checkAuthorised()\n+    validate(name, mimeTypes) match {\n+      case Left(error) => Response.status(400).entity(error).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODA4MDgxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozMjoyMFrOFyqeEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozMjoyMFrOFyqeEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2ODk0Ng==", "bodyText": "I'm thinking if in the POST we're going to return the SearchFilter, it could be useful to do the same here.", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388668946", "createdAt": "2020-03-06T01:32:20Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -101,10 +114,14 @@ class SearchFilterResource {\n \n     getFilterById(uuid, searchSettings) match {\n       case Some(filter) =>\n-        filter.setMimeTypes(mimeTypes)\n-        filter.setName(name)\n-        updateSettings(searchSettings)\n-        Response.status(204).build()\n+        validate(name, mimeTypes) match {\n+          case Left(error) => Response.status(400).entity(error).build()\n+          case Right(_) =>\n+            filter.setMimeTypes(mimeTypes)\n+            filter.setName(name)\n+            updateSettings(searchSettings)\n+            Response.status(204).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODA4MTU2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozMjo1MlrOFyqejw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozMjo1MlrOFyqejw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2OTA3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  errorMessages += \"Need at least one MIMEType.\"\n          \n          \n            \n                  errorMessages += \"Need at least one MIME type.\"", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388669071", "createdAt": "2020-03-06T01:32:52Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -133,4 +150,35 @@ class SearchFilterResource {\n                             searchSettings: SearchSettings): Option[SearchFilter] = {\n     Option(searchSettings.getSearchFilter(filterId.toString))\n   }\n+\n+  private def validate(filterName: String,\n+                       mimeTypes: java.util.List[String]): Either[String, Unit] = {\n+    val errorMessages = ArrayBuffer[String]()\n+\n+    if (Check.isEmpty(filterName)) {\n+      errorMessages += \"Filter name cannot be empty.\"\n+    }\n+\n+    if (Check.isEmpty(mimeTypes)) {\n+      errorMessages += \"Need at least one MIMEType.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODA4Mzc2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozNDowN1rOFyqf7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTozNDowN1rOFyqf7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2OTQyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    errorMessages += \"Value of MIMEType cannot be empty.\"\n          \n          \n            \n                    errorMessages += \"Value of MIME type cannot be empty.\"", "url": "https://github.com/openequella/openEQUELLA/pull/1516#discussion_r388669420", "createdAt": "2020-03-06T01:34:07Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/settings/SearchFilterResource.scala", "diffHunk": "@@ -133,4 +150,35 @@ class SearchFilterResource {\n                             searchSettings: SearchSettings): Option[SearchFilter] = {\n     Option(searchSettings.getSearchFilter(filterId.toString))\n   }\n+\n+  private def validate(filterName: String,\n+                       mimeTypes: java.util.List[String]): Either[String, Unit] = {\n+    val errorMessages = ArrayBuffer[String]()\n+\n+    if (Check.isEmpty(filterName)) {\n+      errorMessages += \"Filter name cannot be empty.\"\n+    }\n+\n+    if (Check.isEmpty(mimeTypes)) {\n+      errorMessages += \"Need at least one MIMEType.\"\n+    } else {\n+      if (mimeTypes.asScala.exists(_.isEmpty)) {\n+        errorMessages += \"Value of MIMEType cannot be empty.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0250bc183bc7c9ad2982f8a00785fb217b4c8ddf"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1482, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}