{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MjMxMzEx", "number": 2245, "reviewThreads": {"totalCount": 46, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMDozNzo1N1rOEeHwvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo1MjoxNVrOEf3l1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDE5OTAyOnYy", "diffSide": "LEFT", "path": "Source/Plugins/Core/com.equella.core/js/__stories__/search/FacetSelector.stories.tsx", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMDozNzo1N1rOHJm-Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNDo1NDo0OFrOHKiCeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgzNzc2Mg==", "bodyText": "Now this is controlled by the component's state so we don't need these two stories (the remaining stories can also show/hide the buttons. I also did some research about how to directly modify state with Storybook to and this seems not to be encouraged (and well supported).", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479837762", "createdAt": "2020-08-31T00:37:57Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/__stories__/search/FacetSelector.stories.tsx", "diffHunk": "@@ -58,17 +54,3 @@ termsSelected.args = {\n   ...noTermsSelected.args,\n   selectedClassificationTerms: selectedClassificationTerms,\n };\n-\n-export const showMore: Story<FacetSelectorProps> = FacetSelectorTemplate.bind(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0NDAxNA==", "bodyText": "Yeah it's interesting, as ideally you'd have a different story for each state. However here the state can not be externally triggered other than by interactions.\nWith the state being internally managed though, does that mean when you click show more/show less in storybook it is now actually properly itnteractive?", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479844014", "createdAt": "2020-08-31T01:18:42Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__stories__/search/FacetSelector.stories.tsx", "diffHunk": "@@ -58,17 +54,3 @@ termsSelected.args = {\n   ...noTermsSelected.args,\n   selectedClassificationTerms: selectedClassificationTerms,\n };\n-\n-export const showMore: Story<FacetSelectorProps> = FacetSelectorTemplate.bind(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgzNzc2Mg=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgwNTQ5OA==", "bodyText": "Yes, they are interactive in storybook now.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r480805498", "createdAt": "2020-09-01T04:54:48Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/__stories__/search/FacetSelector.stories.tsx", "diffHunk": "@@ -58,17 +54,3 @@ termsSelected.args = {\n   ...noTermsSelected.args,\n   selectedClassificationTerms: selectedClassificationTerms,\n };\n-\n-export const showMore: Story<FacetSelectorProps> = FacetSelectorTemplate.bind(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgzNzc2Mg=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDIwMzgxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMDo0MjozMlrOHJnArQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTozOTowOVrOHJnluA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgzODM4MQ==", "bodyText": "Do we want to move this function outside ?", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479838381", "createdAt": "2020-08-31T00:42:32Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -116,40 +116,32 @@ export const defaultPagedSearchResult: OEQ.Common.PagedResult<OEQ.Search.SearchR\n  * @param query the intended search query to be sent to the API\n  * @param addWildcard whether a wildcard should be appended\n  */\n-const formatQuery = (query: string, addWildcard: boolean): string => {\n+export const formatQuery = (query: string, addWildcard: boolean): string => {\n   const trimmedQuery = query ? query.trim() : \"\";\n   const appendWildcard = addWildcard && trimmedQuery.length > 0;\n   return trimmedQuery + (appendWildcard ? \"*\" : \"\");\n };\n \n /**\n- * This function processes the query put in the SearchBar and terms selected from Classifications.\n- * It firstly formats the query based on whether raw mode is on or off.\n- * If there are no Classifications terms selected, it returns the formatted query.\n- * Otherwise, it consolidates all terms into one Lucene query by OR, and combines the two queries\n- * by AND, and return the combined one.\n+ * Generates a Where clause for search. Each condition is linked by a AND.\n  *\n- * @param query The query put in the SearchBar.\n- * @param rawMode Whether raw mode is on or off.\n  * @param classificationTerms A list of selected Classification terms.\n  */\n-const processQuery = (\n-  query: string | undefined,\n-  rawMode: boolean,\n-  classificationTerms?: string[]\n+export const generateWhereQuery = (\n+  classificationTerms?: Map<number, NodeAndTerms>\n ): string | undefined => {\n-  // If query is undefined, then we want to keep 'undefined'; but otherwise let's pre-process it.\n-  const textQuery = query ? formatQuery(query, !rawMode) : undefined;\n-\n-  if (!classificationTerms || classificationTerms.length === 0) {\n-    return textQuery;\n+  if (!classificationTerms) {\n+    return undefined;\n   }\n \n-  const or = \" OR \";\n+  // Append '/xml' back to the schema node and generate a search condition for each term.\n+  const processNodeTerms = ({ node, terms }: NodeAndTerms) =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0Nzg2NA==", "bodyText": "I don't see any need yet.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479847864", "createdAt": "2020-08-31T01:39:09Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -116,40 +116,32 @@ export const defaultPagedSearchResult: OEQ.Common.PagedResult<OEQ.Search.SearchR\n  * @param query the intended search query to be sent to the API\n  * @param addWildcard whether a wildcard should be appended\n  */\n-const formatQuery = (query: string, addWildcard: boolean): string => {\n+export const formatQuery = (query: string, addWildcard: boolean): string => {\n   const trimmedQuery = query ? query.trim() : \"\";\n   const appendWildcard = addWildcard && trimmedQuery.length > 0;\n   return trimmedQuery + (appendWildcard ? \"*\" : \"\");\n };\n \n /**\n- * This function processes the query put in the SearchBar and terms selected from Classifications.\n- * It firstly formats the query based on whether raw mode is on or off.\n- * If there are no Classifications terms selected, it returns the formatted query.\n- * Otherwise, it consolidates all terms into one Lucene query by OR, and combines the two queries\n- * by AND, and return the combined one.\n+ * Generates a Where clause for search. Each condition is linked by a AND.\n  *\n- * @param query The query put in the SearchBar.\n- * @param rawMode Whether raw mode is on or off.\n  * @param classificationTerms A list of selected Classification terms.\n  */\n-const processQuery = (\n-  query: string | undefined,\n-  rawMode: boolean,\n-  classificationTerms?: string[]\n+export const generateWhereQuery = (\n+  classificationTerms?: Map<number, NodeAndTerms>\n ): string | undefined => {\n-  // If query is undefined, then we want to keep 'undefined'; but otherwise let's pre-process it.\n-  const textQuery = query ? formatQuery(query, !rawMode) : undefined;\n-\n-  if (!classificationTerms || classificationTerms.length === 0) {\n-    return textQuery;\n+  if (!classificationTerms) {\n+    return undefined;\n   }\n \n-  const or = \" OR \";\n+  // Append '/xml' back to the schema node and generate a search condition for each term.\n+  const processNodeTerms = ({ node, terms }: NodeAndTerms) =>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgzODM4MQ=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDIwNzg1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/SearchPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMDo0NjoxMVrOHJnCxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMDo0NjoxMVrOHJnCxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgzODkxNw==", "bodyText": "Separate the update of Classification list from the first useEffect to help understand the logic more easily.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479838917", "createdAt": "2020-08-31T00:46:11Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/SearchPage.tsx", "diffHunk": "@@ -115,6 +120,15 @@ const SearchPage = ({ updateTemplate }: TemplateUpdateProps) => {\n     }\n   }, [searchPageOptions]);\n \n+  // When Search options get changed, also update the Classification list.\n+  useEffect(() => {\n+    if (!isInitialSearch.current) {\n+      listClassifications(searchPageOptions).then((classifications) =>\n+        setClassifications(classifications)\n+      );\n+    }\n+  }, [searchPageOptions]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDIxMjUxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/SearchPage.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMDo1MDoyN1rOHJnFNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMDo1MDoyN1rOHJnFNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgzOTU0MA==", "bodyText": "You will see more classificationTerms: undefined, below, but the benefit of doing this is we don't need to put  classificationTerms into state, which does not break 'New search' and 'Back to Search page'. So I feel the repeating is fine.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479839540", "createdAt": "2020-08-31T00:50:27Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/SearchPage.tsx", "diffHunk": "@@ -143,13 +157,15 @@ const SearchPage = ({ updateTemplate }: TemplateUpdateProps) => {\n       ...searchPageOptions,\n       query: query,\n       currentPage: 0,\n+      classificationTerms: undefined,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI0NzQ4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMToyMDoxMFrOHJnXxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMToyMDoxMFrOHJnXxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0NDI5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              it(\"should generate a Where clause for schema node and terms\", () => {\n          \n          \n            \n              it(\"should generate a where clause for schema node and terms\", () => {\n          \n      \n    \n    \n  \n\n.... Actually.... This test sits weird. Let's look at the bigger picture of SearchModule.test.ts....\nWe have a single describe block of describe( \"SearchModule\" ) where all the tests have mainly been about calling the primary function of searchItems. However, now that we have an additional function maybe we need to rework the structure here to make sense. For example:\n\n\ndescribe: searchItems\n\nit: lists items\nit: will not do a wildcard search if the query is empty\nit: does a wildcard search if the query is non-empty and rawMode is false\nit: will not do a wildcard search when rawMode is true\n\n\n\ndescribe: generateWhereQuery\n\nit: returns a where query built from supplied schema nodes and terms\n\n\n\n(One thing that then jumps out at me, is the naming of that new function is probably too abstract - as it only generates a rather specific type of where query. I'll try to comment on that again where the new function is.)", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479844292", "createdAt": "2020-08-31T01:20:10Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "diffHunk": "@@ -69,28 +70,14 @@ describe(\"SearchModule\", () => {\n     validateSearchQuery(`${queryTerm}`);\n   });\n \n-  it(\"should append Classification terms to query if one or more Classifications are selected\", async () => {\n+  it(\"should generate a Where clause for schema node and terms\", () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI1MTc5OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMToyMzoxMVrOHJnaEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMToyMzoxMVrOHJnaEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0NDg4MQ==", "bodyText": "Should just use the below wildcard import and then call SearchModule.generateWhereQuery().", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479844881", "createdAt": "2020-08-31T01:23:11Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "diffHunk": "@@ -16,6 +16,7 @@\n  * limitations under the License.\n  */\n import * as OEQ from \"@openequella/rest-api-client\";\n+import { generateWhereQuery } from \"../../../tsrc/modules/SearchModule\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI2ODA2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTozNTozNVrOHJnjJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDowMjozMVrOHMVDPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0NzIwNA==", "bodyText": "Oooh, this is not ideal is it. We're setting up rather tight coupling here between our business logic layers and our presentation layers. NodeAndTerms should probably belong here if we need them here, or at least be broken out from a UI component. (And I note the same for the general DateRange below.)", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479847204", "createdAt": "2020-08-31T01:35:35Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -17,6 +17,7 @@\n  */\n import * as OEQ from \"@openequella/rest-api-client\";\n import { API_BASE_URL } from \"../config\";\n+import { NodeAndTerms } from \"../search/components/FacetSelector\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4OTg1Mg==", "bodyText": "I agree. I also feel DateRange should be sitting in a utility module because it's not specific to Search page.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482689852", "createdAt": "2020-09-03T04:02:31Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -17,6 +17,7 @@\n  */\n import * as OEQ from \"@openequella/rest-api-client\";\n import { API_BASE_URL } from \"../config\";\n+import { NodeAndTerms } from \"../search/components/FacetSelector\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0NzIwNA=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI2OTQxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTozNjoxN1rOHJnj0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTozNjoxN1rOHJnj0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0NzM3Ng==", "bodyText": "It would be worthwhile highlighting what the number (i.e. key) value is representing.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479847376", "createdAt": "2020-08-31T01:36:17Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -64,10 +65,9 @@ export interface SearchOptions {\n    */\n   status?: OEQ.Common.ItemStatus[];\n   /**\n-   * A list of classification terms. (Typically a subset of those generated by\n-   * Search Facets.)\n+   * A map of selected Classifications and their terms.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI3NDYwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0MDoxMlrOHJnmnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0MDoxMlrOHJnmnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0ODA5Mw==", "bodyText": "Should add a test for this. There's currently only the positive test. (Oh, actually I think there's only a test for when there are multiple queries. Ideally there should be a test which covers none, one and greater than one.)", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479848093", "createdAt": "2020-08-31T01:40:12Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -116,40 +116,32 @@ export const defaultPagedSearchResult: OEQ.Common.PagedResult<OEQ.Search.SearchR\n  * @param query the intended search query to be sent to the API\n  * @param addWildcard whether a wildcard should be appended\n  */\n-const formatQuery = (query: string, addWildcard: boolean): string => {\n+export const formatQuery = (query: string, addWildcard: boolean): string => {\n   const trimmedQuery = query ? query.trim() : \"\";\n   const appendWildcard = addWildcard && trimmedQuery.length > 0;\n   return trimmedQuery + (appendWildcard ? \"*\" : \"\");\n };\n \n /**\n- * This function processes the query put in the SearchBar and terms selected from Classifications.\n- * It firstly formats the query based on whether raw mode is on or off.\n- * If there are no Classifications terms selected, it returns the formatted query.\n- * Otherwise, it consolidates all terms into one Lucene query by OR, and combines the two queries\n- * by AND, and return the combined one.\n+ * Generates a Where clause for search. Each condition is linked by a AND.\n  *\n- * @param query The query put in the SearchBar.\n- * @param rawMode Whether raw mode is on or off.\n  * @param classificationTerms A list of selected Classification terms.\n  */\n-const processQuery = (\n-  query: string | undefined,\n-  rawMode: boolean,\n-  classificationTerms?: string[]\n+export const generateWhereQuery = (\n+  classificationTerms?: Map<number, NodeAndTerms>\n ): string | undefined => {\n-  // If query is undefined, then we want to keep 'undefined'; but otherwise let's pre-process it.\n-  const textQuery = query ? formatQuery(query, !rawMode) : undefined;\n-\n-  if (!classificationTerms || classificationTerms.length === 0) {\n-    return textQuery;\n+  if (!classificationTerms) {\n+    return undefined;\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI3ODY1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0MzozMlrOHJno2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0MzozMlrOHJno2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0ODY2NA==", "bodyText": "This needs a more specific name - as it's not a generic where clause builder. It also contains logic specific to how we want to query with selected facets/categories.\nMaybe:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            export const generateWhereQuery = (\n          \n          \n            \n            export const generateFacetedWhereQuery = (", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479848664", "createdAt": "2020-08-31T01:43:32Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -116,40 +116,32 @@ export const defaultPagedSearchResult: OEQ.Common.PagedResult<OEQ.Search.SearchR\n  * @param query the intended search query to be sent to the API\n  * @param addWildcard whether a wildcard should be appended\n  */\n-const formatQuery = (query: string, addWildcard: boolean): string => {\n+export const formatQuery = (query: string, addWildcard: boolean): string => {\n   const trimmedQuery = query ? query.trim() : \"\";\n   const appendWildcard = addWildcard && trimmedQuery.length > 0;\n   return trimmedQuery + (appendWildcard ? \"*\" : \"\");\n };\n \n /**\n- * This function processes the query put in the SearchBar and terms selected from Classifications.\n- * It firstly formats the query based on whether raw mode is on or off.\n- * If there are no Classifications terms selected, it returns the formatted query.\n- * Otherwise, it consolidates all terms into one Lucene query by OR, and combines the two queries\n- * by AND, and return the combined one.\n+ * Generates a Where clause for search. Each condition is linked by a AND.\n  *\n- * @param query The query put in the SearchBar.\n- * @param rawMode Whether raw mode is on or off.\n  * @param classificationTerms A list of selected Classification terms.\n  */\n-const processQuery = (\n-  query: string | undefined,\n-  rawMode: boolean,\n-  classificationTerms?: string[]\n+export const generateWhereQuery = (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI3OTcwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0NDozNFrOHJnpfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0NDozNFrOHJnpfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0ODgzMQ==", "bodyText": "This method does not really care about the key for this map, so should it just be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              classificationTerms?: Map<number, NodeAndTerms>\n          \n          \n            \n              classificationTerms?: NodeAndTerms[]", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479848831", "createdAt": "2020-08-31T01:44:34Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -116,40 +116,32 @@ export const defaultPagedSearchResult: OEQ.Common.PagedResult<OEQ.Search.SearchR\n  * @param query the intended search query to be sent to the API\n  * @param addWildcard whether a wildcard should be appended\n  */\n-const formatQuery = (query: string, addWildcard: boolean): string => {\n+export const formatQuery = (query: string, addWildcard: boolean): string => {\n   const trimmedQuery = query ? query.trim() : \"\";\n   const appendWildcard = addWildcard && trimmedQuery.length > 0;\n   return trimmedQuery + (appendWildcard ? \"*\" : \"\");\n };\n \n /**\n- * This function processes the query put in the SearchBar and terms selected from Classifications.\n- * It firstly formats the query based on whether raw mode is on or off.\n- * If there are no Classifications terms selected, it returns the formatted query.\n- * Otherwise, it consolidates all terms into one Lucene query by OR, and combines the two queries\n- * by AND, and return the combined one.\n+ * Generates a Where clause for search. Each condition is linked by a AND.\n  *\n- * @param query The query put in the SearchBar.\n- * @param rawMode Whether raw mode is on or off.\n  * @param classificationTerms A list of selected Classification terms.\n  */\n-const processQuery = (\n-  query: string | undefined,\n-  rawMode: boolean,\n-  classificationTerms?: string[]\n+export const generateWhereQuery = (\n+  classificationTerms?: Map<number, NodeAndTerms>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI4NDY4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0ODoxOVrOHJnsJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0ODoxOVrOHJnsJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0OTUwOA==", "bodyText": "For readability, could you please type this Map. I think it's:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                const terms = new Map([\n          \n          \n            \n                const terms = new Map<number, NodeAndTerms>([", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479849508", "createdAt": "2020-08-31T01:48:19Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "diffHunk": "@@ -69,28 +70,14 @@ describe(\"SearchModule\", () => {\n     validateSearchQuery(`${queryTerm}`);\n   });\n \n-  it(\"should append Classification terms to query if one or more Classifications are selected\", async () => {\n+  it(\"should generate a Where clause for schema node and terms\", () => {\n     mockedSearch.mockReset();\n-    const query = \"technology\";\n-    const terms = [\"Java\", \"Scala\", \"SBT\"];\n-    await SearchModule.searchItems({\n-      ...SearchModule.defaultSearchOptions,\n-      query: query,\n-      rawMode: false,\n-      classificationTerms: terms,\n-    });\n-    validateSearchQuery(`${query}* AND (Java OR Scala OR SBT)`);\n-  });\n-\n-  it(\"should just send terms to server if query is empty\", async () => {\n-    mockedSearch.mockReset();\n-    const terms = [\"Java\", \"Scala\"];\n-    await SearchModule.searchItems({\n-      ...SearchModule.defaultSearchOptions,\n-      query: undefined,\n-      rawMode: false,\n-      classificationTerms: terms,\n-    });\n-    validateSearchQuery(\"(Java OR Scala)\");\n+    const terms = new Map([", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI4NjM1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0OTo0M1rOHJntFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo0OTo0M1rOHJntFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg0OTc1MA==", "bodyText": "If this is only used in one describe block (as it is), then best to just scope it into that block.\nAlso, the CLASSIFICATION_ID and SCHEMA_NODE variables seem largely redundant. And again, please type this map for readability.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479849750", "createdAt": "2020-08-31T01:49:43Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "diffHunk": "@@ -77,6 +84,12 @@ const defaultSearchPageOptions: SearchPageOptions = {\n const defaultCollectionPrivileges = [\"SEARCH_COLLECTION\"];\n \n const SORTORDER_SELECT_ID = \"#sort-order-select\";\n+const JAVA_TERM = \"java\";\n+const CLASSIFICATION_ID = 766942;\n+const SCHEMA_NODE = \"item/language\";\n+const termsMap = new Map([\n+  [CLASSIFICATION_ID, { node: SCHEMA_NODE, terms: [JAVA_TERM] }],\n+]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI4OTg0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo1MjowM1rOHJnu5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMjoyNzowM1rOHMTVLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1MDIxNA==", "bodyText": "Seeing this is global, and 'term' is rather generic, you may want to go with a more specific name:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            const selectTerm = (container: HTMLElement, term: string) => {\n          \n          \n            \n            const selectCategory = (container: HTMLElement, term: string) => {\n          \n      \n    \n    \n  \n\nAlso (similar to changeQuery), there could be value in asserting that it has now checked the box. Otherwise this function is really just clickCategory - it's not really concerned with selecting.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479850214", "createdAt": "2020-08-31T01:52:03Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "diffHunk": "@@ -185,6 +198,10 @@ const changeQuery = async (\n   });\n };\n \n+const selectTerm = (container: HTMLElement, term: string) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY2MTY3OQ==", "bodyText": "I prefer change the name to clickCategory because we use MUI FormControlLabel which should ensure clicking the label will tick the box.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482661679", "createdAt": "2020-09-03T02:27:03Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/SearchPage.test.tsx", "diffHunk": "@@ -185,6 +198,10 @@ const changeQuery = async (\n   });\n };\n \n+const selectTerm = (container: HTMLElement, term: string) => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1MDIxNA=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI5MTM0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo1MzoyMFrOHJnvyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo1MzoyMFrOHJnvyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1MDQ0Mg==", "bodyText": "Hmmmm, here's this untyped map again. I look forward to when I find the source of this.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479850442", "createdAt": "2020-08-31T01:53:20Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "diffHunk": "@@ -41,16 +40,19 @@ describe(\"<FacetSelector />\", () => {\n   const COLOR = \"Color\";\n   // Mocked facet\n   const HOBART = \"Hobart\";\n-  const mockedSelectedTerms = new Map([[CITY_ID, [HOBART]]]);\n-  // The text of 'SHOW MORE' button\n+  const SCHEMA_NODE = \"item/city\";\n+  const mockedSelectedTerms = new Map([", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI5MzA4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo1NDo0MVrOHJnwxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo1NDo0MVrOHJnwxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1MDY5NA==", "bodyText": "I wonder how this relates to the button query in MuiQueries. If it's the same, we should use that. If not, we should look at moving this there perhaps?", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479850694", "createdAt": "2020-08-31T01:54:41Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "diffHunk": "@@ -67,16 +69,17 @@ describe(\"<FacetSelector />\", () => {\n     return classification;\n   };\n \n-  // Return a Classification's 'SHOW MORE' button.\n-  const queryShowMoreButton = (\n+  // Return a Classification's 'SHOW MORE'/'SHOW LESS' button.\n+  const queryButton = (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDI5OTY1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMTo1OTo0N1rOHJn0mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMToyNDozOFrOHMR4Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1MTY3NQ==", "bodyText": "Can't this just be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (collections && collections.length > 0) {\n          \n          \n            \n                if (collections?.length > 0) {\n          \n      \n    \n    \n  \n\n?\nBut overall it'd be nice if we can keep it declarative inline with the above structure. Maybe we could have in the above block:\ncollections: collections?.length > 0 ? collections.map((c) => c.uuid) | undefined", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479851675", "createdAt": "2020-08-31T01:59:47Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -59,18 +63,36 @@ export interface Classification {\n const convertSearchOptions: (\n   options: SearchOptions\n ) => OEQ.SearchFacets.SearchFacetsParams = memoize(\n-  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => ({\n-    nodes: [],\n-    q: options.query,\n-    collections: options.collections?.map((c) => c.uuid),\n-    modifiedAfter: getISODateString(options.lastModifiedDateRange?.start),\n-    modifiedBefore: getISODateString(options.lastModifiedDateRange?.end),\n-    owner: options.owner?.id,\n-    showall: isEqual(\n-      options.status?.sort(),\n-      OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n-    ),\n-  })\n+  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => {\n+    const {\n+      query,\n+      collections,\n+      lastModifiedDateRange,\n+      owner,\n+      status,\n+      classificationTerms,\n+      rawMode,\n+    } = options;\n+    let searchFacetsParams: OEQ.SearchFacets.SearchFacetsParams = {\n+      nodes: [],\n+      q: query ? formatQuery(query, !rawMode) : undefined,\n+      modifiedAfter: getISODateString(lastModifiedDateRange?.start),\n+      modifiedBefore: getISODateString(lastModifiedDateRange?.end),\n+      owner: owner?.id,\n+      showall: isEqual(\n+        status?.sort(),\n+        OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n+      ),\n+      where: generateWhereQuery(classificationTerms),\n+    };\n+    if (collections && collections.length > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzNzU1NQ==", "bodyText": "The reason for dong this is to make sure collections is not included in the search params when it's undefined or it is empty.  If we pass undefined or an empty collections to the facet search api, we will get nothing returned. (but we can  make some changes on the api side to make it happy with undefined or an empty collections)", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482637555", "createdAt": "2020-09-03T01:23:07Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -59,18 +63,36 @@ export interface Classification {\n const convertSearchOptions: (\n   options: SearchOptions\n ) => OEQ.SearchFacets.SearchFacetsParams = memoize(\n-  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => ({\n-    nodes: [],\n-    q: options.query,\n-    collections: options.collections?.map((c) => c.uuid),\n-    modifiedAfter: getISODateString(options.lastModifiedDateRange?.start),\n-    modifiedBefore: getISODateString(options.lastModifiedDateRange?.end),\n-    owner: options.owner?.id,\n-    showall: isEqual(\n-      options.status?.sort(),\n-      OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n-    ),\n-  })\n+  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => {\n+    const {\n+      query,\n+      collections,\n+      lastModifiedDateRange,\n+      owner,\n+      status,\n+      classificationTerms,\n+      rawMode,\n+    } = options;\n+    let searchFacetsParams: OEQ.SearchFacets.SearchFacetsParams = {\n+      nodes: [],\n+      q: query ? formatQuery(query, !rawMode) : undefined,\n+      modifiedAfter: getISODateString(lastModifiedDateRange?.start),\n+      modifiedBefore: getISODateString(lastModifiedDateRange?.end),\n+      owner: owner?.id,\n+      showall: isEqual(\n+        status?.sort(),\n+        OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n+      ),\n+      where: generateWhereQuery(classificationTerms),\n+    };\n+    if (collections && collections.length > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1MTY3NQ=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzNzkxMA==", "bodyText": "And Typescript is not happy with if (collections?.length > 0) because collections?.length can be undefined. So we can do if (collections?.length ?? 0 > 0) instead.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482637910", "createdAt": "2020-09-03T01:24:38Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -59,18 +63,36 @@ export interface Classification {\n const convertSearchOptions: (\n   options: SearchOptions\n ) => OEQ.SearchFacets.SearchFacetsParams = memoize(\n-  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => ({\n-    nodes: [],\n-    q: options.query,\n-    collections: options.collections?.map((c) => c.uuid),\n-    modifiedAfter: getISODateString(options.lastModifiedDateRange?.start),\n-    modifiedBefore: getISODateString(options.lastModifiedDateRange?.end),\n-    owner: options.owner?.id,\n-    showall: isEqual(\n-      options.status?.sort(),\n-      OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n-    ),\n-  })\n+  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => {\n+    const {\n+      query,\n+      collections,\n+      lastModifiedDateRange,\n+      owner,\n+      status,\n+      classificationTerms,\n+      rawMode,\n+    } = options;\n+    let searchFacetsParams: OEQ.SearchFacets.SearchFacetsParams = {\n+      nodes: [],\n+      q: query ? formatQuery(query, !rawMode) : undefined,\n+      modifiedAfter: getISODateString(lastModifiedDateRange?.start),\n+      modifiedBefore: getISODateString(lastModifiedDateRange?.end),\n+      owner: owner?.id,\n+      showall: isEqual(\n+        status?.sort(),\n+        OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n+      ),\n+      where: generateWhereQuery(classificationTerms),\n+    };\n+    if (collections && collections.length > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1MTY3NQ=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDMxODk3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNDoxMlrOHJn_Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNDoxMlrOHJn_Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1NDM3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              ); // Filter out empty terms\n          \n          \n            \n              ); // Filter out empty terms, as although the server generates them, sending them back will generate a 500", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479854371", "createdAt": "2020-08-31T02:14:12Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -81,7 +103,9 @@ const convertSearchOptions: (\n export const listCategories = async (\n   options: OEQ.SearchFacets.SearchFacetsParams\n ): Promise<OEQ.SearchFacets.Facet[]> =>\n-  (await OEQ.SearchFacets.searchFacets(API_BASE_URL, options)).results;\n+  (await OEQ.SearchFacets.searchFacets(API_BASE_URL, options)).results.filter(\n+    (r) => r.term\n+  ); // Filter out empty terms", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDUxMTQ0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDoyOTozNFrOHJpqOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDoyOTozNFrOHJpqOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTc4Ng==", "bodyText": "hmmm, I enjoy Maps for their ease of use and overhead. But I must admit this one is becoming some prolific it seems it should be a type. Maybe it'd be fine to simply use a type alias.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479881786", "createdAt": "2020-08-31T04:29:34Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -64,10 +65,9 @@ export interface SearchOptions {\n    */\n   status?: OEQ.Common.ItemStatus[];\n   /**\n-   * A list of classification terms. (Typically a subset of those generated by\n-   * Search Facets.)\n+   * A map of selected Classifications and their terms.\n    */\n-  classificationTerms?: string[];\n+  classificationTerms?: Map<number, NodeAndTerms>;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDUyNDU5OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDozODo0M1rOHJpxlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDozODo0M1rOHJpxlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MzY3MQ==", "bodyText": "As mentioned elsewhere I believe this should be defined in one of the lower modules - not the presentation layer.\nThere's also some kind of relationship between this, SearchFacetsModule.Classification and OEQ.SearchFacets.Facet. It would be effort well spent to see how this can be harmonized over in SearchFacetsModule. That work may actually also align with sorting out the Map<number, NodeAndTerms> as that seems like a sub class of SearchFacetsModule.Classification.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479883671", "createdAt": "2020-08-31T04:38:43Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -39,78 +39,98 @@ const useStyles = makeStyles({\n });\n \n /**\n- * Represents a Classification that is specific to Search page.\n+ * Represent a schema node and a list of terms.\n  */\n-export interface SearchPageClassification extends Classification {\n+export interface NodeAndTerms {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDUzMjc3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo0NDoyNFrOHJp2aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo0NDoyNFrOHJp2aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NDkwNA==", "bodyText": "Can we tweak this while here. This currently states the obvious (due to the types). But what is the purpose of this list?\nMaybe:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * A list of Classifications.\n          \n          \n            \n               * A list of Classifications which will be rendered to sections for each Classifications under which will be the\n          \n          \n            \n               * categories as clickable checkboxes.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479884904", "createdAt": "2020-08-31T04:44:24Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -39,78 +39,98 @@ const useStyles = makeStyles({\n });\n \n /**\n- * Represents a Classification that is specific to Search page.\n+ * Represent a schema node and a list of terms.\n  */\n-export interface SearchPageClassification extends Classification {\n+export interface NodeAndTerms {\n   /**\n-   * A boolean indicating if a classification has hidden categories to show.\n+   * One Schema node.\n    */\n-  showMore: boolean;\n+  node: string;\n+  /**\n+   * Terms related to this node.\n+   */\n+  terms: string[];\n }\n \n export interface FacetSelectorProps {\n   /**\n    * A list of Classifications.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDUzODg0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo0ODoyNFrOHJp50Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo0ODoyNFrOHJp50Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NTc3Nw==", "bodyText": "What about this for the var name:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              const [showMoreMap, setShowMoreMap] = useState<Map<number, boolean>>(\n          \n          \n            \n              const [collapsedClassifications, setCollapsedClassifications] = useState<Map<number, boolean>>(\n          \n      \n    \n    \n  \n\n(Alternatively I feel [expandedClassifications, setExpandedClassifications] reads slightly better, but you'd have to rework all your logic.)", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479885777", "createdAt": "2020-08-31T04:48:24Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -39,78 +39,98 @@ const useStyles = makeStyles({\n });\n \n /**\n- * Represents a Classification that is specific to Search page.\n+ * Represent a schema node and a list of terms.\n  */\n-export interface SearchPageClassification extends Classification {\n+export interface NodeAndTerms {\n   /**\n-   * A boolean indicating if a classification has hidden categories to show.\n+   * One Schema node.\n    */\n-  showMore: boolean;\n+  node: string;\n+  /**\n+   * Terms related to this node.\n+   */\n+  terms: string[];\n }\n \n export interface FacetSelectorProps {\n   /**\n    * A list of Classifications.\n    */\n-  classifications: SearchPageClassification[];\n+  classifications: Classification[];\n   /**\n    * A map where the key is a Classification's ID and value is\n    * a list of terms.\n    */\n-  selectedClassificationTerms?: Map<number, string[]>;\n+  selectedClassificationTerms?: Map<number, NodeAndTerms>;\n   /**\n    * Handler for selecting/deselecting Classification terms.\n    * @param terms A list of currently selected terms.\n    */\n-  onSelectTermsChange: (terms: Map<number, string[]>) => void;\n-  /**\n-   * Handler for clicking a 'SHOW MORE' button.\n-   * @param classificationName The name of a Classification.\n-   */\n-  onShowMore: (classificationID: number) => void;\n+  onSelectTermsChange: (terms: Map<number, NodeAndTerms>) => void;\n }\n \n export const FacetSelector = ({\n   classifications,\n   selectedClassificationTerms,\n   onSelectTermsChange,\n-  onShowMore,\n }: FacetSelectorProps) => {\n   const classes = useStyles();\n+  const [showMoreMap, setShowMoreMap] = useState<Map<number, boolean>>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU0MzQ1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo1MToxN1rOHJp8cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo1MToxN1rOHJp8cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NjQ1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param classificationID The name of a Classification\n          \n          \n            \n               * @param classificationID The ID of a Classification", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479886450", "createdAt": "2020-08-31T04:51:17Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -139,10 +159,12 @@ export const FacetSelector = ({\n   /**\n    * Build a ListItem consisting of a MUI Checkbox and a Label for a facet.\n    * @param classificationID The name of a Classification", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU0NzY0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo1NDoxMFrOHJp-7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo1NDoxMFrOHJp-7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NzA4Ng==", "bodyText": "Seems unnecessary for you to be managing the schemaNode here - you have the more specific Classification ID which can be used for those purposes. This could lead to odd issues if they get out of wack.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479887086", "createdAt": "2020-08-31T04:54:10Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -39,78 +39,98 @@ const useStyles = makeStyles({\n });\n \n /**\n- * Represents a Classification that is specific to Search page.\n+ * Represent a schema node and a list of terms.\n  */\n-export interface SearchPageClassification extends Classification {\n+export interface NodeAndTerms {\n   /**\n-   * A boolean indicating if a classification has hidden categories to show.\n+   * One Schema node.\n    */\n-  showMore: boolean;\n+  node: string;\n+  /**\n+   * Terms related to this node.\n+   */\n+  terms: string[];\n }\n \n export interface FacetSelectorProps {\n   /**\n    * A list of Classifications.\n    */\n-  classifications: SearchPageClassification[];\n+  classifications: Classification[];\n   /**\n    * A map where the key is a Classification's ID and value is\n    * a list of terms.\n    */\n-  selectedClassificationTerms?: Map<number, string[]>;\n+  selectedClassificationTerms?: Map<number, NodeAndTerms>;\n   /**\n    * Handler for selecting/deselecting Classification terms.\n    * @param terms A list of currently selected terms.\n    */\n-  onSelectTermsChange: (terms: Map<number, string[]>) => void;\n-  /**\n-   * Handler for clicking a 'SHOW MORE' button.\n-   * @param classificationName The name of a Classification.\n-   */\n-  onShowMore: (classificationID: number) => void;\n+  onSelectTermsChange: (terms: Map<number, NodeAndTerms>) => void;\n }\n \n export const FacetSelector = ({\n   classifications,\n   selectedClassificationTerms,\n   onSelectTermsChange,\n-  onShowMore,\n }: FacetSelectorProps) => {\n   const classes = useStyles();\n+  const [showMoreMap, setShowMoreMap] = useState<Map<number, boolean>>(\n+    new Map(classifications.map((classification) => [classification.id, true]))\n+  );\n \n+  const onShowMore = (classificationID: number, showMore: boolean) => {\n+    const copiedMap = new Map(showMoreMap);\n+    copiedMap.set(classificationID, showMore);\n+    setShowMoreMap(copiedMap);\n+  };\n   /**\n    * Updates the list of selected Classification terms. If the term exists then remove it\n    * from the list. Add it to the list otherwise.\n    * A copy of the map and a copy of the array of terms are created internally\n    * to avoid mutating parent component's state.\n    *\n    * @param classificationID The ID of a Classification\n+   * @param schemaNode The Schema node of a Classification\n    * @param term The selected or unselected term\n    */\n-  const handleSelectTerms = (classificationID: number, term: string) => {\n-    const terms = selectedClassificationTerms?.get(classificationID);\n-    const copiedTerms = terms ? [...terms] : [];\n+  const handleSelectTerms = (\n+    classificationID: number,\n+    schemaNode: string,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU1MzEzOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNDo1NzozMFrOHJqB8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDo1MTowNFrOHMV0DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4Nzg1Nw==", "bodyText": "These two language strings will likely be used throughout the app. They should probably go inside languageStrings.common.action", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479887857", "createdAt": "2020-08-31T04:57:30Z", "author": {"login": "mrblippy"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "diffHunk": "@@ -41,16 +40,19 @@ describe(\"<FacetSelector />\", () => {\n   const COLOR = \"Color\";\n   // Mocked facet\n   const HOBART = \"Hobart\";\n-  const mockedSelectedTerms = new Map([[CITY_ID, [HOBART]]]);\n-  // The text of 'SHOW MORE' button\n+  const SCHEMA_NODE = \"item/city\";\n+  const mockedSelectedTerms = new Map([\n+    [CITY_ID, { node: SCHEMA_NODE, terms: [HOBART] }],\n+  ]);\n+  // The text of 'SHOW MORE' and 'SHOW LESS' buttons\n   const SHOW_MORE = languageStrings.searchpage.facetSelector.showMoreButton;\n+  const SHOW_LESS = languageStrings.searchpage.facetSelector.showLessButton;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkxMDc2MQ==", "bodyText": "I pondered this too. Then I was wondering... What if people do want to control the text differently specifically on these buttons (vs. other show more/less buttons). If we want to support that, we'd want to keep it specific like this.\nWhat do peeps think?", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479910761", "createdAt": "2020-08-31T06:00:55Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "diffHunk": "@@ -41,16 +40,19 @@ describe(\"<FacetSelector />\", () => {\n   const COLOR = \"Color\";\n   // Mocked facet\n   const HOBART = \"Hobart\";\n-  const mockedSelectedTerms = new Map([[CITY_ID, [HOBART]]]);\n-  // The text of 'SHOW MORE' button\n+  const SCHEMA_NODE = \"item/city\";\n+  const mockedSelectedTerms = new Map([\n+    [CITY_ID, { node: SCHEMA_NODE, terms: [HOBART] }],\n+  ]);\n+  // The text of 'SHOW MORE' and 'SHOW LESS' buttons\n   const SHOW_MORE = languageStrings.searchpage.facetSelector.showMoreButton;\n+  const SHOW_LESS = languageStrings.searchpage.facetSelector.showLessButton;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4Nzg1Nw=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY0NDQ0OQ==", "bodyText": "I prefer they stay here \ud83d\ude04 , what about other peeps ?", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482644449", "createdAt": "2020-09-03T01:48:41Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "diffHunk": "@@ -41,16 +40,19 @@ describe(\"<FacetSelector />\", () => {\n   const COLOR = \"Color\";\n   // Mocked facet\n   const HOBART = \"Hobart\";\n-  const mockedSelectedTerms = new Map([[CITY_ID, [HOBART]]]);\n-  // The text of 'SHOW MORE' button\n+  const SCHEMA_NODE = \"item/city\";\n+  const mockedSelectedTerms = new Map([\n+    [CITY_ID, { node: SCHEMA_NODE, terms: [HOBART] }],\n+  ]);\n+  // The text of 'SHOW MORE' and 'SHOW LESS' buttons\n   const SHOW_MORE = languageStrings.searchpage.facetSelector.showMoreButton;\n+  const SHOW_LESS = languageStrings.searchpage.facetSelector.showLessButton;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4Nzg1Nw=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwMjM0OQ==", "bodyText": "I see @mrblippy changed them over in his PR. So I'll leave it for you guys to reach agreement. ;)", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482702349", "createdAt": "2020-09-03T04:51:04Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/search/components/FacetSelector.test.tsx", "diffHunk": "@@ -41,16 +40,19 @@ describe(\"<FacetSelector />\", () => {\n   const COLOR = \"Color\";\n   // Mocked facet\n   const HOBART = \"Hobart\";\n-  const mockedSelectedTerms = new Map([[CITY_ID, [HOBART]]]);\n-  // The text of 'SHOW MORE' button\n+  const SCHEMA_NODE = \"item/city\";\n+  const mockedSelectedTerms = new Map([\n+    [CITY_ID, { node: SCHEMA_NODE, terms: [HOBART] }],\n+  ]);\n+  // The text of 'SHOW MORE' and 'SHOW LESS' buttons\n   const SHOW_MORE = languageStrings.searchpage.facetSelector.showMoreButton;\n+  const SHOW_LESS = languageStrings.searchpage.facetSelector.showLessButton;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4Nzg1Nw=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU2NDc1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNTowNToxNlrOHJqIjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNTowNToxNlrOHJqIjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4OTU1MA==", "bodyText": "Can we reworking the naming here? It was confusing down below when reviewing listCategories() where you then start using the agreed terminology of 'categories' (rather than the server side, 'terms').\n/**\n * The currently selected categories, where the key of the map is the ID of\n * the `Classification` they below to.\n */\nselectedCategories?: Map<number, NodeAndTerms>;\nHmmm, I wonder why you even need NodeAndTerms here. I mention this further down, I think you should only need the Classification ID and the string array of terms. \ud83e\udd14", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479889550", "createdAt": "2020-08-31T05:05:16Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -39,78 +39,98 @@ const useStyles = makeStyles({\n });\n \n /**\n- * Represents a Classification that is specific to Search page.\n+ * Represent a schema node and a list of terms.\n  */\n-export interface SearchPageClassification extends Classification {\n+export interface NodeAndTerms {\n   /**\n-   * A boolean indicating if a classification has hidden categories to show.\n+   * One Schema node.\n    */\n-  showMore: boolean;\n+  node: string;\n+  /**\n+   * Terms related to this node.\n+   */\n+  terms: string[];\n }\n \n export interface FacetSelectorProps {\n   /**\n    * A list of Classifications.\n    */\n-  classifications: SearchPageClassification[];\n+  classifications: Classification[];\n   /**\n    * A map where the key is a Classification's ID and value is\n    * a list of terms.\n    */\n-  selectedClassificationTerms?: Map<number, string[]>;\n+  selectedClassificationTerms?: Map<number, NodeAndTerms>;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU3Njk0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxMzowMVrOHJqPnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMTo0Nzo1MlrOHMSRGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MTM1Ng==", "bodyText": "As mentioned above on selectedClassificationTerms, let's normalise on our terminology.\nBut... Is this even all required? Doesn't selectedClassificationTerms already hold all this value... Maybe it's because you need it in a different shape for TS, in which case maybe all you need is a .map over it. \ud83e\udd14", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479891356", "createdAt": "2020-08-31T05:13:01Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -171,19 +195,27 @@ export const FacetSelector = ({\n    *\n    * @param id The ID of a Classification\n    * @param categories A list of terms to build into a list\n-   * @param showMore Whether to show more facets or not\n+   * @param schemaNode The Schema node of a Classification\n    * @param maxDisplay Default maximum number of displayed facets\n+   * @param showMore Whether to show more facets or not\n    */\n-  const listCategories = ({\n-    id,\n-    categories,\n-    showMore,\n-    maxDisplay,\n-  }: SearchPageClassification): ReactElement[] =>\n-    categories\n+  const listCategories = (\n+    { id, categories, schemaNode, maxDisplay }: Classification,\n+    showMore: boolean\n+  ): ReactElement[] => {\n+    const selectedTerms = selectedClassificationTerms?.get(id)?.terms ?? [];\n+    const selectedCategories = categories.filter((c) =>\n+      selectedTerms.includes(c.term)\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY0NDI0OA==", "bodyText": "I think we may need because generating each category's label text needs full information of a facet (term and count) , but selectedClassificationTerms only knows the term.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482644248", "createdAt": "2020-09-03T01:47:52Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -171,19 +195,27 @@ export const FacetSelector = ({\n    *\n    * @param id The ID of a Classification\n    * @param categories A list of terms to build into a list\n-   * @param showMore Whether to show more facets or not\n+   * @param schemaNode The Schema node of a Classification\n    * @param maxDisplay Default maximum number of displayed facets\n+   * @param showMore Whether to show more facets or not\n    */\n-  const listCategories = ({\n-    id,\n-    categories,\n-    showMore,\n-    maxDisplay,\n-  }: SearchPageClassification): ReactElement[] =>\n-    categories\n+  const listCategories = (\n+    { id, categories, schemaNode, maxDisplay }: Classification,\n+    showMore: boolean\n+  ): ReactElement[] => {\n+    const selectedTerms = selectedClassificationTerms?.get(id)?.terms ?? [];\n+    const selectedCategories = categories.filter((c) =>\n+      selectedTerms.includes(c.term)\n+    );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MTM1Ng=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU4MDA4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__mocks__/FacetSelector.mock.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxNTowMVrOHJqRaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNDo1OToxNlrOHKiTZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MTgxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import { Classification } from \"../tsrc/modules/SearchFacetsModule\";\n          \n          \n            \n            import type { Classification } from \"../tsrc/modules/SearchFacetsModule\";", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479891819", "createdAt": "2020-08-31T05:15:01Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/__mocks__/FacetSelector.mock.ts", "diffHunk": "@@ -15,9 +15,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-import type { SearchPageClassification } from \"../tsrc/search/components/FacetSelector\";\n \n-export const classifications: SearchPageClassification[] = [\n+import { Classification } from \"../tsrc/modules/SearchFacetsModule\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgwOTgyOQ==", "bodyText": "Thanks Sam. I always forget this \ud83d\ude25", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r480809829", "createdAt": "2020-09-01T04:59:16Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/js/__mocks__/FacetSelector.mock.ts", "diffHunk": "@@ -15,9 +15,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-import type { SearchPageClassification } from \"../tsrc/search/components/FacetSelector\";\n \n-export const classifications: SearchPageClassification[] = [\n+import { Classification } from \"../tsrc/modules/SearchFacetsModule\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MTgxOQ=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU4NTI2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxODowM1rOHJqUhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxODowM1rOHJqUhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MjYxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * The configured Schema node of this classification.\n          \n          \n            \n               * The configured schema node of this classification.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479892615", "createdAt": "2020-08-31T05:18:03Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -49,6 +49,10 @@ export interface Classification {\n    * The configured order in which this classification should be displayed.\n    */\n   orderIndex: number;\n+  /**\n+   * The configured Schema node of this classification.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU4NjczOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxOTowOFrOHJqVYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxOTowOFrOHJqVYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MjgzNA==", "bodyText": "I'd suggest you rename i to something more meaningful.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479892834", "createdAt": "2020-08-31T05:19:08Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -59,18 +63,36 @@ export interface Classification {\n const convertSearchOptions: (\n   options: SearchOptions\n ) => OEQ.SearchFacets.SearchFacetsParams = memoize(\n-  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => ({\n-    nodes: [],\n-    q: options.query,\n-    collections: options.collections?.map((c) => c.uuid),\n-    modifiedAfter: getISODateString(options.lastModifiedDateRange?.start),\n-    modifiedBefore: getISODateString(options.lastModifiedDateRange?.end),\n-    owner: options.owner?.id,\n-    showall: isEqual(\n-      options.status?.sort(),\n-      OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n-    ),\n-  })\n+  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => {\n+    const {\n+      query,\n+      collections,\n+      lastModifiedDateRange,\n+      owner,\n+      status,\n+      classificationTerms,\n+      rawMode,\n+    } = options;\n+    let searchFacetsParams: OEQ.SearchFacets.SearchFacetsParams = {\n+      nodes: [],\n+      q: query ? formatQuery(query, !rawMode) : undefined,\n+      modifiedAfter: getISODateString(lastModifiedDateRange?.start),\n+      modifiedBefore: getISODateString(lastModifiedDateRange?.end),\n+      owner: owner?.id,\n+      showall: isEqual(\n+        status?.sort(),\n+        OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU4NzMxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxOToyOVrOHJqVtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNjo0NTowMVrOHJsb_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MjkxNg==", "bodyText": "I'd suggest you rename c to something more meaningful.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479892916", "createdAt": "2020-08-31T05:19:29Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -59,18 +63,36 @@ export interface Classification {\n const convertSearchOptions: (\n   options: SearchOptions\n ) => OEQ.SearchFacets.SearchFacetsParams = memoize(\n-  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => ({\n-    nodes: [],\n-    q: options.query,\n-    collections: options.collections?.map((c) => c.uuid),\n-    modifiedAfter: getISODateString(options.lastModifiedDateRange?.start),\n-    modifiedBefore: getISODateString(options.lastModifiedDateRange?.end),\n-    owner: options.owner?.id,\n-    showall: isEqual(\n-      options.status?.sort(),\n-      OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n-    ),\n-  })\n+  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => {\n+    const {\n+      query,\n+      collections,\n+      lastModifiedDateRange,\n+      owner,\n+      status,\n+      classificationTerms,\n+      rawMode,\n+    } = options;\n+    let searchFacetsParams: OEQ.SearchFacets.SearchFacetsParams = {\n+      nodes: [],\n+      q: query ? formatQuery(query, !rawMode) : undefined,\n+      modifiedAfter: getISODateString(lastModifiedDateRange?.start),\n+      modifiedBefore: getISODateString(lastModifiedDateRange?.end),\n+      owner: owner?.id,\n+      showall: isEqual(\n+        status?.sort(),\n+        OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n+      ),\n+      where: generateWhereQuery(classificationTerms),\n+    };\n+    if (collections && collections.length > 0) {\n+      searchFacetsParams = {\n+        ...searchFacetsParams,\n+        collections: collections.map((c) => c.uuid),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5Nzc1MQ==", "bodyText": "Single character is okay if it's in close context - like here and below in single use anonymous functions. So these are all good. \ud83d\udc4d", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479897751", "createdAt": "2020-08-31T05:37:50Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -59,18 +63,36 @@ export interface Classification {\n const convertSearchOptions: (\n   options: SearchOptions\n ) => OEQ.SearchFacets.SearchFacetsParams = memoize(\n-  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => ({\n-    nodes: [],\n-    q: options.query,\n-    collections: options.collections?.map((c) => c.uuid),\n-    modifiedAfter: getISODateString(options.lastModifiedDateRange?.start),\n-    modifiedBefore: getISODateString(options.lastModifiedDateRange?.end),\n-    owner: options.owner?.id,\n-    showall: isEqual(\n-      options.status?.sort(),\n-      OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n-    ),\n-  })\n+  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => {\n+    const {\n+      query,\n+      collections,\n+      lastModifiedDateRange,\n+      owner,\n+      status,\n+      classificationTerms,\n+      rawMode,\n+    } = options;\n+    let searchFacetsParams: OEQ.SearchFacets.SearchFacetsParams = {\n+      nodes: [],\n+      q: query ? formatQuery(query, !rawMode) : undefined,\n+      modifiedAfter: getISODateString(lastModifiedDateRange?.start),\n+      modifiedBefore: getISODateString(lastModifiedDateRange?.end),\n+      owner: owner?.id,\n+      showall: isEqual(\n+        status?.sort(),\n+        OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n+      ),\n+      where: generateWhereQuery(classificationTerms),\n+    };\n+    if (collections && collections.length > 0) {\n+      searchFacetsParams = {\n+        ...searchFacetsParams,\n+        collections: collections.map((c) => c.uuid),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MjkxNg=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyNzI5NQ==", "bodyText": "Sure thing! I'll resolve them.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479927295", "createdAt": "2020-08-31T06:45:01Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -59,18 +63,36 @@ export interface Classification {\n const convertSearchOptions: (\n   options: SearchOptions\n ) => OEQ.SearchFacets.SearchFacetsParams = memoize(\n-  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => ({\n-    nodes: [],\n-    q: options.query,\n-    collections: options.collections?.map((c) => c.uuid),\n-    modifiedAfter: getISODateString(options.lastModifiedDateRange?.start),\n-    modifiedBefore: getISODateString(options.lastModifiedDateRange?.end),\n-    owner: options.owner?.id,\n-    showall: isEqual(\n-      options.status?.sort(),\n-      OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n-    ),\n-  })\n+  (options: SearchOptions): OEQ.SearchFacets.SearchFacetsParams => {\n+    const {\n+      query,\n+      collections,\n+      lastModifiedDateRange,\n+      owner,\n+      status,\n+      classificationTerms,\n+      rawMode,\n+    } = options;\n+    let searchFacetsParams: OEQ.SearchFacets.SearchFacetsParams = {\n+      nodes: [],\n+      q: query ? formatQuery(query, !rawMode) : undefined,\n+      modifiedAfter: getISODateString(lastModifiedDateRange?.start),\n+      modifiedBefore: getISODateString(lastModifiedDateRange?.end),\n+      owner: owner?.id,\n+      showall: isEqual(\n+        status?.sort(),\n+        OEQ.Common.ItemStatuses.alternatives.map((i) => i.value).sort()\n+      ),\n+      where: generateWhereQuery(classificationTerms),\n+    };\n+    if (collections && collections.length > 0) {\n+      searchFacetsParams = {\n+        ...searchFacetsParams,\n+        collections: collections.map((c) => c.uuid),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MjkxNg=="}, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU4Nzg4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxOTo0OFrOHJqV_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToxOTo0OFrOHJqV_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5Mjk5MQ==", "bodyText": "As above - single letter identifier.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479892991", "createdAt": "2020-08-31T05:19:48Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchFacetsModule.ts", "diffHunk": "@@ -81,7 +103,9 @@ const convertSearchOptions: (\n export const listCategories = async (\n   options: OEQ.SearchFacets.SearchFacetsParams\n ): Promise<OEQ.SearchFacets.Facet[]> =>\n-  (await OEQ.SearchFacets.searchFacets(API_BASE_URL, options)).results;\n+  (await OEQ.SearchFacets.searchFacets(API_BASE_URL, options)).results.filter(\n+    (r) => r.term", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU5MDAxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyMTowOVrOHJqXLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyMTowOVrOHJqXLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5MzI5Mg==", "bodyText": "As above.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479893292", "createdAt": "2020-08-31T05:21:09Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/modules/SearchModule.ts", "diffHunk": "@@ -116,40 +116,32 @@ export const defaultPagedSearchResult: OEQ.Common.PagedResult<OEQ.Search.SearchR\n  * @param query the intended search query to be sent to the API\n  * @param addWildcard whether a wildcard should be appended\n  */\n-const formatQuery = (query: string, addWildcard: boolean): string => {\n+export const formatQuery = (query: string, addWildcard: boolean): string => {\n   const trimmedQuery = query ? query.trim() : \"\";\n   const appendWildcard = addWildcard && trimmedQuery.length > 0;\n   return trimmedQuery + (appendWildcard ? \"*\" : \"\");\n };\n \n /**\n- * This function processes the query put in the SearchBar and terms selected from Classifications.\n- * It firstly formats the query based on whether raw mode is on or off.\n- * If there are no Classifications terms selected, it returns the formatted query.\n- * Otherwise, it consolidates all terms into one Lucene query by OR, and combines the two queries\n- * by AND, and return the combined one.\n+ * Generates a Where clause for search. Each condition is linked by a AND.\n  *\n- * @param query The query put in the SearchBar.\n- * @param rawMode Whether raw mode is on or off.\n  * @param classificationTerms A list of selected Classification terms.\n  */\n-const processQuery = (\n-  query: string | undefined,\n-  rawMode: boolean,\n-  classificationTerms?: string[]\n+export const generateWhereQuery = (\n+  classificationTerms?: Map<number, NodeAndTerms>\n ): string | undefined => {\n-  // If query is undefined, then we want to keep 'undefined'; but otherwise let's pre-process it.\n-  const textQuery = query ? formatQuery(query, !rawMode) : undefined;\n-\n-  if (!classificationTerms || classificationTerms.length === 0) {\n-    return textQuery;\n+  if (!classificationTerms) {\n+    return undefined;\n   }\n \n-  const or = \" OR \";\n+  // Append '/xml' back to the schema node and generate a search condition for each term.\n+  const processNodeTerms = ({ node, terms }: NodeAndTerms) =>\n+    terms.map((t) => `/xml${node}='${t}'`);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU5NDkxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyMzo0OVrOHJqZxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyMzo0OVrOHJqZxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5Mzk1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Create a button to help show more/less categories for each Classification.\n          \n          \n            \n               * Create a button to show more/less categories for each Classification.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479893956", "createdAt": "2020-08-31T05:23:49Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -39,78 +39,98 @@ const useStyles = makeStyles({\n });\n \n /**\n- * Represents a Classification that is specific to Search page.\n+ * Represent a schema node and a list of terms.\n  */\n-export interface SearchPageClassification extends Classification {\n+export interface NodeAndTerms {\n   /**\n-   * A boolean indicating if a classification has hidden categories to show.\n+   * One Schema node.\n    */\n-  showMore: boolean;\n+  node: string;\n+  /**\n+   * Terms related to this node.\n+   */\n+  terms: string[];\n }\n \n export interface FacetSelectorProps {\n   /**\n    * A list of Classifications.\n    */\n-  classifications: SearchPageClassification[];\n+  classifications: Classification[];\n   /**\n    * A map where the key is a Classification's ID and value is\n    * a list of terms.\n    */\n-  selectedClassificationTerms?: Map<number, string[]>;\n+  selectedClassificationTerms?: Map<number, NodeAndTerms>;\n   /**\n    * Handler for selecting/deselecting Classification terms.\n    * @param terms A list of currently selected terms.\n    */\n-  onSelectTermsChange: (terms: Map<number, string[]>) => void;\n-  /**\n-   * Handler for clicking a 'SHOW MORE' button.\n-   * @param classificationName The name of a Classification.\n-   */\n-  onShowMore: (classificationID: number) => void;\n+  onSelectTermsChange: (terms: Map<number, NodeAndTerms>) => void;\n }\n \n export const FacetSelector = ({\n   classifications,\n   selectedClassificationTerms,\n   onSelectTermsChange,\n-  onShowMore,\n }: FacetSelectorProps) => {\n   const classes = useStyles();\n+  const [showMoreMap, setShowMoreMap] = useState<Map<number, boolean>>(\n+    new Map(classifications.map((classification) => [classification.id, true]))\n+  );\n \n+  const onShowMore = (classificationID: number, showMore: boolean) => {\n+    const copiedMap = new Map(showMoreMap);\n+    copiedMap.set(classificationID, showMore);\n+    setShowMoreMap(copiedMap);\n+  };\n   /**\n    * Updates the list of selected Classification terms. If the term exists then remove it\n    * from the list. Add it to the list otherwise.\n    * A copy of the map and a copy of the array of terms are created internally\n    * to avoid mutating parent component's state.\n    *\n    * @param classificationID The ID of a Classification\n+   * @param schemaNode The Schema node of a Classification\n    * @param term The selected or unselected term\n    */\n-  const handleSelectTerms = (classificationID: number, term: string) => {\n-    const terms = selectedClassificationTerms?.get(classificationID);\n-    const copiedTerms = terms ? [...terms] : [];\n+  const handleSelectTerms = (\n+    classificationID: number,\n+    schemaNode: string,\n+    term: string\n+  ) => {\n+    const nodeAndTerms = selectedClassificationTerms?.get(classificationID);\n+    const copiedTerms = nodeAndTerms ? [...nodeAndTerms.terms] : [];\n     const termIndex = copiedTerms.indexOf(term);\n     if (termIndex === -1) {\n       copiedTerms.push(term);\n     } else {\n       copiedTerms.splice(termIndex, 1);\n     }\n     const copiedMap = new Map(selectedClassificationTerms ?? []);\n-    copiedMap.set(classificationID, copiedTerms);\n+    copiedMap.set(classificationID, { node: schemaNode, terms: copiedTerms });\n     onSelectTermsChange(copiedMap);\n   };\n \n   /**\n-   * Render a 'SHOW MORE' button for each Classification.\n+   * Create a button to help show more/less categories for each Classification.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU5NTg1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyNDoyM1rOHJqaRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyNDoyM1rOHJqaRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5NDA4Nw==", "bodyText": "As above.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479894087", "createdAt": "2020-08-31T05:24:23Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -171,19 +195,27 @@ export const FacetSelector = ({\n    *\n    * @param id The ID of a Classification\n    * @param categories A list of terms to build into a list\n-   * @param showMore Whether to show more facets or not\n+   * @param schemaNode The Schema node of a Classification\n    * @param maxDisplay Default maximum number of displayed facets\n+   * @param showMore Whether to show more facets or not\n    */\n-  const listCategories = ({\n-    id,\n-    categories,\n-    showMore,\n-    maxDisplay,\n-  }: SearchPageClassification): ReactElement[] =>\n-    categories\n+  const listCategories = (\n+    { id, categories, schemaNode, maxDisplay }: Classification,\n+    showMore: boolean\n+  ): ReactElement[] => {\n+    const selectedTerms = selectedClassificationTerms?.get(id)?.terms ?? [];\n+    const selectedCategories = categories.filter((c) =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU5NjMxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyNDozN1rOHJqaiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyNDozN1rOHJqaiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5NDE1Mw==", "bodyText": "As above.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479894153", "createdAt": "2020-08-31T05:24:37Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/FacetSelector.tsx", "diffHunk": "@@ -171,19 +195,27 @@ export const FacetSelector = ({\n    *\n    * @param id The ID of a Classification\n    * @param categories A list of terms to build into a list\n-   * @param showMore Whether to show more facets or not\n+   * @param schemaNode The Schema node of a Classification\n    * @param maxDisplay Default maximum number of displayed facets\n+   * @param showMore Whether to show more facets or not\n    */\n-  const listCategories = ({\n-    id,\n-    categories,\n-    showMore,\n-    maxDisplay,\n-  }: SearchPageClassification): ReactElement[] =>\n-    categories\n+  const listCategories = (\n+    { id, categories, schemaNode, maxDisplay }: Classification,\n+    showMore: boolean\n+  ): ReactElement[] => {\n+    const selectedTerms = selectedClassificationTerms?.get(id)?.terms ?? [];\n+    const selectedCategories = categories.filter((c) =>\n+      selectedTerms.includes(c.term)\n+    );\n+    const unselectedCategories = categories.filter(\n+      (c) => !selectedTerms.includes(c.term)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDU5NzIyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/util/langstrings.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyNTowNFrOHJqbCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNToyNTowNFrOHJqbCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5NDI4Mw==", "bodyText": "These should probably be common strings.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r479894283", "createdAt": "2020-08-31T05:25:04Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/util/langstrings.ts", "diffHunk": "@@ -339,7 +339,9 @@ export const languageStrings = {\n       day: \"Day\",\n     },\n     facetSelector: {\n+      title: \"Classifications\",\n       showMoreButton: \"Show more\",\n+      showLessButton: \"Show less\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a22b1c50e2af525e594f72d85ec59787d971642"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODAyOTczOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDo1NjozNFrOHMV6UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDo1NjozNFrOHMV6UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwMzk1Mg==", "bodyText": "Whoops! Typo.\nAnd please make sure we have white space between definitions of interfaces, classes and funcs at the top level.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            export interface GategorySelectorProps {\n          \n          \n            \n            \n          \n          \n            \n            export interface CategorySelectorProps {", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482703952", "createdAt": "2020-09-03T04:56:34Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import {\n+  Button,\n+  Checkbox,\n+  FormControlLabel,\n+  Grid,\n+  List,\n+  ListItem,\n+  Typography,\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/core/styles\";\n+import { ReactElement, useState } from \"react\";\n+import * as React from \"react\";\n+import * as OEQ from \"@openequella/rest-api-client\";\n+import {\n+  Classification,\n+  SelectedCategories,\n+} from \"../../modules/SearchFacetsModule\";\n+import { languageStrings } from \"../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  classificationList: {\n+    maxHeight: 500,\n+    overflow: \"auto\",\n+  },\n+});\n+export interface GategorySelectorProps {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81ff6ecee853642678148f8945c13af03900db10"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODAzMDIxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDo1Njo0NlrOHMV6jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDo1Njo0NlrOHMV6jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwNDAxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            export const CategorySelector = ({\n          \n          \n            \n            \n          \n          \n            \n            export const CategorySelector = ({", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482704013", "createdAt": "2020-09-03T04:56:46Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import {\n+  Button,\n+  Checkbox,\n+  FormControlLabel,\n+  Grid,\n+  List,\n+  ListItem,\n+  Typography,\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/core/styles\";\n+import { ReactElement, useState } from \"react\";\n+import * as React from \"react\";\n+import * as OEQ from \"@openequella/rest-api-client\";\n+import {\n+  Classification,\n+  SelectedCategories,\n+} from \"../../modules/SearchFacetsModule\";\n+import { languageStrings } from \"../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  classificationList: {\n+    maxHeight: 500,\n+    overflow: \"auto\",\n+  },\n+});\n+export interface GategorySelectorProps {\n+  /**\n+   * A list of Classifications which will be rendered to sections for each\n+   * Classifications under which will be the categories as clickable checkboxes.\n+   */\n+  classifications: Classification[];\n+  /**\n+   * A list of selected categories which are grouped by their Classification ID.\n+   */\n+  selectedCategories?: SelectedCategories[];\n+  /**\n+   * Handler for selecting/deselecting categories.\n+   * @param terms A list of currently selected terms.\n+   */\n+  onSelectedCategoriesChange: (categories: SelectedCategories[]) => void;\n+}\n+export const CategorySelector = ({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81ff6ecee853642678148f8945c13af03900db10"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODAzOTExOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNTowMTo0OFrOHMV_yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNTowMTo0OFrOHMV_yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwNTM1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n            \n          \n          \n            \n              /**", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482705353", "createdAt": "2020-09-03T05:01:48Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import {\n+  Button,\n+  Checkbox,\n+  FormControlLabel,\n+  Grid,\n+  List,\n+  ListItem,\n+  Typography,\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/core/styles\";\n+import { ReactElement, useState } from \"react\";\n+import * as React from \"react\";\n+import * as OEQ from \"@openequella/rest-api-client\";\n+import {\n+  Classification,\n+  SelectedCategories,\n+} from \"../../modules/SearchFacetsModule\";\n+import { languageStrings } from \"../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  classificationList: {\n+    maxHeight: 500,\n+    overflow: \"auto\",\n+  },\n+});\n+export interface GategorySelectorProps {\n+  /**\n+   * A list of Classifications which will be rendered to sections for each\n+   * Classifications under which will be the categories as clickable checkboxes.\n+   */\n+  classifications: Classification[];\n+  /**\n+   * A list of selected categories which are grouped by their Classification ID.\n+   */\n+  selectedCategories?: SelectedCategories[];\n+  /**\n+   * Handler for selecting/deselecting categories.\n+   * @param terms A list of currently selected terms.\n+   */\n+  onSelectedCategoriesChange: (categories: SelectedCategories[]) => void;\n+}\n+export const CategorySelector = ({\n+  classifications,\n+  selectedCategories = [],\n+  onSelectedCategoriesChange,\n+}: GategorySelectorProps) => {\n+  const classes = useStyles();\n+  const [expandedClassifications, setExpandedClassifications] = useState<\n+    Map<number, boolean>\n+  >(\n+    new Map(classifications.map((classification) => [classification.id, false]))\n+  );\n+\n+  /**\n+   * Handler for clicking the 'SHOW MORE' and 'SHOW LESS' buttons.\n+   * @param classificationID The ID of a Classification whose SHOW MORE' and 'SHOW LESS' buttons is clicked.\n+   * @param expanded Whether the section of this Classification is expanded or not.\n+   */\n+  const onShowMore = (classificationID: number, expanded: boolean) => {\n+    const copiedMap = new Map(expandedClassifications);\n+    copiedMap.set(classificationID, expanded);\n+    setExpandedClassifications(copiedMap);\n+  };\n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81ff6ecee853642678148f8945c13af03900db10"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODA1MzM1OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNTowOTo0MFrOHMWIOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNTowOTo0MFrOHMWIOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwNzUxMg==", "bodyText": "Nit: Could be good to rename this too - and then update the JSDoc.", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482707512", "createdAt": "2020-09-03T05:09:40Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import {\n+  Button,\n+  Checkbox,\n+  FormControlLabel,\n+  Grid,\n+  List,\n+  ListItem,\n+  Typography,\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/core/styles\";\n+import { ReactElement, useState } from \"react\";\n+import * as React from \"react\";\n+import * as OEQ from \"@openequella/rest-api-client\";\n+import {\n+  Classification,\n+  SelectedCategories,\n+} from \"../../modules/SearchFacetsModule\";\n+import { languageStrings } from \"../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  classificationList: {\n+    maxHeight: 500,\n+    overflow: \"auto\",\n+  },\n+});\n+export interface GategorySelectorProps {\n+  /**\n+   * A list of Classifications which will be rendered to sections for each\n+   * Classifications under which will be the categories as clickable checkboxes.\n+   */\n+  classifications: Classification[];\n+  /**\n+   * A list of selected categories which are grouped by their Classification ID.\n+   */\n+  selectedCategories?: SelectedCategories[];\n+  /**\n+   * Handler for selecting/deselecting categories.\n+   * @param terms A list of currently selected terms.\n+   */\n+  onSelectedCategoriesChange: (categories: SelectedCategories[]) => void;\n+}\n+export const CategorySelector = ({\n+  classifications,\n+  selectedCategories = [],\n+  onSelectedCategoriesChange,\n+}: GategorySelectorProps) => {\n+  const classes = useStyles();\n+  const [expandedClassifications, setExpandedClassifications] = useState<\n+    Map<number, boolean>\n+  >(\n+    new Map(classifications.map((classification) => [classification.id, false]))\n+  );\n+\n+  /**\n+   * Handler for clicking the 'SHOW MORE' and 'SHOW LESS' buttons.\n+   * @param classificationID The ID of a Classification whose SHOW MORE' and 'SHOW LESS' buttons is clicked.\n+   * @param expanded Whether the section of this Classification is expanded or not.\n+   */\n+  const onShowMore = (classificationID: number, expanded: boolean) => {\n+    const copiedMap = new Map(expandedClassifications);\n+    copiedMap.set(classificationID, expanded);\n+    setExpandedClassifications(copiedMap);\n+  };\n+  /**\n+   * The list of selected categories are grouped by Classification ID.\n+   * If there is a group matching the ID, then update this group's selected categories,\n+   * and otherwise add a new group for the ID and its firstly selected category.\n+   *\n+   * @param classificationID The ID of a Classification\n+   * @param category The selected or unselected category\n+   */\n+  const handleSelectCategories = (\n+    classificationID: number,\n+    category: string\n+  ) => {\n+    const categoryGroupIndex = selectedCategories.findIndex(\n+      (c) => c.id === classificationID\n+    );\n+    const copiedCategoryGroups = [...selectedCategories];\n+\n+    // If there is no group for this category then add a new group,\n+    // and otherwise update the category list of this group.\n+    if (categoryGroupIndex === -1) {\n+      copiedCategoryGroups.push({\n+        id: classificationID,\n+        categories: [category],\n+      });\n+    } else {\n+      const copiedSelectedCategories = [\n+        ...selectedCategories[categoryGroupIndex].categories,\n+      ];\n+      const categoryIndex = copiedSelectedCategories.indexOf(category);\n+      if (categoryIndex === -1) {\n+        copiedSelectedCategories.push(category);\n+      } else {\n+        copiedSelectedCategories.splice(categoryIndex, 1);\n+      }\n+      copiedCategoryGroups.splice(categoryGroupIndex, 1, {\n+        id: classificationID,\n+        categories: copiedSelectedCategories,\n+      });\n+    }\n+\n+    onSelectedCategoriesChange(copiedCategoryGroups);\n+  };\n+\n+  /**\n+   * Create a button to show more/less categories for each Classification.\n+   * @param classificationID The ID of a Classification.\n+   * @param expanded Whether the section of a Classification has been expanded or not.\n+   */\n+  const showMoreButton = (\n+    classificationID: number,\n+    expanded: boolean\n+  ): ReactElement => (\n+    <ListItem>\n+      <Grid container justify=\"center\">\n+        <Grid item>\n+          <Button\n+            variant=\"text\"\n+            onClick={() => onShowMore(classificationID, !expanded)}\n+          >\n+            {expanded\n+              ? languageStrings.searchpage.categorySelector.showLessButton\n+              : languageStrings.searchpage.categorySelector.showMoreButton}\n+          </Button>\n+        </Grid>\n+      </Grid>\n+    </ListItem>\n+  );\n+\n+  /**\n+   * Generate texts in the format of 'term (count)' for displaying a Category.\n+   * @param term The term of a category\n+   * @param count The count of a category\n+   */\n+  const categoryLabel = ({\n+    term,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81ff6ecee853642678148f8945c13af03900db10"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODQ5NjI3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo0NjoxMlrOHMaQ-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo0NjoxMlrOHMaQ-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc3NTI4OA==", "bodyText": "As discussed, I'm finding this one a little tricky to read. Seems mainly due to variable names, and variable shadowing, but I think also compounded by the imperative nature of it.\nI've come up with this alternative more declarative implementation:\n  const listCategories = (\n    { id, categories, maxDisplay }: Classification,\n    expanded: boolean\n  ): ReactElement[] => {\n    const selectedTerms: string[] =\n      selectedCategories?.find((c) => c.id === id)?.categories ?? [];\n    const selectedFacets: OEQ.SearchFacets.Facet[] = selectedTerms.map((selectedTerm) => {\n      const facet = categories.find((c) => selectedTerm === c.term);\n      if (!facet) {\n        throw new Error(\n          \"Data integrity issue, we're unable to match a selected term.\"\n        );\n      }\n\n      return facet;\n    });\n    const orderedFacets = selectedFacets.concat(\n      categories.filter((c) => !selectedFacets.includes(c))\n    );\n\n    return orderedFacets\n      .slice(0, expanded ? undefined : maxDisplay)\n      .map((facet) => categoryListItem(id, facet));\n  };\nTwo things interesting here:\n\nAlthough it should never happen, this showed the potential for a data integrity issue that would be glossed over; and\nAgainst my own advice I've been drawn into having to use Categories, Terms and Facets in the one function. But this was to align with data types and existing variable names. So, I dunno. \ud83e\udd37\n\n(Also, because this is declarative it highlights the data linkages/flow. I could've chained all this together, but I erred on the side of readability. \ud83d\ude09  )", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482775288", "createdAt": "2020-09-03T07:46:12Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/tsrc/search/components/CategorySelector.tsx", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import {\n+  Button,\n+  Checkbox,\n+  FormControlLabel,\n+  Grid,\n+  List,\n+  ListItem,\n+  Typography,\n+} from \"@material-ui/core\";\n+import { makeStyles } from \"@material-ui/core/styles\";\n+import { ReactElement, useState } from \"react\";\n+import * as React from \"react\";\n+import * as OEQ from \"@openequella/rest-api-client\";\n+import {\n+  Classification,\n+  SelectedCategories,\n+} from \"../../modules/SearchFacetsModule\";\n+import { languageStrings } from \"../../util/langstrings\";\n+\n+const useStyles = makeStyles({\n+  classificationList: {\n+    maxHeight: 500,\n+    overflow: \"auto\",\n+  },\n+});\n+export interface GategorySelectorProps {\n+  /**\n+   * A list of Classifications which will be rendered to sections for each\n+   * Classifications under which will be the categories as clickable checkboxes.\n+   */\n+  classifications: Classification[];\n+  /**\n+   * A list of selected categories which are grouped by their Classification ID.\n+   */\n+  selectedCategories?: SelectedCategories[];\n+  /**\n+   * Handler for selecting/deselecting categories.\n+   * @param terms A list of currently selected terms.\n+   */\n+  onSelectedCategoriesChange: (categories: SelectedCategories[]) => void;\n+}\n+export const CategorySelector = ({\n+  classifications,\n+  selectedCategories = [],\n+  onSelectedCategoriesChange,\n+}: GategorySelectorProps) => {\n+  const classes = useStyles();\n+  const [expandedClassifications, setExpandedClassifications] = useState<\n+    Map<number, boolean>\n+  >(\n+    new Map(classifications.map((classification) => [classification.id, false]))\n+  );\n+\n+  /**\n+   * Handler for clicking the 'SHOW MORE' and 'SHOW LESS' buttons.\n+   * @param classificationID The ID of a Classification whose SHOW MORE' and 'SHOW LESS' buttons is clicked.\n+   * @param expanded Whether the section of this Classification is expanded or not.\n+   */\n+  const onShowMore = (classificationID: number, expanded: boolean) => {\n+    const copiedMap = new Map(expandedClassifications);\n+    copiedMap.set(classificationID, expanded);\n+    setExpandedClassifications(copiedMap);\n+  };\n+  /**\n+   * The list of selected categories are grouped by Classification ID.\n+   * If there is a group matching the ID, then update this group's selected categories,\n+   * and otherwise add a new group for the ID and its firstly selected category.\n+   *\n+   * @param classificationID The ID of a Classification\n+   * @param category The selected or unselected category\n+   */\n+  const handleSelectCategories = (\n+    classificationID: number,\n+    category: string\n+  ) => {\n+    const categoryGroupIndex = selectedCategories.findIndex(\n+      (c) => c.id === classificationID\n+    );\n+    const copiedCategoryGroups = [...selectedCategories];\n+\n+    // If there is no group for this category then add a new group,\n+    // and otherwise update the category list of this group.\n+    if (categoryGroupIndex === -1) {\n+      copiedCategoryGroups.push({\n+        id: classificationID,\n+        categories: [category],\n+      });\n+    } else {\n+      const copiedSelectedCategories = [\n+        ...selectedCategories[categoryGroupIndex].categories,\n+      ];\n+      const categoryIndex = copiedSelectedCategories.indexOf(category);\n+      if (categoryIndex === -1) {\n+        copiedSelectedCategories.push(category);\n+      } else {\n+        copiedSelectedCategories.splice(categoryIndex, 1);\n+      }\n+      copiedCategoryGroups.splice(categoryGroupIndex, 1, {\n+        id: classificationID,\n+        categories: copiedSelectedCategories,\n+      });\n+    }\n+\n+    onSelectedCategoriesChange(copiedCategoryGroups);\n+  };\n+\n+  /**\n+   * Create a button to show more/less categories for each Classification.\n+   * @param classificationID The ID of a Classification.\n+   * @param expanded Whether the section of a Classification has been expanded or not.\n+   */\n+  const showMoreButton = (\n+    classificationID: number,\n+    expanded: boolean\n+  ): ReactElement => (\n+    <ListItem>\n+      <Grid container justify=\"center\">\n+        <Grid item>\n+          <Button\n+            variant=\"text\"\n+            onClick={() => onShowMore(classificationID, !expanded)}\n+          >\n+            {expanded\n+              ? languageStrings.searchpage.categorySelector.showLessButton\n+              : languageStrings.searchpage.categorySelector.showMoreButton}\n+          </Button>\n+        </Grid>\n+      </Grid>\n+    </ListItem>\n+  );\n+\n+  /**\n+   * Generate texts in the format of 'term (count)' for displaying a Category.\n+   * @param term The term of a category\n+   * @param count The count of a category\n+   */\n+  const categoryLabel = ({\n+    term,\n+    count,\n+  }: OEQ.SearchFacets.Facet): ReactElement => (\n+    <Grid container spacing={1}>\n+      <Grid item>\n+        <Typography>{term}</Typography>\n+      </Grid>\n+      <Grid item>\n+        <Typography color=\"textSecondary\">{`(${count})`}</Typography>\n+      </Grid>\n+    </Grid>\n+  );\n+\n+  /**\n+   * Build a ListItem consisting of a MUI Checkbox and a Label for a category.\n+   * @param classificationID The ID of a Classification\n+   * @param category A category to be displayed\n+   */\n+  const categoryListItem = (\n+    classificationID: number,\n+    category: OEQ.SearchFacets.Facet\n+  ): ReactElement => {\n+    const { term } = category;\n+    return (\n+      <ListItem key={`${classificationID}:${term}`} style={{ padding: 0 }}>\n+        <FormControlLabel\n+          control={\n+            <Checkbox\n+              checked={\n+                selectedCategories\n+                  ?.find((c) => c.id === classificationID)\n+                  ?.categories?.includes(term) ?? false\n+              }\n+              onChange={() => handleSelectCategories(classificationID, term)}\n+            />\n+          }\n+          label={categoryLabel(category)}\n+        />\n+      </ListItem>\n+    );\n+  };\n+\n+  /**\n+   * Build a list for a Classification's categories. Some categories may have facets\n+   * not displayed due to the configured maximum display number.\n+   *\n+   * @param id The ID of a Classification\n+   * @param categories A list of terms to build into a list\n+   * @param maxDisplay Default maximum number of displayed facets\n+   * @param expanded Whether to show more categories or not\n+   */\n+  const listCategories = (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c9248f13487fdaca77030068272458dcc6492e3"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODUwMjAyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__stories__/search/CategorySelector.stories.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo0NzozNFrOHMaUgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo0NzozNFrOHMaUgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc3NjE5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              title: \"Search/FacetSelector\",\n          \n          \n            \n              title: \"Search/CategorySelector\",", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482776193", "createdAt": "2020-09-03T07:47:34Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__stories__/search/CategorySelector.stories.tsx", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import * as React from \"react\";\n+import { SelectedCategories } from \"../../tsrc/modules/SearchFacetsModule\";\n+import {\n+  CategorySelector,\n+  GategorySelectorProps,\n+} from \"../../tsrc/search/components/CategorySelector\";\n+import * as CategorySelectorMock from \"../../__mocks__/CategorySelector.mock\";\n+import type { Meta, Story } from \"@storybook/react\";\n+\n+export default {\n+  title: \"Search/FacetSelector\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c9248f13487fdaca77030068272458dcc6492e3"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODUwNTE4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__stories__/search/CategorySelector.stories.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo0ODoyNVrOHMaWZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo0ODoyNVrOHMaWZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc3NjY3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            const FacetSelectorTemplate = (args: GategorySelectorProps) => (\n          \n          \n            \n            const CategorySelectorTemplate = (args: GategorySelectorProps) => (", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482776679", "createdAt": "2020-09-03T07:48:25Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__stories__/search/CategorySelector.stories.tsx", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import * as React from \"react\";\n+import { SelectedCategories } from \"../../tsrc/modules/SearchFacetsModule\";\n+import {\n+  CategorySelector,\n+  GategorySelectorProps,\n+} from \"../../tsrc/search/components/CategorySelector\";\n+import * as CategorySelectorMock from \"../../__mocks__/CategorySelector.mock\";\n+import type { Meta, Story } from \"@storybook/react\";\n+\n+export default {\n+  title: \"Search/FacetSelector\",\n+  component: CategorySelector,\n+  argType: {\n+    onSelectedCategoriesChange: { action: \"on select categories\" },\n+  },\n+} as Meta<GategorySelectorProps>;\n+\n+const FacetSelectorTemplate = (args: GategorySelectorProps) => (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c9248f13487fdaca77030068272458dcc6492e3"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODUwNzkyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo0OTowNVrOHMaX_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo0OTowNVrOHMaX_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc3NzA4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                it(\"should provide an list of items\", async () => {\n          \n          \n            \n                it(\"should provide a list of items\", async () => {", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482777085", "createdAt": "2020-09-03T07:49:05Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "diffHunk": "@@ -25,72 +26,81 @@ const mockedSearch = (OEQ.Search.search as jest.Mock<\n >).mockResolvedValue(getSearchResult);\n \n describe(\"SearchModule\", () => {\n-  it(\"should provide an list of items\", async () => {\n-    const searchResult = await SearchModule.searchItems(\n-      SearchModule.defaultSearchOptions\n-    );\n-    expect(searchResult.available).toBe(12);\n-    expect(searchResult.results).toHaveLength(12);\n-  });\n+  describe(\"searchItems\", () => {\n+    it(\"should provide an list of items\", async () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c9248f13487fdaca77030068272458dcc6492e3"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODUyMTE2OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo1MjoxNVrOHMafrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo1MjoxNVrOHMafrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc3OTA1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                it(\"should generate a where clause for one category\", () => {\n          \n          \n            \n            \n          \n          \n            \n                it(\"should generate a where clause for one category\", () => {", "url": "https://github.com/openequella/openEQUELLA/pull/2245#discussion_r482779055", "createdAt": "2020-09-03T07:52:15Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/modules/SearchModule.test.ts", "diffHunk": "@@ -25,72 +26,81 @@ const mockedSearch = (OEQ.Search.search as jest.Mock<\n >).mockResolvedValue(getSearchResult);\n \n describe(\"SearchModule\", () => {\n-  it(\"should provide an list of items\", async () => {\n-    const searchResult = await SearchModule.searchItems(\n-      SearchModule.defaultSearchOptions\n-    );\n-    expect(searchResult.available).toBe(12);\n-    expect(searchResult.results).toHaveLength(12);\n-  });\n+  describe(\"searchItems\", () => {\n+    it(\"should provide an list of items\", async () => {\n+      const searchResult = await SearchModule.searchItems(\n+        SearchModule.defaultSearchOptions\n+      );\n+      expect(searchResult.available).toBe(12);\n+      expect(searchResult.results).toHaveLength(12);\n+    });\n \n-  const validateSearchQuery = (expectedQuery: string) => {\n-    const calls = mockedSearch.mock.calls;\n-    const params = calls[0][1]; // Second parameter of the call is the 'params'\n-    expect(params.query).toEqual(expectedQuery);\n-  };\n+    const validateSearchQuery = (expectedQuery: string) => {\n+      const calls = mockedSearch.mock.calls;\n+      const params = calls[0][1]; // Second parameter of the call is the 'params'\n+      expect(params.query).toEqual(expectedQuery);\n+    };\n \n-  it(\"should not append a wildcard for a search which is empty when trimmed\", async () => {\n-    mockedSearch.mockReset();\n-    await SearchModule.searchItems({\n-      ...SearchModule.defaultSearchOptions,\n-      query: \"   \",\n+    it(\"should not append a wildcard for a search which is empty when trimmed\", async () => {\n+      mockedSearch.mockReset();\n+      await SearchModule.searchItems({\n+        ...SearchModule.defaultSearchOptions,\n+        query: \"   \",\n+      });\n+      validateSearchQuery(\"\");\n     });\n-    validateSearchQuery(\"\");\n-  });\n \n-  it(\"should append a wildcard for a search non-rawMode, non-empty query\", async () => {\n-    mockedSearch.mockReset();\n-    const queryTerm = \"non RAW\";\n-    await SearchModule.searchItems({\n-      ...SearchModule.defaultSearchOptions,\n-      query: queryTerm,\n+    it(\"should append a wildcard for a search non-rawMode, non-empty query\", async () => {\n+      mockedSearch.mockReset();\n+      const queryTerm = \"non RAW\";\n+      await SearchModule.searchItems({\n+        ...SearchModule.defaultSearchOptions,\n+        query: queryTerm,\n+      });\n+      validateSearchQuery(`${queryTerm}*`);\n     });\n-    validateSearchQuery(`${queryTerm}*`);\n-  });\n \n-  it(\"should NOT append a wildcard for a rawMode search with a non-empty query\", async () => {\n-    mockedSearch.mockReset();\n-    const queryTerm = \"RAW mode!\";\n-    await SearchModule.searchItems({\n-      ...SearchModule.defaultSearchOptions,\n-      query: queryTerm,\n-      rawMode: true,\n+    it(\"should NOT append a wildcard for a rawMode search with a non-empty query\", async () => {\n+      mockedSearch.mockReset();\n+      const queryTerm = \"RAW mode!\";\n+      await SearchModule.searchItems({\n+        ...SearchModule.defaultSearchOptions,\n+        query: queryTerm,\n+        rawMode: true,\n+      });\n+      validateSearchQuery(`${queryTerm}`);\n     });\n-    validateSearchQuery(`${queryTerm}`);\n   });\n \n-  it(\"should append Classification terms to query if one or more Classifications are selected\", async () => {\n-    mockedSearch.mockReset();\n-    const query = \"technology\";\n-    const terms = [\"Java\", \"Scala\", \"SBT\"];\n-    await SearchModule.searchItems({\n-      ...SearchModule.defaultSearchOptions,\n-      query: query,\n-      rawMode: false,\n-      classificationTerms: terms,\n+  describe(\"generateCategoryWhereQuery\", () => {\n+    const selectedCategories: SelectedCategories[] = [\n+      {\n+        id: 766942,\n+        schemaNode: \"/item/language\",\n+        categories: [\"Java\", \"Scala\"],\n+      },\n+      {\n+        id: 766943,\n+        schemaNode: \"/item/city\",\n+        categories: [\"Hobart\"],\n+      },\n+    ];\n+    it(\"should generate a where clause for one category\", () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c9248f13487fdaca77030068272458dcc6492e3"}, "originalPosition": 115}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1759, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}