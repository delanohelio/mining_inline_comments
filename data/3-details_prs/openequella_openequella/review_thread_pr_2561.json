{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MzQ1MzQ3", "number": 2561, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyMTo0NFrOE-6PRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMDozMjozNlrOFBi6SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDAxMzQ4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/IAttachment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyMTo0NFrOH8UY9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyMTo0NFrOH8UY9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMDY3OQ==", "bodyText": "Although not done historically, for the new stuff we add JavaDoc to help our future selves. Please add.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533010679", "createdAt": "2020-12-01T01:21:44Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/IAttachment.java", "diffHunk": "@@ -67,4 +67,8 @@\n   boolean isRestricted();\n \n   IItem<?> getItem();\n+\n+  boolean isErroredIndexing();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDAxOTgyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.base/src/com/tle/web/api/item/interfaces/beans/AttachmentBean.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyNDo1MVrOH8UcpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyNDo1MVrOH8UcpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMTYyMQ==", "bodyText": "Please JavaDoc - even if it's a @see to IAttachment matching method.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533011621", "createdAt": "2020-12-01T01:24:51Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/web/api/item/interfaces/beans/AttachmentBean.java", "diffHunk": "@@ -65,4 +66,12 @@ public boolean isPreview() {\n   public void setPreview(boolean preview) {\n     this.preview = preview;\n   }\n+\n+  public boolean isErroredIndexing() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDAyMzcyOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/resources/lang/i18n-resource-centre.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyNjoyNVrOH8Ue2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyNjoyNVrOH8Ue2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMjE4NA==", "bodyText": "Be worthwhile to keep wording around it generic. That way if in the future we have other failure modes, we're all set.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /com.tle.core.entity.services.migration.v20202.indexing.errored=Add column to attachment table to allow indexer to skip individual attachments that have timed out.\n          \n          \n            \n            /com.tle.core.entity.services.migration.v20202.indexing.errored=Add column to attachment table to allow indexer to skip individual attachments that have failed.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533012184", "createdAt": "2020-12-01T01:26:25Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/resources/lang/i18n-resource-centre.properties", "diffHunk": "@@ -80,6 +80,7 @@\n /com.tle.core.entity.services.migration.v20192.unknownuser.alluser=Create a new table for all users\n /com.tle.core.entity.services.migration.v20202.facetedsearch.classification=Create a new table for faceted search classification\n /com.tle.core.entity.services.migration.v20202.removelastknownuserconstraint=Remove last known user composite constraint (username and institution ID)\n+/com.tle.core.entity.services.migration.v20202.indexing.errored=Add column to attachment table to allow indexer to skip individual attachments that have timed out.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDAzMjExOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTozMDowMFrOH8UjoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTozMDowMFrOH8UjoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMzQwOA==", "bodyText": "Being in Java 8 land, best to now go with an anonymous lambda rather than an anonymous class and all its overhead.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533013408", "createdAt": "2020-12-01T01:30:00Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "diffHunk": "@@ -50,25 +56,34 @@ public boolean isSupportedByDefault(MimeEntry mimeEntry) {\n   @Override\n   public void extractText(\n       String mimeType, InputStream input, StringBuilder outputText, int maxSize, long parseDuration)\n-      throws IOException {\n+      throws IOException, InterruptedException, ExecutionException, TimeoutException {\n     WriteOutContentHandler wrapped = new WriteOutContentHandler(maxSize);\n     ContentHandler handler = new CappedBodyContentHandler(wrapped, parseDuration);\n-    try {\n-      Metadata meta = new Metadata();\n-      Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n-      parser.parse(input, handler, meta, new ParseContext());\n+    Runnable runnableParse =\n+        new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDA3NzA3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo1MDoyOVrOH8U9Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMToxNzo0M1rOH9Gexw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxOTk5MA==", "bodyText": "It could be good to add a catch for InterruptException to capture when it's terminated early (or by other unforeseen interrupts). \ud83e\udd14", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533019990", "createdAt": "2020-12-01T01:50:29Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "diffHunk": "@@ -50,25 +56,34 @@ public boolean isSupportedByDefault(MimeEntry mimeEntry) {\n   @Override\n   public void extractText(\n       String mimeType, InputStream input, StringBuilder outputText, int maxSize, long parseDuration)\n-      throws IOException {\n+      throws IOException, InterruptedException, ExecutionException, TimeoutException {\n     WriteOutContentHandler wrapped = new WriteOutContentHandler(maxSize);\n     ContentHandler handler = new CappedBodyContentHandler(wrapped, parseDuration);\n-    try {\n-      Metadata meta = new Metadata();\n-      Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n-      parser.parse(input, handler, meta, new ParseContext());\n+    Runnable runnableParse =\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              Metadata meta = new Metadata();\n+              Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n+              parser.parse(input, handler, meta, new ParseContext());\n \n-      appendText(handler, outputText, maxSize);\n-\n-    } catch (Exception t) {\n-      if (wrapped.isWriteLimitReached(t)) {\n-        // keep going\n-        LOGGER.debug(\"PDF size limit reached.  Indexing truncated text\");\n-        appendText(handler, outputText, maxSize);\n-        return;\n-      }\n-      throw Throwables.propagate(t);\n-    }\n+              appendText(handler, outputText, maxSize);\n+            } catch (Exception t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzMTM2Nw==", "bodyText": "The InterruptedException isn't actually thrown here - it's thrown by future.get. So I surrounded that with try/catch and logged the InterruptedException/TimeoutException/ExecutionException that can throw. Then I rethrew so that the indexerThread can catch it further up where it sets the erroredIndexing flag.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533831367", "createdAt": "2020-12-02T01:17:43Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "diffHunk": "@@ -50,25 +56,34 @@ public boolean isSupportedByDefault(MimeEntry mimeEntry) {\n   @Override\n   public void extractText(\n       String mimeType, InputStream input, StringBuilder outputText, int maxSize, long parseDuration)\n-      throws IOException {\n+      throws IOException, InterruptedException, ExecutionException, TimeoutException {\n     WriteOutContentHandler wrapped = new WriteOutContentHandler(maxSize);\n     ContentHandler handler = new CappedBodyContentHandler(wrapped, parseDuration);\n-    try {\n-      Metadata meta = new Metadata();\n-      Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n-      parser.parse(input, handler, meta, new ParseContext());\n+    Runnable runnableParse =\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              Metadata meta = new Metadata();\n+              Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n+              parser.parse(input, handler, meta, new ParseContext());\n \n-      appendText(handler, outputText, maxSize);\n-\n-    } catch (Exception t) {\n-      if (wrapped.isWriteLimitReached(t)) {\n-        // keep going\n-        LOGGER.debug(\"PDF size limit reached.  Indexing truncated text\");\n-        appendText(handler, outputText, maxSize);\n-        return;\n-      }\n-      throw Throwables.propagate(t);\n-    }\n+              appendText(handler, outputText, maxSize);\n+            } catch (Exception t) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxOTk5MA=="}, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDA4MzcwOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo1MzozNVrOH8VBNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMDowMzozNlrOH9E2Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyMDk4Mg==", "bodyText": "Bringing in an ExecutorService etc. seems rather heavy handed for a single thread. How about just going with:\nThread extractThread = new Thread(() -> { ... }, \"ExtractThread\");\nextractThread.join(parseDuration);\nextractThread.interrupt();\nI'm assuming that interrupt() will be sufficient, as that's they typical recommendation for ExecutorService.shutdownNow(). But maybe you had issues?", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533020982", "createdAt": "2020-12-01T01:53:35Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "diffHunk": "@@ -50,25 +56,34 @@ public boolean isSupportedByDefault(MimeEntry mimeEntry) {\n   @Override\n   public void extractText(\n       String mimeType, InputStream input, StringBuilder outputText, int maxSize, long parseDuration)\n-      throws IOException {\n+      throws IOException, InterruptedException, ExecutionException, TimeoutException {\n     WriteOutContentHandler wrapped = new WriteOutContentHandler(maxSize);\n     ContentHandler handler = new CappedBodyContentHandler(wrapped, parseDuration);\n-    try {\n-      Metadata meta = new Metadata();\n-      Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n-      parser.parse(input, handler, meta, new ParseContext());\n+    Runnable runnableParse =\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              Metadata meta = new Metadata();\n+              Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n+              parser.parse(input, handler, meta, new ParseContext());\n \n-      appendText(handler, outputText, maxSize);\n-\n-    } catch (Exception t) {\n-      if (wrapped.isWriteLimitReached(t)) {\n-        // keep going\n-        LOGGER.debug(\"PDF size limit reached.  Indexing truncated text\");\n-        appendText(handler, outputText, maxSize);\n-        return;\n-      }\n-      throw Throwables.propagate(t);\n-    }\n+              appendText(handler, outputText, maxSize);\n+            } catch (Exception t) {\n+              if (wrapped.isWriteLimitReached(t)) {\n+                // keep going\n+                LOGGER.info(\"PDF size limit reached.  Indexing truncated text\");\n+                appendText(handler, outputText, maxSize);\n+                return;\n+              }\n+              throw Throwables.propagate(t);\n+            }\n+          }\n+        };\n+    ExecutorService executor = Executors.newSingleThreadExecutor();\n+    Future<?> future = executor.submit(runnableParse);\n+    future.get(parseDuration, TimeUnit.MILLISECONDS);\n+    executor.shutdownNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4OTk5MA==", "bodyText": "I tried your way and it doesn't seem to work. The problem with interrupt is that it seems to simply set a flag that needs to be handled in the thread with isInterrupted(), which would be fine if we had a loop but we don't, it's parser.parse that is the cause of the issue.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533789990", "createdAt": "2020-12-01T23:24:12Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "diffHunk": "@@ -50,25 +56,34 @@ public boolean isSupportedByDefault(MimeEntry mimeEntry) {\n   @Override\n   public void extractText(\n       String mimeType, InputStream input, StringBuilder outputText, int maxSize, long parseDuration)\n-      throws IOException {\n+      throws IOException, InterruptedException, ExecutionException, TimeoutException {\n     WriteOutContentHandler wrapped = new WriteOutContentHandler(maxSize);\n     ContentHandler handler = new CappedBodyContentHandler(wrapped, parseDuration);\n-    try {\n-      Metadata meta = new Metadata();\n-      Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n-      parser.parse(input, handler, meta, new ParseContext());\n+    Runnable runnableParse =\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              Metadata meta = new Metadata();\n+              Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n+              parser.parse(input, handler, meta, new ParseContext());\n \n-      appendText(handler, outputText, maxSize);\n-\n-    } catch (Exception t) {\n-      if (wrapped.isWriteLimitReached(t)) {\n-        // keep going\n-        LOGGER.debug(\"PDF size limit reached.  Indexing truncated text\");\n-        appendText(handler, outputText, maxSize);\n-        return;\n-      }\n-      throw Throwables.propagate(t);\n-    }\n+              appendText(handler, outputText, maxSize);\n+            } catch (Exception t) {\n+              if (wrapped.isWriteLimitReached(t)) {\n+                // keep going\n+                LOGGER.info(\"PDF size limit reached.  Indexing truncated text\");\n+                appendText(handler, outputText, maxSize);\n+                return;\n+              }\n+              throw Throwables.propagate(t);\n+            }\n+          }\n+        };\n+    ExecutorService executor = Executors.newSingleThreadExecutor();\n+    Future<?> future = executor.submit(runnableParse);\n+    future.get(parseDuration, TimeUnit.MILLISECONDS);\n+    executor.shutdownNow();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyMDk4Mg=="}, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwNDU1NA==", "bodyText": "Cool, evidentially the implementation is doing more of a hard stop - which is typically advised against due to stray objects etc. But that is more so where there are multiple threads of the same code.\nSo in this case, you have cause for the increased complexity. Thanks for checking. \ud83d\udc4d", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r533804554", "createdAt": "2020-12-02T00:03:36Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/freetext/extracter/standard/PdfExtracter.java", "diffHunk": "@@ -50,25 +56,34 @@ public boolean isSupportedByDefault(MimeEntry mimeEntry) {\n   @Override\n   public void extractText(\n       String mimeType, InputStream input, StringBuilder outputText, int maxSize, long parseDuration)\n-      throws IOException {\n+      throws IOException, InterruptedException, ExecutionException, TimeoutException {\n     WriteOutContentHandler wrapped = new WriteOutContentHandler(maxSize);\n     ContentHandler handler = new CappedBodyContentHandler(wrapped, parseDuration);\n-    try {\n-      Metadata meta = new Metadata();\n-      Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n-      parser.parse(input, handler, meta, new ParseContext());\n+    Runnable runnableParse =\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              Metadata meta = new Metadata();\n+              Parser parser = new AutoDetectParser(new TikaConfig(getClass().getClassLoader()));\n+              parser.parse(input, handler, meta, new ParseContext());\n \n-      appendText(handler, outputText, maxSize);\n-\n-    } catch (Exception t) {\n-      if (wrapped.isWriteLimitReached(t)) {\n-        // keep going\n-        LOGGER.debug(\"PDF size limit reached.  Indexing truncated text\");\n-        appendText(handler, outputText, maxSize);\n-        return;\n-      }\n-      throw Throwables.propagate(t);\n-    }\n+              appendText(handler, outputText, maxSize);\n+            } catch (Exception t) {\n+              if (wrapped.isWriteLimitReached(t)) {\n+                // keep going\n+                LOGGER.info(\"PDF size limit reached.  Indexing truncated text\");\n+                appendText(handler, outputText, maxSize);\n+                return;\n+              }\n+              throw Throwables.propagate(t);\n+            }\n+          }\n+        };\n+    ExecutorService executor = Executors.newSingleThreadExecutor();\n+    Future<?> future = executor.submit(runnableParse);\n+    future.get(parseDuration, TimeUnit.MILLISECONDS);\n+    executor.shutdownNow();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyMDk4Mg=="}, "originalCommit": {"oid": "b3f4215f4c8447f40679be1394b670b8028133f6"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDU4OTQ0OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNDowODoxMlrOH94oyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMTo1MDo1M1rOIAS0og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MzEzMA==", "bodyText": "\ud83e\udd14 would this make sense as a state/enumeration rather than a flag?\nsomething like\n             state machine\n+-----------------------------------------+\n|                                         |\n|                        +--------------+ |\n|                        |              | |\n|         +-----------+->+ indexed      | |\n| added   |           |  |              | |\n+-------->+ unindexed |  +--------------+ |\n|         |           |  |              | |\n|         +-----------+->+ index failed | |\n|                        |              | |\n|                        +--------------+ |\n|                                         |\n+-----------------------------------------+\n\n\nnew attachments start as unindexed, they can move to indexed, to index failed when processed.\nA state system would also leave to door open for partially indexed content, or other possible states.\nThough it may be overkill here \ud83e\udd14\nThoughts? \ud83d\udcad", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r534653130", "createdAt": "2020-12-03T04:08:12Z", "author": {"login": "ChristianMurphy"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "diffHunk": "@@ -86,6 +86,9 @@\n \n   private boolean restricted;\n \n+  @Column(name = \"errored_when_indexing\")\n+  private boolean erroredIndexing;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE0Nzc1OA==", "bodyText": "This is what we were talking about at the start @SammyIsConfused . But I believe you highlighted that unfortunately the tracking of this is split across levels of the entity hierarchy. I think the primary index tracking is done at the item level, yet what was being addressed and flagged here was the actions occurring at the item attachment level.\nSo now we can have an item which is 'indexed' (after previously being 'unindexed'), but potentially some attachments are flagged as having errored - avoiding excessive future indexing. Is that right?", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r537147758", "createdAt": "2020-12-06T23:20:11Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "diffHunk": "@@ -86,6 +86,9 @@\n \n   private boolean restricted;\n \n+  @Column(name = \"errored_when_indexing\")\n+  private boolean erroredIndexing;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MzEzMA=="}, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE3OTI5OA==", "bodyText": "Well summed up Ian, yes that's correct. The index tracking is at the item level and doesn't keep info about specific attachments. This change means that an entire item can be indexed even if it has an attachment flagged as errored - that attachment will simply be skipped in future indexes to prevent performance problems.\nThis also gives the ability to look at the database and get a list of all attachments that need fixing up to be indexed properly. SELECT * FROM attachment WHERE errored_when_indexing=true will point a DBA at exactly where the problems are. It would not have been possible to glean this info from the item table alone.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r537179298", "createdAt": "2020-12-07T01:50:53Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "diffHunk": "@@ -86,6 +86,9 @@\n \n   private boolean restricted;\n \n+  @Column(name = \"errored_when_indexing\")\n+  private boolean erroredIndexing;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MzEzMA=="}, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDU5MTk3OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNDowOToxOFrOH94qOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMTo1MToxM1rOIAS00g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MzQ5Nw==", "bodyText": "would it make sense for the param to also be errorIndexing?", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r534653497", "createdAt": "2020-12-03T04:09:18Z", "author": {"login": "ChristianMurphy"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "diffHunk": "@@ -281,4 +284,12 @@ public void setRestricted(boolean restricted) {\n   public String getAttachmentSignature() {\n     return item.getIdString() + \"/\" + this.uuid + \" [\" + this.description + \"]\";\n   }\n+\n+  public boolean isErroredIndexing() {\n+    return erroredIndexing;\n+  }\n+\n+  public void setErroredIndexing(boolean skipIndexing) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE3OTM0Ng==", "bodyText": "Well spotted, will fix that up. That was the old name of this field.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r537179346", "createdAt": "2020-12-07T01:51:13Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "diffHunk": "@@ -281,4 +284,12 @@ public void setRestricted(boolean restricted) {\n   public String getAttachmentSignature() {\n     return item.getIdString() + \"/\" + this.uuid + \" [\" + this.description + \"]\";\n   }\n+\n+  public boolean isErroredIndexing() {\n+    return erroredIndexing;\n+  }\n+\n+  public void setErroredIndexing(boolean skipIndexing) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MzQ5Nw=="}, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDU5NjE4OnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNDoxMTowMFrOH94sgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQyMzozNjozMVrOIAREuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1NDA4MQ==", "bodyText": "Maybe hasErroredIndexing would read more naturally here? \ud83e\udd14", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r534654081", "createdAt": "2020-12-03T04:11:00Z", "author": {"login": "ChristianMurphy"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "diffHunk": "@@ -281,4 +284,12 @@ public void setRestricted(boolean restricted) {\n   public String getAttachmentSignature() {\n     return item.getIdString() + \"/\" + this.uuid + \" [\" + this.description + \"]\";\n   }\n+\n+  public boolean isErroredIndexing() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE1MDY0OQ==", "bodyText": "Although I agree that it would read more natural. The Java standard for booleans on Beans (this being an Entity bean) is to  use the is prefix for boolean getters.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r537150649", "createdAt": "2020-12-06T23:36:31Z", "author": {"login": "edalex-ian"}, "path": "Source/Plugins/Core/com.equella.base/src/com/tle/beans/item/attachments/Attachment.java", "diffHunk": "@@ -281,4 +284,12 @@ public void setRestricted(boolean restricted) {\n   public String getAttachmentSignature() {\n     return item.getIdString() + \"/\" + this.uuid + \" [\" + this.description + \"]\";\n   }\n+\n+  public boolean isErroredIndexing() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1NDA4MQ=="}, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MTY0ODUxOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/institution/migration/v20202/AddIndexingErrorColumnMigration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMDozMjoxOVrOIARtcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMDozMjoxOVrOIARtcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE2MTA3NA==", "bodyText": "If you do nullable = false in Attachment.java, you also need to do that here.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r537161074", "createdAt": "2020-12-07T00:32:19Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/institution/migration/v20202/AddIndexingErrorColumnMigration.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.core.institution.migration.v20202;\n+\n+import com.google.inject.Singleton;\n+import com.tle.core.guice.Bind;\n+import com.tle.core.hibernate.impl.HibernateMigrationHelper;\n+import com.tle.core.migration.AbstractHibernateSchemaMigration;\n+import com.tle.core.migration.MigrationInfo;\n+import com.tle.core.migration.MigrationResult;\n+import java.util.List;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import org.hibernate.Query;\n+import org.hibernate.Session;\n+import org.hibernate.annotations.AccessType;\n+\n+@Bind\n+@Singleton\n+public class AddIndexingErrorColumnMigration extends AbstractHibernateSchemaMigration {\n+\n+  @Override\n+  protected void executeDataMigration(\n+      HibernateMigrationHelper helper, MigrationResult result, Session session) throws Exception {\n+    Query q = session.createQuery(\"UPDATE Attachment SET errored_when_indexing = :value\");\n+    q.setParameter(\"value\", false);\n+    q.executeUpdate();\n+  }\n+\n+  @Override\n+  protected int countDataMigrations(HibernateMigrationHelper helper, Session session) {\n+    return 1;\n+  }\n+\n+  @Override\n+  protected List<String> getDropModifySql(HibernateMigrationHelper helper) {\n+    return helper.getAddNotNullSQL(\"attachment\", \"errored_when_indexing\");\n+  }\n+\n+  @Override\n+  protected List<String> getAddSql(HibernateMigrationHelper helper) {\n+    return helper.getAddColumnsSQL(\"attachment\", \"errored_when_indexing\");\n+  }\n+\n+  @Override\n+  protected Class<?>[] getDomainClasses() {\n+    return new Class<?>[] {FakeAttachment.class};\n+  }\n+\n+  @Override\n+  public MigrationInfo createMigrationInfo() {\n+    return new MigrationInfo(\"com.tle.core.entity.services.migration.v20202.indexing.errored\");\n+  }\n+\n+  @Entity(name = \"Attachment\")\n+  @AccessType(\"field\")\n+  public static class FakeAttachment {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO)\n+    long id;\n+\n+    @Column boolean errored_when_indexing;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MTY0ODczOnYy", "diffSide": "RIGHT", "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/institution/migration/v20202/AddIndexingErrorColumnMigration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMDozMjozNlrOIARtkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNTo0MzowOFrOIAW2Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE2MTEwNA==", "bodyText": "Hi Sam, I have two questions here.\n\n\nDo we need to drop column 'errored_when_indexing'  in any situation?  If yes, I think we should use\n'getDropModifySql'. If no we can just return null.\n\n\nI am not quite sure why use getAddNotNullSQL. If this column needs a not null constraint, you can try\n@Column(name = \"errored_when_indexing\", nullable = false) in  attachment.java.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r537161104", "createdAt": "2020-12-07T00:32:36Z", "author": {"login": "PenghaiZhang"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/institution/migration/v20202/AddIndexingErrorColumnMigration.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.core.institution.migration.v20202;\n+\n+import com.google.inject.Singleton;\n+import com.tle.core.guice.Bind;\n+import com.tle.core.hibernate.impl.HibernateMigrationHelper;\n+import com.tle.core.migration.AbstractHibernateSchemaMigration;\n+import com.tle.core.migration.MigrationInfo;\n+import com.tle.core.migration.MigrationResult;\n+import java.util.List;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import org.hibernate.Query;\n+import org.hibernate.Session;\n+import org.hibernate.annotations.AccessType;\n+\n+@Bind\n+@Singleton\n+public class AddIndexingErrorColumnMigration extends AbstractHibernateSchemaMigration {\n+\n+  @Override\n+  protected void executeDataMigration(\n+      HibernateMigrationHelper helper, MigrationResult result, Session session) throws Exception {\n+    Query q = session.createQuery(\"UPDATE Attachment SET errored_when_indexing = :value\");\n+    q.setParameter(\"value\", false);\n+    q.executeUpdate();\n+  }\n+\n+  @Override\n+  protected int countDataMigrations(HibernateMigrationHelper helper, Session session) {\n+    return 1;\n+  }\n+\n+  @Override\n+  protected List<String> getDropModifySql(HibernateMigrationHelper helper) {\n+    return helper.getAddNotNullSQL(\"attachment\", \"errored_when_indexing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0NTE5MQ==", "bodyText": "There's no need for the getDropModifySql, I was following another as a template.\nAdding nullable=false to Attachment.java now.", "url": "https://github.com/openequella/openEQUELLA/pull/2561#discussion_r537245191", "createdAt": "2020-12-07T05:43:08Z", "author": {"login": "SammyIsConfused"}, "path": "Source/Plugins/Core/com.equella.core/src/com/tle/core/institution/migration/v20202/AddIndexingErrorColumnMigration.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.core.institution.migration.v20202;\n+\n+import com.google.inject.Singleton;\n+import com.tle.core.guice.Bind;\n+import com.tle.core.hibernate.impl.HibernateMigrationHelper;\n+import com.tle.core.migration.AbstractHibernateSchemaMigration;\n+import com.tle.core.migration.MigrationInfo;\n+import com.tle.core.migration.MigrationResult;\n+import java.util.List;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import org.hibernate.Query;\n+import org.hibernate.Session;\n+import org.hibernate.annotations.AccessType;\n+\n+@Bind\n+@Singleton\n+public class AddIndexingErrorColumnMigration extends AbstractHibernateSchemaMigration {\n+\n+  @Override\n+  protected void executeDataMigration(\n+      HibernateMigrationHelper helper, MigrationResult result, Session session) throws Exception {\n+    Query q = session.createQuery(\"UPDATE Attachment SET errored_when_indexing = :value\");\n+    q.setParameter(\"value\", false);\n+    q.executeUpdate();\n+  }\n+\n+  @Override\n+  protected int countDataMigrations(HibernateMigrationHelper helper, Session session) {\n+    return 1;\n+  }\n+\n+  @Override\n+  protected List<String> getDropModifySql(HibernateMigrationHelper helper) {\n+    return helper.getAddNotNullSQL(\"attachment\", \"errored_when_indexing\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE2MTEwNA=="}, "originalCommit": {"oid": "0772539274c8f218f9806769922e894ceb98d3a7"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1590, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}