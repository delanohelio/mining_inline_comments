{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTEwMTE0", "number": 6586, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo0NzoxMlrOEC5AQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTozMzoxMVrOEGfS8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDY2NTYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo0NzoxMlrOGfn4RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo0NzoxMlrOGfn4RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxMjQyMA==", "bodyText": "Please avoid abbreviations.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435812420", "createdAt": "2020-06-05T09:47:12Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> stream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        Stream<Map.Entry<String, String>> streamTail = data.entrySet().stream().filter(entry -> entry.getKey().equals(MetaData.GROUPSTREE) || entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        stream = Stream.concat(stream, streamTail);\n+\n+        Iterator<Map.Entry<String, String>> it = stream.iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad11243bb1e29bcaae6caa8fdd41b728844f1282"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDY4MzQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo1Mjo1NlrOGfoD2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo1Mjo1NlrOGfoD2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxNTM4NQ==", "bodyText": "Please avoid simple whitespace changes. Eclipse tends to push lines beyond 80 characters just to line method arguments with the brackets. But this makes it hard to read on smaller screens as well as in code reviews.\nAlso we want to avoid an 'IDE war' in JabRef, since autoformat in IntelliJ would then put a tabspace there instead again with the next refactor. We try to keep a consistent codestyle in JabRef and common practice is now to use the IntelliJ-style, as it keeps the code more compact.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435815385", "createdAt": "2020-06-05T09:52:56Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -117,103 +119,113 @@ public GroupDialogViewModel(DialogService dialogService, BibDatabaseContext curr\n \n     private void setupValidation() {\n         nameValidator = new FunctionBasedValidator<>(\n-                nameProperty,\n-                StringUtil::isNotBlank,\n-                ValidationMessage.error(Localization.lang(\"Please enter a name for the group.\")));\n+                                                     nameProperty,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad11243bb1e29bcaae6caa8fdd41b728844f1282"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDY4OTM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo1NDo0MFrOGfoHnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo1NDo0MFrOGfoHnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxNjM1MQ==", "bodyText": "Please omit the underscore in variable names.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435816351", "createdAt": "2020-06-05T09:54:40Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -232,6 +244,14 @@ private void setupValidation() {\n                 validator.removeValidators(keywordFieldEmptyValidator, keywordRegexValidator, keywordSearchTermEmptyValidator);\n             }\n         });\n+\n+        typeTexProperty.addListener((obs, _oldValue, isSelected) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad11243bb1e29bcaae6caa8fdd41b728844f1282"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDcxMjY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDowMTowM1rOGfoWBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDowMTowM1rOGfoWBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMDAzNg==", "bodyText": "I think this check can be reduced to StringUtil.isBlank().", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435820036", "createdAt": "2020-06-05T10:01:03Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -117,103 +119,113 @@ public GroupDialogViewModel(DialogService dialogService, BibDatabaseContext curr\n \n     private void setupValidation() {\n         nameValidator = new FunctionBasedValidator<>(\n-                nameProperty,\n-                StringUtil::isNotBlank,\n-                ValidationMessage.error(Localization.lang(\"Please enter a name for the group.\")));\n+                                                     nameProperty,\n+                                                     StringUtil::isNotBlank,\n+                                                     ValidationMessage.error(Localization.lang(\"Please enter a name for the group.\")));\n \n         nameContainsDelimiterValidator = new FunctionBasedValidator<>(\n-                nameProperty,\n-                name -> !name.contains(Character.toString(preferencesService.getKeywordDelimiter())),\n-                ValidationMessage.warning(\n-                        Localization.lang(\n-                                \"The group name contains the keyword separator \\\"%0\\\" and thus probably does not work as expected.\",\n-                                Character.toString(preferencesService.getKeywordDelimiter())\n-                        )));\n+                                                                      nameProperty,\n+                                                                      name -> !name.contains(Character.toString(preferencesService.getKeywordDelimiter())),\n+                                                                      ValidationMessage.warning(\n+                                                                                                Localization.lang(\n+                                                                                                                  \"The group name contains the keyword separator \\\"%0\\\" and thus probably does not work as expected.\",\n+                                                                                                                  Character.toString(preferencesService.getKeywordDelimiter()))));\n \n         sameNameValidator = new FunctionBasedValidator<>(\n-                nameProperty,\n-                name -> {\n-                    Optional<GroupTreeNode> rootGroup = currentDatabase.getMetaData().getGroups();\n-                    if (rootGroup.isPresent()) {\n-                        int groupsWithSameName = rootGroup.get().findChildrenSatisfying(group -> group.getName().equals(name)).size();\n-                        if ((editedGroup == null) && (groupsWithSameName > 0)) {\n-                            // New group but there is already one group with the same name\n-                            return false;\n-                        }\n-\n-                        // Edit group, changed name to something that is already present\n-                        return (editedGroup == null) || editedGroup.getName().equals(name) || (groupsWithSameName <= 0);\n-                    }\n-                    return true;\n-                },\n-                ValidationMessage.error(Localization.lang(\"There exists already a group with the same name.\")));\n+                                                         nameProperty,\n+                                                         name -> {\n+                                                             Optional<GroupTreeNode> rootGroup = currentDatabase.getMetaData().getGroups();\n+                                                             if (rootGroup.isPresent()) {\n+                                                                 int groupsWithSameName = rootGroup.get().findChildrenSatisfying(group -> group.getName().equals(name)).size();\n+                                                                 if ((editedGroup == null) && (groupsWithSameName > 0)) {\n+                                                                     // New group but there is already one group with the same name\n+                                                                     return false;\n+                                                                 }\n+\n+                                                                 // Edit group, changed name to something that is already present\n+                                                                 return (editedGroup == null) || editedGroup.getName().equals(name) || (groupsWithSameName <= 0);\n+                                                             }\n+                                                             return true;\n+                                                         },\n+                                                         ValidationMessage.error(Localization.lang(\"There exists already a group with the same name.\")));\n \n         keywordRegexValidator = new FunctionBasedValidator<>(\n-                keywordGroupSearchTermProperty,\n-                input -> {\n-                    if (!keywordGroupRegexProperty.getValue()) {\n-                        return true;\n-                    }\n-\n-                    if (StringUtil.isNullOrEmpty(input)) {\n-                        return false;\n-                    }\n-\n-                    try {\n-                        Pattern.compile(input);\n-                        return true;\n-                    } catch (PatternSyntaxException ignored) {\n-                        return false;\n-                    }\n-                },\n-                ValidationMessage.error(String.format(\"%s > %n %s %n %n %s\",\n-                        Localization.lang(\"Searching for keywords\"),\n-                        Localization.lang(\"Keywords\"),\n-                        Localization.lang(\"Invalid regular expression.\"))));\n+                                                             keywordGroupSearchTermProperty,\n+                                                             input -> {\n+                                                                 if (!keywordGroupRegexProperty.getValue()) {\n+                                                                     return true;\n+                                                                 }\n+\n+                                                                 if (StringUtil.isNullOrEmpty(input)) {\n+                                                                     return false;\n+                                                                 }\n+\n+                                                                 try {\n+                                                                     Pattern.compile(input);\n+                                                                     return true;\n+                                                                 } catch (PatternSyntaxException ignored) {\n+                                                                     return false;\n+                                                                 }\n+                                                             },\n+                                                             ValidationMessage.error(String.format(\"%s > %n %s %n %n %s\",\n+                                                                                                   Localization.lang(\"Searching for keywords\"),\n+                                                                                                   Localization.lang(\"Keywords\"),\n+                                                                                                   Localization.lang(\"Invalid regular expression.\"))));\n \n         keywordFieldEmptyValidator = new FunctionBasedValidator<>(\n-                keywordGroupSearchFieldProperty,\n-                StringUtil::isNotBlank,\n-                ValidationMessage.error(Localization.lang(\"Please enter a field name to search for keywords.\")));\n+                                                                  keywordGroupSearchFieldProperty,\n+                                                                  StringUtil::isNotBlank,\n+                                                                  ValidationMessage.error(Localization.lang(\"Please enter a field name to search for keywords.\")));\n \n         keywordSearchTermEmptyValidator = new FunctionBasedValidator<>(\n-                keywordGroupSearchTermProperty,\n-                input -> !StringUtil.isNullOrEmpty(input),\n-                ValidationMessage.error(String.format(\"%s > %n %s %n %n %s\",\n-                        Localization.lang(\"Searching for keywords\"),\n-                        Localization.lang(\"Keywords\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                                                                       keywordGroupSearchTermProperty,\n+                                                                       input -> !StringUtil.isNullOrEmpty(input),\n+                                                                       ValidationMessage.error(String.format(\"%s > %n %s %n %n %s\",\n+                                                                                                             Localization.lang(\"Searching for keywords\"),\n+                                                                                                             Localization.lang(\"Keywords\"),\n+                                                                                                             Localization.lang(\"Search term is empty.\"))));\n \n         searchRegexValidator = new FunctionBasedValidator<>(\n-                searchGroupSearchTermProperty,\n-                input -> {\n-                    if (!searchGroupRegexProperty.getValue()) {\n-                        return true;\n-                    }\n-\n-                    if (StringUtil.isNullOrEmpty(input)) {\n-                        return false;\n-                    }\n-\n-                    try {\n-                        Pattern.compile(input);\n-                        return true;\n-                    } catch (PatternSyntaxException ignored) {\n-                        return false;\n-                    }\n-                },\n-                ValidationMessage.error(String.format(\"%s > %n %s\",\n-                        Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Invalid regular expression.\"))));\n+                                                            searchGroupSearchTermProperty,\n+                                                            input -> {\n+                                                                if (!searchGroupRegexProperty.getValue()) {\n+                                                                    return true;\n+                                                                }\n+\n+                                                                if (StringUtil.isNullOrEmpty(input)) {\n+                                                                    return false;\n+                                                                }\n+\n+                                                                try {\n+                                                                    Pattern.compile(input);\n+                                                                    return true;\n+                                                                } catch (PatternSyntaxException ignored) {\n+                                                                    return false;\n+                                                                }\n+                                                            },\n+                                                            ValidationMessage.error(String.format(\"%s > %n %s\",\n+                                                                                                  Localization.lang(\"Free search expression\"),\n+                                                                                                  Localization.lang(\"Invalid regular expression.\"))));\n \n         searchSearchTermEmptyValidator = new FunctionBasedValidator<>(\n-                searchGroupSearchTermProperty,\n-                input -> !StringUtil.isNullOrEmpty(input),\n-                ValidationMessage.error(String.format(\"%s > %n %s\",\n-                        Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                                                                      searchGroupSearchTermProperty,\n+                                                                      input -> !StringUtil.isNullOrEmpty(input),\n+                                                                      ValidationMessage.error(String.format(\"%s > %n %s\",\n+                                                                                                            Localization.lang(\"Free search expression\"),\n+                                                                                                            Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                                                                 texGroupFilePathProperty,\n+                                                                 input -> {\n+                                                                     if (StringUtil.isNullOrEmpty(input)) {\n+                                                                         return false;\n+                                                                     } else if (input.trim().length() == 0) {\n+                                                                         return false;\n+                                                                     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad11243bb1e29bcaae6caa8fdd41b728844f1282"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDcyODc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDowNjowNVrOGfogSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDowNjowNVrOGfogSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMjY2NA==", "bodyText": "Can you please use more meaningful variable names? Like entrySetStream and groupsTreeStream or similar.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435822664", "createdAt": "2020-06-05T10:06:05Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> stream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        Stream<Map.Entry<String, String>> streamTail = data.entrySet().stream().filter(entry -> entry.getKey().equals(MetaData.GROUPSTREE) || entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        stream = Stream.concat(stream, streamTail);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad11243bb1e29bcaae6caa8fdd41b728844f1282"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc0MzY4OnYy", "diffSide": "RIGHT", "path": "CHANGELOG.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxMToxMFrOGfoqDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxMToxMFrOGfoqDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNTE2NA==", "bodyText": "The english here sounds a bit rough. I myself often use deepl.com to produce texts, since english isn't my mother tongue. There's no shame in that. \ud83d\ude09", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435825164", "createdAt": "2020-06-05T10:11:10Z", "author": {"login": "calixtus"}, "path": "CHANGELOG.md", "diffHunk": "@@ -83,6 +83,8 @@ Note that this project **does not** adhere to [Semantic Versioning](http://semve\n - We fixed an issue where \"null\" appeared in generated BibTeX keys. [#6459](https://github.com/JabRef/jabref/issues/6459)\n - We fixed an issue where the authors' names were incorrectly displayed in the authors' column when they were bracketed. [#6465](https://github.com/JabRef/jabref/issues/6465) [#6459](https://github.com/JabRef/jabref/issues/6459)\n - We fixed an issue where importing certain unlinked files would result in an exception [#5815](https://github.com/JabRef/jabref/issues/5815)\n+- We fixed an issue with creating a group of cited entries, which wrongly triggered that the library had been changed externally. [#6420](https://github.com/JabRef/jabref/issues/6420)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad11243bb1e29bcaae6caa8fdd41b728844f1282"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDg2NDc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDo1Mzo1M1rOGfp2qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDo1Mzo1M1rOGfp2qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NDc3OQ==", "bodyText": "StringUtil.isBlank()can be used here too.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435844779", "createdAt": "2020-06-05T10:53:53Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b7063d91d81f94112a779b8d9df620d031aa822"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDg4NTQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTowMDo0MFrOGfqC1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMzoyNDoyOVrOGfuUnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0Nzg5NQ==", "bodyText": "Have you tried FileUtil.find() here?", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435847895", "createdAt": "2020-06-05T11:00:40Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;\n+                    } else if ((input.length() < 4) || !input.substring(input.length() - 4).toLowerCase().equals(\".aux\")) {\n+                        return false;\n+                    } else {\n+                        Path path = preferencesService.getWorkingDir();\n+                        File texFile = new File(path.toString(), input);\n+                        if (!texFile.exists() || !texFile.isFile()) {\n+                            return false;\n+                        }\n+                        return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b7063d91d81f94112a779b8d9df620d031aa822"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTEwMg==", "bodyText": "I'm not sure, whether this is a good idea. I intended to explicitly check the provided file, without searching other locations. \ud83e\udd14", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435861102", "createdAt": "2020-06-05T11:31:35Z", "author": {"login": "systemoperator"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;\n+                    } else if ((input.length() < 4) || !input.substring(input.length() - 4).toLowerCase().equals(\".aux\")) {\n+                        return false;\n+                    } else {\n+                        Path path = preferencesService.getWorkingDir();\n+                        File texFile = new File(path.toString(), input);\n+                        if (!texFile.exists() || !texFile.isFile()) {\n+                            return false;\n+                        }\n+                        return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0Nzg5NQ=="}, "originalCommit": {"oid": "8b7063d91d81f94112a779b8d9df620d031aa822"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMDYyMQ==", "bodyText": "I see, maybe this can provide a solution using only the more modern nio files package:\nPath resolved = preferencesService.getWorkingDir().resolve(input);\nreturn Files.exist(resolved);", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435900621", "createdAt": "2020-06-05T12:52:48Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;\n+                    } else if ((input.length() < 4) || !input.substring(input.length() - 4).toLowerCase().equals(\".aux\")) {\n+                        return false;\n+                    } else {\n+                        Path path = preferencesService.getWorkingDir();\n+                        File texFile = new File(path.toString(), input);\n+                        if (!texFile.exists() || !texFile.isFile()) {\n+                            return false;\n+                        }\n+                        return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0Nzg5NQ=="}, "originalCommit": {"oid": "8b7063d91d81f94112a779b8d9df620d031aa822"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkxNzk4MQ==", "bodyText": "I have adapted it.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435917981", "createdAt": "2020-06-05T13:24:29Z", "author": {"login": "systemoperator"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;\n+                    } else if ((input.length() < 4) || !input.substring(input.length() - 4).toLowerCase().equals(\".aux\")) {\n+                        return false;\n+                    } else {\n+                        Path path = preferencesService.getWorkingDir();\n+                        File texFile = new File(path.toString(), input);\n+                        if (!texFile.exists() || !texFile.isFile()) {\n+                            return false;\n+                        }\n+                        return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0Nzg5NQ=="}, "originalCommit": {"oid": "8b7063d91d81f94112a779b8d9df620d031aa822"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDg5NDU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTowMzozOVrOGfqIKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTowMzozOVrOGfqIKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0OTI1Ng==", "bodyText": "This can probably abbreviated with FileUtil.getFileExtension()", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435849256", "createdAt": "2020-06-05T11:03:39Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;\n+                    } else if ((input.length() < 4) || !input.substring(input.length() - 4).toLowerCase().equals(\".aux\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b7063d91d81f94112a779b8d9df620d031aa822"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTc4MDE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNToxOToxM1rOGfyzsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNToxOToxM1rOGfyzsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTQ3Mg==", "bodyText": "I think sorting the entries as described here https://stackoverflow.com/a/30286728/873661 is a bit more readable.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435991472", "createdAt": "2020-06-05T15:19:13Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> entrySetStream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74f05ea31d7cb1208a1ed5babc76b59b497e65d6"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTc4MTk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNToxOTo0MlrOGfy01Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo0ODoxM1rOGf13aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTc2NQ==", "bodyText": "A more \"streamy\" way is using the stream.foreach(...) method.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435991765", "createdAt": "2020-06-05T15:19:42Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> entrySetStream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        Stream<Map.Entry<String, String>> entrySetStreamTail = data.entrySet().stream().filter(entry -> entry.getKey().equals(MetaData.GROUPSTREE) || entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        entrySetStream = Stream.concat(entrySetStream, entrySetStreamTail);\n+\n+        Iterator<Map.Entry<String, String>> entryIterator = entrySetStream.iterator();\n+\n+        while (entryIterator.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74f05ea31d7cb1208a1ed5babc76b59b497e65d6"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNzE1MA==", "bodyText": "In the loop exceptions may be thrown. It's slightly complicated to throw them back within a lambda expression (at least for me).", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r436037150", "createdAt": "2020-06-05T16:39:39Z", "author": {"login": "systemoperator"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> entrySetStream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        Stream<Map.Entry<String, String>> entrySetStreamTail = data.entrySet().stream().filter(entry -> entry.getKey().equals(MetaData.GROUPSTREE) || entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        entrySetStream = Stream.concat(entrySetStream, entrySetStreamTail);\n+\n+        Iterator<Map.Entry<String, String>> entryIterator = entrySetStream.iterator();\n+\n+        while (entryIterator.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTc2NQ=="}, "originalCommit": {"oid": "74f05ea31d7cb1208a1ed5babc76b59b497e65d6"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MTU3Nw==", "bodyText": "ok, good argument. I think first using collect to get an ordinary list and then using foreach is still slightly better.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r436041577", "createdAt": "2020-06-05T16:48:13Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> entrySetStream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        Stream<Map.Entry<String, String>> entrySetStreamTail = data.entrySet().stream().filter(entry -> entry.getKey().equals(MetaData.GROUPSTREE) || entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        entrySetStream = Stream.concat(entrySetStream, entrySetStreamTail);\n+\n+        Iterator<Map.Entry<String, String>> entryIterator = entrySetStream.iterator();\n+\n+        while (entryIterator.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTc2NQ=="}, "originalCommit": {"oid": "74f05ea31d7cb1208a1ed5babc76b59b497e65d6"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjIyMjkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzozMzo0MVrOGf3RZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzozMzo0MVrOGf3RZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2NDYxNQ==", "bodyText": "Just an idea: Can creating streams theoretically be omitted by using List.copyof(data.entrySet()).sort(groupsLast()) ?", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r436064615", "createdAt": "2020-06-05T17:33:41Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +52,62 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> entrySetStream = data.entrySet().stream().sorted(groupsLast());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c120c457c662ddedf3804c1747f066fc77261fea"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Njk3OTQ0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fileformat/BibtexParserTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo0NjowMVrOGke7Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo0NjowMVrOGke7Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkwODU1MQ==", "bodyText": "I would suggest removing empty @throws annotations.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440908551", "createdAt": "2020-06-16T14:46:01Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fileformat/BibtexParserTest.java", "diffHunk": "@@ -1388,6 +1390,36 @@ void integrationTestGroupTree() throws IOException, ParseException {\n                 ((ExplicitGroup) root.getChildren().get(2).getGroup()).getLegacyEntryKeys());\n     }\n \n+    /**\n+     * Checks that a TexGroup finally gets the required data, after parsing the library.\n+     * @throws IOException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Njk4MjA0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fileformat/BibtexParserTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo0NjozNFrOGke8nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo0NjozNFrOGke8nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkwODk1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void integrationTestTexGroup() throws IOException, ParseException {\n          \n          \n            \n                void integrationTestTexGroup() throws Exception {\n          \n      \n    \n    \n  \n\nWe have the convention that always Exception is thrown at tests.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440908959", "createdAt": "2020-06-16T14:46:34Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fileformat/BibtexParserTest.java", "diffHunk": "@@ -1388,6 +1390,36 @@ void integrationTestGroupTree() throws IOException, ParseException {\n                 ((ExplicitGroup) root.getChildren().get(2).getGroup()).getLegacyEntryKeys());\n     }\n \n+    /**\n+     * Checks that a TexGroup finally gets the required data, after parsing the library.\n+     * @throws IOException\n+     * @throws ParseException\n+     */\n+    @Test\n+    void integrationTestTexGroup() throws IOException, ParseException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzAwMTAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo1MDozNFrOGkfImg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTozMToxM1rOGlUYiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg==", "bodyText": "Can we keep the switch (entry.getKey) somehow? Maybe nested in an else branch?\nYou can use the new Java14 switch: https://openjdk.java.net/jeps/361\n(File needs to be added to \n  \n    \n      jabref/config/checkstyle/checkstyle.xml\n    \n    \n         Line 15\n      in\n      ca06b71\n    \n    \n    \n    \n\n        \n          \n           <property name=\"fileNamePattern\" value=\"AuthorAndsReplacer.java|Ordinal.java|EntryTypeView.java\" /> \n        \n    \n  \n\n then)", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440912026", "createdAt": "2020-06-16T14:50:34Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +50,63 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        List<Map.Entry<String, String>> entryList = new ArrayList<>(data.entrySet());\n+        entryList.sort(groupsLast());\n+\n+        for (Map.Entry<String, String> entry : entryList) {\n             List<String> value = getAsList(entry.getValue());\n \n             if (entry.getKey().startsWith(MetaData.PREFIX_KEYPATTERN)) {\n                 EntryType entryType = EntryTypeFactory.parse(entry.getKey().substring(MetaData.PREFIX_KEYPATTERN.length()));\n                 nonDefaultCiteKeyPatterns.put(entryType, Collections.singletonList(getSingleItem(value)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + '-')) {\n                 // The user name comes directly after \"FILE_DIRECTORY-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 1);\n                 metaData.setUserFileDirectory(user, getSingleItem(value));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.SELECTOR_META_PREFIX)) {\n                 metaData.addContentSelector(ContentSelectors.parse(FieldFactory.parseField(entry.getKey().substring(MetaData.SELECTOR_META_PREFIX.length())), StringUtil.unquote(entry.getValue(), MetaData.ESCAPE_CHARACTER)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + \"Latex-\")) {\n                 // The user name comes directly after \"FILE_DIRECTORYLatex-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 6);\n                 Path path = Path.of(getSingleItem(value)).normalize();\n                 metaData.setLatexFileDirectory(user, path);\n-                continue;\n-            }\n-\n-            switch (entry.getKey()) {\n-                case MetaData.GROUPSTREE:\n-                case MetaData.GROUPSTREE_LEGACY:\n-                    metaData.setGroups(GroupsParser.importGroups(value, keywordSeparator, fileMonitor, metaData));\n-                    break;\n-                case MetaData.SAVE_ACTIONS:\n-                    metaData.setSaveActions(Cleanups.parse(value));\n-                    break;\n-                case MetaData.DATABASE_TYPE:\n-                    metaData.setMode(BibDatabaseMode.parse(getSingleItem(value)));\n-                    break;\n-                case MetaData.KEYPATTERNDEFAULT:\n-                    defaultCiteKeyPattern = Collections.singletonList(getSingleItem(value));\n-                    break;\n-                case MetaData.PROTECTED_FLAG_META:\n-                    if (Boolean.parseBoolean(getSingleItem(value))) {\n-                        metaData.markAsProtected();\n-                    } else {\n-                        metaData.markAsNotProtected();\n-                    }\n-                    break;\n-                case MetaData.FILE_DIRECTORY:\n-                    metaData.setDefaultFileDirectory(getSingleItem(value));\n-                    break;\n-                case MetaData.SAVE_ORDER_CONFIG:\n-                    metaData.setSaveOrderConfig(SaveOrderConfig.parse(value));\n-                    break;\n-                default:\n-                    // Keep meta data items that we do not know in the file\n-                    metaData.putUnknownMetaDataItem(entry.getKey(), value);\n+            } else if (entry.getKey().equals(MetaData.SAVE_ACTIONS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk0ODMzNw==", "bodyText": "This is still a huge p.i.t.a.\nCheckstyle really needs to keep up, people start getting tired of these workarounds.\nSome background information, if you are interested: checkstyle/checkstyle#6615", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440948337", "createdAt": "2020-06-16T15:36:28Z", "author": {"login": "calixtus"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +50,63 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        List<Map.Entry<String, String>> entryList = new ArrayList<>(data.entrySet());\n+        entryList.sort(groupsLast());\n+\n+        for (Map.Entry<String, String> entry : entryList) {\n             List<String> value = getAsList(entry.getValue());\n \n             if (entry.getKey().startsWith(MetaData.PREFIX_KEYPATTERN)) {\n                 EntryType entryType = EntryTypeFactory.parse(entry.getKey().substring(MetaData.PREFIX_KEYPATTERN.length()));\n                 nonDefaultCiteKeyPatterns.put(entryType, Collections.singletonList(getSingleItem(value)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + '-')) {\n                 // The user name comes directly after \"FILE_DIRECTORY-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 1);\n                 metaData.setUserFileDirectory(user, getSingleItem(value));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.SELECTOR_META_PREFIX)) {\n                 metaData.addContentSelector(ContentSelectors.parse(FieldFactory.parseField(entry.getKey().substring(MetaData.SELECTOR_META_PREFIX.length())), StringUtil.unquote(entry.getValue(), MetaData.ESCAPE_CHARACTER)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + \"Latex-\")) {\n                 // The user name comes directly after \"FILE_DIRECTORYLatex-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 6);\n                 Path path = Path.of(getSingleItem(value)).normalize();\n                 metaData.setLatexFileDirectory(user, path);\n-                continue;\n-            }\n-\n-            switch (entry.getKey()) {\n-                case MetaData.GROUPSTREE:\n-                case MetaData.GROUPSTREE_LEGACY:\n-                    metaData.setGroups(GroupsParser.importGroups(value, keywordSeparator, fileMonitor, metaData));\n-                    break;\n-                case MetaData.SAVE_ACTIONS:\n-                    metaData.setSaveActions(Cleanups.parse(value));\n-                    break;\n-                case MetaData.DATABASE_TYPE:\n-                    metaData.setMode(BibDatabaseMode.parse(getSingleItem(value)));\n-                    break;\n-                case MetaData.KEYPATTERNDEFAULT:\n-                    defaultCiteKeyPattern = Collections.singletonList(getSingleItem(value));\n-                    break;\n-                case MetaData.PROTECTED_FLAG_META:\n-                    if (Boolean.parseBoolean(getSingleItem(value))) {\n-                        metaData.markAsProtected();\n-                    } else {\n-                        metaData.markAsNotProtected();\n-                    }\n-                    break;\n-                case MetaData.FILE_DIRECTORY:\n-                    metaData.setDefaultFileDirectory(getSingleItem(value));\n-                    break;\n-                case MetaData.SAVE_ORDER_CONFIG:\n-                    metaData.setSaveOrderConfig(SaveOrderConfig.parse(value));\n-                    break;\n-                default:\n-                    // Keep meta data items that we do not know in the file\n-                    metaData.putUnknownMetaDataItem(entry.getKey(), value);\n+            } else if (entry.getKey().equals(MetaData.SAVE_ACTIONS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk1NDk0OQ==", "bodyText": "The key problem is here that switch cases are not executed in order. That's the reason for the if else", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440954949", "createdAt": "2020-06-16T15:45:28Z", "author": {"login": "Siedlerchr"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +50,63 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        List<Map.Entry<String, String>> entryList = new ArrayList<>(data.entrySet());\n+        entryList.sort(groupsLast());\n+\n+        for (Map.Entry<String, String> entry : entryList) {\n             List<String> value = getAsList(entry.getValue());\n \n             if (entry.getKey().startsWith(MetaData.PREFIX_KEYPATTERN)) {\n                 EntryType entryType = EntryTypeFactory.parse(entry.getKey().substring(MetaData.PREFIX_KEYPATTERN.length()));\n                 nonDefaultCiteKeyPatterns.put(entryType, Collections.singletonList(getSingleItem(value)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + '-')) {\n                 // The user name comes directly after \"FILE_DIRECTORY-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 1);\n                 metaData.setUserFileDirectory(user, getSingleItem(value));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.SELECTOR_META_PREFIX)) {\n                 metaData.addContentSelector(ContentSelectors.parse(FieldFactory.parseField(entry.getKey().substring(MetaData.SELECTOR_META_PREFIX.length())), StringUtil.unquote(entry.getValue(), MetaData.ESCAPE_CHARACTER)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + \"Latex-\")) {\n                 // The user name comes directly after \"FILE_DIRECTORYLatex-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 6);\n                 Path path = Path.of(getSingleItem(value)).normalize();\n                 metaData.setLatexFileDirectory(user, path);\n-                continue;\n-            }\n-\n-            switch (entry.getKey()) {\n-                case MetaData.GROUPSTREE:\n-                case MetaData.GROUPSTREE_LEGACY:\n-                    metaData.setGroups(GroupsParser.importGroups(value, keywordSeparator, fileMonitor, metaData));\n-                    break;\n-                case MetaData.SAVE_ACTIONS:\n-                    metaData.setSaveActions(Cleanups.parse(value));\n-                    break;\n-                case MetaData.DATABASE_TYPE:\n-                    metaData.setMode(BibDatabaseMode.parse(getSingleItem(value)));\n-                    break;\n-                case MetaData.KEYPATTERNDEFAULT:\n-                    defaultCiteKeyPattern = Collections.singletonList(getSingleItem(value));\n-                    break;\n-                case MetaData.PROTECTED_FLAG_META:\n-                    if (Boolean.parseBoolean(getSingleItem(value))) {\n-                        metaData.markAsProtected();\n-                    } else {\n-                        metaData.markAsNotProtected();\n-                    }\n-                    break;\n-                case MetaData.FILE_DIRECTORY:\n-                    metaData.setDefaultFileDirectory(getSingleItem(value));\n-                    break;\n-                case MetaData.SAVE_ORDER_CONFIG:\n-                    metaData.setSaveOrderConfig(SaveOrderConfig.parse(value));\n-                    break;\n-                default:\n-                    // Keep meta data items that we do not know in the file\n-                    metaData.putUnknownMetaDataItem(entry.getKey(), value);\n+            } else if (entry.getKey().equals(MetaData.SAVE_ACTIONS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk1NzQ1Ng==", "bodyText": "In the concrete case here, it is always checked for entry.getKey(). Please check the diff:\n\nThe wrong order was at that diff - completely unrelated to my proposal!", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440957456", "createdAt": "2020-06-16T15:48:51Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +50,63 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        List<Map.Entry<String, String>> entryList = new ArrayList<>(data.entrySet());\n+        entryList.sort(groupsLast());\n+\n+        for (Map.Entry<String, String> entry : entryList) {\n             List<String> value = getAsList(entry.getValue());\n \n             if (entry.getKey().startsWith(MetaData.PREFIX_KEYPATTERN)) {\n                 EntryType entryType = EntryTypeFactory.parse(entry.getKey().substring(MetaData.PREFIX_KEYPATTERN.length()));\n                 nonDefaultCiteKeyPatterns.put(entryType, Collections.singletonList(getSingleItem(value)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + '-')) {\n                 // The user name comes directly after \"FILE_DIRECTORY-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 1);\n                 metaData.setUserFileDirectory(user, getSingleItem(value));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.SELECTOR_META_PREFIX)) {\n                 metaData.addContentSelector(ContentSelectors.parse(FieldFactory.parseField(entry.getKey().substring(MetaData.SELECTOR_META_PREFIX.length())), StringUtil.unquote(entry.getValue(), MetaData.ESCAPE_CHARACTER)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + \"Latex-\")) {\n                 // The user name comes directly after \"FILE_DIRECTORYLatex-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 6);\n                 Path path = Path.of(getSingleItem(value)).normalize();\n                 metaData.setLatexFileDirectory(user, path);\n-                continue;\n-            }\n-\n-            switch (entry.getKey()) {\n-                case MetaData.GROUPSTREE:\n-                case MetaData.GROUPSTREE_LEGACY:\n-                    metaData.setGroups(GroupsParser.importGroups(value, keywordSeparator, fileMonitor, metaData));\n-                    break;\n-                case MetaData.SAVE_ACTIONS:\n-                    metaData.setSaveActions(Cleanups.parse(value));\n-                    break;\n-                case MetaData.DATABASE_TYPE:\n-                    metaData.setMode(BibDatabaseMode.parse(getSingleItem(value)));\n-                    break;\n-                case MetaData.KEYPATTERNDEFAULT:\n-                    defaultCiteKeyPattern = Collections.singletonList(getSingleItem(value));\n-                    break;\n-                case MetaData.PROTECTED_FLAG_META:\n-                    if (Boolean.parseBoolean(getSingleItem(value))) {\n-                        metaData.markAsProtected();\n-                    } else {\n-                        metaData.markAsNotProtected();\n-                    }\n-                    break;\n-                case MetaData.FILE_DIRECTORY:\n-                    metaData.setDefaultFileDirectory(getSingleItem(value));\n-                    break;\n-                case MetaData.SAVE_ORDER_CONFIG:\n-                    metaData.setSaveOrderConfig(SaveOrderConfig.parse(value));\n-                    break;\n-                default:\n-                    // Keep meta data items that we do not know in the file\n-                    metaData.putUnknownMetaDataItem(entry.getKey(), value);\n+            } else if (entry.getKey().equals(MetaData.SAVE_ACTIONS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU2OTgxNw==", "bodyText": "Yes, the switch statement could be reintroduced (and simplified). Before this fix, the code was structured really confusing and looked error-prone. So I decided to create this consistent and simplified version, which I find quite acceptable.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r441569817", "createdAt": "2020-06-17T14:02:43Z", "author": {"login": "systemoperator"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +50,63 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        List<Map.Entry<String, String>> entryList = new ArrayList<>(data.entrySet());\n+        entryList.sort(groupsLast());\n+\n+        for (Map.Entry<String, String> entry : entryList) {\n             List<String> value = getAsList(entry.getValue());\n \n             if (entry.getKey().startsWith(MetaData.PREFIX_KEYPATTERN)) {\n                 EntryType entryType = EntryTypeFactory.parse(entry.getKey().substring(MetaData.PREFIX_KEYPATTERN.length()));\n                 nonDefaultCiteKeyPatterns.put(entryType, Collections.singletonList(getSingleItem(value)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + '-')) {\n                 // The user name comes directly after \"FILE_DIRECTORY-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 1);\n                 metaData.setUserFileDirectory(user, getSingleItem(value));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.SELECTOR_META_PREFIX)) {\n                 metaData.addContentSelector(ContentSelectors.parse(FieldFactory.parseField(entry.getKey().substring(MetaData.SELECTOR_META_PREFIX.length())), StringUtil.unquote(entry.getValue(), MetaData.ESCAPE_CHARACTER)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + \"Latex-\")) {\n                 // The user name comes directly after \"FILE_DIRECTORYLatex-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 6);\n                 Path path = Path.of(getSingleItem(value)).normalize();\n                 metaData.setLatexFileDirectory(user, path);\n-                continue;\n-            }\n-\n-            switch (entry.getKey()) {\n-                case MetaData.GROUPSTREE:\n-                case MetaData.GROUPSTREE_LEGACY:\n-                    metaData.setGroups(GroupsParser.importGroups(value, keywordSeparator, fileMonitor, metaData));\n-                    break;\n-                case MetaData.SAVE_ACTIONS:\n-                    metaData.setSaveActions(Cleanups.parse(value));\n-                    break;\n-                case MetaData.DATABASE_TYPE:\n-                    metaData.setMode(BibDatabaseMode.parse(getSingleItem(value)));\n-                    break;\n-                case MetaData.KEYPATTERNDEFAULT:\n-                    defaultCiteKeyPattern = Collections.singletonList(getSingleItem(value));\n-                    break;\n-                case MetaData.PROTECTED_FLAG_META:\n-                    if (Boolean.parseBoolean(getSingleItem(value))) {\n-                        metaData.markAsProtected();\n-                    } else {\n-                        metaData.markAsNotProtected();\n-                    }\n-                    break;\n-                case MetaData.FILE_DIRECTORY:\n-                    metaData.setDefaultFileDirectory(getSingleItem(value));\n-                    break;\n-                case MetaData.SAVE_ORDER_CONFIG:\n-                    metaData.setSaveOrderConfig(SaveOrderConfig.parse(value));\n-                    break;\n-                default:\n-                    // Keep meta data items that we do not know in the file\n-                    metaData.putUnknownMetaDataItem(entry.getKey(), value);\n+            } else if (entry.getKey().equals(MetaData.SAVE_ACTIONS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4NDQ1Nw==", "bodyText": "I meant only for the lower part; not with the xxxx continue statements. Just for the endless chain of else if (entry.getKey().equeals(MetaData.X)) chains, where only X is different from the checks.\nThere is ALWAYS entry.getKey() compared from line 75 to line 92 (or did I see something wrong?).\nThis is just a matter of taste. Maybe, I'll just do it and open another PR to have the discussions there. Should not be a show stopper for us now.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r441784457", "createdAt": "2020-06-17T19:31:13Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +50,63 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        List<Map.Entry<String, String>> entryList = new ArrayList<>(data.entrySet());\n+        entryList.sort(groupsLast());\n+\n+        for (Map.Entry<String, String> entry : entryList) {\n             List<String> value = getAsList(entry.getValue());\n \n             if (entry.getKey().startsWith(MetaData.PREFIX_KEYPATTERN)) {\n                 EntryType entryType = EntryTypeFactory.parse(entry.getKey().substring(MetaData.PREFIX_KEYPATTERN.length()));\n                 nonDefaultCiteKeyPatterns.put(entryType, Collections.singletonList(getSingleItem(value)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + '-')) {\n                 // The user name comes directly after \"FILE_DIRECTORY-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 1);\n                 metaData.setUserFileDirectory(user, getSingleItem(value));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.SELECTOR_META_PREFIX)) {\n                 metaData.addContentSelector(ContentSelectors.parse(FieldFactory.parseField(entry.getKey().substring(MetaData.SELECTOR_META_PREFIX.length())), StringUtil.unquote(entry.getValue(), MetaData.ESCAPE_CHARACTER)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + \"Latex-\")) {\n                 // The user name comes directly after \"FILE_DIRECTORYLatex-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 6);\n                 Path path = Path.of(getSingleItem(value)).normalize();\n                 metaData.setLatexFileDirectory(user, path);\n-                continue;\n-            }\n-\n-            switch (entry.getKey()) {\n-                case MetaData.GROUPSTREE:\n-                case MetaData.GROUPSTREE_LEGACY:\n-                    metaData.setGroups(GroupsParser.importGroups(value, keywordSeparator, fileMonitor, metaData));\n-                    break;\n-                case MetaData.SAVE_ACTIONS:\n-                    metaData.setSaveActions(Cleanups.parse(value));\n-                    break;\n-                case MetaData.DATABASE_TYPE:\n-                    metaData.setMode(BibDatabaseMode.parse(getSingleItem(value)));\n-                    break;\n-                case MetaData.KEYPATTERNDEFAULT:\n-                    defaultCiteKeyPattern = Collections.singletonList(getSingleItem(value));\n-                    break;\n-                case MetaData.PROTECTED_FLAG_META:\n-                    if (Boolean.parseBoolean(getSingleItem(value))) {\n-                        metaData.markAsProtected();\n-                    } else {\n-                        metaData.markAsNotProtected();\n-                    }\n-                    break;\n-                case MetaData.FILE_DIRECTORY:\n-                    metaData.setDefaultFileDirectory(getSingleItem(value));\n-                    break;\n-                case MetaData.SAVE_ORDER_CONFIG:\n-                    metaData.setSaveOrderConfig(SaveOrderConfig.parse(value));\n-                    break;\n-                default:\n-                    // Keep meta data items that we do not know in the file\n-                    metaData.putUnknownMetaDataItem(entry.getKey(), value);\n+            } else if (entry.getKey().equals(MetaData.SAVE_ACTIONS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzA0MTkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo1ODozN1rOGkfiXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo1ODozN1rOGkfiXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxODYyMg==", "bodyText": "Can we put this directly after line 225?\nI simplified it. Furthermore calling .isEmpty in an Optional felles wrong. I propose following code:\nPath texFilePath = preferencesService.getWorkingDir().resolve(input);\nif (!Files.isRegularFile(texFilePath)) {\n  return false;\n}\nreturn FileUtil.getFileExtension(input)\n  .map(extension -> extension.toLowerCase().equals(\"aux\"))\n  .orElse(false);", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440918622", "createdAt": "2020-06-16T14:58:37Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,25 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isBlank(input)) {\n+                        return false;\n+                    } else {\n+                        Path texFilePath = preferencesService.getWorkingDir().resolve(input);\n+                        Optional<String> fileExtension = FileUtil.getFileExtension(input);\n+                        if (fileExtension.isEmpty() || !fileExtension.get().toLowerCase().equals(\"aux\")) {\n+                            return false;\n+                        } else if (!Files.isRegularFile(texFilePath)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjM5NjY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTozMzoxMVrOGlUc0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTozMzoxMVrOGlUc0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4NTU1NQ==", "bodyText": "@stefan-kolb Would review here: \"Fail fast\". Not endless nested if/else statements, but just exit early.\nTherefore, I proposed:\nif (StringUtil.isBlank(input)) {\n  return false;\n}\nThink, I will start another PR with this and the other code style thing and we can have the discussion there --> we need to get this fix in soon.", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r441785555", "createdAt": "2020-06-17T19:33:11Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,24 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isBlank(input)) {\n+                        return false;\n+                    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3548a1a4e8fce657681336108a6035a767ee68"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1747, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}