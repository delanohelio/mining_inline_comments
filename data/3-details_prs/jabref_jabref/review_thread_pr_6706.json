{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1ODI2MDcx", "number": 6706, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo0MDozN1rOERh47Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQyMDozNzo1NlrOEldMJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODE2NDkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo0MDozN1rOG2SxBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODoxODo0MFrOG2WPXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4Mzc0OA==", "bodyText": "Can probably be a list instead of an array", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r459583748", "createdAt": "2020-07-23T16:40:37Z", "author": {"login": "Siedlerchr"}, "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "diffHunk": "@@ -707,102 +707,97 @@ public static String lastAuthorForenameInitials(String authorField) {\n     /**\n      * Gets the last name of all authors/editors\n      *\n-     * @param authorField a <code>String</code>\n+     * @param authorList an {@link AuthorList}\n      * @return the sur name of all authors/editors\n      */\n-    public static String allAuthors(String authorField) {\n-        // Quick hack to use NAuthors to avoid code duplication\n-        return nAuthors(authorField, Integer.MAX_VALUE);\n+    public static String allAuthors(AuthorList authorList) {\n+        return joinAuthorsOnLastName(authorList, authorList.getNumberOfAuthors(), \"\", \"\");\n     }\n \n     /**\n      * Returns the authors according to the BibTeX-alpha-Style\n      *\n-     * @param authorField string containing the value of the author field\n-     * @return the initials of all authornames\n+     * @param authorList an {@link AuthorList}\n+     * @return the initials of all authors' names\n      */\n-    public static String authorsAlpha(String authorField) {\n-        String authors = \"\";\n+    public static String authorsAlpha(AuthorList authorList) {\n+        StringBuilder authors = new StringBuilder();\n \n-        String fixedAuthors = AuthorList.fixAuthorLastNameOnlyCommas(authorField, false);\n+        String[] tokens = authorList.getAuthors().stream().map(Author::getLastOnly).toArray(String[]::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53f705c6711e1d5cfd9c11efde6b5adaa07c878f"}, "originalPosition": 469}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MDY2OA==", "bodyText": "Good point. I tried adding what is hopefully some readability improvements as well.", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r459640668", "createdAt": "2020-07-23T18:18:40Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "diffHunk": "@@ -707,102 +707,97 @@ public static String lastAuthorForenameInitials(String authorField) {\n     /**\n      * Gets the last name of all authors/editors\n      *\n-     * @param authorField a <code>String</code>\n+     * @param authorList an {@link AuthorList}\n      * @return the sur name of all authors/editors\n      */\n-    public static String allAuthors(String authorField) {\n-        // Quick hack to use NAuthors to avoid code duplication\n-        return nAuthors(authorField, Integer.MAX_VALUE);\n+    public static String allAuthors(AuthorList authorList) {\n+        return joinAuthorsOnLastName(authorList, authorList.getNumberOfAuthors(), \"\", \"\");\n     }\n \n     /**\n      * Returns the authors according to the BibTeX-alpha-Style\n      *\n-     * @param authorField string containing the value of the author field\n-     * @return the initials of all authornames\n+     * @param authorList an {@link AuthorList}\n+     * @return the initials of all authors' names\n      */\n-    public static String authorsAlpha(String authorField) {\n-        String authors = \"\";\n+    public static String authorsAlpha(AuthorList authorList) {\n+        StringBuilder authors = new StringBuilder();\n \n-        String fixedAuthors = AuthorList.fixAuthorLastNameOnlyCommas(authorField, false);\n+        String[] tokens = authorList.getAuthors().stream().map(Author::getLastOnly).toArray(String[]::new);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4Mzc0OA=="}, "originalCommit": {"oid": "53f705c6711e1d5cfd9c11efde6b5adaa07c878f"}, "originalPosition": 469}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzQzMDI2OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/citationkeypattern/CitationKeyGeneratorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToxMTowOVrOHCm07w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTozMzo0NVrOHCnelQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5NTM0Mw==", "bodyText": "Is there a missing bracket at the end?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(2, generateKey(bibEntry, \"[auth:truncate2\").length());\n          \n          \n            \n                    assertEquals(2, generateKey(bibEntry, \"[auth:truncate2]\").length());", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r472495343", "createdAt": "2020-08-18T21:11:09Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/citationkeypattern/CitationKeyGeneratorTest.java", "diffHunk": "@@ -1094,4 +1094,20 @@ void generateKeyWithWithFirstNCharacters() {\n \n         assertEquals(\"newt-2019\", generateKey(entry, \"[auth4:lower]-[year]\"));\n     }\n+\n+    @Test\n+    void generateKeyCorrectKeyLengthWithTruncateModifierAndUnicode() {\n+        BibEntry bibEntry = new BibEntry();\n+        bibEntry.setField(StandardField.AUTHOR, \"G\u00f6del, Kurt\");\n+\n+        assertEquals(2, generateKey(bibEntry, \"[auth:truncate2\").length());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "715364d1662c4ed5441fa45b4292be96e660fd58"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwNjAwNQ==", "bodyText": "There is indeed. Should the missing bracket generate an error or should I leave it alone?", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r472506005", "createdAt": "2020-08-18T21:33:45Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/test/java/org/jabref/logic/citationkeypattern/CitationKeyGeneratorTest.java", "diffHunk": "@@ -1094,4 +1094,20 @@ void generateKeyWithWithFirstNCharacters() {\n \n         assertEquals(\"newt-2019\", generateKey(entry, \"[auth4:lower]-[year]\"));\n     }\n+\n+    @Test\n+    void generateKeyCorrectKeyLengthWithTruncateModifierAndUnicode() {\n+        BibEntry bibEntry = new BibEntry();\n+        bibEntry.setField(StandardField.AUTHOR, \"G\u00f6del, Kurt\");\n+\n+        assertEquals(2, generateKey(bibEntry, \"[auth:truncate2\").length());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5NTM0Mw=="}, "originalCommit": {"oid": "715364d1662c4ed5441fa45b4292be96e660fd58"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTg3MDUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzo1MTo0NFrOHIbFnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDoyNjo0OFrOHIgEcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NDQ2MA==", "bodyText": "Can you add a comment why the number 4 is chosen. Maybe also what the constant means? Is it the maximum number of authors used when expanded something? Maybe, it's a dumb question, because I am looking at the diff only.", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r478594460", "createdAt": "2020-08-27T17:51:44Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "diffHunk": "@@ -44,6 +45,7 @@\n     private static final Logger LOGGER = LoggerFactory.getLogger(BracketedPattern.class);\n \n     private static final int CHARS_OF_FIRST = 5;\n+    private static final int MAX_ALPHA_AUTHORS = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cac2dbe4c36ba7ea5d6ad1ddb0bcde9aceb8724"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NjA4MA==", "bodyText": "I will look into it! I am sure having the comment will make someone's life easier in the future so it should be there in either case, I just weren't paying enough attention.", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r478676080", "createdAt": "2020-08-27T20:26:48Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "diffHunk": "@@ -44,6 +45,7 @@\n     private static final Logger LOGGER = LoggerFactory.getLogger(BracketedPattern.class);\n \n     private static final int CHARS_OF_FIRST = 5;\n+    private static final int MAX_ALPHA_AUTHORS = 4;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NDQ2MA=="}, "originalCommit": {"oid": "9cac2dbe4c36ba7ea5d6ad1ddb0bcde9aceb8724"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjMyNTcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDowODowNlrOHIffVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTo1MDo0MFrOHKKctg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2NjU4MQ==", "bodyText": "A reformat of the file should add an empty line before, shouldn't it?", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r478666581", "createdAt": "2020-08-27T20:08:06Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "diffHunk": "@@ -420,14 +396,50 @@ public static String getFieldValue(BibEntry entry, String value, Character keywo\n                 return sb.toString();\n             } else {\n                 // we haven't seen any special demands\n-                return entry.getResolvedFieldOrAlias(FieldFactory.parseField(val), database).orElse(\"\");\n+                return entry.getResolvedFieldOrAlias(FieldFactory.parseField(pattern), database).orElse(\"\");\n             }\n         } catch (NullPointerException ex) {\n             LOGGER.debug(\"Problem making expanding bracketed expression\", ex);\n             return \"\";\n         }\n     }\n \n+    /**\n+     * Parses the provided string to an {@link AuthorList}, which are then formatted by {@link LatexToUnicodeAdapter}.\n+     * Afterward, any institutions are formatted into an institution key.\n+     * @param unparsedAuthors a string representation of authors or editors\n+     * @return an {@link AuthorList} consisting of authors and institution keys with resolved latex.\n+     */\n+    private static AuthorList createAuthorList(String unparsedAuthors) {\n+        AuthorList authorList = new AuthorList();\n+        for (Author author : AuthorList.parse(unparsedAuthors).getAuthors()) {\n+            // If the author is an institution, use an institution key instead of the full name\n+            String lastName = author.getLast()\n+                                    .map(LatexToUnicodeAdapter::format)\n+                                    .map(isInstitution(author) ?\n+                                            BracketedPattern::generateInstitutionKey : Function.identity())\n+                                    .orElse(null);\n+            authorList.addAuthor(\n+                    author.getFirst().map(LatexToUnicodeAdapter::format).orElse(null),\n+                    author.getFirstAbbr().map(LatexToUnicodeAdapter::format).orElse(null),\n+                    author.getVon().map(LatexToUnicodeAdapter::format).orElse(null),\n+                    lastName,\n+                    author.getJr().map(LatexToUnicodeAdapter::format).orElse(null)\n+            );\n+        }\n+        return authorList;\n+    }\n+\n+    /**\n+     * Checks if an author is an institution by verifying that only the last name is present.\n+     * @param author the checked author", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cac2dbe4c36ba7ea5d6ad1ddb0bcde9aceb8724"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxODk5OA==", "bodyText": "Yes. I had not reformatted the file. I have now done so and tried to address the points where the reformatting is wrong (e.g., use ordered/unordered lists where appropriate instead of the auto-generated <p>). I tried fixing some of the additional warnings the file were giving as well.", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r480418998", "createdAt": "2020-08-31T21:50:40Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "diffHunk": "@@ -420,14 +396,50 @@ public static String getFieldValue(BibEntry entry, String value, Character keywo\n                 return sb.toString();\n             } else {\n                 // we haven't seen any special demands\n-                return entry.getResolvedFieldOrAlias(FieldFactory.parseField(val), database).orElse(\"\");\n+                return entry.getResolvedFieldOrAlias(FieldFactory.parseField(pattern), database).orElse(\"\");\n             }\n         } catch (NullPointerException ex) {\n             LOGGER.debug(\"Problem making expanding bracketed expression\", ex);\n             return \"\";\n         }\n     }\n \n+    /**\n+     * Parses the provided string to an {@link AuthorList}, which are then formatted by {@link LatexToUnicodeAdapter}.\n+     * Afterward, any institutions are formatted into an institution key.\n+     * @param unparsedAuthors a string representation of authors or editors\n+     * @return an {@link AuthorList} consisting of authors and institution keys with resolved latex.\n+     */\n+    private static AuthorList createAuthorList(String unparsedAuthors) {\n+        AuthorList authorList = new AuthorList();\n+        for (Author author : AuthorList.parse(unparsedAuthors).getAuthors()) {\n+            // If the author is an institution, use an institution key instead of the full name\n+            String lastName = author.getLast()\n+                                    .map(LatexToUnicodeAdapter::format)\n+                                    .map(isInstitution(author) ?\n+                                            BracketedPattern::generateInstitutionKey : Function.identity())\n+                                    .orElse(null);\n+            authorList.addAuthor(\n+                    author.getFirst().map(LatexToUnicodeAdapter::format).orElse(null),\n+                    author.getFirstAbbr().map(LatexToUnicodeAdapter::format).orElse(null),\n+                    author.getVon().map(LatexToUnicodeAdapter::format).orElse(null),\n+                    lastName,\n+                    author.getJr().map(LatexToUnicodeAdapter::format).orElse(null)\n+            );\n+        }\n+        return authorList;\n+    }\n+\n+    /**\n+     * Checks if an author is an institution by verifying that only the last name is present.\n+     * @param author the checked author", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2NjU4MQ=="}, "originalCommit": {"oid": "9cac2dbe4c36ba7ea5d6ad1ddb0bcde9aceb8724"}, "originalPosition": 341}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjM0MTY0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/citationkeypattern/CitationKeyGeneratorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDoxMjo0NVrOHIfpIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDoxMjo0NVrOHIfpIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2OTA4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BibEntry bibEntry = new BibEntry();\n          \n          \n            \n                    bibEntry.setField(StandardField.AUTHOR, author);\n          \n          \n            \n                    return new BibEntry()\n          \n          \n            \n                      .withField(StandardField.AUTHOR, author);", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r478669089", "createdAt": "2020-08-27T20:12:45Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/citationkeypattern/CitationKeyGeneratorTest.java", "diffHunk": "@@ -54,6 +72,12 @@ void setUp() {\n         importFormatPreferences = mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS);\n     }\n \n+    private static BibEntry createABibEntryAuthor(String author) {\n+        BibEntry bibEntry = new BibEntry();\n+        bibEntry.setField(StandardField.AUTHOR, author);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cac2dbe4c36ba7ea5d6ad1ddb0bcde9aceb8724"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NzEwOTg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQyMDozNzozNlrOHU87Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQyMDozNzozNlrOHU87Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTczMTc0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.warn(\"Missing closing bracket ']' in '\" + pattern + \"'\");\n          \n          \n            \n                        LOGGER.warn(\"Missing closing bracket ']' in '{}'\", pattern);", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r491731742", "createdAt": "2020-09-20T20:37:36Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "diffHunk": "@@ -150,229 +172,231 @@ public String expand(BibEntry bibentry, Character keywordDelimiter, BibDatabase\n     public static String expandBrackets(String pattern, Character keywordDelimiter, BibEntry entry, BibDatabase database) {\n         Objects.requireNonNull(pattern);\n         Objects.requireNonNull(entry);\n-        StringBuilder sb = new StringBuilder();\n-        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\\\"\", true);\n-\n-        while (st.hasMoreTokens()) {\n-            String token = st.nextToken();\n-            if (\"\\\"\".equals(token)) {\n-                sb.append(token);\n-                while (st.hasMoreTokens()) {\n-                    token = st.nextToken();\n-                    sb.append(token);\n-                    if (\"\\\"\".equals(token)) {\n-                        break;\n+        StringBuilder expandedPattern = new StringBuilder();\n+        StringTokenizer parsedPattern = new StringTokenizer(pattern, \"\\\\[]\\\"\", true);\n+\n+        while (parsedPattern.hasMoreTokens()) {\n+            String token = parsedPattern.nextToken();\n+            switch (token) {\n+                case \"\\\"\" -> appendQuote(expandedPattern, parsedPattern);\n+                case \"[\" -> {\n+                    String fieldMarker = contentBetweenBrackets(parsedPattern, pattern);\n+\n+                    List<String> fieldParts = parseFieldMarker(fieldMarker);\n+                    // check whether there is a modifier on the end such as\n+                    // \":lower\":\n+                    if (fieldParts.size() <= 1) {\n+                        expandedPattern.append(getFieldValue(entry, fieldMarker, keywordDelimiter, database));\n+                    } else {\n+                        // apply modifiers:\n+                        String fieldValue = getFieldValue(entry, fieldParts.get(0), keywordDelimiter, database);\n+                        expandedPattern.append(applyModifiers(fieldValue, fieldParts, 1));\n                     }\n                 }\n-            } else {\n-                if (\"\\\\\".equals(token)) {\n-                    if (st.hasMoreTokens()) {\n-                        sb.append(st.nextToken());\n+                case \"\\\\\" -> {\n+                    if (parsedPattern.hasMoreTokens()) {\n+                        expandedPattern.append(parsedPattern.nextToken());\n                     }\n                     // FIXME: else -> raise exception or log? (S.G.)\n-                } else {\n-                    if (\"[\".equals(token)) {\n-                        Boolean foundClosingBracket = false;\n-                        // Fetch the next token after the '[':\n-                        token = st.nextToken();\n-                        if (\"]\".equals(token)) {\n-                            LOGGER.warn(\"Found empty brackets \\\"[]\\\" in '\" + pattern + \"'\");\n-                            foundClosingBracket = true;\n-                        }\n-                        // make sure to read until the next ']'\n-                        while (st.hasMoreTokens() && !foundClosingBracket) {\n-                            String subtoken = st.nextToken();\n-                            // I the beginning of a quote is found, include the content in the original token\n-                            if (\"\\\"\".equals(subtoken)) {\n-                                token = token + subtoken;\n-                                while (st.hasMoreTokens()) {\n-                                    subtoken = st.nextToken();\n-                                    token = token + subtoken;\n-                                    if (\"\\\"\".equals(subtoken)) {\n-                                        break;\n-                                    }\n-                                }\n-                            } else {\n-                                if (\"]\".equals(subtoken)) {\n-                                    foundClosingBracket = true;\n-                                    break;\n-                                } else {\n-                                    token = token + subtoken;\n-                                }\n-                            }\n-                        }\n-                        if (!foundClosingBracket) {\n-                            LOGGER.warn(\"Missing closing bracket ']' in '\" + pattern + \"'\");\n-                        }\n-                        List<String> fieldParts = parseFieldMarker(token);\n-                        // check whether there is a modifier on the end such as\n-                        // \":lower\":\n-                        if (fieldParts.size() <= 1) {\n-                            sb.append(getFieldValue(entry, token, keywordDelimiter, database));\n-                        } else {\n-                            // apply modifiers:\n-                            String fieldValue = getFieldValue(entry, fieldParts.get(0), keywordDelimiter, database);\n-                            sb.append(applyModifiers(fieldValue, fieldParts, 1));\n-                        }\n-                    } else {\n-                        sb.append(token);\n-                    }\n                 }\n+                default -> expandedPattern.append(token);\n             }\n         }\n \n-        return sb.toString();\n+        return expandedPattern.toString();\n     }\n \n     /**\n-     * Evaluates the given pattern (\"value\") to the given bibentry and database\n+     * Returns the content enclosed between brackets, including enclosed quotes, and excluding the enclosing brackets.\n+     * Intended to be used by {@link BracketedPattern#expandBrackets(String, Character, BibEntry, BibDatabase)} when a [\n+     * is encountered, and has been consumed, by the {@code StringTokenizer}.\n+     *\n+     * @param pattern   pattern used by {@code expandBrackets}, used for logging\n+     * @param tokenizer the tokenizer producing the tokens\n+     * @return the content enclosed by brackets\n+     */\n+    private static String contentBetweenBrackets(StringTokenizer tokenizer, final String pattern) {\n+        StringBuilder bracketContent = new StringBuilder();\n+        boolean foundClosingBracket = false;\n+        // make sure to read until the next ']'\n+        while (tokenizer.hasMoreTokens() && !foundClosingBracket) {\n+            String token = tokenizer.nextToken();\n+            // If the beginning of a quote is found, append the content\n+            switch (token) {\n+                case \"\\\"\" -> appendQuote(bracketContent, tokenizer);\n+                case \"]\" -> foundClosingBracket = true;\n+                default -> bracketContent.append(token);\n+            }\n+        }\n+\n+        if (!foundClosingBracket) {\n+            LOGGER.warn(\"Missing closing bracket ']' in '\" + pattern + \"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c73301ff51b784cbc331e0dacd4046a44ac75c3"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NzExMDE0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQyMDozNzo1NlrOHU87Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQyMDozNzo1NlrOHU87Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTczMTc3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.warn(\"Found empty brackets \\\"[]\\\" in '\" + pattern + \"'\");\n          \n          \n            \n                        LOGGER.warn(\"Found empty brackets \\\"[]\\\" in '{}'\", pattern);", "url": "https://github.com/JabRef/jabref/pull/6706#discussion_r491731775", "createdAt": "2020-09-20T20:37:56Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/citationkeypattern/BracketedPattern.java", "diffHunk": "@@ -150,229 +172,231 @@ public String expand(BibEntry bibentry, Character keywordDelimiter, BibDatabase\n     public static String expandBrackets(String pattern, Character keywordDelimiter, BibEntry entry, BibDatabase database) {\n         Objects.requireNonNull(pattern);\n         Objects.requireNonNull(entry);\n-        StringBuilder sb = new StringBuilder();\n-        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\\\"\", true);\n-\n-        while (st.hasMoreTokens()) {\n-            String token = st.nextToken();\n-            if (\"\\\"\".equals(token)) {\n-                sb.append(token);\n-                while (st.hasMoreTokens()) {\n-                    token = st.nextToken();\n-                    sb.append(token);\n-                    if (\"\\\"\".equals(token)) {\n-                        break;\n+        StringBuilder expandedPattern = new StringBuilder();\n+        StringTokenizer parsedPattern = new StringTokenizer(pattern, \"\\\\[]\\\"\", true);\n+\n+        while (parsedPattern.hasMoreTokens()) {\n+            String token = parsedPattern.nextToken();\n+            switch (token) {\n+                case \"\\\"\" -> appendQuote(expandedPattern, parsedPattern);\n+                case \"[\" -> {\n+                    String fieldMarker = contentBetweenBrackets(parsedPattern, pattern);\n+\n+                    List<String> fieldParts = parseFieldMarker(fieldMarker);\n+                    // check whether there is a modifier on the end such as\n+                    // \":lower\":\n+                    if (fieldParts.size() <= 1) {\n+                        expandedPattern.append(getFieldValue(entry, fieldMarker, keywordDelimiter, database));\n+                    } else {\n+                        // apply modifiers:\n+                        String fieldValue = getFieldValue(entry, fieldParts.get(0), keywordDelimiter, database);\n+                        expandedPattern.append(applyModifiers(fieldValue, fieldParts, 1));\n                     }\n                 }\n-            } else {\n-                if (\"\\\\\".equals(token)) {\n-                    if (st.hasMoreTokens()) {\n-                        sb.append(st.nextToken());\n+                case \"\\\\\" -> {\n+                    if (parsedPattern.hasMoreTokens()) {\n+                        expandedPattern.append(parsedPattern.nextToken());\n                     }\n                     // FIXME: else -> raise exception or log? (S.G.)\n-                } else {\n-                    if (\"[\".equals(token)) {\n-                        Boolean foundClosingBracket = false;\n-                        // Fetch the next token after the '[':\n-                        token = st.nextToken();\n-                        if (\"]\".equals(token)) {\n-                            LOGGER.warn(\"Found empty brackets \\\"[]\\\" in '\" + pattern + \"'\");\n-                            foundClosingBracket = true;\n-                        }\n-                        // make sure to read until the next ']'\n-                        while (st.hasMoreTokens() && !foundClosingBracket) {\n-                            String subtoken = st.nextToken();\n-                            // I the beginning of a quote is found, include the content in the original token\n-                            if (\"\\\"\".equals(subtoken)) {\n-                                token = token + subtoken;\n-                                while (st.hasMoreTokens()) {\n-                                    subtoken = st.nextToken();\n-                                    token = token + subtoken;\n-                                    if (\"\\\"\".equals(subtoken)) {\n-                                        break;\n-                                    }\n-                                }\n-                            } else {\n-                                if (\"]\".equals(subtoken)) {\n-                                    foundClosingBracket = true;\n-                                    break;\n-                                } else {\n-                                    token = token + subtoken;\n-                                }\n-                            }\n-                        }\n-                        if (!foundClosingBracket) {\n-                            LOGGER.warn(\"Missing closing bracket ']' in '\" + pattern + \"'\");\n-                        }\n-                        List<String> fieldParts = parseFieldMarker(token);\n-                        // check whether there is a modifier on the end such as\n-                        // \":lower\":\n-                        if (fieldParts.size() <= 1) {\n-                            sb.append(getFieldValue(entry, token, keywordDelimiter, database));\n-                        } else {\n-                            // apply modifiers:\n-                            String fieldValue = getFieldValue(entry, fieldParts.get(0), keywordDelimiter, database);\n-                            sb.append(applyModifiers(fieldValue, fieldParts, 1));\n-                        }\n-                    } else {\n-                        sb.append(token);\n-                    }\n                 }\n+                default -> expandedPattern.append(token);\n             }\n         }\n \n-        return sb.toString();\n+        return expandedPattern.toString();\n     }\n \n     /**\n-     * Evaluates the given pattern (\"value\") to the given bibentry and database\n+     * Returns the content enclosed between brackets, including enclosed quotes, and excluding the enclosing brackets.\n+     * Intended to be used by {@link BracketedPattern#expandBrackets(String, Character, BibEntry, BibDatabase)} when a [\n+     * is encountered, and has been consumed, by the {@code StringTokenizer}.\n+     *\n+     * @param pattern   pattern used by {@code expandBrackets}, used for logging\n+     * @param tokenizer the tokenizer producing the tokens\n+     * @return the content enclosed by brackets\n+     */\n+    private static String contentBetweenBrackets(StringTokenizer tokenizer, final String pattern) {\n+        StringBuilder bracketContent = new StringBuilder();\n+        boolean foundClosingBracket = false;\n+        // make sure to read until the next ']'\n+        while (tokenizer.hasMoreTokens() && !foundClosingBracket) {\n+            String token = tokenizer.nextToken();\n+            // If the beginning of a quote is found, append the content\n+            switch (token) {\n+                case \"\\\"\" -> appendQuote(bracketContent, tokenizer);\n+                case \"]\" -> foundClosingBracket = true;\n+                default -> bracketContent.append(token);\n+            }\n+        }\n+\n+        if (!foundClosingBracket) {\n+            LOGGER.warn(\"Missing closing bracket ']' in '\" + pattern + \"'\");\n+        } else if (bracketContent.length() == 0) {\n+            LOGGER.warn(\"Found empty brackets \\\"[]\\\" in '\" + pattern + \"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c73301ff51b784cbc331e0dacd4046a44ac75c3"}, "originalPosition": 238}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1786, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}