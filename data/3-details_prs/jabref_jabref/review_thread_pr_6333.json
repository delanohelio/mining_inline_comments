{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2OTI2OTI3", "number": 6333, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjoyMToyOVrOD0lKvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozOTo1NlrOD1N5uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDYxNTAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjoyMToyOVrOGJlS2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDoxMDo0NVrOGKVtFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw==", "bodyText": "Why not directly initialize that HashMap in the field declaration?", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412701403", "createdAt": "2020-04-22T06:21:29Z", "author": {"login": "Siedlerchr"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjMwNQ==", "bodyText": "MAybe you did not see that the later code uses the BibtexDatabase from the constructor. We decided to put the code into check - and not into the constructor - to have a lean constructor and not have high CPU usage when initializing the checker, but at the first time an entry is checked.", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412712305", "createdAt": "2020-04-22T06:43:55Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxNzQxMg==", "bodyText": "This seems like premature optimization for me.", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412717412", "createdAt": "2020-04-22T06:53:31Z", "author": {"login": "Siedlerchr"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzNjI1MQ==", "bodyText": "Why are you caching the errors anyway? Also in case you are worrying about performance, why do you choose to implement a solution that has O(n^2) (with n = entries). Why not implement a O(n) solution (e.g. https://stackoverflow.com/a/31341963/873661) which you call in checkDatabase below?", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412936251", "createdAt": "2020-04-22T12:26:39Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyOTEwNA==", "bodyText": "See in line 30 that the method is called once per entry. Is is by design of the Checker interface that there is method for checking each entry. There is no method for checking a complete database. There is also no interface for a complete database.\nAt the first call, the result map is filled. At all subsequent calls do not fill the map and reuse it.\nWe are O(n+m) where n is the size of the database and m is the number of entries with DOIs.", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413229104", "createdAt": "2020-04-22T18:43:12Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NDU0OQ==", "bodyText": "To make the code more reable, I moved the call to the error check to the constructor. See fd7621d", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413494549", "createdAt": "2020-04-23T04:10:45Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDYxNzY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjo0NDozN1rOGJl-4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDoxMDo1OVrOGKVtXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjY3NQ==", "bodyText": "It is doi, not entry. However, doi cannot be used as the variable name is already bound.", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412712675", "createdAt": "2020-04-22T06:44:37Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();\n+\n+            ObservableList<BibEntry> bibEntries = database.getEntries();\n+            BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+            for (BibEntry bibEntry : bibEntries) {\n+                bibEntry.getDOI().ifPresent(doi ->\n+                        duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxNTg1Mg==", "bodyText": "@koppor Please have a close look. The second argument of duplicateMap.computeIfAbsent refers to the value and this clearly is of type  List.   So then maybe name it entries", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412715852", "createdAt": "2020-04-22T06:50:43Z", "author": {"login": "Siedlerchr"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();\n+\n+            ObservableList<BibEntry> bibEntries = database.getEntries();\n+            BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+            for (BibEntry bibEntry : bibEntries) {\n+                bibEntry.getDOI().ifPresent(doi ->\n+                        duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjY3NQ=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc2NjI3Nw==", "bodyText": "@Siedlerchr Please explain the JavaDoc to me. The Map is FROM doi TO list. https://www.geeksforgeeks.org/hashmap-computeifabsent-method-in-java-with-examples/ explains the computeIfAbsent.\nTo me, it reads, that the key is passed to Function<? super K, ? extends V> remappingFunction. The key is clearly (!) a DOI not a list. -- Am I wrong?", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412766277", "createdAt": "2020-04-22T08:09:34Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();\n+\n+            ObservableList<BibEntry> bibEntries = database.getEntries();\n+            BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+            for (BibEntry bibEntry : bibEntries) {\n+                bibEntry.getDOI().ifPresent(doi ->\n+                        duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjY3NQ=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NDYyMQ==", "bodyText": "To make the code more reable, I called the variable absentDoi. See 6f9b148", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413494621", "createdAt": "2020-04-23T04:10:59Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();\n+\n+            ObservableList<BibEntry> bibEntries = database.getEntries();\n+            BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+            for (BibEntry bibEntry : bibEntries) {\n+                bibEntry.getDOI().ifPresent(doi ->\n+                        duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjY3NQ=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NjEyMDUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/integrity/IntegrityCheck.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMjoxNjoxNFrOGJzNOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDoxMjo0OFrOGKVvpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyOTMzOA==", "bodyText": "To be honest, I don't see any advantage of this refactoring. Just makes the code more complex and harder to maintain in my opinion.\nIf you really feel like the original code needs a refactoring, then you create a list of all checkers that need to be run a) always, b) bibtex c)biblatex (still I would create these lists only in the checkdatabase method). This would get ride of the repeated check methods below. But to be honest, I don't think this yields a more readable code either.", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412929338", "createdAt": "2020-04-22T12:16:14Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/integrity/IntegrityCheck.java", "diffHunk": "@@ -32,9 +45,36 @@ public IntegrityCheck(BibDatabaseContext bibDatabaseContext,\n         this.journalAbbreviationRepository = Objects.requireNonNull(journalAbbreviationRepository);\n         this.enforceLegalKey = enforceLegalKey;\n         this.allowIntegerEdition = allowIntegerEdition;\n+        initCheckers(bibDatabaseContext, bibtexKeyPatternPreferences, journalAbbreviationRepository);\n     }\n \n-    public List<IntegrityMessage> checkDatabase() {\n+    private void initCheckers(BibDatabaseContext bibDatabaseContext, BibtexKeyPatternPreferences bibtexKeyPatternPreferences, JournalAbbreviationRepository journalAbbreviationRepository) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0MDkzNQ==", "bodyText": "We initialize the checkers once per database check - not once per entry check. In case of a 20k database, approx 100k less java objects in memory per quality check.\nWe ensured that each checker is stateless - thus, it can be reused for acroess entries.\nI agree with your proposal though.", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413340935", "createdAt": "2020-04-22T21:19:58Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/integrity/IntegrityCheck.java", "diffHunk": "@@ -32,9 +45,36 @@ public IntegrityCheck(BibDatabaseContext bibDatabaseContext,\n         this.journalAbbreviationRepository = Objects.requireNonNull(journalAbbreviationRepository);\n         this.enforceLegalKey = enforceLegalKey;\n         this.allowIntegerEdition = allowIntegerEdition;\n+        initCheckers(bibDatabaseContext, bibtexKeyPatternPreferences, journalAbbreviationRepository);\n     }\n \n-    public List<IntegrityMessage> checkDatabase() {\n+    private void initCheckers(BibDatabaseContext bibDatabaseContext, BibtexKeyPatternPreferences bibtexKeyPatternPreferences, JournalAbbreviationRepository journalAbbreviationRepository) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyOTMzOA=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NTIwNg==", "bodyText": "With your proposal, the code is much more reable. \ud83c\udf89 03dd2a0", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413495206", "createdAt": "2020-04-23T04:12:48Z", "author": {"login": "koppor"}, "path": "src/main/java/org/jabref/logic/integrity/IntegrityCheck.java", "diffHunk": "@@ -32,9 +45,36 @@ public IntegrityCheck(BibDatabaseContext bibDatabaseContext,\n         this.journalAbbreviationRepository = Objects.requireNonNull(journalAbbreviationRepository);\n         this.enforceLegalKey = enforceLegalKey;\n         this.allowIntegerEdition = allowIntegerEdition;\n+        initCheckers(bibDatabaseContext, bibtexKeyPatternPreferences, journalAbbreviationRepository);\n     }\n \n-    public List<IntegrityMessage> checkDatabase() {\n+    private void initCheckers(BibDatabaseContext bibDatabaseContext, BibtexKeyPatternPreferences bibtexKeyPatternPreferences, JournalAbbreviationRepository journalAbbreviationRepository) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyOTMzOA=="}, "originalCommit": {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTI2ODcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/integrity/Checker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNToyMVrOGKihYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNToyMVrOGKihYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNDU0Nw==", "bodyText": "Rename to EntryChecker?", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413704547", "createdAt": "2020-04-23T10:35:21Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/integrity/Checker.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.List;\n+\n+import org.jabref.model.entry.BibEntry;\n+\n+@FunctionalInterface\n+public interface Checker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c9e687a0f2181704ba08f0eff9edbabe17a6971"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTI3NjMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNzowNFrOGKilvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxODoxNTo0MlrOGK1rtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNTY2MQ==", "bodyText": "I think \"The same DOI is used...\" is better", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413705661", "createdAt": "2020-04-23T10:37:04Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements DatabaseChecker {\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibDatabase database) {\n+        ObservableList<BibEntry> bibEntries = database.getEntries();\n+        BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+        for (BibEntry bibEntry : bibEntries) {\n+            bibEntry.getDOI().ifPresent(doi ->\n+                    duplicateMap.computeIfAbsent(doi, absentDoi -> new ArrayList<>()).add(bibEntry));\n+        }\n+\n+        return duplicateMap.inverse().keySet().stream()\n+                           .filter(list -> list.size() > 1)\n+                           .flatMap(list -> list.stream())\n+                           .map(item -> new IntegrityMessage(Localization.lang(\"Unique DOI used in multiple entries\"), item, StandardField.DOI))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c9e687a0f2181704ba08f0eff9edbabe17a6971"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxODQ4NA==", "bodyText": "Just \"Same DOI...\" will do.", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r414018484", "createdAt": "2020-04-23T18:15:42Z", "author": {"login": "stefan-kolb"}, "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements DatabaseChecker {\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibDatabase database) {\n+        ObservableList<BibEntry> bibEntries = database.getEntries();\n+        BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+        for (BibEntry bibEntry : bibEntries) {\n+            bibEntry.getDOI().ifPresent(doi ->\n+                    duplicateMap.computeIfAbsent(doi, absentDoi -> new ArrayList<>()).add(bibEntry));\n+        }\n+\n+        return duplicateMap.inverse().keySet().stream()\n+                           .filter(list -> list.size() > 1)\n+                           .flatMap(list -> list.stream())\n+                           .map(item -> new IntegrityMessage(Localization.lang(\"Unique DOI used in multiple entries\"), item, StandardField.DOI))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNTY2MQ=="}, "originalCommit": {"oid": "4c9e687a0f2181704ba08f0eff9edbabe17a6971"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTI4ODg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/integrity/IntegrityCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozOTo1NlrOGKis-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozOTo1NlrOGKis-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzUxMw==", "bodyText": "Name it simply check?", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413707513", "createdAt": "2020-04-23T10:39:56Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/integrity/IntegrityCheck.java", "diffHunk": "@@ -14,75 +15,77 @@\n public class IntegrityCheck {\n \n     private final BibDatabaseContext bibDatabaseContext;\n-    private final FilePreferences filePreferences;\n-    private final BibtexKeyPatternPreferences bibtexKeyPatternPreferences;\n-    private final JournalAbbreviationRepository journalAbbreviationRepository;\n-    private final boolean enforceLegalKey;\n-    private final boolean allowIntegerEdition;\n+    private final FieldCheckers fieldCheckers;\n+    private final List<Checker> entryCheckers;\n \n     public IntegrityCheck(BibDatabaseContext bibDatabaseContext,\n                           FilePreferences filePreferences,\n                           BibtexKeyPatternPreferences bibtexKeyPatternPreferences,\n                           JournalAbbreviationRepository journalAbbreviationRepository,\n                           boolean enforceLegalKey,\n                           boolean allowIntegerEdition) {\n-        this.bibDatabaseContext = Objects.requireNonNull(bibDatabaseContext);\n-        this.filePreferences = Objects.requireNonNull(filePreferences);\n-        this.bibtexKeyPatternPreferences = Objects.requireNonNull(bibtexKeyPatternPreferences);\n-        this.journalAbbreviationRepository = Objects.requireNonNull(journalAbbreviationRepository);\n-        this.enforceLegalKey = enforceLegalKey;\n-        this.allowIntegerEdition = allowIntegerEdition;\n+        this.bibDatabaseContext = bibDatabaseContext;\n+\n+        fieldCheckers = new FieldCheckers(bibDatabaseContext,\n+                filePreferences,\n+                journalAbbreviationRepository,\n+                enforceLegalKey,\n+                allowIntegerEdition);\n+\n+        entryCheckers = new ArrayList<>(List.of(\n+                new BibtexKeyChecker(),\n+                new TypeChecker(),\n+                new BibStringChecker(),\n+                new HTMLCharacterChecker(),\n+                new EntryLinkChecker(bibDatabaseContext.getDatabase()),\n+                new BibtexkeyDeviationChecker(bibDatabaseContext, bibtexKeyPatternPreferences),\n+                new BibtexKeyDuplicationChecker(bibDatabaseContext.getDatabase())\n+        ));\n+\n+        if (!bibDatabaseContext.isBiblatexMode()) {\n+            entryCheckers.add(new JournalInAbbreviationListChecker(StandardField.JOURNALTITLE, journalAbbreviationRepository));\n+        } else {\n+            entryCheckers.addAll(List.of(\n+                    new JournalInAbbreviationListChecker(StandardField.JOURNAL, journalAbbreviationRepository),\n+                    new ASCIICharacterChecker(),\n+                    new NoBibtexFieldChecker(),\n+                    new BibTeXEntryTypeChecker())\n+            );\n+        }\n     }\n \n-    public List<IntegrityMessage> checkDatabase() {\n+    List<IntegrityMessage> executeAllCheckers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c9e687a0f2181704ba08f0eff9edbabe17a6971"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1938, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}