{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ0MzUxMzIw", "number": 7228, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxNjowNDozMFrOFKHdww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDoyMjozMVrOFK1jqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MTUyMzg3OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxNjowNDozMFrOIMwPbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxNjowNDozMFrOIMwPbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI0NDIwNg==", "bodyText": "It's better to construct a list of expected elements by hand and compare to that. For example, if the code happens to return 3 elements, you now only get a message saying \"expected 2 but got 3\" - not very helpful. But if you do\nexpected = Arrays.asList(new Keywordgroup(...), ...); assertEquals(expected, subgroups) you get a nice message, showing you which additional group is there.", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550244206", "createdAt": "2020-12-30T16:04:30Z", "author": {"login": "tobiasdiez"}, "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.model.groups;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class AutomaticPersonsGroupTest {\n+    @Test\n+    void createSubgroupsFromCommaSeparatedLastNames() {\n+        BibEntry bibEntry = new BibEntry().withField(StandardField.AUTHOR, \"Turing, Alan and Hopper, Grace\");\n+        var subgroups = new AutomaticPersonsGroup(\"\", GroupHierarchyType.INDEPENDENT, StandardField.AUTHOR).createSubgroups(bibEntry);\n+        assertEquals(2, subgroups.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d749e626373562ff7f8310b856feb0e6ac37295"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MTU0ODY3OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxNjoxNTo1N1rOIMwdmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxNjoxNTo1N1rOIMwdmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI0NzgzNA==", "bodyText": "It's better to construct a list of expected elements by hand and compare to that. For example, if the code happens to return 3 elements, you now only get a message saying \"expected 2 but got 3\" - not very helpful. But if you do\nexpected = Arrays.asList(new Keywordgroup(...), ...); assertEquals(expected, subgroups) you get a nice message, showing you which additional group is there.", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550247834", "createdAt": "2020-12-30T16:15:57Z", "author": {"login": "tobiasdiez"}, "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.model.groups;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class AutomaticPersonsGroupTest {\n+    @Test\n+    void createSubgroupsFromCommaSeparatedLastNames() {\n+        BibEntry bibEntry = new BibEntry().withField(StandardField.AUTHOR, \"Turing, Alan and Hopper, Grace\");\n+        var subgroups = new AutomaticPersonsGroup(\"\", GroupHierarchyType.INDEPENDENT, StandardField.AUTHOR).createSubgroups(bibEntry);\n+        assertEquals(2, subgroups.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d749e626373562ff7f8310b856feb0e6ac37295"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzI1ODE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMjo1OTozMFrOIM-i0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxNTowMDo1MFrOIM_28w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3ODU0NA==", "bodyText": "if you add flatmap already here, it allows to chain everything nicely I think", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550478544", "createdAt": "2020-12-31T12:59:30Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.Author;\n+import org.jabref.model.entry.AuthorList;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.Field;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+/**\n+ * Matches based on a latex free last name in a specified field. The field is parsed as an author list and the last names are resolved of latex.\n+ */\n+public class LastNameGroup extends KeywordGroup {\n+    public LastNameGroup(String groupName, GroupHierarchyType context, Field searchField, String lastName) {\n+        super(groupName, context, searchField, LatexToUnicodeAdapter.format(lastName), true);\n+    }\n+\n+    static List<String> getAsLastNamesLatexFree(Field field, BibEntry bibEntry) {\n+        return bibEntry.getField(field)\n+                       .map(AuthorList::parse)\n+                       .map(AuthorList::getAuthors)\n+                       .map(authors ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccb3ae23264eb8e20dbdae2b12bf75b9230ca29"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDUwMDA4Mw==", "bodyText": "... I forgot that Optional.stream existed as a method, not just a method reference... \ud83e\udd2f", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550500083", "createdAt": "2020-12-31T15:00:50Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.Author;\n+import org.jabref.model.entry.AuthorList;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.Field;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+/**\n+ * Matches based on a latex free last name in a specified field. The field is parsed as an author list and the last names are resolved of latex.\n+ */\n+public class LastNameGroup extends KeywordGroup {\n+    public LastNameGroup(String groupName, GroupHierarchyType context, Field searchField, String lastName) {\n+        super(groupName, context, searchField, LatexToUnicodeAdapter.format(lastName), true);\n+    }\n+\n+    static List<String> getAsLastNamesLatexFree(Field field, BibEntry bibEntry) {\n+        return bibEntry.getField(field)\n+                       .map(AuthorList::parse)\n+                       .map(AuthorList::getAuthors)\n+                       .map(authors ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3ODU0NA=="}, "originalCommit": {"oid": "2ccb3ae23264eb8e20dbdae2b12bf75b9230ca29"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzI2MDY0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMzowMTo1OFrOIM-kPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wM1QxNDo0NDoxMFrOINfRsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3ODkxMQ==", "bodyText": "please remove distinct and the latextounicode part here. The tests should be a as stupid as possible, e.g. if you want to test that the code transforms latex to unicode, you better do it by hand.", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550478911", "createdAt": "2020-12-31T13:01:58Z", "author": {"login": "tobiasdiez"}, "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class AutomaticPersonsGroupTest {\n+    private static Set<GroupTreeNode> createPersonSubGroupFrom(String... lastNames) {\n+        return Arrays.stream(lastNames)\n+                     .distinct()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccb3ae23264eb8e20dbdae2b12bf75b9230ca29"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ5MDU1MA==", "bodyText": "This is what I use to generate the expected result.\n\nI am using latextounicode part here because I use the last name both as group name and search expression. As it is the expected subgroup they must be the same. (and without latex)\nThe distinct is implied from the set. Given that this is used to generate the expected result, if something messes up in the equality/hashing of the group, it is likelier to be caught by using distinct Strings to create the groups.\n\nThat said, if you don't agree I'll change both.", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550490550", "createdAt": "2020-12-31T14:08:51Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class AutomaticPersonsGroupTest {\n+    private static Set<GroupTreeNode> createPersonSubGroupFrom(String... lastNames) {\n+        return Arrays.stream(lastNames)\n+                     .distinct()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3ODkxMQ=="}, "originalCommit": {"oid": "2ccb3ae23264eb8e20dbdae2b12bf75b9230ca29"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc3OTI4OA==", "bodyText": "I think createPersonSubGroupFrom(A, A) should create two groups. It's the responsible of the caller to make sure she passes distinct values. Similar, one should pass R\u00f6mer instead of R\\\"omer if one expect that latex is resolved.\nThe current test passes if latex2unicode is changed to return always the same string that was put into it. That's not desired.", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550779288", "createdAt": "2021-01-01T15:37:30Z", "author": {"login": "tobiasdiez"}, "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class AutomaticPersonsGroupTest {\n+    private static Set<GroupTreeNode> createPersonSubGroupFrom(String... lastNames) {\n+        return Arrays.stream(lastNames)\n+                     .distinct()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3ODkxMQ=="}, "originalCommit": {"oid": "2ccb3ae23264eb8e20dbdae2b12bf75b9230ca29"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNDgzMg==", "bodyText": "Unless I have missed something, the tests should now be as stupid as they can be ^^", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r551014832", "createdAt": "2021-01-03T14:44:10Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class AutomaticPersonsGroupTest {\n+    private static Set<GroupTreeNode> createPersonSubGroupFrom(String... lastNames) {\n+        return Arrays.stream(lastNames)\n+                     .distinct()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3ODkxMQ=="}, "originalCommit": {"oid": "2ccb3ae23264eb8e20dbdae2b12bf75b9230ca29"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzI2MTkzOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMzowMzoxM1rOIM-k8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxNDowNToxNlrOIM_PBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3OTA4OQ==", "bodyText": "godelEntry is not used, right? (here and in the following test)", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550479089", "createdAt": "2020-12-31T13:03:13Z", "author": {"login": "tobiasdiez"}, "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class AutomaticPersonsGroupTest {\n+    private static Set<GroupTreeNode> createPersonSubGroupFrom(String... lastNames) {\n+        return Arrays.stream(lastNames)\n+                     .distinct()\n+                     .map(LatexToUnicodeAdapter::format)\n+                     .map(lastName ->\n+                             new LastNameGroup(lastName, GroupHierarchyType.INDEPENDENT, StandardField.AUTHOR, lastName))\n+                     .map(GroupTreeNode::new)\n+                     .collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void createSubgroupsFromCommaSeparatedLastNames() {\n+        BibEntry bibEntry = new BibEntry().withField(StandardField.AUTHOR, \"Turing, Alan and Hopper, Grace\");\n+        var subgroups = new AutomaticPersonsGroup(\"\", GroupHierarchyType.INDEPENDENT, StandardField.AUTHOR).createSubgroups(bibEntry);\n+        var expectedSubgroups = createPersonSubGroupFrom(\"Turing\", \"Hopper\");\n+        assertEquals(expectedSubgroups, subgroups);\n+    }\n+\n+    @Test\n+    void createSubgroupsContainingCommaSeparatedLastNames() {\n+        BibEntry bibEntry = new BibEntry().withField(StandardField.AUTHOR, \"Turing, Alan and Hopper, Grace\");\n+        var subgroups = new AutomaticPersonsGroup(\"\", GroupHierarchyType.INDEPENDENT, StandardField.AUTHOR).createSubgroups(bibEntry);\n+        var expectedSubgroups = createPersonSubGroupFrom(\"Turing\", \"Hopper\");\n+        assertEquals(expectedSubgroups, subgroups);\n+    }\n+\n+    @Test\n+    void createSubgroupFromLatexAndCheckForUnicodeLastName() {\n+        BibEntry bibEntry = new BibEntry().withField(StandardField.AUTHOR, \"Kurt G{\\\\\\\"{o}}del\");\n+        BibEntry godelEntry = new BibEntry().withField(StandardField.AUTHOR, \"Kurt G\u00f6del\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ccb3ae23264eb8e20dbdae2b12bf75b9230ca29"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ4OTg2Mw==", "bodyText": "Nope. I really need to stop ignoring my IDE warnings, at least in code I have written myself. Sorry about that.", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r550489863", "createdAt": "2020-12-31T14:05:16Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/test/java/org/jabref/model/groups/AutomaticPersonsGroupTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class AutomaticPersonsGroupTest {\n+    private static Set<GroupTreeNode> createPersonSubGroupFrom(String... lastNames) {\n+        return Arrays.stream(lastNames)\n+                     .distinct()\n+                     .map(LatexToUnicodeAdapter::format)\n+                     .map(lastName ->\n+                             new LastNameGroup(lastName, GroupHierarchyType.INDEPENDENT, StandardField.AUTHOR, lastName))\n+                     .map(GroupTreeNode::new)\n+                     .collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void createSubgroupsFromCommaSeparatedLastNames() {\n+        BibEntry bibEntry = new BibEntry().withField(StandardField.AUTHOR, \"Turing, Alan and Hopper, Grace\");\n+        var subgroups = new AutomaticPersonsGroup(\"\", GroupHierarchyType.INDEPENDENT, StandardField.AUTHOR).createSubgroups(bibEntry);\n+        var expectedSubgroups = createPersonSubGroupFrom(\"Turing\", \"Hopper\");\n+        assertEquals(expectedSubgroups, subgroups);\n+    }\n+\n+    @Test\n+    void createSubgroupsContainingCommaSeparatedLastNames() {\n+        BibEntry bibEntry = new BibEntry().withField(StandardField.AUTHOR, \"Turing, Alan and Hopper, Grace\");\n+        var subgroups = new AutomaticPersonsGroup(\"\", GroupHierarchyType.INDEPENDENT, StandardField.AUTHOR).createSubgroups(bibEntry);\n+        var expectedSubgroups = createPersonSubGroupFrom(\"Turing\", \"Hopper\");\n+        assertEquals(expectedSubgroups, subgroups);\n+    }\n+\n+    @Test\n+    void createSubgroupFromLatexAndCheckForUnicodeLastName() {\n+        BibEntry bibEntry = new BibEntry().withField(StandardField.AUTHOR, \"Kurt G{\\\\\\\"{o}}del\");\n+        BibEntry godelEntry = new BibEntry().withField(StandardField.AUTHOR, \"Kurt G\u00f6del\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3OTA4OQ=="}, "originalCommit": {"oid": "2ccb3ae23264eb8e20dbdae2b12bf75b9230ca29"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2OTA3NTYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDoyMjozMVrOINsWpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQyMDoxMzo1NVrOIQyCDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyOTA5Mw==", "bodyText": "You can easily use instanceof here that should also check for supertypes.\nhttp://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html\nAnd tip: Use Objects.equals(getSearchField, otherGroup.getSearchField)", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r551229093", "createdAt": "2021-01-04T10:22:31Z", "author": {"login": "Siedlerchr"}, "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.Author;\n+import org.jabref.model.entry.AuthorList;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.Field;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+/**\n+ * Matches based on a latex free last name in a specified field. The field is parsed as an author list and the last names are resolved of latex.\n+ */\n+public class LastNameGroup extends KeywordGroup {\n+    public LastNameGroup(String groupName, GroupHierarchyType context, Field searchField, String lastName) {\n+        super(groupName, context, searchField, LatexToUnicodeAdapter.format(lastName), true);\n+    }\n+\n+    static List<String> getAsLastNamesLatexFree(Field field, BibEntry bibEntry) {\n+        return bibEntry.getField(field).stream()\n+                       .map(AuthorList::parse)\n+                       .map(AuthorList::getAuthors)\n+                       .flatMap(Collection::stream)\n+                       .map(Author::getLastLatexFree)\n+                       .flatMap(Optional::stream)\n+                       .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public boolean contains(BibEntry entry) {\n+        return getAsLastNamesLatexFree(getSearchField(), entry).stream().anyMatch(name -> name.equals(getSearchExpression()));\n+    }\n+\n+    @Override\n+    public AbstractGroup deepCopy() {\n+        return new LastNameGroup(getName(), getHierarchicalContext(), getSearchField(), getSearchExpression());\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (super.equals(other)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30282373fe039365f809b8878cc7a52061de2641"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMyNDY4OA==", "bodyText": "Objects.equals, good catch, I am not sure why I didn't use it.\n\n\nIf I understand you correctly, you'd like a specific check for LastNameGroup rather than relying on the .getClass() from AbstractGroup.equals\n\n  \n    \n      jabref/src/main/java/org/jabref/model/groups/AbstractGroup.java\n    \n    \n        Lines 52 to 57\n      in\n      10180ed\n    \n    \n    \n    \n\n        \n          \n           if (this == other) { \n        \n\n        \n          \n               return true; \n        \n\n        \n          \n           } \n        \n\n        \n          \n           if ((other == null) || (getClass() != other.getClass())) { \n        \n\n        \n          \n               return false; \n        \n\n        \n          \n           } \n        \n    \n  \n\n\n?", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r551324688", "createdAt": "2021-01-04T13:45:12Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.Author;\n+import org.jabref.model.entry.AuthorList;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.Field;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+/**\n+ * Matches based on a latex free last name in a specified field. The field is parsed as an author list and the last names are resolved of latex.\n+ */\n+public class LastNameGroup extends KeywordGroup {\n+    public LastNameGroup(String groupName, GroupHierarchyType context, Field searchField, String lastName) {\n+        super(groupName, context, searchField, LatexToUnicodeAdapter.format(lastName), true);\n+    }\n+\n+    static List<String> getAsLastNamesLatexFree(Field field, BibEntry bibEntry) {\n+        return bibEntry.getField(field).stream()\n+                       .map(AuthorList::parse)\n+                       .map(AuthorList::getAuthors)\n+                       .flatMap(Collection::stream)\n+                       .map(Author::getLastLatexFree)\n+                       .flatMap(Optional::stream)\n+                       .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public boolean contains(BibEntry entry) {\n+        return getAsLastNamesLatexFree(getSearchField(), entry).stream().anyMatch(name -> name.equals(getSearchExpression()));\n+    }\n+\n+    @Override\n+    public AbstractGroup deepCopy() {\n+        return new LastNameGroup(getName(), getHierarchicalContext(), getSearchField(), getSearchExpression());\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (super.equals(other)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyOTA5Mw=="}, "originalCommit": {"oid": "30282373fe039365f809b8878cc7a52061de2641"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMzOTE2OA==", "bodyText": "if (this instanceof other) was the approach I thought of", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r551339168", "createdAt": "2021-01-04T14:12:58Z", "author": {"login": "Siedlerchr"}, "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.Author;\n+import org.jabref.model.entry.AuthorList;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.Field;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+/**\n+ * Matches based on a latex free last name in a specified field. The field is parsed as an author list and the last names are resolved of latex.\n+ */\n+public class LastNameGroup extends KeywordGroup {\n+    public LastNameGroup(String groupName, GroupHierarchyType context, Field searchField, String lastName) {\n+        super(groupName, context, searchField, LatexToUnicodeAdapter.format(lastName), true);\n+    }\n+\n+    static List<String> getAsLastNamesLatexFree(Field field, BibEntry bibEntry) {\n+        return bibEntry.getField(field).stream()\n+                       .map(AuthorList::parse)\n+                       .map(AuthorList::getAuthors)\n+                       .flatMap(Collection::stream)\n+                       .map(Author::getLastLatexFree)\n+                       .flatMap(Optional::stream)\n+                       .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public boolean contains(BibEntry entry) {\n+        return getAsLastNamesLatexFree(getSearchField(), entry).stream().anyMatch(name -> name.equals(getSearchExpression()));\n+    }\n+\n+    @Override\n+    public AbstractGroup deepCopy() {\n+        return new LastNameGroup(getName(), getHierarchicalContext(), getSearchField(), getSearchExpression());\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (super.equals(other)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyOTA5Mw=="}, "originalCommit": {"oid": "30282373fe039365f809b8878cc7a52061de2641"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MjE0NA==", "bodyText": "There were a few things in the article I had not encountered before, and I have made the changes I believe are necessary for a \"class hierarchies of value types\". (The code is now almost identical to \"Listing 4\" in the article)", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r551562144", "createdAt": "2021-01-04T20:52:33Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.Author;\n+import org.jabref.model.entry.AuthorList;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.Field;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+/**\n+ * Matches based on a latex free last name in a specified field. The field is parsed as an author list and the last names are resolved of latex.\n+ */\n+public class LastNameGroup extends KeywordGroup {\n+    public LastNameGroup(String groupName, GroupHierarchyType context, Field searchField, String lastName) {\n+        super(groupName, context, searchField, LatexToUnicodeAdapter.format(lastName), true);\n+    }\n+\n+    static List<String> getAsLastNamesLatexFree(Field field, BibEntry bibEntry) {\n+        return bibEntry.getField(field).stream()\n+                       .map(AuthorList::parse)\n+                       .map(AuthorList::getAuthors)\n+                       .flatMap(Collection::stream)\n+                       .map(Author::getLastLatexFree)\n+                       .flatMap(Optional::stream)\n+                       .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public boolean contains(BibEntry entry) {\n+        return getAsLastNamesLatexFree(getSearchField(), entry).stream().anyMatch(name -> name.equals(getSearchExpression()));\n+    }\n+\n+    @Override\n+    public AbstractGroup deepCopy() {\n+        return new LastNameGroup(getName(), getHierarchicalContext(), getSearchField(), getSearchExpression());\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (super.equals(other)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyOTA5Mw=="}, "originalCommit": {"oid": "30282373fe039365f809b8878cc7a52061de2641"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ2NDE3Mw==", "bodyText": "@Siedlerchr are you ok with the current approach?", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r554464173", "createdAt": "2021-01-09T19:37:14Z", "author": {"login": "k3KAW8Pnf7mkmdSMPHz27"}, "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.Author;\n+import org.jabref.model.entry.AuthorList;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.Field;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+/**\n+ * Matches based on a latex free last name in a specified field. The field is parsed as an author list and the last names are resolved of latex.\n+ */\n+public class LastNameGroup extends KeywordGroup {\n+    public LastNameGroup(String groupName, GroupHierarchyType context, Field searchField, String lastName) {\n+        super(groupName, context, searchField, LatexToUnicodeAdapter.format(lastName), true);\n+    }\n+\n+    static List<String> getAsLastNamesLatexFree(Field field, BibEntry bibEntry) {\n+        return bibEntry.getField(field).stream()\n+                       .map(AuthorList::parse)\n+                       .map(AuthorList::getAuthors)\n+                       .flatMap(Collection::stream)\n+                       .map(Author::getLastLatexFree)\n+                       .flatMap(Optional::stream)\n+                       .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public boolean contains(BibEntry entry) {\n+        return getAsLastNamesLatexFree(getSearchField(), entry).stream().anyMatch(name -> name.equals(getSearchExpression()));\n+    }\n+\n+    @Override\n+    public AbstractGroup deepCopy() {\n+        return new LastNameGroup(getName(), getHierarchicalContext(), getSearchField(), getSearchExpression());\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (super.equals(other)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyOTA5Mw=="}, "originalCommit": {"oid": "30282373fe039365f809b8878cc7a52061de2641"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ2Nzg1NQ==", "bodyText": "(By the way, Intellj can also auto-generate these equals/hash/tostring methods)", "url": "https://github.com/JabRef/jabref/pull/7228#discussion_r554467855", "createdAt": "2021-01-09T20:13:55Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/model/groups/LastNameGroup.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.jabref.model.groups;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.model.entry.Author;\n+import org.jabref.model.entry.AuthorList;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.Field;\n+import org.jabref.model.strings.LatexToUnicodeAdapter;\n+\n+/**\n+ * Matches based on a latex free last name in a specified field. The field is parsed as an author list and the last names are resolved of latex.\n+ */\n+public class LastNameGroup extends KeywordGroup {\n+    public LastNameGroup(String groupName, GroupHierarchyType context, Field searchField, String lastName) {\n+        super(groupName, context, searchField, LatexToUnicodeAdapter.format(lastName), true);\n+    }\n+\n+    static List<String> getAsLastNamesLatexFree(Field field, BibEntry bibEntry) {\n+        return bibEntry.getField(field).stream()\n+                       .map(AuthorList::parse)\n+                       .map(AuthorList::getAuthors)\n+                       .flatMap(Collection::stream)\n+                       .map(Author::getLastLatexFree)\n+                       .flatMap(Optional::stream)\n+                       .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public boolean contains(BibEntry entry) {\n+        return getAsLastNamesLatexFree(getSearchField(), entry).stream().anyMatch(name -> name.equals(getSearchExpression()));\n+    }\n+\n+    @Override\n+    public AbstractGroup deepCopy() {\n+        return new LastNameGroup(getName(), getHierarchicalContext(), getSearchField(), getSearchExpression());\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (super.equals(other)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyOTA5Mw=="}, "originalCommit": {"oid": "30282373fe039365f809b8878cc7a52061de2641"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2155, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}