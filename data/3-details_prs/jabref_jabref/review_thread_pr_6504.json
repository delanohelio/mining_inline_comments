{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNzY4NTU1", "number": 6504, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo0Mzo1OVrOD-QNlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzowNjoyNVrOD_b8rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjAzOTI0OnYy", "diffSide": "RIGHT", "path": "CHANGELOG.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo0Mzo1OVrOGYPV7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo0Mzo1OVrOGYPV7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MDM4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - We added a new fetcher to enable users to search all available E-Libraries simultaneously. [#369](https://github.com/koppor/jabref/issues/369)\n          \n          \n            \n            - We added a new fetcher to enable users to search all available E-Libraries simultaneously. [koppor#369](https://github.com/koppor/jabref/issues/369)", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r428070380", "createdAt": "2020-05-20T14:43:59Z", "author": {"login": "Siedlerchr"}, "path": "CHANGELOG.md", "diffHunk": "@@ -24,6 +24,7 @@ Note that this project **does not** adhere to [Semantic Versioning](http://semve\n - We fixed the bug when strike the delete key in the text field. [#6421](https://github.com/JabRef/jabref/issues/6421)\n - We added a BibTex key modifier for truncating strings. [#3915](https://github.com/JabRef/jabref/issues/3915)\n - We added support for jumping to target entry when typing letter/digit after sorting a column in maintable [#6146](https://github.com/JabRef/jabref/issues/6146)\n+- We added a new fetcher to enable users to search all available E-Libraries simultaneously. [#369](https://github.com/koppor/jabref/issues/369)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6cf33add066b40f18b65264ee41dcc9d224bf09"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODI1NjQ0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMToyMVrOGaEnXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMToyMVrOGaEnXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MTc3Mg==", "bodyText": "Maybe, debug would be more appropriate then?", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429991772", "createdAt": "2020-05-25T15:31:21Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODI1Njk4OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMTozNFrOGaEntQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMTozNFrOGaEntQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MTg2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                             * and just leads to no additional results in the returned list. Therefor the test should not fail\n          \n          \n            \n                             * and just leads to no additional results in the returned list. Therefore the test should not fail", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429991861", "createdAt": "2020-05-25T15:31:34Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODI1Nzg2OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMjowMVrOGaEoSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMjowMVrOGaEoSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjAwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n          \n          \n            \n                 * This method provides other methods with different sized sets of search-based fetchers wrapped in arguments.", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429992008", "createdAt": "2020-05-25T15:32:01Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODI1ODQ0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMjoxNVrOGaEopg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMjoxNVrOGaEopg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjEwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A stream of Arguments wrapping the sets.\n          \n          \n            \n                 * @return A stream of Arguments wrapping sets of fetchers.", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429992102", "createdAt": "2020-05-25T15:32:15Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODI2MjEzOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMzo0MlrOGaEqzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozMzo0MlrOGaEqzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjY1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ\n          \n          \n            \n                    /* Disabled due to an issue regarding comparison: Title fields of the entries that otherwise are equivalent differ", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429992655", "createdAt": "2020-05-25T15:33:42Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.\n+     */\n+    static Stream<Arguments> performSearchParameters() {\n+        ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n+        when(importFormatPreferences.getFieldContentFormatterPreferences())\n+                .thenReturn(mock(FieldContentFormatterPreferences.class));\n+        List<Set<SearchBasedFetcher>> fetcherParameters = new ArrayList<>();\n+        List<SearchBasedFetcher> list = new ArrayList<>();\n+\n+        list.add(new ArXiv(importFormatPreferences));\n+        list.add(new INSPIREFetcher(importFormatPreferences));\n+        list.add(new GvkFetcher());\n+        list.add(new AstrophysicsDataSystem(importFormatPreferences));\n+        list.add(new MathSciNet(importFormatPreferences));\n+        list.add(new ZbMATH(importFormatPreferences));\n+        list.add(new GoogleScholar(importFormatPreferences));\n+        list.add(new DBLPFetcher(importFormatPreferences));\n+        list.add(new SpringerFetcher());\n+        list.add(new CrossRef());\n+        list.add(new CiteSeer());\n+        list.add(new DOAJFetcher(importFormatPreferences));\n+        list.add(new IEEE(importFormatPreferences));\n+        /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODI2Mjk3OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozNDowOVrOGaErZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMjoxNTo0M1rOGaKYVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjgwNg==", "bodyText": "Can you provide me the concreete example? Maybe, we need to fix the MedlineFetcher?", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429992806", "createdAt": "2020-05-25T15:34:09Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.\n+     */\n+    static Stream<Arguments> performSearchParameters() {\n+        ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n+        when(importFormatPreferences.getFieldContentFormatterPreferences())\n+                .thenReturn(mock(FieldContentFormatterPreferences.class));\n+        List<Set<SearchBasedFetcher>> fetcherParameters = new ArrayList<>();\n+        List<SearchBasedFetcher> list = new ArrayList<>();\n+\n+        list.add(new ArXiv(importFormatPreferences));\n+        list.add(new INSPIREFetcher(importFormatPreferences));\n+        list.add(new GvkFetcher());\n+        list.add(new AstrophysicsDataSystem(importFormatPreferences));\n+        list.add(new MathSciNet(importFormatPreferences));\n+        list.add(new ZbMATH(importFormatPreferences));\n+        list.add(new GoogleScholar(importFormatPreferences));\n+        list.add(new DBLPFetcher(importFormatPreferences));\n+        list.add(new SpringerFetcher());\n+        list.add(new CrossRef());\n+        list.add(new CiteSeer());\n+        list.add(new DOAJFetcher(importFormatPreferences));\n+        list.add(new IEEE(importFormatPreferences));\n+        /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ\n+         * due to different JAXBElements.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA4NjIyOA==", "bodyText": "AFAIK:\nWhen using the same instance of MedlineFetcher to fetch results directly or as part of the CompositeFetcher, certain BibEntries have differing titles due to something related to JAXBElements.\nWhen searching for \"Indistinguishable Photons from Deterministically\" the direct use of the MedLine Fetcher returns a BibEntry with the title:\n\ntitle = {Indistinguishable Photons from Deterministically Integrated Single Quantum Dots in Heterogeneous GaAs/Si, javax.xml.bind.JAXBElement@31b82e0f, N, javax.xml.bind.JAXBElement@27a09971, Quantum Photonic Circuits.}\n\nThe CompositeFetcher, on the other hand, returns a BibEntry with the title:\n\ntitle = {Indistinguishable Photons from Deterministically Integrated Single Quantum Dots in Heterogeneous GaAs/Si, javax.xml.bind.JAXBElement@3289079a, N, javax.xml.bind.JAXBElement@32fa809f, Quantum Photonic Circuits.}\n\nBoth would be the same only differing by the JAXBElement Instance.", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r430086228", "createdAt": "2020-05-25T22:15:43Z", "author": {"login": "DominikVoigt"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.\n+     */\n+    static Stream<Arguments> performSearchParameters() {\n+        ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n+        when(importFormatPreferences.getFieldContentFormatterPreferences())\n+                .thenReturn(mock(FieldContentFormatterPreferences.class));\n+        List<Set<SearchBasedFetcher>> fetcherParameters = new ArrayList<>();\n+        List<SearchBasedFetcher> list = new ArrayList<>();\n+\n+        list.add(new ArXiv(importFormatPreferences));\n+        list.add(new INSPIREFetcher(importFormatPreferences));\n+        list.add(new GvkFetcher());\n+        list.add(new AstrophysicsDataSystem(importFormatPreferences));\n+        list.add(new MathSciNet(importFormatPreferences));\n+        list.add(new ZbMATH(importFormatPreferences));\n+        list.add(new GoogleScholar(importFormatPreferences));\n+        list.add(new DBLPFetcher(importFormatPreferences));\n+        list.add(new SpringerFetcher());\n+        list.add(new CrossRef());\n+        list.add(new CiteSeer());\n+        list.add(new DOAJFetcher(importFormatPreferences));\n+        list.add(new IEEE(importFormatPreferences));\n+        /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ\n+         * due to different JAXBElements.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjgwNg=="}, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODI2NjQ5OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozNTozNlrOGaEtgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTozNTozNlrOGaEtgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MzM0NQ==", "bodyText": "Can we do some different sub sets? Not always include the first one, but something like: Always +3 and then use the subsets matched by the respective bits?\n6543210\n0110001 --> list entry 5,4,0 are used\n\n(Not sure what the others think of it)", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429993345", "createdAt": "2020-05-25T15:35:36Z", "author": {"login": "koppor"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.\n+     */\n+    static Stream<Arguments> performSearchParameters() {\n+        ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n+        when(importFormatPreferences.getFieldContentFormatterPreferences())\n+                .thenReturn(mock(FieldContentFormatterPreferences.class));\n+        List<Set<SearchBasedFetcher>> fetcherParameters = new ArrayList<>();\n+        List<SearchBasedFetcher> list = new ArrayList<>();\n+\n+        list.add(new ArXiv(importFormatPreferences));\n+        list.add(new INSPIREFetcher(importFormatPreferences));\n+        list.add(new GvkFetcher());\n+        list.add(new AstrophysicsDataSystem(importFormatPreferences));\n+        list.add(new MathSciNet(importFormatPreferences));\n+        list.add(new ZbMATH(importFormatPreferences));\n+        list.add(new GoogleScholar(importFormatPreferences));\n+        list.add(new DBLPFetcher(importFormatPreferences));\n+        list.add(new SpringerFetcher());\n+        list.add(new CrossRef());\n+        list.add(new CiteSeer());\n+        list.add(new DOAJFetcher(importFormatPreferences));\n+        list.add(new IEEE(importFormatPreferences));\n+        /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ\n+         * due to different JAXBElements.\n+         */\n+        // list.add(new MedlineFetcher());\n+\n+        // Create different sized sets of fetchers to use in the composite fetcher.\n+        for (int i = 1; i < list.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODQ0MjAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzowMzowNFrOGaGYkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzowMzowNFrOGaGYkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyMDc1Mg==", "bodyText": "I think we should add a limit(...) of say 30 items here, at least unless paged fetcher are implemented.", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r430020752", "createdAt": "2020-05-25T17:03:04Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcher.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.help.HelpFile;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CompositeSearchBasedFetcher implements SearchBasedFetcher {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcher.class);\n+\n+    private final Set<SearchBasedFetcher> fetchers;\n+\n+    public CompositeSearchBasedFetcher(Set<SearchBasedFetcher> searchBasedFetchers) {\n+        // Remove the Composite Fetcher instance from its own fetcher set to prevent a StackOverflow\n+        this.fetchers = searchBasedFetchers.stream()\n+                .filter(searchBasedFetcher -> searchBasedFetcher != this)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public List<BibEntry> performSearch(String query) {\n+        return fetchers.stream().flatMap(searchBasedFetcher -> {\n+            try {\n+                return searchBasedFetcher.performSearch(query).stream();\n+            } catch (FetcherException e) {\n+                LOGGER.warn(String.format(\"%s API request failed\", searchBasedFetcher.getName()), e);\n+                return Stream.empty();\n+            }\n+        }).parallel().collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODQ0NzgzOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzowNjoyNVrOGaGb6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzowNjoyNVrOGaGb6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyMTYxMQ==", "bodyText": "please don't use assertTrue(empty) but assertEquals(..., emptyList) since this gives a better error message", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r430021611", "createdAt": "2020-05-25T17:06:25Z", "author": {"login": "tobiasdiez"}, "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1851, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}