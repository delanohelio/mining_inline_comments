{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2NTkwNzgx", "number": 6469, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMToxMTo1MlrOD7mjZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMToxMTo1MlrOD7mjZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODI0MjI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/jabref/logic/bibtexkeypattern/BracketedPattern.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMToxMTo1MlrOGUBp7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTo0Mzo0MFrOGUCpUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY1MTgyMw==", "bodyText": "Question: you fetch the next token above in line 131, and then here the subtoken. So this moves the stream forward twice, right? What happens if the user adds an empty brace, i.e []. Is the closing bracket still found? Can you please add a test for this case as well. Thanks!", "url": "https://github.com/JabRef/jabref/pull/6469#discussion_r423651823", "createdAt": "2020-05-12T11:11:52Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/bibtexkeypattern/BracketedPattern.java", "diffHunk": "@@ -106,40 +106,68 @@ public static String expandBrackets(String pattern, Character keywordDelimiter,\n         Objects.requireNonNull(pattern);\n         Objects.requireNonNull(entry);\n         StringBuilder sb = new StringBuilder();\n-        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\", true);\n+        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\\\"\", true);\n \n         while (st.hasMoreTokens()) {\n             String token = st.nextToken();\n-            if (\"\\\\\".equals(token)) {\n-                if (st.hasMoreTokens()) {\n-                    sb.append(st.nextToken());\n-                }\n-                // FIXME: else -> raise exception or log? (S.G.)\n-            } else {\n-                if (\"[\".equals(token)) {\n-                    // Fetch the next token after the '[':\n+            if (\"\\\"\".equals(token)) {\n+                sb.append(token);\n+                while (st.hasMoreTokens()) {\n                     token = st.nextToken();\n-                    List<String> fieldParts = parseFieldMarker(token);\n-                    // check whether there is a modifier on the end such as\n-                    // \":lower\":\n-                    if (fieldParts.size() <= 1) {\n-                        sb.append(getFieldValue(entry, token, keywordDelimiter, database));\n-                    } else {\n-                        // apply modifiers:\n-                        String fieldValue = getFieldValue(entry, fieldParts.get(0), keywordDelimiter, database);\n-                        sb.append(applyModifiers(fieldValue, fieldParts, 1));\n+                    sb.append(token);\n+                    if (\"\\\"\".equals(token)) {\n+                        break;\n                     }\n-                    // Fetch and discard the closing ']'\n+                }\n+            } else {\n+                if (\"\\\\\".equals(token)) {\n                     if (st.hasMoreTokens()) {\n+                        sb.append(st.nextToken());\n+                    }\n+                    // FIXME: else -> raise exception or log? (S.G.)\n+                } else {\n+                    if (\"[\".equals(token)) {\n+                        // Fetch the next token after the '[':\n                         token = st.nextToken();\n+                        Boolean foundClosingBracket = false;\n+                        // make sure to read until the next ']'\n+                        while (st.hasMoreTokens()) {\n+                            String subtoken = st.nextToken();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5861685e11ba8e1539c35e6c40be9ed6ecf80fc7"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY1NjIxNA==", "bodyText": "Good catch! But what should \"[]\" expand to? Inside a quote, the parsing should work fine. but what does \"[]\" mean in terms of JabRef fields? Should it just do nothing and print an appropriate warning?", "url": "https://github.com/JabRef/jabref/pull/6469#discussion_r423656214", "createdAt": "2020-05-12T11:20:16Z", "author": {"login": "btut"}, "path": "src/main/java/org/jabref/logic/bibtexkeypattern/BracketedPattern.java", "diffHunk": "@@ -106,40 +106,68 @@ public static String expandBrackets(String pattern, Character keywordDelimiter,\n         Objects.requireNonNull(pattern);\n         Objects.requireNonNull(entry);\n         StringBuilder sb = new StringBuilder();\n-        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\", true);\n+        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\\\"\", true);\n \n         while (st.hasMoreTokens()) {\n             String token = st.nextToken();\n-            if (\"\\\\\".equals(token)) {\n-                if (st.hasMoreTokens()) {\n-                    sb.append(st.nextToken());\n-                }\n-                // FIXME: else -> raise exception or log? (S.G.)\n-            } else {\n-                if (\"[\".equals(token)) {\n-                    // Fetch the next token after the '[':\n+            if (\"\\\"\".equals(token)) {\n+                sb.append(token);\n+                while (st.hasMoreTokens()) {\n                     token = st.nextToken();\n-                    List<String> fieldParts = parseFieldMarker(token);\n-                    // check whether there is a modifier on the end such as\n-                    // \":lower\":\n-                    if (fieldParts.size() <= 1) {\n-                        sb.append(getFieldValue(entry, token, keywordDelimiter, database));\n-                    } else {\n-                        // apply modifiers:\n-                        String fieldValue = getFieldValue(entry, fieldParts.get(0), keywordDelimiter, database);\n-                        sb.append(applyModifiers(fieldValue, fieldParts, 1));\n+                    sb.append(token);\n+                    if (\"\\\"\".equals(token)) {\n+                        break;\n                     }\n-                    // Fetch and discard the closing ']'\n+                }\n+            } else {\n+                if (\"\\\\\".equals(token)) {\n                     if (st.hasMoreTokens()) {\n+                        sb.append(st.nextToken());\n+                    }\n+                    // FIXME: else -> raise exception or log? (S.G.)\n+                } else {\n+                    if (\"[\".equals(token)) {\n+                        // Fetch the next token after the '[':\n                         token = st.nextToken();\n+                        Boolean foundClosingBracket = false;\n+                        // make sure to read until the next ']'\n+                        while (st.hasMoreTokens()) {\n+                            String subtoken = st.nextToken();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY1MTgyMw=="}, "originalCommit": {"oid": "5861685e11ba8e1539c35e6c40be9ed6ecf80fc7"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY1OTE5OA==", "bodyText": "Yes, I would say it should do nothing and log a warning. I don't really see a use case for the empty bracket, it should just not break the parser.", "url": "https://github.com/JabRef/jabref/pull/6469#discussion_r423659198", "createdAt": "2020-05-12T11:26:01Z", "author": {"login": "tobiasdiez"}, "path": "src/main/java/org/jabref/logic/bibtexkeypattern/BracketedPattern.java", "diffHunk": "@@ -106,40 +106,68 @@ public static String expandBrackets(String pattern, Character keywordDelimiter,\n         Objects.requireNonNull(pattern);\n         Objects.requireNonNull(entry);\n         StringBuilder sb = new StringBuilder();\n-        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\", true);\n+        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\\\"\", true);\n \n         while (st.hasMoreTokens()) {\n             String token = st.nextToken();\n-            if (\"\\\\\".equals(token)) {\n-                if (st.hasMoreTokens()) {\n-                    sb.append(st.nextToken());\n-                }\n-                // FIXME: else -> raise exception or log? (S.G.)\n-            } else {\n-                if (\"[\".equals(token)) {\n-                    // Fetch the next token after the '[':\n+            if (\"\\\"\".equals(token)) {\n+                sb.append(token);\n+                while (st.hasMoreTokens()) {\n                     token = st.nextToken();\n-                    List<String> fieldParts = parseFieldMarker(token);\n-                    // check whether there is a modifier on the end such as\n-                    // \":lower\":\n-                    if (fieldParts.size() <= 1) {\n-                        sb.append(getFieldValue(entry, token, keywordDelimiter, database));\n-                    } else {\n-                        // apply modifiers:\n-                        String fieldValue = getFieldValue(entry, fieldParts.get(0), keywordDelimiter, database);\n-                        sb.append(applyModifiers(fieldValue, fieldParts, 1));\n+                    sb.append(token);\n+                    if (\"\\\"\".equals(token)) {\n+                        break;\n                     }\n-                    // Fetch and discard the closing ']'\n+                }\n+            } else {\n+                if (\"\\\\\".equals(token)) {\n                     if (st.hasMoreTokens()) {\n+                        sb.append(st.nextToken());\n+                    }\n+                    // FIXME: else -> raise exception or log? (S.G.)\n+                } else {\n+                    if (\"[\".equals(token)) {\n+                        // Fetch the next token after the '[':\n                         token = st.nextToken();\n+                        Boolean foundClosingBracket = false;\n+                        // make sure to read until the next ']'\n+                        while (st.hasMoreTokens()) {\n+                            String subtoken = st.nextToken();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY1MTgyMw=="}, "originalCommit": {"oid": "5861685e11ba8e1539c35e6c40be9ed6ecf80fc7"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2ODA1MQ==", "bodyText": "Done 230fef2", "url": "https://github.com/JabRef/jabref/pull/6469#discussion_r423668051", "createdAt": "2020-05-12T11:43:40Z", "author": {"login": "btut"}, "path": "src/main/java/org/jabref/logic/bibtexkeypattern/BracketedPattern.java", "diffHunk": "@@ -106,40 +106,68 @@ public static String expandBrackets(String pattern, Character keywordDelimiter,\n         Objects.requireNonNull(pattern);\n         Objects.requireNonNull(entry);\n         StringBuilder sb = new StringBuilder();\n-        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\", true);\n+        StringTokenizer st = new StringTokenizer(pattern, \"\\\\[]\\\"\", true);\n \n         while (st.hasMoreTokens()) {\n             String token = st.nextToken();\n-            if (\"\\\\\".equals(token)) {\n-                if (st.hasMoreTokens()) {\n-                    sb.append(st.nextToken());\n-                }\n-                // FIXME: else -> raise exception or log? (S.G.)\n-            } else {\n-                if (\"[\".equals(token)) {\n-                    // Fetch the next token after the '[':\n+            if (\"\\\"\".equals(token)) {\n+                sb.append(token);\n+                while (st.hasMoreTokens()) {\n                     token = st.nextToken();\n-                    List<String> fieldParts = parseFieldMarker(token);\n-                    // check whether there is a modifier on the end such as\n-                    // \":lower\":\n-                    if (fieldParts.size() <= 1) {\n-                        sb.append(getFieldValue(entry, token, keywordDelimiter, database));\n-                    } else {\n-                        // apply modifiers:\n-                        String fieldValue = getFieldValue(entry, fieldParts.get(0), keywordDelimiter, database);\n-                        sb.append(applyModifiers(fieldValue, fieldParts, 1));\n+                    sb.append(token);\n+                    if (\"\\\"\".equals(token)) {\n+                        break;\n                     }\n-                    // Fetch and discard the closing ']'\n+                }\n+            } else {\n+                if (\"\\\\\".equals(token)) {\n                     if (st.hasMoreTokens()) {\n+                        sb.append(st.nextToken());\n+                    }\n+                    // FIXME: else -> raise exception or log? (S.G.)\n+                } else {\n+                    if (\"[\".equals(token)) {\n+                        // Fetch the next token after the '[':\n                         token = st.nextToken();\n+                        Boolean foundClosingBracket = false;\n+                        // make sure to read until the next ']'\n+                        while (st.hasMoreTokens()) {\n+                            String subtoken = st.nextToken();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY1MTgyMw=="}, "originalCommit": {"oid": "5861685e11ba8e1539c35e6c40be9ed6ecf80fc7"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1830, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}