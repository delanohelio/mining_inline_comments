{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4OTUyMjcw", "number": 1118, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODo0ODoyMlrOD2Ke7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzozNTozN1rOD2z1Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MTIxNDUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODo0ODoyMlrOGL479g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODo1MzowMlrOGL4_cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEyMDM3NA==", "bodyText": "\u0410 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0440\u0430\u0437\u043c\u0435\u0440 \u0437\u0430\u0447\u0435\u043c?", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r415120374", "createdAt": "2020-04-25T18:48:22Z", "author": {"login": "asosnoviy"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+    var tree = Trees.findAllRuleNodes(ctx, BSLParser.RULE_returnStatement);\n+    if (tree.size() > 1) {\n+      var expressions = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(BSLParser.ReturnStatementContext::expression)\n+        .flatMap(Stream::ofNullable)\n+        .collect(Collectors.toList());\n+\n+      expressions.stream()\n+        .map(expression -> Trees.findAllRuleNodes(expression, BSLParser.RULE_complexIdentifier))\n+        .filter(Collection::isEmpty)\n+        .findAny()\n+        .ifPresent(\n+          parseTrees -> checkPrimitiveValue(ctx, tree, expressions)\n+        );\n+    }\n+    return ctx;\n+  }\n+\n+  private void checkPrimitiveValue(\n+    BSLParser.FunctionContext ctx, Collection<ParseTree> tree, List<BSLParser.ExpressionContext> expressions) {\n+\n+    var set = expressions.stream().map(BSLParser.ExpressionContext::getText).collect(Collectors.toSet());\n+    if (set.size() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4421d3b4737e0b330b7df794b8564ca8f967e801"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEyMTI2Ng==", "bodyText": "\u0435\u0441\u043b\u0438 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e.", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r415121266", "createdAt": "2020-04-25T18:53:02Z", "author": {"login": "otymko"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+    var tree = Trees.findAllRuleNodes(ctx, BSLParser.RULE_returnStatement);\n+    if (tree.size() > 1) {\n+      var expressions = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(BSLParser.ReturnStatementContext::expression)\n+        .flatMap(Stream::ofNullable)\n+        .collect(Collectors.toList());\n+\n+      expressions.stream()\n+        .map(expression -> Trees.findAllRuleNodes(expression, BSLParser.RULE_complexIdentifier))\n+        .filter(Collection::isEmpty)\n+        .findAny()\n+        .ifPresent(\n+          parseTrees -> checkPrimitiveValue(ctx, tree, expressions)\n+        );\n+    }\n+    return ctx;\n+  }\n+\n+  private void checkPrimitiveValue(\n+    BSLParser.FunctionContext ctx, Collection<ParseTree> tree, List<BSLParser.ExpressionContext> expressions) {\n+\n+    var set = expressions.stream().map(BSLParser.ExpressionContext::getText).collect(Collectors.toSet());\n+    if (set.size() == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEyMDM3NA=="}, "originalCommit": {"oid": "4421d3b4737e0b330b7df794b8564ca8f967e801"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NDYxNzQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwNToxMzowMFrOGMRCsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzowMzoyMlrOGMt-Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUxNTMxMw==", "bodyText": "\u0412\u044b\u043d\u043e\u0441\u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u043d\u0430 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0435 \u0432 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043f\u0443\u0441\u0442\u044c \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u0442\u0438\u043d\u0430.", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r415515313", "createdAt": "2020-04-27T05:13:00Z", "author": {"login": "theshadowco"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    var abortCheck = Optional.ofNullable(ctx.funcDeclaration())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf2479a9ab15de37f05a7067a91ce7f0b62a8cf"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwMTg5Mw==", "bodyText": "\u041d\u0443 \u0440\u0430\u0437 \u0442\u0435\u0431\u0435 \u043d\u0443\u0436\u043d\u0430 - \u0434\u0430\u0432\u0430\u0439 \u0441\u0434\u0435\u043b\u0430\u0435\u043c )", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r415601893", "createdAt": "2020-04-27T08:09:57Z", "author": {"login": "otymko"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    var abortCheck = Optional.ofNullable(ctx.funcDeclaration())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUxNTMxMw=="}, "originalCommit": {"oid": "8bf2479a9ab15de37f05a7067a91ce7f0b62a8cf"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4OTMzNQ==", "bodyText": "", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r415989335", "createdAt": "2020-04-27T17:03:22Z", "author": {"login": "otymko"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    var abortCheck = Optional.ofNullable(ctx.funcDeclaration())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUxNTMxMw=="}, "originalCommit": {"oid": "8bf2479a9ab15de37f05a7067a91ce7f0b62a8cf"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzg2ODk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxMTowMlrOGMuSyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzozNjoyNVrOGMvbMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NDU3MA==", "bodyText": "@otymko \u0430 \u0442\u0443\u0442 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442\u0441\u044f \u043d\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u043b\u0438 \u044d\u0442\u043e? \u0410 \u043d\u0435\u0442 \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u043f\u043e\u043f\u0440\u043e\u0449\u0435?", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r415994570", "createdAt": "2020-04-27T17:11:02Z", "author": {"login": "asosnoviy"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticParameter;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  private static final boolean CHECK_ATTACHABLE_METHODS = true;\n+\n+  @DiagnosticParameter(\n+    type = Boolean.class,\n+    defaultValue = \"\" + CHECK_ATTACHABLE_METHODS\n+  )\n+  private boolean checkAttachableMethods = CHECK_ATTACHABLE_METHODS;\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    if (checkAttachableMethods) {\n+      // \u0418\u0441\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b\n+      var abortCheck = Optional.ofNullable(ctx.funcDeclaration())\n+        .map(BSLParser.FuncDeclarationContext::subName)\n+        .filter(subNameContext -> pattern.matcher(subNameContext.getText()).find())\n+        .isPresent();\n+      if (abortCheck) {\n+        return ctx;\n+      }\n+    }\n+\n+    var tree = Trees.findAllRuleNodes(ctx, BSLParser.RULE_returnStatement);\n+    if (tree.size() > 1) {\n+      var expressions = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(BSLParser.ReturnStatementContext::expression)\n+        .flatMap(Stream::ofNullable)\n+        .collect(Collectors.toList());\n+\n+      expressions.stream()\n+        .map(expression -> Trees.findAllRuleNodes(expression, BSLParser.RULE_complexIdentifier))\n+        .filter(Collection::isEmpty)\n+        .findAny()\n+        .ifPresent(\n+          parseTrees -> checkPrimitiveValue(ctx, tree, expressions)\n+        );\n+    }\n+    return ctx;\n+  }\n+\n+  private void checkPrimitiveValue(\n+    BSLParser.FunctionContext ctx, Collection<ParseTree> tree, List<BSLParser.ExpressionContext> expressions) {\n+\n+    var set = expressions.stream()\n+      .map((BSLParser.ExpressionContext expression) -> {\n+        var text = expression.getText();\n+        if (Trees.findAllRuleNodes(expression, BSLParser.RULE_string).isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "406078f2faa521663e0bc245bd226ab56d355776"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMjE0Mw==", "bodyText": "\u0422\u0443\u0442 \u0434\u0432\u0430 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0430. \u041b\u0438\u0431\u043e \u0437\u0430\u0431\u0438\u0442\u044c \u043d\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0441\u0442\u0440\u043e\u043a (\u0442.\u043a. \u043a\u0435\u0439\u0441 \u043d\u0435 \u043f\u043e\u043d\u044f\u0442\u0435\u043d) \u0438\u043b\u0438 \u0438\u0441\u043a\u0430\u0442\u044c \u0432 \u0441\u0442\u0440\u043e\u043a\u0435 \"", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r416002143", "createdAt": "2020-04-27T17:21:56Z", "author": {"login": "otymko"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticParameter;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  private static final boolean CHECK_ATTACHABLE_METHODS = true;\n+\n+  @DiagnosticParameter(\n+    type = Boolean.class,\n+    defaultValue = \"\" + CHECK_ATTACHABLE_METHODS\n+  )\n+  private boolean checkAttachableMethods = CHECK_ATTACHABLE_METHODS;\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    if (checkAttachableMethods) {\n+      // \u0418\u0441\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b\n+      var abortCheck = Optional.ofNullable(ctx.funcDeclaration())\n+        .map(BSLParser.FuncDeclarationContext::subName)\n+        .filter(subNameContext -> pattern.matcher(subNameContext.getText()).find())\n+        .isPresent();\n+      if (abortCheck) {\n+        return ctx;\n+      }\n+    }\n+\n+    var tree = Trees.findAllRuleNodes(ctx, BSLParser.RULE_returnStatement);\n+    if (tree.size() > 1) {\n+      var expressions = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(BSLParser.ReturnStatementContext::expression)\n+        .flatMap(Stream::ofNullable)\n+        .collect(Collectors.toList());\n+\n+      expressions.stream()\n+        .map(expression -> Trees.findAllRuleNodes(expression, BSLParser.RULE_complexIdentifier))\n+        .filter(Collection::isEmpty)\n+        .findAny()\n+        .ifPresent(\n+          parseTrees -> checkPrimitiveValue(ctx, tree, expressions)\n+        );\n+    }\n+    return ctx;\n+  }\n+\n+  private void checkPrimitiveValue(\n+    BSLParser.FunctionContext ctx, Collection<ParseTree> tree, List<BSLParser.ExpressionContext> expressions) {\n+\n+    var set = expressions.stream()\n+      .map((BSLParser.ExpressionContext expression) -> {\n+        var text = expression.getText();\n+        if (Trees.findAllRuleNodes(expression, BSLParser.RULE_string).isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NDU3MA=="}, "originalCommit": {"oid": "406078f2faa521663e0bc245bd226ab56d355776"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMjIwOQ==", "bodyText": "\u041a\u0430\u043f\u0435\u043b\u044c\u043a\u0443 \u043f\u0440\u043e\u0449\u0435 !Trees.nodeContains(expression, BSLParser.RULE_string)", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r416012209", "createdAt": "2020-04-27T17:35:16Z", "author": {"login": "asosnoviy"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticParameter;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  private static final boolean CHECK_ATTACHABLE_METHODS = true;\n+\n+  @DiagnosticParameter(\n+    type = Boolean.class,\n+    defaultValue = \"\" + CHECK_ATTACHABLE_METHODS\n+  )\n+  private boolean checkAttachableMethods = CHECK_ATTACHABLE_METHODS;\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    if (checkAttachableMethods) {\n+      // \u0418\u0441\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b\n+      var abortCheck = Optional.ofNullable(ctx.funcDeclaration())\n+        .map(BSLParser.FuncDeclarationContext::subName)\n+        .filter(subNameContext -> pattern.matcher(subNameContext.getText()).find())\n+        .isPresent();\n+      if (abortCheck) {\n+        return ctx;\n+      }\n+    }\n+\n+    var tree = Trees.findAllRuleNodes(ctx, BSLParser.RULE_returnStatement);\n+    if (tree.size() > 1) {\n+      var expressions = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(BSLParser.ReturnStatementContext::expression)\n+        .flatMap(Stream::ofNullable)\n+        .collect(Collectors.toList());\n+\n+      expressions.stream()\n+        .map(expression -> Trees.findAllRuleNodes(expression, BSLParser.RULE_complexIdentifier))\n+        .filter(Collection::isEmpty)\n+        .findAny()\n+        .ifPresent(\n+          parseTrees -> checkPrimitiveValue(ctx, tree, expressions)\n+        );\n+    }\n+    return ctx;\n+  }\n+\n+  private void checkPrimitiveValue(\n+    BSLParser.FunctionContext ctx, Collection<ParseTree> tree, List<BSLParser.ExpressionContext> expressions) {\n+\n+    var set = expressions.stream()\n+      .map((BSLParser.ExpressionContext expression) -> {\n+        var text = expression.getText();\n+        if (Trees.findAllRuleNodes(expression, BSLParser.RULE_string).isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NDU3MA=="}, "originalCommit": {"oid": "406078f2faa521663e0bc245bd226ab56d355776"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMzEwNA==", "bodyText": "\u0411\u0443\u0434\u0443 \u0437\u043d\u0430\u0442\u044c", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r416013104", "createdAt": "2020-04-27T17:36:25Z", "author": {"login": "otymko"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticParameter;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  private static final boolean CHECK_ATTACHABLE_METHODS = true;\n+\n+  @DiagnosticParameter(\n+    type = Boolean.class,\n+    defaultValue = \"\" + CHECK_ATTACHABLE_METHODS\n+  )\n+  private boolean checkAttachableMethods = CHECK_ATTACHABLE_METHODS;\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    if (checkAttachableMethods) {\n+      // \u0418\u0441\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b\n+      var abortCheck = Optional.ofNullable(ctx.funcDeclaration())\n+        .map(BSLParser.FuncDeclarationContext::subName)\n+        .filter(subNameContext -> pattern.matcher(subNameContext.getText()).find())\n+        .isPresent();\n+      if (abortCheck) {\n+        return ctx;\n+      }\n+    }\n+\n+    var tree = Trees.findAllRuleNodes(ctx, BSLParser.RULE_returnStatement);\n+    if (tree.size() > 1) {\n+      var expressions = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(BSLParser.ReturnStatementContext::expression)\n+        .flatMap(Stream::ofNullable)\n+        .collect(Collectors.toList());\n+\n+      expressions.stream()\n+        .map(expression -> Trees.findAllRuleNodes(expression, BSLParser.RULE_complexIdentifier))\n+        .filter(Collection::isEmpty)\n+        .findAny()\n+        .ifPresent(\n+          parseTrees -> checkPrimitiveValue(ctx, tree, expressions)\n+        );\n+    }\n+    return ctx;\n+  }\n+\n+  private void checkPrimitiveValue(\n+    BSLParser.FunctionContext ctx, Collection<ParseTree> tree, List<BSLParser.ExpressionContext> expressions) {\n+\n+    var set = expressions.stream()\n+      .map((BSLParser.ExpressionContext expression) -> {\n+        var text = expression.getText();\n+        if (Trees.findAllRuleNodes(expression, BSLParser.RULE_string).isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NDU3MA=="}, "originalCommit": {"oid": "406078f2faa521663e0bc245bd226ab56d355776"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzk4ODgzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzozNTozN1rOGMvYng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzozNzoyN1rOGMveRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMjQ0Ng==", "bodyText": "info.getMessage() \u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r416012446", "createdAt": "2020-04-27T17:35:37Z", "author": {"login": "asosnoviy"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticParameter;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  private static final boolean CHECK_ATTACHABLE_METHODS = true;\n+\n+  @DiagnosticParameter(\n+    type = Boolean.class,\n+    defaultValue = \"\" + CHECK_ATTACHABLE_METHODS\n+  )\n+  private boolean checkAttachableMethods = CHECK_ATTACHABLE_METHODS;\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    if (checkAttachableMethods) {\n+      // \u0418\u0441\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b\n+      var abortCheck = Optional.ofNullable(ctx.funcDeclaration())\n+        .map(BSLParser.FuncDeclarationContext::subName)\n+        .filter(subNameContext -> pattern.matcher(subNameContext.getText()).find())\n+        .isPresent();\n+      if (abortCheck) {\n+        return ctx;\n+      }\n+    }\n+\n+    var tree = Trees.findAllRuleNodes(ctx, BSLParser.RULE_returnStatement);\n+    if (tree.size() > 1) {\n+      var expressions = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(BSLParser.ReturnStatementContext::expression)\n+        .flatMap(Stream::ofNullable)\n+        .collect(Collectors.toList());\n+\n+      expressions.stream()\n+        .map(expression -> Trees.findAllRuleNodes(expression, BSLParser.RULE_complexIdentifier))\n+        .filter(Collection::isEmpty)\n+        .findAny()\n+        .ifPresent(\n+          parseTrees -> checkPrimitiveValue(ctx, tree, expressions)\n+        );\n+    }\n+    return ctx;\n+  }\n+\n+  private void checkPrimitiveValue(\n+    BSLParser.FunctionContext ctx, Collection<ParseTree> tree, List<BSLParser.ExpressionContext> expressions) {\n+\n+    var set = expressions.stream()\n+      .map((BSLParser.ExpressionContext expression) -> {\n+        var text = expression.getText();\n+        if (Trees.findAllRuleNodes(expression, BSLParser.RULE_string).isEmpty()) {\n+          text = text.toUpperCase(Locale.ENGLISH);\n+        }\n+        return text;\n+      })\n+      .collect(Collectors.toSet());\n+    if (set.size() == 1) {\n+      var relatedInformation = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(statement -> RelatedInformation.create(\n+          documentContext.getUri(),\n+          Ranges.create(statement.getStart()),\n+          info.getResourceString(KEY_MESSAGE)))\n+        .collect(Collectors.toList());\n+      diagnosticStorage.addDiagnostic(getSubNameRange(ctx), info.getMessage(), relatedInformation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "406078f2faa521663e0bc245bd226ab56d355776"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMzg5Mg==", "bodyText": "", "url": "https://github.com/1c-syntax/bsl-language-server/pull/1118#discussion_r416013892", "createdAt": "2020-04-27T17:37:27Z", "author": {"login": "otymko"}, "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FunctionReturnsSamePrimitiveDiagnostic.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This file is a part of BSL Language Server.\n+ *\n+ * Copyright \u00a9 2018-2020\n+ * Alexey Sosnoviy <labotamy@gmail.com>, Nikita Gryzlov <nixel2007@gmail.com> and contributors\n+ *\n+ * SPDX-License-Identifier: LGPL-3.0-or-later\n+ *\n+ * BSL Language Server is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3.0 of the License, or (at your option) any later version.\n+ *\n+ * BSL Language Server is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with BSL Language Server.\n+ */\n+package com.github._1c_syntax.bsl.languageserver.diagnostics;\n+\n+import com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticInfo;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticMetadata;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticParameter;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticSeverity;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticTag;\n+import com.github._1c_syntax.bsl.languageserver.diagnostics.metadata.DiagnosticType;\n+import com.github._1c_syntax.bsl.languageserver.utils.Ranges;\n+import com.github._1c_syntax.bsl.languageserver.utils.RelatedInformation;\n+import com.github._1c_syntax.bsl.languageserver.utils.Trees;\n+import com.github._1c_syntax.bsl.parser.BSLParser;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@DiagnosticMetadata(\n+  type = DiagnosticType.ERROR,\n+  severity = DiagnosticSeverity.MAJOR,\n+  minutesToFix = 5,\n+  tags = {\n+    DiagnosticTag.DESIGN,\n+    DiagnosticTag.BADPRACTICE\n+  }\n+\n+)\n+public class FunctionReturnsSamePrimitiveDiagnostic extends AbstractVisitorDiagnostic {\n+\n+  private static final String KEY_MESSAGE = \"diagnosticMessageReturnStatement\";\n+  private static final Pattern pattern = Pattern.compile(\n+    \"^(\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0439|attachable)_\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n+\n+  private static final boolean CHECK_ATTACHABLE_METHODS = true;\n+\n+  @DiagnosticParameter(\n+    type = Boolean.class,\n+    defaultValue = \"\" + CHECK_ATTACHABLE_METHODS\n+  )\n+  private boolean checkAttachableMethods = CHECK_ATTACHABLE_METHODS;\n+\n+  public FunctionReturnsSamePrimitiveDiagnostic(DiagnosticInfo info) {\n+    super(info);\n+  }\n+\n+  @Override\n+  public ParseTree visitFunction(BSLParser.FunctionContext ctx) {\n+\n+    if (checkAttachableMethods) {\n+      // \u0418\u0441\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b\n+      var abortCheck = Optional.ofNullable(ctx.funcDeclaration())\n+        .map(BSLParser.FuncDeclarationContext::subName)\n+        .filter(subNameContext -> pattern.matcher(subNameContext.getText()).find())\n+        .isPresent();\n+      if (abortCheck) {\n+        return ctx;\n+      }\n+    }\n+\n+    var tree = Trees.findAllRuleNodes(ctx, BSLParser.RULE_returnStatement);\n+    if (tree.size() > 1) {\n+      var expressions = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(BSLParser.ReturnStatementContext::expression)\n+        .flatMap(Stream::ofNullable)\n+        .collect(Collectors.toList());\n+\n+      expressions.stream()\n+        .map(expression -> Trees.findAllRuleNodes(expression, BSLParser.RULE_complexIdentifier))\n+        .filter(Collection::isEmpty)\n+        .findAny()\n+        .ifPresent(\n+          parseTrees -> checkPrimitiveValue(ctx, tree, expressions)\n+        );\n+    }\n+    return ctx;\n+  }\n+\n+  private void checkPrimitiveValue(\n+    BSLParser.FunctionContext ctx, Collection<ParseTree> tree, List<BSLParser.ExpressionContext> expressions) {\n+\n+    var set = expressions.stream()\n+      .map((BSLParser.ExpressionContext expression) -> {\n+        var text = expression.getText();\n+        if (Trees.findAllRuleNodes(expression, BSLParser.RULE_string).isEmpty()) {\n+          text = text.toUpperCase(Locale.ENGLISH);\n+        }\n+        return text;\n+      })\n+      .collect(Collectors.toSet());\n+    if (set.size() == 1) {\n+      var relatedInformation = tree.stream()\n+        .map(BSLParser.ReturnStatementContext.class::cast)\n+        .map(statement -> RelatedInformation.create(\n+          documentContext.getUri(),\n+          Ranges.create(statement.getStart()),\n+          info.getResourceString(KEY_MESSAGE)))\n+        .collect(Collectors.toList());\n+      diagnosticStorage.addDiagnostic(getSubNameRange(ctx), info.getMessage(), relatedInformation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMjQ0Ng=="}, "originalCommit": {"oid": "406078f2faa521663e0bc245bd226ab56d355776"}, "originalPosition": 128}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4781, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}