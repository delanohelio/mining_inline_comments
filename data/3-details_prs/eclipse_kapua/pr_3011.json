{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MDgzMjky", "number": 3011, "title": "Cache manager review the cache instantiation process", "bodyText": "Signed-off-by: riccardomodanese riccardo.modanese@eurotech.com\nBrief description of the PR.\nKeep CachingProvider and CacheManager instance reference in KapuaCacheManager class\nRelated Issue\nnone\nDescription of the solution adopted\nThe process to create a cache instance involves the creation of a CachingProvider and a CacheManager.\nThe previous implementation creates a new instance of both of them for each cache instantiation.\nNow the CachingProvider and CacheManager are instantiated once and kept as reference for the further getCache invocations.\nThis is perfectly allowed and shouldn't change any cache behavior since from CachingProvider.getCacheManager method javadoc (JCache specification):\n\"Requests a CacheManager configured according to the implementation specific URI that uses the provided ClassLoader for loading underlying classes.\nMultiple calls to this method with the same URI and ClassLoader must return the same CacheManager instance, except if a previously returned CacheManager has been closed.\"\nScreenshots\nnone\nAny side note on the changes made\nnone", "createdAt": "2020-07-03T14:21:57Z", "url": "https://github.com/eclipse/kapua/pull/3011", "merged": true, "mergeCommit": {"oid": "fe4d6744bd29864eca02c7f42c06fffafbd95705"}, "closed": true, "closedAt": "2020-07-03T14:55:18Z", "author": {"login": "riccardomodanese"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxTFELAH2gAyNDQ0MDgzMjkyOjYxOTQ3NDAwMTgyYWIzMzJlNzQwNWZlZDNkY2FjNjljOTdiYmVkMTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxUkU2gFqTQ0MjQ1ODEyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "61947400182ab332e7405fed3dcac69c97bbed17", "author": {"user": {"login": "riccardomodanese", "name": null}}, "url": "https://github.com/eclipse/kapua/commit/61947400182ab332e7405fed3dcac69c97bbed17", "committedDate": "2020-07-03T13:02:06Z", "message": "Cache initilization fix (Using the same CacheManager for all the instantiated caches)\n\nSigned-off-by: riccardomodanese <riccardo.modanese@eurotech.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNDU2NDM3", "url": "https://github.com/eclipse/kapua/pull/3011#pullrequestreview-442456437", "createdAt": "2020-07-03T14:43:01Z", "commit": {"oid": "61947400182ab332e7405fed3dcac69c97bbed17"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNDo0MzowMlrOGsybcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNDo0MzowMlrOGsybcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNjc1Mw==", "bodyText": "I don't think registeredCache.dec() is enough, it should be set to zero, am I wrong ?", "url": "https://github.com/eclipse/kapua/pull/3011#discussion_r449616753", "createdAt": "2020-07-03T14:43:02Z", "author": {"login": "stefanomorson"}, "path": "commons/src/main/java/org/eclipse/kapua/commons/service/internal/cache/KapuaCacheManager.java", "diffHunk": "@@ -97,39 +119,74 @@ private static URI getCacheConfig() {\n             synchronized (CACHE_MAP) {\n                 cache = CACHE_MAP.get(cacheName);\n                 if (cache == null) {\n-                    Factory expiryPolicyFactory;\n-                    if (ExpiryPolicy.TOUCHED.name().equals(EXPIRY_POLICY)) {\n-                        expiryPolicyFactory = TouchedExpiryPolicy.factoryOf(new Duration(TimeUnit.SECONDS, TTL));\n-                    } else {\n-                        expiryPolicyFactory = ModifiedExpiryPolicy.factoryOf(new Duration(TimeUnit.SECONDS, TTL));\n-                    }\n-                    MutableConfiguration<Serializable, Serializable> config = new MutableConfiguration<>();\n-                    config.setExpiryPolicyFactory(expiryPolicyFactory);\n-                    CachingProvider cachingProvider;\n-                    if (CACHING_PROVIDER_CLASS_NAME != null && CACHING_PROVIDER_CLASS_NAME.trim().length() > 0) {\n-                        cachingProvider = Caching.getCachingProvider(CACHING_PROVIDER_CLASS_NAME);\n-                    } else {\n-                        try {\n-                            cachingProvider = Caching.getCachingProvider();\n-                        } catch (CacheException e) {\n-                            LOGGER.warn(\"Error while loading the CachingProvider... Loading the default one ({}).\", DEFAULT_CACHING_PROVIDER_CLASS_NAME);\n-                            cachingProvider = Caching.getCachingProvider(DEFAULT_CACHING_PROVIDER_CLASS_NAME);\n-                        }\n-                    }\n-                    cache = cachingProvider.getCacheManager(CACHE_CONFIG_URI, null).createCache(cacheName, config);\n+                    checkCacheManager();\n+                    cache = cacheManager.createCache(cacheName, initConfig());\n                     CACHE_MAP.put(cacheName, cache);\n+                    registeredCache.inc();\n                     LOGGER.info(\"Created cache: {} - Expiry Policy: {} - TTL: {}\", cacheName, EXPIRY_POLICY, TTL);\n                 }\n             }\n         }\n         return cache;\n     }\n \n+\n+    private static void checkCacheManager() {\n+        //called by synchronized section so no concurrency issues can arise\n+        if (cacheManager == null) {\n+            CachingProvider cachingProvider;\n+            try {\n+                if (!StringUtils.isEmpty(CACHING_PROVIDER_CLASS_NAME)) {\n+                    cachingProvider = Caching.getCachingProvider(CACHING_PROVIDER_CLASS_NAME);\n+                } else {\n+                    cachingProvider = Caching.getCachingProvider();\n+                }\n+                //set the default cache flag\n+                cacheStatus = 1;\n+            } catch (CacheException e) {\n+                //set the \"default cache\" flag (already done by initDefualtCacheProvider)\n+                LOGGER.warn(\"Error while loading the CachingProvider... Loading the default one ({}).\", DEFAULT_CACHING_PROVIDER_CLASS_NAME);\n+                cachingProvider = initDefualtCacheProvider();\n+            }\n+            try {\n+                cacheManager = cachingProvider.getCacheManager(CACHE_CONFIG_URI, null);\n+            }\n+            catch (Exception e) {\n+                //anyway set the \"default cache\" flag (already done by initDefualtCacheProvider)\n+                //second fallback\n+                LOGGER.warn(\"Error while loading the CacheManager... Switching to CachingProvider default ({}). Error: {}\", DEFAULT_CACHING_PROVIDER_CLASS_NAME, e.getMessage(), e);\n+                cachingProvider = initDefualtCacheProvider();\n+                cacheManager = cachingProvider.getCacheManager(CACHE_CONFIG_URI, null);\n+            }\n+        }\n+    }\n+\n+    private static CachingProvider initDefualtCacheProvider() {\n+        //set the default cache flag\n+        cacheStatus = -1;\n+        return Caching.getCachingProvider(DEFAULT_CACHING_PROVIDER_CLASS_NAME);\n+    }\n+\n+    private static MutableConfiguration<Serializable, Serializable> initConfig() {\n+        Factory expiryPolicyFactory;\n+        if (ExpiryPolicy.TOUCHED.name().equals(EXPIRY_POLICY)) {\n+            expiryPolicyFactory = TouchedExpiryPolicy.factoryOf(new Duration(TimeUnit.SECONDS, TTL));\n+        } else {\n+            expiryPolicyFactory = ModifiedExpiryPolicy.factoryOf(new Duration(TimeUnit.SECONDS, TTL));\n+        }\n+        MutableConfiguration<Serializable, Serializable> config = new MutableConfiguration<>();\n+        config.setExpiryPolicyFactory(expiryPolicyFactory);\n+        return config;\n+    }\n+\n     /**\n      * Utility method to cleanup the whole cache.\n      */\n     public static void invalidateAll() {\n-        CACHE_MAP.forEach((cacheKey, cache) -> cache.clear());\n+        CACHE_MAP.forEach((cacheKey, cache) -> {\n+            cache.clear();\n+            registeredCache.dec();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61947400182ab332e7405fed3dcac69c97bbed17"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNDU4MTIx", "url": "https://github.com/eclipse/kapua/pull/3011#pullrequestreview-442458121", "createdAt": "2020-07-03T14:46:10Z", "commit": {"oid": "61947400182ab332e7405fed3dcac69c97bbed17"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 184, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}