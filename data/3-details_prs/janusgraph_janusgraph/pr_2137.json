{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MjY5NjA1", "number": 2137, "title": "Graph Reindexing Issue Fix", "bodyText": "Fix to avoid index corruption after reindexing RelationTypeIndex with direction IN or BOTH\nWhile reindexing RelationTypeIndex, edges are created according to the position of relation arity\n\nSteps to reproduce to the self-link issue:\n\nCreate an Edge label (Assume name is 'link')\nCreate  an property key (Assume name is 'assockind\nBuild an 'Edge Index' by label 'link' and property key 'assockind' with Direction 'IN' or 'BOTH'\nCreate two vertices(let us call it A, B) and add a edge between A and B with label 'link' and some random value (Example : 1) for the property key 'assockind'\nQuery for all the IN edges of vertex A. Make sure the query uses the edge index. This will give no result as there is no IN edge for vertex A\ng.V().has('name' , 'A').inE().hasLabel('link').has('assocKind',1)\nReindex the edge index.\nmgmt.updateIndex(index, SchemaAction.REINDEX).get()\nExecute the Step 3 once again after the reindexing. We can see a self link created for vertex A.\n\nComplete demonstration is provided in below forum post.\nhttps://groups.google.com/forum/#!topic/janusgraph-dev/rZPsk2CDwJ0\nSigned-off-by: Shivaa Krishnan shkrishnan@informatica.com\n\nThank you for contributing to JanusGraph!\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n Is there an issue associated with this PR? Is it referenced in the commit message?\n Does your PR body contain #xyz where xyz is the issue number you are trying to resolve?\n[ x] Has your PR been rebased against the latest commit within the target branch (typically master)?\n Is your initial contribution a single, squashed commit? - Single\n\nFor code changes:\n\n[ x] Have you written and/or updated unit tests to verify your changes?\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n If applicable, have you updated the LICENSE.txt file, including the main LICENSE.txt file in the root of this repository?\n If applicable, have you updated the NOTICE.txt file, including the main NOTICE.txt file found in the root of this repository?\n\nFor documentation related changes:\n\n Have you ensured that format looks appropriate for the output in which it is rendered?\n If this PR is a documentation-only change, have you added a [doc only]\ntag to the first line of your commit message to avoid spending CPU cycles in\nTravis CI when no code, tests, or build configuration are modified?\n\nNote:\nPlease ensure that once the PR is submitted, you check Travis CI for build issues and submit an update to your PR as soon as possible.", "createdAt": "2020-06-16T14:51:20Z", "url": "https://github.com/JanusGraph/janusgraph/pull/2137", "merged": true, "mergeCommit": {"oid": "74ce61665e25915d523810a1314563ac0144c727"}, "closed": true, "closedAt": "2021-03-24T08:26:50Z", "author": {"login": "shkrishn"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7CxFLAFqTQ1OTY3MzYyMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABeF_X7hAFqTYxODc4NTMwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjczNjIx", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459673621", "createdAt": "2020-08-02T19:41:02Z", "commit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MTowMlrOG6nX7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MTowMlrOG6nX7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTY5Mg==", "bodyText": "seems to be unused.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115692", "createdAt": "2020-08-02T19:41:02Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+        getV(graph, c).remove();\n+        \n+    \tclose();\n+    }\n+    \n+\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindOut\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t//add Edge\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \tclose();\n+    }\n+\t\n+\tprivate void initReindexSchema() {\n+\t\tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"vtName\")) {\n+\t\t\tmgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"assocKind\")) {\n+\t\t\tmgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+\t\t}\n+\t}\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tGraphTraversal<Vertex, Edge> result = null; \n+    \t\n+    \tswitch(direction) {\n+    \tcase \"IN\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).inE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"OUT\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).outE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"BOTH\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).bothE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \t}\n+    \t\n+    \torg.junit.Assert.assertNotNull(\"Invalid Direction\",result);\n+    \tint noOfRelations=0;\n+    \twhile(result.hasNext()) {\n+    \t\tEdge next = result.next();\n+    \t\tJanusGraphVertex outVertex = (JanusGraphVertex)next.outVertex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 245}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjczNjM5", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459673639", "createdAt": "2020-08-02T19:41:24Z", "commit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MToyNFrOG6nYCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MToyNFrOG6nYCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTcyMA==", "bodyText": "could you use junit5 assertions.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115720", "createdAt": "2020-08-02T19:41:24Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+        getV(graph, c).remove();\n+        \n+    \tclose();\n+    }\n+    \n+\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindOut\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t//add Edge\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \tclose();\n+    }\n+\t\n+\tprivate void initReindexSchema() {\n+\t\tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"vtName\")) {\n+\t\t\tmgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"assocKind\")) {\n+\t\t\tmgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+\t\t}\n+\t}\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tGraphTraversal<Vertex, Edge> result = null; \n+    \t\n+    \tswitch(direction) {\n+    \tcase \"IN\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).inE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"OUT\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).outE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"BOTH\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).bothE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \t}\n+    \t\n+    \torg.junit.Assert.assertNotNull(\"Invalid Direction\",result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 241}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjczNjkw", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459673690", "createdAt": "2020-08-02T19:42:23Z", "commit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MjoyM1rOG6nYcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MjoyM1rOG6nYcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg==", "bodyText": "Why do you need to run remove?", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115826", "createdAt": "2020-08-02T19:42:23Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 130}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjczODU0", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459673854", "createdAt": "2020-08-02T19:45:04Z", "commit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTowNFrOG6nZrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTowNFrOG6nZrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjE0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n          \n          \n            \n                            Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116141", "createdAt": "2020-08-02T19:45:04Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjczODg2", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459673886", "createdAt": "2020-08-02T19:45:32Z", "commit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTozMlrOG6nZzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTozMlrOG6nZzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjE3NA==", "bodyText": "spacing", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116174", "createdAt": "2020-08-02T19:45:32Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); \n+                        }else if(pos==1) {\n+                        \t//Create IN edge index entry. Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                        \tInternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                        \tthrow new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\t\t//Mutating all OUT relationships for the current vertex", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjczOTE0", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459673914", "createdAt": "2020-08-02T19:45:41Z", "commit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTo0MVrOG6nZ_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTo0MVrOG6nZ_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjIyMw==", "bodyText": "indent", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116223", "createdAt": "2020-08-02T19:45:41Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); \n+                        }else if(pos==1) {\n+                        \t//Create IN edge index entry. Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                        \tInternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                        \tthrow new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\t\t//Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {\n+                \tStaticBuffer otherVertexKey = entry.getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjczOTMw", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459673930", "createdAt": "2020-08-02T19:45:59Z", "commit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTo1OVrOG6naCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTo1OVrOG6naCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjIzNQ==", "bodyText": "indent", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116235", "createdAt": "2020-08-02T19:45:59Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjczOTkz", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459673993", "createdAt": "2020-08-02T19:46:56Z", "commit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5OTM0MzI2", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459934326", "createdAt": "2020-08-03T10:55:41Z", "commit": {"oid": "5ea2b19e585009dcc8c6d76c4ab399a2549c96fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMDo1NTo0MVrOG61G9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMDo1NTo0MVrOG61G9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MDcyNw==", "bodyText": "We use space instead of tabs.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464340727", "createdAt": "2020-08-03T10:55:41Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+\t\t\t\t//Create OUT edge index entry. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea2b19e585009dcc8c6d76c4ab399a2549c96fd"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5OTUwNzMz", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-459950733", "createdAt": "2020-08-03T11:26:36Z", "commit": {"oid": "b17c5035da5c745ff4e08368134700ca744382e4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToyNjozNlrOG615bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToyNjozNlrOG615bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1MzY0Ng==", "bodyText": "You can remove also close.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464353646", "createdAt": "2020-08-03T11:26:36Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,240 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+\t\tclose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b17c5035da5c745ff4e08368134700ca744382e4"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NDQ5NDcw", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-477449470", "createdAt": "2020-08-28T07:58:17Z", "commit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NTc3OTU3", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-494577957", "createdAt": "2020-09-23T11:55:21Z", "commit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTo1NToyMVrOHWo2Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MTozM1rOHWranw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n          \n          \n            \n                                        InternalVertex otherVertex = janusgraphRelation.getVertex(1);", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493499926", "createdAt": "2020-09-23T11:55:21Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyNzUxNQ==", "bodyText": "isReindexed parameter is not used. Anyway, you don't even need a whole method here. I suggest doing\ng.V().has(\"vtName\", \"A\").inE().hasLabel(\"egLabel\").has(\"assoKind\", 1).count().next()\ndirectly, wherever you currently use countOfEdges method.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493527515", "createdAt": "2020-09-23T12:26:06Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {\n+        if(!mgmt.containsEdgeLabel(\"egLabel\")){\n+            mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+        }\n+\n+        if(!mgmt.containsPropertyKey(\"vtName\")) {\n+            mgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+        }\n+\t\t\n+        if(!mgmt.containsPropertyKey(\"assocKind\")) {\n+            mgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+        }\n+    }\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMjEzNA==", "bodyText": "When you put an ancillary method which is for one or more specific scenarios, you'd better not use a seemingly generic name like \"assertEdgeCounts\".", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493532134", "createdAt": "2020-09-23T12:30:57Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {\n+        if(!mgmt.containsEdgeLabel(\"egLabel\")){\n+            mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+        }\n+\n+        if(!mgmt.containsPropertyKey(\"vtName\")) {\n+            mgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+        }\n+\t\t\n+        if(!mgmt.containsPropertyKey(\"assocKind\")) {\n+            mgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+        }\n+    }\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNjgwNQ==", "bodyText": "Looks like the three test cases are very similar, except they have different directions. Can you put most of the common logic into one helper method, e.g. \"testReindexingForEdgeIndex(direction)\", and have 3 very short test cases that use that helper method?", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493536805", "createdAt": "2020-09-23T12:36:02Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MDQ1NA==", "bodyText": "Once you extract test logic into a single helper method, e.g. \"testReindexingForEdgeIndex(direction)\", then you should be able to put the preparation work in that method and dismiss this method.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493540454", "createdAt": "2020-09-23T12:39:59Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MjA0Nw==", "bodyText": "IllegalStateException sounds more suitable to me.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493542047", "createdAt": "2020-09-23T12:41:33Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjE5Mjk0", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-494619294", "createdAt": "2020-09-23T12:45:13Z", "commit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0NToxM1rOHWro_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0NToxM1rOHWro_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0NTcyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                totalInAdditions = inAdditions.size();\n          \n          \n            \n                                totalInAdditions += inAdditions.size();", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493545725", "createdAt": "2020-09-23T12:45:13Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\n+                //Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {\n+                    StaticBuffer otherVertexKey = entry.getKey();\n+                    List<Entry> inAdditions = entry.getValue();\n+                    totalInAdditions = inAdditions.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjIxMTc0", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-494621174", "createdAt": "2020-09-23T12:47:25Z", "commit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0NzoyNVrOHWrxcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0NzoyNVrOHWrxcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0Nzg5MQ==", "bodyText": "Can be just Map.Entry, since you have Map imported.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493547891", "createdAt": "2020-09-23T12:47:25Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\n+                //Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb5d031fee768d667644348b1c1abe36247bd757", "author": {"user": {"login": "shkrishn", "name": "Shivaa Krishnan"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/fb5d031fee768d667644348b1c1abe36247bd757", "committedDate": "2021-01-08T17:07:32Z", "message": "minor code fix"}, "afterCommit": {"oid": "0b732b82ca769ac65179261db9fdbec2b7e6f6ef", "author": {"user": {"login": "shkrishn", "name": "Shivaa Krishnan"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/0b732b82ca769ac65179261db9fdbec2b7e6f6ef", "committedDate": "2021-01-08T17:15:20Z", "message": "minor code fix\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28cc0efe3b834c7240a556ce48f4376b89477397", "author": {"user": {"login": "shkrishn", "name": "Shivaa Krishnan"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/28cc0efe3b834c7240a556ce48f4376b89477397", "committedDate": "2021-01-09T07:54:59Z", "message": "Removed sysouts"}, "afterCommit": {"oid": "3fbfc589d583b7e13881ca345e117bd344cd3c18", "author": {"user": {"login": "shkrishn", "name": "Shivaa Krishnan"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/3fbfc589d583b7e13881ca345e117bd344cd3c18", "committedDate": "2021-01-09T08:04:11Z", "message": "Removed sysouts\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8fda6ea46cac2f1810693aeed61ed451deedb193", "author": {"user": {"login": "shkrishn", "name": "Shivaa Krishnan"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/8fda6ea46cac2f1810693aeed61ed451deedb193", "committedDate": "2021-01-09T08:19:43Z", "message": "Reverting all changes\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>"}, "afterCommit": {"oid": "0b732b82ca769ac65179261db9fdbec2b7e6f6ef", "author": {"user": {"login": "shkrishn", "name": "Shivaa Krishnan"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/0b732b82ca769ac65179261db9fdbec2b7e6f6ef", "committedDate": "2021-01-08T17:15:20Z", "message": "minor code fix\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2MDUyNzA4", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-566052708", "createdAt": "2021-01-12T08:54:20Z", "commit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwODo1NDoyMFrOIR3cfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxMzozNTo0MFrOISBtgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYwNTExNg==", "bodyText": "As @farodin91  suggested, please remove getV(graph, a).remove();, getV(graph, b).remove();\nPlease also remove close(). They are not needed.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555605116", "createdAt": "2021-01-12T08:54:20Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg=="}, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYzODMwOA==", "bodyText": "The clopen here is not needed.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555638308", "createdAt": "2021-01-12T09:45:36Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcwOTMxOA==", "bodyText": "No need to check. You can just create edge labels, property keys, etc. directly.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555709318", "createdAt": "2021-01-12T11:42:12Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexWithDirectionIn = \"edgesByAssocKindIn\";\n+    \tString indexwithDirectionOut = \"edgesByAssocKindOut\";\n+    \tString indexWithDirectionBoth = \"edgesByAssocKindBoth\";\n+    \t\n+    \tString propertyKeyForIn = \"assocKindForIn\";\n+    \tString propertyKeyForOut = \"assocKindForOut\";\n+    \tString propertyKeyForBoth = \"assocKindForBoth\";\n+    \t\n+    \t\n+    \t//Schema creation\n+    \tif(!mgmt.containsEdgeLabel(\"egLabel\")){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc3MzMxMw==", "bodyText": "You can do this:\nEdgeLabel edgeLabel = mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\nso that you don't need to call getEdgeLabel later. Similar for property keys.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555773313", "createdAt": "2021-01-12T13:35:40Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexWithDirectionIn = \"edgesByAssocKindIn\";\n+    \tString indexwithDirectionOut = \"edgesByAssocKindOut\";\n+    \tString indexWithDirectionBoth = \"edgesByAssocKindBoth\";\n+    \t\n+    \tString propertyKeyForIn = \"assocKindForIn\";\n+    \tString propertyKeyForOut = \"assocKindForOut\";\n+    \tString propertyKeyForBoth = \"assocKindForBoth\";\n+    \t\n+    \t\n+    \t//Schema creation\n+    \tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 23}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d3fdbacc825f5512bde365973ac86bb4a34b7a3f", "author": {"user": {"login": "shkrishn", "name": "Shivaa Krishnan"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/d3fdbacc825f5512bde365973ac86bb4a34b7a3f", "committedDate": "2021-01-15T03:34:54Z", "message": "fixed few stylistic issues\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>"}, "afterCommit": {"oid": "52037fbd217e62b6dce1d5a84f55b0889d80d297", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/52037fbd217e62b6dce1d5a84f55b0889d80d297", "committedDate": "2021-01-29T12:45:09Z", "message": "Enhance GraphCentricQuery profiling\n\n1. Indicate \"constructGraphCentricQuery\" phase in profiler rather than a vague\n\"optimization\" annotation, if applicable.\n2. Indicate \"GraphCentricQuery\" in profiler if applicable. Previously profiling result\nis corrupted when a gremlin query is satisfied by multiple graph centric queries.\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238", "author": {"user": {"login": "shkrishn", "name": "Shivaa Krishnan"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/23ca9a20ecea3baad93b292c2c0cb93a1134c238", "committedDate": "2021-01-30T08:47:17Z", "message": "Bug fix related to graph reindexing\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NzQzNjU3", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-579743657", "createdAt": "2021-01-30T09:27:47Z", "commit": {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0zMFQwOToyNzo0N1rOIc8ijw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0zMFQwOToyNzo0N1rOIc8ijw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIyMjkyNw==", "bodyText": "I find that your test case testReindexingForEdgeIndex will pass even if I remove this whole \"else\" branch. There are two possibilities:\n\nYour test case is not effective enough to cover the edge case\nThis is actually not needed. Maybe only the case where pos == 0 is needed.\n\nCan you please investigate if you have some time? Otherwise, I'll take a look later.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r567222927", "createdAt": "2021-01-30T09:27:47Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex(1);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4Nzg1MzA2", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#pullrequestreview-618785306", "createdAt": "2021-03-23T16:07:54Z", "commit": {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNjowNzo1NFrOI77pcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNjowNzo1NFrOI77pcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTcxNDE2Mg==", "bodyText": "Your fix is correct. It's just that your test case is not effective enough. I can provide a subsequent PR to improve the tests.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r599714162", "createdAt": "2021-03-23T16:07:54Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex(1);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIyMjkyNw=="}, "originalCommit": {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4789, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}