{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4OTU5MzY0", "number": 2169, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0ODowNlrOESsYhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxNTowMzoxOFrOE73VMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDM2OTk4OnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0ODowNlrOG4At7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0ODowNlrOG4At7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4NTE5OA==", "bodyText": "@porunov Looks like isExhausted() was removed in driver 4.x but it wasn't replaced by isFullyFetched() as that also existed in version 3.x. From looking at the implementation of currentResultSet.one() I assume that here we should be writing:\n            return currentResultSet.iterator().hasNext();\nThat seems to get a few more tests passing.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r461385198", "createdAt": "2020-07-28T07:48:06Z", "author": {"login": "smcquillan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -450,7 +473,7 @@ public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSuppli\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            return !currentResultSet.isFullyFetched();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bdfeb4543563af4914ad973142b44ed4e42fd11"}, "originalPosition": 462}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTcxNzYzOnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMTowMTo0OVrOG4za9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMTowMTo0OVrOG4za9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNTkyNA==", "bodyText": "@porunov Think I finally now understand the reason why some of the tests are failing with the Mockito exception\norg.mockito.exceptions.misusing.UnnecessaryStubbingException\n\nAnd it's because the session member variable was made final and this prevents the @InjectMocks annotation in CQLStoreTest from injecting the mock session instance which the tests are expecting. When I remove the final qualifier from the session the tests pass for me.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r462215924", "createdAt": "2020-07-29T11:01:49Z", "author": {"login": "smcquillan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLStoreManager.java", "diffHunk": "@@ -148,9 +82,7 @@\n     final ExecutorService executorService;\n \n     @Resource\n-    private Cluster cluster;\n-    @Resource\n-    private Session session;\n+    private final CqlSession session;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39d0a674df18186835aeae295dc05c401a8b1618"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTkxNjE2OnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLStoreManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozMjoxM1rOG5bgBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozMjoxM1rOG5bgBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MjU4Mw==", "bodyText": "@porunov Build is  failing on cassandra3-murmur-ssl with:\njava.lang.IllegalArgumentException: Invalid configuration value for [root.storage.cql.ssl.keystore.location]:\n\nThis is because we're setting the key store options when client auth has not been enabled. So these options need moved out to something like:\n            if(configuration.get(SSL_CLIENT_AUTHENTICATION_ENABLED)) {\n            \tconfigLoaderBuilder.withString(DefaultDriverOption.SSL_KEYSTORE_PATH, configuration.get(SSL_KEYSTORE_LOCATION))\n                                   .withString(DefaultDriverOption.SSL_KEYSTORE_PASSWORD, configuration.get(SSL_KEYSTORE_KEY_PASSWORD));\n            }", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r462872583", "createdAt": "2020-07-30T09:32:13Z", "author": {"login": "smcquillan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLStoreManager.java", "diffHunk": "@@ -227,114 +159,71 @@ public CQLStoreManager(final Configuration configuration) throws BackendExceptio\n         this.openStores = new ConcurrentHashMap<>();\n     }\n \n-    private void initializeJmxMetrics() {\n-        final Configuration configuration = getStorageConfig();\n-        if (configuration.get(METRICS_JMX_ENABLED) && configuration.get(BASIC_METRICS)) {\n-            MetricManager.INSTANCE.getRegistry().registerAll(cluster.getMetrics().getRegistry());\n-        }\n-    }\n-\n-    Cluster initializeCluster() throws PermanentBackendException {\n+    CqlSession initializeSession() throws PermanentBackendException {\n         final Configuration configuration = getStorageConfig();\n \n         final List<InetSocketAddress> contactPoints;\n         try {\n             contactPoints = Array.of(this.hostnames)\n-                    .map(hostName -> hostName.split(\":\"))\n-                    .map(array -> Tuple.of(array[0], array.length == 2 ? Integer.parseInt(array[1]) : this.port))\n-                    .map(tuple -> new InetSocketAddress(tuple._1, tuple._2))\n-                    .toJavaList();\n+                .map(hostName -> hostName.split(\":\"))\n+                .map(array -> Tuple.of(array[0], array.length == 2 ? Integer.parseInt(array[1]) : this.port))\n+                .map(tuple -> new InetSocketAddress(tuple._1, tuple._2))\n+                .toJavaList();\n         } catch (SecurityException | ArrayIndexOutOfBoundsException | NumberFormatException e) {\n             throw new PermanentBackendException(\"Error initialising cluster contact points\", e);\n         }\n \n-        final Builder builder = Cluster.builder()\n-            .withoutJMXReporting()\n-            .addContactPointsWithPorts(contactPoints)\n-            .withClusterName(configuration.get(CLUSTER_NAME));\n+        final CqlSessionBuilder builder = CqlSession.builder()\n+            .addContactPoints(contactPoints)\n+            .withLocalDatacenter(configuration.get(LOCAL_DATACENTER));\n+\n+        ProgrammaticDriverConfigLoaderBuilder configLoaderBuilder = DriverConfigLoader.programmaticBuilder();\n+        configLoaderBuilder.withString(DefaultDriverOption.SESSION_NAME, configuration.get(SESSION_NAME));\n \n         if (configuration.get(PROTOCOL_VERSION) != 0) {\n-            builder.withProtocolVersion(ProtocolVersion.fromInt(configuration.get(PROTOCOL_VERSION)));\n+            configLoaderBuilder.withInt(DefaultDriverOption.PROTOCOL_VERSION, configuration.get(PROTOCOL_VERSION));\n         }\n \n         if (configuration.has(AUTH_USERNAME) && configuration.has(AUTH_PASSWORD)) {\n-            builder.withCredentials(configuration.get(AUTH_USERNAME), configuration.get(AUTH_PASSWORD));\n-        }\n-\n-        if (configuration.has(LOCAL_DATACENTER)) {\n-            builder.withLoadBalancingPolicy(new TokenAwarePolicy(DCAwareRoundRobinPolicy.builder()\n-                    .withLocalDc(configuration.get(LOCAL_DATACENTER))\n-                    .build()));\n+            configLoaderBuilder\n+                .withClass(DefaultDriverOption.AUTH_PROVIDER_CLASS, PlainTextAuthProvider.class)\n+                .withString(DefaultDriverOption.AUTH_PROVIDER_USER_NAME, configuration.get(AUTH_USERNAME))\n+                .withString(DefaultDriverOption.AUTH_PROVIDER_PASSWORD, configuration.get(AUTH_PASSWORD));\n         }\n \n         if (configuration.get(SSL_ENABLED)) {\n-            try {\n-                KeyManager[] keyManagers = null;\n-                if(configuration.get(SSL_CLIENT_AUTHENTICATION_ENABLED)) {\n-                    try (final FileInputStream keyStoreStream = new FileInputStream(configuration.get(SSL_KEYSTORE_LOCATION))) {\n-                        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n-                        keystore.load(keyStoreStream, configuration.get(SSL_KEYSTORE_STORE_PASSWORD).toCharArray());\n-                        final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-                        keyManagerFactory.init(keystore, configuration.get(SSL_KEYSTORE_KEY_PASSWORD).toCharArray());\n-                        keyManagers = keyManagerFactory.getKeyManagers();\n-                    }\n-                }\n-                final TrustManager[] trustManagers;\n-                try (final FileInputStream keyStoreStream = new FileInputStream(configuration.get(SSL_TRUSTSTORE_LOCATION))) {\n-                    final KeyStore keystore = KeyStore.getInstance(\"jks\");\n-                    keystore.load(keyStoreStream, configuration.get(SSL_TRUSTSTORE_PASSWORD).toCharArray());\n-                    final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n-                    trustManagerFactory.init(keystore);\n-                    trustManagers = trustManagerFactory.getTrustManagers();\n-                }\n-\n-                final SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n-                sslContext.init(keyManagers, trustManagers, null);\n-\n-                final JdkSSLOptions sslOptions = JdkSSLOptions.builder()\n-                        .withSSLContext(sslContext)\n-                        .build();\n-                builder.withSSL(sslOptions);\n-\n-            } catch (UnrecoverableKeyException | NoSuchAlgorithmException | CertificateException | IOException | KeyStoreException | KeyManagementException e) {\n-                throw new PermanentBackendException(\"Error initialising SSL connection properties\", e);\n-            }\n+            configLoaderBuilder\n+                .withClass(DefaultDriverOption.SSL_ENGINE_FACTORY_CLASS, DefaultSslEngineFactory.class)\n+                .withString(DefaultDriverOption.SSL_KEYSTORE_PATH, configuration.get(SSL_KEYSTORE_LOCATION))\n+                .withString(DefaultDriverOption.SSL_KEYSTORE_PASSWORD, configuration.get(SSL_KEYSTORE_KEY_PASSWORD))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a623a674c44ee28dd4aaad0769b01e2fe83f8aec"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4Nzg5Mjk1OnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNjowNDoyOFrOH0FsvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMDoyMzo0NVrOH2HqXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg==", "bodyText": "Do you know when this line will be executed? Codecov shows this is not covered. By testing locally, I created a graph with a million vertices and did a full scan, but still, this line was not executed.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r524381372", "createdAt": "2020-11-16T16:04:28Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5MjMzNA==", "bodyText": "Hmm. Interesting. This line should be executed when currentPageIterator has no any elements on this page but there are still some pages available i.e. !currentPageIterator.hasNext() && !currentResultSet.isFullyFetched()", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r524392334", "createdAt": "2020-11-16T16:19:25Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg=="}, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5NTA0Nw==", "bodyText": "Did you have 1,000,000 vertices in currentPageIterator?", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r524395047", "createdAt": "2020-11-16T16:23:08Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg=="}, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5NjI1Ng==", "bodyText": "What was your storeManager.getPageSize()? Did you change storage.page-size parameter?", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r524396256", "createdAt": "2020-11-16T16:24:43Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg=="}, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwODE4MQ==", "bodyText": "Interesting. This line isn't reachable for me as well.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r524408181", "createdAt": "2020-11-16T16:40:24Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg=="}, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcxMDY4Nw==", "bodyText": "I will check that again. Looks like pages are fetched automatically but as far as I remember it wasn't true for the new driver. Maybe something changed or I missed something and pages are fetched automatically in the iterator. I will check that. Nevertheless this logic shouldn't break anything but if this logic is redundant we should remove it to simplify it.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r524710687", "createdAt": "2020-11-16T22:57:24Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg=="}, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEwMjcxNQ==", "bodyText": "Okay, I checked, indeed DSE driver automatically fetches pages but now I see why this iterator was implemented. It has a comment above that automatic DSE pagination could lead to OOM because it was storing the whole history. Thus, we were adding another level of pagination. I will check if it is the issue still and if so will fix this part of the logic. Thank you for catching this!", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r525102715", "createdAt": "2020-11-17T12:03:40Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg=="}, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ1MjY4NQ==", "bodyText": "ExecutionInfo is stored for each new page as seen here:\nhttps://github.com/datastax/java-driver/blob/c225588811a85e25d98790ce4b4f399e0ca066e4/core/src/main/java/com/datastax/dse/driver/internal/core/graph/MultiPageGraphResultSet.java#L108\nSo, potentially it may result in OOM. Thus, I'm changing the logic of this iterator back to forcing new request per page as it was before. It's great that you noticed this issue @li-boxuan ! Thanks!", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r526452685", "createdAt": "2020-11-18T22:03:06Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg=="}, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxMDY4NQ==", "bodyText": "Fixed with explanations here: #2169 (comment)", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r526510685", "createdAt": "2020-11-19T00:23:45Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +444,43 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final Supplier<BatchableStatement<BoundStatement>> statementSupplier;\n \n-        private byte[] lastPagingState = null;\n-\n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n+        public CQLPagingIterator(Supplier<BatchableStatement<BoundStatement>> statementSupplier) {\n             this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(currentPageIterator.hasNext()){\n+                return true;\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;\n+            }\n+            updateResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTM3Mg=="}, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 505}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Njk5MzczOnYy", "diffSide": "RIGHT", "path": "docs/basics/janusgraph-cfg.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNzowODo0MFrOH1fu8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNzowODo0MFrOH1fu8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg1NjQ5Nw==", "bodyText": "The change log says storage.cql.local-datacenter is mandatory now, but config doc still suggests it can be \"unset or set to whitespace\".", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r525856497", "createdAt": "2020-11-18T07:08:40Z", "author": {"login": "li-boxuan"}, "path": "docs/basics/janusgraph-cfg.md", "diffHunk": "@@ -371,29 +371,58 @@ CQL storage backend options\n | ---- | ---- | ---- | ---- | ---- |\n | storage.cql.atomic-batch-mutate | True to use Cassandra atomic batch mutation, false to use non-atomic batches | Boolean | false | MASKABLE |\n | storage.cql.batch-statement-size | The number of statements in each batch | Integer | 20 | MASKABLE |\n-| storage.cql.cluster-name | Default name for the Cassandra cluster | String | JanusGraph Cluster | MASKABLE |\n | storage.cql.compaction-strategy-class | The compaction strategy to use for JanusGraph tables | String | (no default value) | FIXED |\n | storage.cql.compaction-strategy-options | Compaction strategy options.  This list is interpreted as a map.  It must have an even number of elements in [key,val,key,val,...] form. | String[] | (no default value) | FIXED |\n | storage.cql.compression | Whether the storage backend should use compression when storing the data | Boolean | true | FIXED |\n | storage.cql.compression-block-size | The size of the compression blocks in kilobytes | Integer | 64 | FIXED |\n | storage.cql.compression-type | The sstable_compression value JanusGraph uses when creating column families. This accepts any value allowed by Cassandra's sstable_compression option. Leave this unset to disable sstable_compression on JanusGraph-created CFs. | String | LZ4Compressor | MASKABLE |\n+| storage.cql.heartbeat-interval | The connection heartbeat interval in milliseconds. | Long | (no default value) | MASKABLE |\n+| storage.cql.heartbeat-timeout | How long the driver waits for the response (in milliseconds) to a heartbeat. | Long | (no default value) | MASKABLE |\n | storage.cql.keyspace | The name of JanusGraph's keyspace.  It will be created if it does not exist. | String | janusgraph | LOCAL |\n-| storage.cql.local-core-connections-per-host | The number of connections initially created and kept open to each host for local datacenter | Integer | 1 | FIXED |\n-| storage.cql.local-datacenter | The name of the local or closest Cassandra datacenter.  When set and not whitespace, this value will be passed into ConnectionPoolConfigurationImpl.setLocalDatacenter. When unset or set to whitespace, setLocalDatacenter will not be invoked. | String | (no default value) | MASKABLE |\n+| storage.cql.local-datacenter | The name of the local or closest Cassandra datacenter.  When set and not whitespace, this value will be passed into ConnectionPoolConfigurationImpl.setLocalDatacenter. When unset or set to whitespace, setLocalDatacenter will not be invoked. | String | datacenter1 | MASKABLE |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODA3NzUyOnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLConfigOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTo0Njo0N1rOH1qAPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTo0Njo0N1rOH1qAPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAyNDc2NQ==", "bodyText": "nitpick: Missing space after the period. If you search \"between 0 and 5\" you will see the other two places where space is missing between two sentences.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r526024765", "createdAt": "2020-11-18T11:46:47Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLConfigOptions.java", "diffHunk": "@@ -283,6 +284,175 @@\n              * the same Cassandra DC.\n              */\n             ConfigOption.Type.MASKABLE,\n-            String.class);\n-\n+            String.class,\n+        \"datacenter1\");\n+\n+    // Netty\n+\n+    ConfigNamespace NETTY = new ConfigNamespace(\n+        CQL_NS,\n+        \"netty\",\n+        \"Configuration options related to the Netty event loop groups used internally by the CQL driver.\");\n+\n+    ConfigOption<Integer> NETTY_IO_SIZE = new ConfigOption<>(\n+        NETTY,\n+        \"io-size\",\n+        \"The number of threads for the event loop group used for I/O operations \" +\n+            \"(reading and writing to Cassandra nodes). \" +\n+            \"If this is set to 0, the driver will use `Runtime.getRuntime().availableProcessors() * 2`.\",\n+        ConfigOption.Type.LOCAL,\n+        Integer.class,\n+        0);\n+\n+    ConfigOption<Integer> NETTY_ADMIN_SIZE = new ConfigOption<>(\n+        NETTY,\n+        \"admin-size\",\n+        \"The number of threads for the event loop group used for admin tasks not related to request I/O \" +\n+            \"(handle cluster events, refresh metadata, schedule reconnections, etc.). \" +\n+            \"If this is set to 0, the driver will use `Runtime.getRuntime().availableProcessors() * 2`.\",\n+        ConfigOption.Type.LOCAL,\n+        Integer.class,\n+        0);\n+\n+    ConfigOption<Long> NETTY_TIMER_TICK_DURATION = new ConfigOption<>(\n+        NETTY,\n+        \"timer-tick-duration\",\n+        \"The timer tick duration in milliseconds. This is how frequent the timer should wake up to check for timed-out tasks \" +\n+            \"or speculative executions. See DataStax Java Driver option \" +\n+            DefaultDriverOption.NETTY_TIMER_TICK_DURATION.getPath() + \" for more information.\",\n+        ConfigOption.Type.LOCAL,\n+        Long.class);\n+\n+    ConfigOption<Integer> NETTY_TIMER_TICKS_PER_WHEEL = new ConfigOption<>(\n+        NETTY,\n+        \"timer-ticks-per-wheel\",\n+        \"Number of ticks in a Timer wheel. See DataStax Java Driver option \" +\n+            DefaultDriverOption.NETTY_TIMER_TICKS_PER_WHEEL.getPath() + \" for more information.\",\n+        ConfigOption.Type.LOCAL,\n+        Integer.class);\n+\n+    // Metrics\n+\n+    ConfigNamespace METRICS = new ConfigNamespace(\n+        CQL_NS,\n+        \"metrics\",\n+        \"Configuration options for CQL metrics\");\n+\n+    ConfigOption<String[]> METRICS_SESSION_ENABLED = new ConfigOption<>(\n+        METRICS,\n+        \"session-enabled\",\n+        \"Comma separated list of enabled session metrics. Used only when basic metrics are enabled. \" +\n+            \"Check DataStax Cassandra Driver 4 documentation for available metrics \" +\n+            \"(example: bytes-sent, bytes-received, connected-nodes).\",\n+        ConfigOption.Type.LOCAL,\n+        String[].class);\n+\n+    ConfigOption<Long> METRICS_SESSION_REQUESTS_HIGHEST_LATENCY = new ConfigOption<>(\n+        METRICS,\n+        \"cql-requests-highest-latency\",\n+        \"The largest latency that we expect to record for requests in milliseconds. \" +\n+            \"Used if 'cql-requests' session metric is enabled. \"+\n+            \"See DataStax driver configuration option `\"\n+            +DefaultDriverOption.METRICS_SESSION_CQL_REQUESTS_HIGHEST.getPath()+\"`\",\n+        ConfigOption.Type.LOCAL,\n+        Long.class);\n+\n+    ConfigOption<Integer> METRICS_SESSION_REQUESTS_SIGNIFICANT_DIGITS = new ConfigOption<>(\n+        METRICS,\n+        \"cql-requests-significant-digits\",\n+        \"The number of significant decimal digits to which internal structures will maintain value resolution \" +\n+            \"and separation for requests. This must be between 0 and 5.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTIyODQyOnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLConfigOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjowMzo1N1rOH11JOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjowMzo1N1rOH11JOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwNzI5MQ==", "bodyText": "nitpick: missing backquote around DefaultDriverOption.NETTY_TIMER_TICK_DURATION.getPath(). Same for next config option.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r526207291", "createdAt": "2020-11-18T16:03:57Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLConfigOptions.java", "diffHunk": "@@ -283,6 +284,175 @@\n              * the same Cassandra DC.\n              */\n             ConfigOption.Type.MASKABLE,\n-            String.class);\n-\n+            String.class,\n+        \"datacenter1\");\n+\n+    // Netty\n+\n+    ConfigNamespace NETTY = new ConfigNamespace(\n+        CQL_NS,\n+        \"netty\",\n+        \"Configuration options related to the Netty event loop groups used internally by the CQL driver.\");\n+\n+    ConfigOption<Integer> NETTY_IO_SIZE = new ConfigOption<>(\n+        NETTY,\n+        \"io-size\",\n+        \"The number of threads for the event loop group used for I/O operations \" +\n+            \"(reading and writing to Cassandra nodes). \" +\n+            \"If this is set to 0, the driver will use `Runtime.getRuntime().availableProcessors() * 2`.\",\n+        ConfigOption.Type.LOCAL,\n+        Integer.class,\n+        0);\n+\n+    ConfigOption<Integer> NETTY_ADMIN_SIZE = new ConfigOption<>(\n+        NETTY,\n+        \"admin-size\",\n+        \"The number of threads for the event loop group used for admin tasks not related to request I/O \" +\n+            \"(handle cluster events, refresh metadata, schedule reconnections, etc.). \" +\n+            \"If this is set to 0, the driver will use `Runtime.getRuntime().availableProcessors() * 2`.\",\n+        ConfigOption.Type.LOCAL,\n+        Integer.class,\n+        0);\n+\n+    ConfigOption<Long> NETTY_TIMER_TICK_DURATION = new ConfigOption<>(\n+        NETTY,\n+        \"timer-tick-duration\",\n+        \"The timer tick duration in milliseconds. This is how frequent the timer should wake up to check for timed-out tasks \" +\n+            \"or speculative executions. See DataStax Java Driver option \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672bfb0c37039deefedeb7522afc761803b00e81"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDUyMjExOnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjo0NDoyOFrOH2ns5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzowNjo1MlrOH2oyfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzNTYyMg==", "bodyText": "Nice! Just a nitpick:\nNow this line seems unreachable. See codecov: https://app.codecov.io/gh/JanusGraph/janusgraph/compare/2169/diff\nAlso sample test code:\n    @Test\n    public void testPagingIterator() {\n        clopen(option(PAGE_SIZE), 10);\n        int numVertices = 10;\n        for (int i = 0; i < numVertices; i++) {\n            graph.addVertex().property(\"prop\", i);\n        }\n        graph.tx().commit();\n\n        List<Object> values = graph.traversal().V().values(\"prop\").toList();\n        assertEquals(numVertices, values.size());\n        assertEquals(numVertices, new HashSet<>(values).size());\n    }\nSeems the underlying Datastax driver needs to execute the query once more to know that the current result set is fully fetched. Thus this if-statement seems to be useless.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r527035622", "createdAt": "2020-11-19T16:44:28Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +443,48 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n         private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final int paginatedResultSize;\n \n-        private byte[] lastPagingState = null;\n+        private BoundStatement boundStatement;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n+        public CQLPagingIterator(final int pageSize, BoundStatement boundStatement) {\n             this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            this.boundStatement = boundStatement;\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(index<paginatedResultSize){\n+                return currentPageIterator.hasNext();\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eba708f181a22ce9e7698f7a1d8d449c0d132e45"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0MDQ2Nw==", "bodyText": "Interestingly, this line is reachable and is necessary when paginatedResultSize is negative. Seems Datastax driver allows negative value, simply ignores it, and uses the default value. If we don't have this if-statement, our program will go into an endless loop.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r527040467", "createdAt": "2020-11-19T16:50:37Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +443,48 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n         private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final int paginatedResultSize;\n \n-        private byte[] lastPagingState = null;\n+        private BoundStatement boundStatement;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n+        public CQLPagingIterator(final int pageSize, BoundStatement boundStatement) {\n             this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            this.boundStatement = boundStatement;\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(index<paginatedResultSize){\n+                return currentPageIterator.hasNext();\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzNTYyMg=="}, "originalCommit": {"oid": "eba708f181a22ce9e7698f7a1d8d449c0d132e45"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0MzEyOA==", "bodyText": "The following test case fails under CQLGraphTest but can pass InMemoryGraphTest & BerkeleyGraphTest:\n    @Test\n    public void testPagingIterator() {\n        clopen(option(PAGE_SIZE), -1);\n        int numVertices = 10;\n        for (int i = 0; i < numVertices; i++) {\n            graph.addVertex().property(\"prop\", i);\n        }\n        graph.tx().commit();\n\n        List<Object> values = graph.traversal().V().values(\"prop\").toList();\n        assertEquals(numVertices, values.size());\n        assertEquals(numVertices, new HashSet<>(values).size());\n    }\ndidn't check thoroughly but I guess it's because the implementation here assumes paging size is non-negative.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r527043128", "createdAt": "2020-11-19T16:54:25Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +443,48 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n         private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final int paginatedResultSize;\n \n-        private byte[] lastPagingState = null;\n+        private BoundStatement boundStatement;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n+        public CQLPagingIterator(final int pageSize, BoundStatement boundStatement) {\n             this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            this.boundStatement = boundStatement;\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(index<paginatedResultSize){\n+                return currentPageIterator.hasNext();\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzNTYyMg=="}, "originalCommit": {"oid": "eba708f181a22ce9e7698f7a1d8d449c0d132e45"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1MzQzOQ==", "bodyText": "Oh, didn't think about this edge case. For some reason I thought that negative value isn't allowed. I will fix that", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r527053439", "createdAt": "2020-11-19T17:06:52Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -434,43 +443,48 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n     private class CQLPagingIterator implements Iterator<Row> {\n \n         private ResultSet currentResultSet;\n+        private java.util.Iterator<Row> currentPageIterator;\n \n         private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n+        private final int paginatedResultSize;\n \n-        private byte[] lastPagingState = null;\n+        private BoundStatement boundStatement;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n+        public CQLPagingIterator(final int pageSize, BoundStatement boundStatement) {\n             this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+            this.boundStatement = boundStatement;\n+            updateResultSet();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            if(index<paginatedResultSize){\n+                return currentPageIterator.hasNext();\n+            }\n+            if(currentResultSet.isFullyFetched()){\n+                return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzNTYyMg=="}, "originalCommit": {"oid": "eba708f181a22ce9e7698f7a1d8d449c0d132e45"}, "originalPosition": 512}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTAwMDYwOnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODozNjowOVrOH2sV2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODozNjowOVrOH2sV2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzExMTY0Mw==", "bodyText": "This part should be unreachable in most cases. The possible case I think about when this part is actually reachable is when we have storage.page-size=1 and call next(); hasNext(); next();. In such case it's possible that during the last next() operation our dseStoredExecutionInfos.size() will be equal to 3. In normal scenarios when we always call hasNext() before next() we shouldn't reach this else case.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r527111643", "createdAt": "2020-11-19T18:36:09Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -414,63 +423,50 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n         return Try.of(() -> new CQLResultSetKeyIterator(\n                 query,\n                 this.getter,\n-                new CQLPagingIterator(this.storeManager.getPageSize(), () ->\n-                    getKeysAll.bind()\n-                        .setBytes(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n-                        .setBytes(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n-                        .setFetchSize(this.storeManager.getPageSize())\n-                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()))))\n+                new CQLPagingIterator(\n+                    getKeysAll.boundStatementBuilder()\n+                        .setByteBuffer(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n+                        .setByteBuffer(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n+                        .setPageSize(this.storeManager.getPageSize())\n+                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()).build())))\n                 .getOrElseThrow(EXCEPTION_MAPPER);\n     }\n \n     /**\n      * This class provides a paging implementation that sits on top of the DSE Cassandra driver. The driver already\n      * has its own built in paging support but this has limitations when doing a full scan of the key ring due\n      * to how driver paging metadata is stored. The driver stores a full history of a given query's paging metadata\n-     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by doing another level\n-     * of paging that re-executes the query after a configurable number of rows. When the original query is re-executed\n-     * it is initialized to the correct offset using the last page's metadata.\n+     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by forcing the internal\n+     * metadata which isn't needed anymore to be deleted to be free for GC.\n      */\n     private class CQLPagingIterator implements Iterator<Row> {\n \n-        private ResultSet currentResultSet;\n-\n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n-\n-        private byte[] lastPagingState = null;\n+        private final List<ExecutionInfo> dseStoredExecutionInfos;\n+        private final java.util.Iterator<Row> currentPageIterator;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+        public CQLPagingIterator(BoundStatement boundStatement) {\n+            ResultSet currentResultSet = session.execute(boundStatement);\n+            currentPageIterator = currentResultSet.iterator();\n+            this.dseStoredExecutionInfos = currentResultSet.getExecutionInfos();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            return currentPageIterator.hasNext();\n         }\n \n         @Override\n         public Row next() {\n-            if(index == paginatedResultSize) {\n-                currentResultSet = getResultSet();\n-                this.index = 0;\n-            }\n-            this.index++;\n-            lastPagingState = currentResultSet.getExecutionInfo().getPagingStateUnsafe();\n-            return currentResultSet.one();\n-\n-        }\n-\n-        private ResultSet getResultSet() {\n-            final Statement boundStmnt = statementSupplier.get();\n-            if (lastPagingState != null) {\n-                boundStmnt.setPagingStateUnsafe(lastPagingState);\n+            if(dseStoredExecutionInfos.size()>1){\n+                if(dseStoredExecutionInfos.size()==2){\n+                    dseStoredExecutionInfos.set(0, dseStoredExecutionInfos.remove(1));\n+                } else {\n+                    ExecutionInfo lastExecutionInfo = dseStoredExecutionInfos.get(dseStoredExecutionInfos.size()-1);\n+                    dseStoredExecutionInfos.clear();\n+                    dseStoredExecutionInfos.add(lastExecutionInfo);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70321725c0cd1be7a40ceedd36a43a94127d0eb1"}, "originalPosition": 543}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTAyMDY0OnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODo0MTozOVrOH2siDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODo0MTozOVrOH2siDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzExNDc2Nw==", "bodyText": "Current DSE ResultSet implementations return mutable ArrayList when getExecutionInfos() is called. The only case when this list is Immutable is when SinglePageResultSet is used but we won't mutate that list because it always has the size of 1. Thus, it's not possible to enter this if statement with that Immutable list.", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r527114767", "createdAt": "2020-11-19T18:41:39Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -414,63 +423,50 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n         return Try.of(() -> new CQLResultSetKeyIterator(\n                 query,\n                 this.getter,\n-                new CQLPagingIterator(this.storeManager.getPageSize(), () ->\n-                    getKeysAll.bind()\n-                        .setBytes(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n-                        .setBytes(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n-                        .setFetchSize(this.storeManager.getPageSize())\n-                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()))))\n+                new CQLPagingIterator(\n+                    getKeysAll.boundStatementBuilder()\n+                        .setByteBuffer(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n+                        .setByteBuffer(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n+                        .setPageSize(this.storeManager.getPageSize())\n+                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()).build())))\n                 .getOrElseThrow(EXCEPTION_MAPPER);\n     }\n \n     /**\n      * This class provides a paging implementation that sits on top of the DSE Cassandra driver. The driver already\n      * has its own built in paging support but this has limitations when doing a full scan of the key ring due\n      * to how driver paging metadata is stored. The driver stores a full history of a given query's paging metadata\n-     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by doing another level\n-     * of paging that re-executes the query after a configurable number of rows. When the original query is re-executed\n-     * it is initialized to the correct offset using the last page's metadata.\n+     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by forcing the internal\n+     * metadata which isn't needed anymore to be deleted to be free for GC.\n      */\n     private class CQLPagingIterator implements Iterator<Row> {\n \n-        private ResultSet currentResultSet;\n-\n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n-\n-        private byte[] lastPagingState = null;\n+        private final List<ExecutionInfo> dseStoredExecutionInfos;\n+        private final java.util.Iterator<Row> currentPageIterator;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+        public CQLPagingIterator(BoundStatement boundStatement) {\n+            ResultSet currentResultSet = session.execute(boundStatement);\n+            currentPageIterator = currentResultSet.iterator();\n+            this.dseStoredExecutionInfos = currentResultSet.getExecutionInfos();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            return currentPageIterator.hasNext();\n         }\n \n         @Override\n         public Row next() {\n-            if(index == paginatedResultSize) {\n-                currentResultSet = getResultSet();\n-                this.index = 0;\n-            }\n-            this.index++;\n-            lastPagingState = currentResultSet.getExecutionInfo().getPagingStateUnsafe();\n-            return currentResultSet.one();\n-\n-        }\n-\n-        private ResultSet getResultSet() {\n-            final Statement boundStmnt = statementSupplier.get();\n-            if (lastPagingState != null) {\n-                boundStmnt.setPagingStateUnsafe(lastPagingState);\n+            if(dseStoredExecutionInfos.size()>1){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70321725c0cd1be7a40ceedd36a43a94127d0eb1"}, "originalPosition": 536}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjA3OTg3OnYy", "diffSide": "RIGHT", "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxNTowMzoxOFrOH3vHRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxOTo0ODoxM1rOH3w7dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNTYzOQ==", "bodyText": "What about dseStoredExecutionInfos.remove(0)? Actually, if we simply do dseStoredExecutionInfos.remove(0), or use your code in the else branch, then we don't need two branches at all. Is there any specific reason to keep the if(dseStoredExecutionInfos.size()==2) condition here?", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r528205639", "createdAt": "2020-11-21T15:03:18Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -414,63 +423,50 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n         return Try.of(() -> new CQLResultSetKeyIterator(\n                 query,\n                 this.getter,\n-                new CQLPagingIterator(this.storeManager.getPageSize(), () ->\n-                    getKeysAll.bind()\n-                        .setBytes(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n-                        .setBytes(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n-                        .setFetchSize(this.storeManager.getPageSize())\n-                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()))))\n+                new CQLPagingIterator(\n+                    getKeysAll.boundStatementBuilder()\n+                        .setByteBuffer(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n+                        .setByteBuffer(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n+                        .setPageSize(this.storeManager.getPageSize())\n+                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()).build())))\n                 .getOrElseThrow(EXCEPTION_MAPPER);\n     }\n \n     /**\n      * This class provides a paging implementation that sits on top of the DSE Cassandra driver. The driver already\n      * has its own built in paging support but this has limitations when doing a full scan of the key ring due\n      * to how driver paging metadata is stored. The driver stores a full history of a given query's paging metadata\n-     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by doing another level\n-     * of paging that re-executes the query after a configurable number of rows. When the original query is re-executed\n-     * it is initialized to the correct offset using the last page's metadata.\n+     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by forcing the internal\n+     * metadata which isn't needed anymore to be deleted to be free for GC.\n      */\n     private class CQLPagingIterator implements Iterator<Row> {\n \n-        private ResultSet currentResultSet;\n-\n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n-\n-        private byte[] lastPagingState = null;\n+        private final List<ExecutionInfo> dseStoredExecutionInfos;\n+        private final java.util.Iterator<Row> currentPageIterator;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+        public CQLPagingIterator(BoundStatement boundStatement) {\n+            ResultSet currentResultSet = session.execute(boundStatement);\n+            currentPageIterator = currentResultSet.iterator();\n+            this.dseStoredExecutionInfos = currentResultSet.getExecutionInfos();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            return currentPageIterator.hasNext();\n         }\n \n         @Override\n         public Row next() {\n-            if(index == paginatedResultSize) {\n-                currentResultSet = getResultSet();\n-                this.index = 0;\n-            }\n-            this.index++;\n-            lastPagingState = currentResultSet.getExecutionInfo().getPagingStateUnsafe();\n-            return currentResultSet.one();\n-\n-        }\n-\n-        private ResultSet getResultSet() {\n-            final Statement boundStmnt = statementSupplier.get();\n-            if (lastPagingState != null) {\n-                boundStmnt.setPagingStateUnsafe(lastPagingState);\n+            if(dseStoredExecutionInfos.size()>1){\n+                if(dseStoredExecutionInfos.size()==2){\n+                    dseStoredExecutionInfos.set(0, dseStoredExecutionInfos.remove(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70321725c0cd1be7a40ceedd36a43a94127d0eb1"}, "originalPosition": 538}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxNjQwMA==", "bodyText": "dseStoredExecutionInfos.remove(0) - will remove only the first element. So, if there are 3 elements 2 elements will be left. So, in case we execute next(); hasNext(); next(); hasNext(); next(); hasNext(); with page size 1 it will produce 5 elements in dseStoredExecutionInfos because on next(); hasNext(); we are adding 2 elments but on nest() we are removing only 1 element.\ndseStoredExecutionInfos.remove(0) and dseStoredExecutionInfos.set(0, dseStoredExecutionInfos.remove(1)) are kind of the same if the size == 2 but when we execute dseStoredExecutionInfos.remove(1) we are not triggering System.arraycopy because we removed the last element and when we execute dseStoredExecutionInfos.remove(0) we trigger that. From another hand System.arraycopy will copy just 1 element, thus it will be fast. I just thought that dseStoredExecutionInfos.set(0, dseStoredExecutionInfos.remove(1)) would be several operations faster then dseStoredExecutionInfos.remove(0) but it shouldn't be much difference and I didn't really compare the performance. Just assumed", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r528216400", "createdAt": "2020-11-21T16:44:40Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -414,63 +423,50 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n         return Try.of(() -> new CQLResultSetKeyIterator(\n                 query,\n                 this.getter,\n-                new CQLPagingIterator(this.storeManager.getPageSize(), () ->\n-                    getKeysAll.bind()\n-                        .setBytes(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n-                        .setBytes(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n-                        .setFetchSize(this.storeManager.getPageSize())\n-                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()))))\n+                new CQLPagingIterator(\n+                    getKeysAll.boundStatementBuilder()\n+                        .setByteBuffer(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n+                        .setByteBuffer(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n+                        .setPageSize(this.storeManager.getPageSize())\n+                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()).build())))\n                 .getOrElseThrow(EXCEPTION_MAPPER);\n     }\n \n     /**\n      * This class provides a paging implementation that sits on top of the DSE Cassandra driver. The driver already\n      * has its own built in paging support but this has limitations when doing a full scan of the key ring due\n      * to how driver paging metadata is stored. The driver stores a full history of a given query's paging metadata\n-     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by doing another level\n-     * of paging that re-executes the query after a configurable number of rows. When the original query is re-executed\n-     * it is initialized to the correct offset using the last page's metadata.\n+     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by forcing the internal\n+     * metadata which isn't needed anymore to be deleted to be free for GC.\n      */\n     private class CQLPagingIterator implements Iterator<Row> {\n \n-        private ResultSet currentResultSet;\n-\n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n-\n-        private byte[] lastPagingState = null;\n+        private final List<ExecutionInfo> dseStoredExecutionInfos;\n+        private final java.util.Iterator<Row> currentPageIterator;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+        public CQLPagingIterator(BoundStatement boundStatement) {\n+            ResultSet currentResultSet = session.execute(boundStatement);\n+            currentPageIterator = currentResultSet.iterator();\n+            this.dseStoredExecutionInfos = currentResultSet.getExecutionInfos();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            return currentPageIterator.hasNext();\n         }\n \n         @Override\n         public Row next() {\n-            if(index == paginatedResultSize) {\n-                currentResultSet = getResultSet();\n-                this.index = 0;\n-            }\n-            this.index++;\n-            lastPagingState = currentResultSet.getExecutionInfo().getPagingStateUnsafe();\n-            return currentResultSet.one();\n-\n-        }\n-\n-        private ResultSet getResultSet() {\n-            final Statement boundStmnt = statementSupplier.get();\n-            if (lastPagingState != null) {\n-                boundStmnt.setPagingStateUnsafe(lastPagingState);\n+            if(dseStoredExecutionInfos.size()>1){\n+                if(dseStoredExecutionInfos.size()==2){\n+                    dseStoredExecutionInfos.set(0, dseStoredExecutionInfos.remove(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNTYzOQ=="}, "originalCommit": {"oid": "70321725c0cd1be7a40ceedd36a43a94127d0eb1"}, "originalPosition": 538}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxNzIxMQ==", "bodyText": "Ah, I got it. I misunderstood second part. You are right. We don't need 2 branches if we use the code in else branch. I was just optimizing usage of unnecessary operations here but I think it just made the code more complex", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r528217211", "createdAt": "2020-11-21T16:51:51Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -414,63 +423,50 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n         return Try.of(() -> new CQLResultSetKeyIterator(\n                 query,\n                 this.getter,\n-                new CQLPagingIterator(this.storeManager.getPageSize(), () ->\n-                    getKeysAll.bind()\n-                        .setBytes(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n-                        .setBytes(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n-                        .setFetchSize(this.storeManager.getPageSize())\n-                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()))))\n+                new CQLPagingIterator(\n+                    getKeysAll.boundStatementBuilder()\n+                        .setByteBuffer(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n+                        .setByteBuffer(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n+                        .setPageSize(this.storeManager.getPageSize())\n+                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()).build())))\n                 .getOrElseThrow(EXCEPTION_MAPPER);\n     }\n \n     /**\n      * This class provides a paging implementation that sits on top of the DSE Cassandra driver. The driver already\n      * has its own built in paging support but this has limitations when doing a full scan of the key ring due\n      * to how driver paging metadata is stored. The driver stores a full history of a given query's paging metadata\n-     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by doing another level\n-     * of paging that re-executes the query after a configurable number of rows. When the original query is re-executed\n-     * it is initialized to the correct offset using the last page's metadata.\n+     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by forcing the internal\n+     * metadata which isn't needed anymore to be deleted to be free for GC.\n      */\n     private class CQLPagingIterator implements Iterator<Row> {\n \n-        private ResultSet currentResultSet;\n-\n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n-\n-        private byte[] lastPagingState = null;\n+        private final List<ExecutionInfo> dseStoredExecutionInfos;\n+        private final java.util.Iterator<Row> currentPageIterator;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+        public CQLPagingIterator(BoundStatement boundStatement) {\n+            ResultSet currentResultSet = session.execute(boundStatement);\n+            currentPageIterator = currentResultSet.iterator();\n+            this.dseStoredExecutionInfos = currentResultSet.getExecutionInfos();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            return currentPageIterator.hasNext();\n         }\n \n         @Override\n         public Row next() {\n-            if(index == paginatedResultSize) {\n-                currentResultSet = getResultSet();\n-                this.index = 0;\n-            }\n-            this.index++;\n-            lastPagingState = currentResultSet.getExecutionInfo().getPagingStateUnsafe();\n-            return currentResultSet.one();\n-\n-        }\n-\n-        private ResultSet getResultSet() {\n-            final Statement boundStmnt = statementSupplier.get();\n-            if (lastPagingState != null) {\n-                boundStmnt.setPagingStateUnsafe(lastPagingState);\n+            if(dseStoredExecutionInfos.size()>1){\n+                if(dseStoredExecutionInfos.size()==2){\n+                    dseStoredExecutionInfos.set(0, dseStoredExecutionInfos.remove(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNTYzOQ=="}, "originalCommit": {"oid": "70321725c0cd1be7a40ceedd36a43a94127d0eb1"}, "originalPosition": 538}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNTM4MQ==", "bodyText": "Updated the code as you suggested here: https://github.com/JanusGraph/janusgraph/compare/70321725c0cd1be7a40ceedd36a43a94127d0eb1..65cad01828f1a455cc51435f8efaf309111c0768", "url": "https://github.com/JanusGraph/janusgraph/pull/2169#discussion_r528235381", "createdAt": "2020-11-21T19:48:13Z", "author": {"login": "porunov"}, "path": "janusgraph-cql/src/main/java/org/janusgraph/diskstorage/cql/CQLKeyColumnValueStore.java", "diffHunk": "@@ -414,63 +423,50 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t\n         return Try.of(() -> new CQLResultSetKeyIterator(\n                 query,\n                 this.getter,\n-                new CQLPagingIterator(this.storeManager.getPageSize(), () ->\n-                    getKeysAll.bind()\n-                        .setBytes(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n-                        .setBytes(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n-                        .setFetchSize(this.storeManager.getPageSize())\n-                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()))))\n+                new CQLPagingIterator(\n+                    getKeysAll.boundStatementBuilder()\n+                        .setByteBuffer(SLICE_START_BINDING, query.getSliceStart().asByteBuffer())\n+                        .setByteBuffer(SLICE_END_BINDING, query.getSliceEnd().asByteBuffer())\n+                        .setPageSize(this.storeManager.getPageSize())\n+                        .setConsistencyLevel(getTransaction(txh).getReadConsistencyLevel()).build())))\n                 .getOrElseThrow(EXCEPTION_MAPPER);\n     }\n \n     /**\n      * This class provides a paging implementation that sits on top of the DSE Cassandra driver. The driver already\n      * has its own built in paging support but this has limitations when doing a full scan of the key ring due\n      * to how driver paging metadata is stored. The driver stores a full history of a given query's paging metadata\n-     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by doing another level\n-     * of paging that re-executes the query after a configurable number of rows. When the original query is re-executed\n-     * it is initialized to the correct offset using the last page's metadata.\n+     * which can lead to OOM issues on non-trivially sized data sets. This class overcomes this by forcing the internal\n+     * metadata which isn't needed anymore to be deleted to be free for GC.\n      */\n     private class CQLPagingIterator implements Iterator<Row> {\n \n-        private ResultSet currentResultSet;\n-\n-        private int index;\n-        private int paginatedResultSize;\n-        private final Supplier<Statement> statementSupplier;\n-\n-        private byte[] lastPagingState = null;\n+        private final List<ExecutionInfo> dseStoredExecutionInfos;\n+        private final java.util.Iterator<Row> currentPageIterator;\n \n-        public CQLPagingIterator(final int pageSize, Supplier<Statement> statementSupplier) {\n-            this.index = 0;\n-            this.paginatedResultSize = pageSize;\n-            this.statementSupplier = statementSupplier;\n-            this.currentResultSet = getResultSet();\n+        public CQLPagingIterator(BoundStatement boundStatement) {\n+            ResultSet currentResultSet = session.execute(boundStatement);\n+            currentPageIterator = currentResultSet.iterator();\n+            this.dseStoredExecutionInfos = currentResultSet.getExecutionInfos();\n         }\n \n         @Override\n         public boolean hasNext() {\n-            return !currentResultSet.isExhausted();\n+            return currentPageIterator.hasNext();\n         }\n \n         @Override\n         public Row next() {\n-            if(index == paginatedResultSize) {\n-                currentResultSet = getResultSet();\n-                this.index = 0;\n-            }\n-            this.index++;\n-            lastPagingState = currentResultSet.getExecutionInfo().getPagingStateUnsafe();\n-            return currentResultSet.one();\n-\n-        }\n-\n-        private ResultSet getResultSet() {\n-            final Statement boundStmnt = statementSupplier.get();\n-            if (lastPagingState != null) {\n-                boundStmnt.setPagingStateUnsafe(lastPagingState);\n+            if(dseStoredExecutionInfos.size()>1){\n+                if(dseStoredExecutionInfos.size()==2){\n+                    dseStoredExecutionInfos.set(0, dseStoredExecutionInfos.remove(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNTYzOQ=="}, "originalCommit": {"oid": "70321725c0cd1be7a40ceedd36a43a94127d0eb1"}, "originalPosition": 538}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1332, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}