{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NzUwMjc3", "number": 2195, "title": "Optimize performance of transaction-wise index query cache", "bodyText": "This refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\nCloses #2194\n\nThank you for contributing to JanusGraph!\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n Is there an issue associated with this PR? Is it referenced in the commit message?\n Does your PR body contain #xyz where xyz is the issue number you are trying to resolve?\n Has your PR been rebased against the latest commit within the target branch (typically master)?\n Is your initial contribution a single, squashed commit?\n\nFor code changes:\n\n Have you written and/or updated unit tests to verify your changes?\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n If applicable, have you updated the LICENSE.txt file, including the main LICENSE.txt file in the root of this repository?\n If applicable, have you updated the NOTICE.txt file, including the main NOTICE.txt file found in the root of this repository?\n\nFor documentation related changes:\n\n Have you ensured that format looks appropriate for the output in which it is rendered?\n If this PR is a documentation-only change, have you added a [doc only]\ntag to the first line of your commit message to avoid spending CPU cycles in\nTravis CI when no code, tests, or build configuration are modified?\n\nNote:\nPlease ensure that once the PR is submitted, you check Travis CI for build issues and submit an update to your PR as soon as possible.", "createdAt": "2020-08-29T09:28:01Z", "url": "https://github.com/JanusGraph/janusgraph/pull/2195", "merged": true, "mergeCommit": {"oid": "bb5daf26138f840459e35ed84d7234f797abdaba"}, "closed": true, "closedAt": "2021-01-02T14:01:14Z", "author": {"login": "li-boxuan"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdGe-j8AFqTQ4MzM0NDgxNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdsNAaPgBqjQxNjE2OTkwMTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMzQ0ODE1", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#pullrequestreview-483344815", "createdAt": "2020-09-07T08:13:58Z", "commit": {"oid": "599b6b8beed017644ebef8283b69c47c5a11fbc5"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwODoxMzo1OVrOHN1ONQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwODo0Mjo0MVrOHN2QFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NTUyNQ==", "bodyText": "Nitpick: Do values and limit have to be modifiable once their values are set by the constructor?", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484265525", "createdAt": "2020-09-07T08:13:59Z", "author": {"login": "rngcntr"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/subquerycache/SubqueryCache.java", "diffHunk": "@@ -0,0 +1,112 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.transaction.subquerycache;\n+\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+/**\n+ * Cache for {@link JointIndexQuery.Subquery} results. Cache entries are manually added using\n+ * {@link #get(JointIndexQuery.Subquery, Callable)} or {@link #put(JointIndexQuery.Subquery, List)},\n+ * and stored in the cache until evicted or invalidated.\n+ * <p>\n+ * Different from a simple exact mapping from keys to values,\n+ * it leverages the fact that the results of a Subquery A with limit X are first X entries of the results of the\n+ * a Subquery B with limit Y, where A and B only differ in limit, and X is less than or equal to Y.\n+ * <p>\n+ * For example, suppose the cache is empty at the beginning. Firstly, prop1_idx:multiKSQ[1]@100 query leads to a cache\n+ * miss, and then results are loaded into cache. Secondly, prop1_idx:multiKSQ[1]@20 query leads to a cache hit, and\n+ * then first 20 results of cached responses are returned. Thirdly, prop1_idx:multiKSQ[1]@2000 leads to a cache miss,\n+ * then results are loaded into cache, and initial results saved by prop1_idx:multiKSQ[1]@100 query are overriden by\n+ * the new results.\n+ * <p>\n+ * Internally, raw query results are encapsulated in {@link SubqueryResult} object together with limit of the query.\n+ * Meanwhile, keys are stored without limit (or with a dummy limit). Whenever there is a hit for key, the limit of\n+ * cached results and that of the query will be compared, and whether this is a cache hit or miss will be determined.\n+ * <p>\n+ * Compared to a simply {@link JointIndexQuery.Subquery} to {@code List<Object>} mapping, this cache has two benefits:\n+ * 1) it reduces latency, as \"subset\" queries can effectively leverage cached results.\n+ * 2) it saves space, as queries only differing in limit will not be saved more than once in cache.\n+ *\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public interface SubqueryCache {\n+\n+    /**\n+     * Return a list of results if given query exists in cache, otherwise\n+     * return null\n+     *\n+     * @param query a subquery of joint index query\n+     * @return a list of matching results or null if is not in the cache\n+     */\n+    List<Object> getIfPresent(JointIndexQuery.Subquery query);\n+\n+    /**\n+     * Add given values into cache\n+     *\n+     * @param query  a subquery of joint index query\n+     * @param values a list of results to be cached\n+     */\n+    void put(JointIndexQuery.Subquery query, List<Object> values);\n+\n+    /**\n+     * Returns a list of results. If given query not in cache, call the\n+     * value loader to retrieve results and put into the cache\n+     *\n+     * @param query       a subquery of joint index query\n+     * @param valueLoader a callable that returns a list of results\n+     * @return a list of results\n+     * @throws Exception if exception thrown when calling the value loader\n+     */\n+    List<Object> get(JointIndexQuery.Subquery query, Callable<? extends List<Object>> valueLoader) throws Exception;\n+\n+    /**\n+     * Closes the cache which allows the cache to release allocated memory.\n+     * Calling any of the other methods after closing a cache has undetermined behavior.\n+     */\n+    void close();\n+\n+    public class SubqueryResult {\n+        private List<Object> values;\n+        private int limit;\n+\n+        protected SubqueryResult(List<Object> values, int limit) {\n+            this.values = values;\n+            this.limit = limit;\n+        }\n+\n+        public List<Object> getValues() {\n+            return values;\n+        }\n+\n+        public void setValues(List<Object> values) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599b6b8beed017644ebef8283b69c47c5a11fbc5"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI3MTE4MQ==", "bodyText": "The Java Stream API ist relatively inefficient in most simple cases. Instead you could use List.subList() here.", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484271181", "createdAt": "2020-09-07T08:23:52Z", "author": {"login": "rngcntr"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/subquerycache/GuavaSubqueryCache.java", "diffHunk": "@@ -0,0 +1,71 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.transaction.subquerycache;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.Weigher;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class GuavaSubqueryCache implements SubqueryCache {\n+    private Cache<JointIndexQuery.Subquery, SubqueryResult> indexCache;\n+\n+    public GuavaSubqueryCache(int concurrencyLevel, long maximumWeight) {\n+        indexCache = CacheBuilder.newBuilder()\n+            .weigher((Weigher<JointIndexQuery.Subquery, SubqueryResult>) (q, r) -> 2 + r.size())\n+            .concurrencyLevel(concurrencyLevel).maximumWeight(maximumWeight).build();\n+    }\n+\n+    @Override\n+    public List<Object> getIfPresent(JointIndexQuery.Subquery key) {\n+        int limit = key.getLimit();\n+        JointIndexQuery.Subquery noLimitKey = key.updateLimit(0);\n+        SubqueryResult result = indexCache.getIfPresent(noLimitKey);\n+        if (result != null && (result.getLimit() >= limit || result.getLimit() > result.size())) {\n+            return result.getValues().stream().limit(limit).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599b6b8beed017644ebef8283b69c47c5a11fbc5"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI3NDA1Mw==", "bodyText": "These tests do not cover the case in which we have a limit x first and then a limit y > x later. Otherwise the tests look good", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484274053", "createdAt": "2020-09-07T08:28:37Z", "author": {"login": "rngcntr"}, "path": "janusgraph-test/src/test/java/org/janusgraph/graphdb/query/QueryTest.java", "diffHunk": "@@ -131,6 +132,45 @@ public void testOrderList() {\n \n     }\n \n+    @Test\n+    public void testIndexQueryCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599b6b8beed017644ebef8283b69c47c5a11fbc5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI3NzA0MQ==", "bodyText": "I like your verbose documentation \ud83d\udc4d\nBut in this case, I think the description of the internal logic does not fit here. What you describe actually happens inside GuavaSubqueryCache, not SubqueryCache. So you should either move the description there ore move the caching logic here.\nI would even prefer to have as much logic as possible right within SubqueryCache to ensure that all implementations are behaving logically equivalent.", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484277041", "createdAt": "2020-09-07T08:33:38Z", "author": {"login": "rngcntr"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/subquerycache/SubqueryCache.java", "diffHunk": "@@ -0,0 +1,112 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.transaction.subquerycache;\n+\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+/**\n+ * Cache for {@link JointIndexQuery.Subquery} results. Cache entries are manually added using\n+ * {@link #get(JointIndexQuery.Subquery, Callable)} or {@link #put(JointIndexQuery.Subquery, List)},\n+ * and stored in the cache until evicted or invalidated.\n+ * <p>\n+ * Different from a simple exact mapping from keys to values,\n+ * it leverages the fact that the results of a Subquery A with limit X are first X entries of the results of the\n+ * a Subquery B with limit Y, where A and B only differ in limit, and X is less than or equal to Y.\n+ * <p>\n+ * For example, suppose the cache is empty at the beginning. Firstly, prop1_idx:multiKSQ[1]@100 query leads to a cache\n+ * miss, and then results are loaded into cache. Secondly, prop1_idx:multiKSQ[1]@20 query leads to a cache hit, and\n+ * then first 20 results of cached responses are returned. Thirdly, prop1_idx:multiKSQ[1]@2000 leads to a cache miss,\n+ * then results are loaded into cache, and initial results saved by prop1_idx:multiKSQ[1]@100 query are overriden by\n+ * the new results.\n+ * <p>\n+ * Internally, raw query results are encapsulated in {@link SubqueryResult} object together with limit of the query.\n+ * Meanwhile, keys are stored without limit (or with a dummy limit). Whenever there is a hit for key, the limit of\n+ * cached results and that of the query will be compared, and whether this is a cache hit or miss will be determined.\n+ * <p>\n+ * Compared to a simply {@link JointIndexQuery.Subquery} to {@code List<Object>} mapping, this cache has two benefits:\n+ * 1) it reduces latency, as \"subset\" queries can effectively leverage cached results.\n+ * 2) it saves space, as queries only differing in limit will not be saved more than once in cache.\n+ *\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599b6b8beed017644ebef8283b69c47c5a11fbc5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI4MjM5MQ==", "bodyText": "If no limit is given, the cached result can be used if ordering is applied afterwards. But this wasn't done before so I'm also ok with declaring it out of scope of this PR.", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484282391", "createdAt": "2020-09-07T08:42:41Z", "author": {"login": "rngcntr"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphIndexTest.java", "diffHunk": "@@ -2307,4 +2310,71 @@ public void testOrForceIndexComposite() throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * This test builds a mixed index and tests index queries with order and limit.\n+     * It also tests if index query cache is utilised correctly.\n+     */\n+    @Test\n+    public void testOrderByWithLimit() {\n+        final PropertyKey age = makeKey(\"age\", Integer.class);\n+        final JanusGraphIndex mixed = mgmt.buildIndex(\"mixed\", Vertex.class).addKey(age).buildMixedIndex(INDEX);\n+        finishSchema();\n+\n+        for (int i = 0; i < 100; i++) {\n+            tx.addVertex(\"age\", i);\n+        }\n+        tx.commit();\n+\n+        clopen(option(ADJUST_LIMIT),false);\n+        final int[] ascTop100 = IntStream.range(0, 100).toArray();\n+        final int[] ascTop30 = IntStream.range(0, 30).toArray();\n+        final int[] ascTop10 = IntStream.range(0, 10).toArray();\n+        final int[] descTop100 = IntStream.range(0, 100).map(i -> 99 - i).toArray();\n+        final int[] descTop30 = IntStream.range(0, 30).map(i -> 99 - i).toArray();\n+        final int[] descTop10 = IntStream.range(0, 10).map(i -> 99 - i).toArray();\n+\n+        Supplier<GraphTraversal<Vertex, Vertex>> traversal = () -> graph.traversal().V().has(\"age\", P.gte(0)).order();\n+\n+        // traverse with limit 30 (cache cold miss)\n+        assertTrue(hasBackendQuery((TraversalMetrics) traversal.get().by(ORDER_AGE_ASC).limit(30).values(\"age\").profile().next()));\n+        List<Integer> ascAges30 = traversal.get().by(ORDER_AGE_ASC).limit(30).values(\"age\").toList();\n+        assertArrayEquals(ascTop30, ascAges30.stream().mapToInt(i -> i).toArray());\n+        assertTrue(hasBackendQuery((TraversalMetrics) traversal.get().by(ORDER_AGE_DESC).limit(30).values(\"age\").profile().next()));\n+        List<Integer> descAges30 = traversal.get().by(ORDER_AGE_DESC).limit(30).values(\"age\").toList();\n+        assertArrayEquals(descTop30, descAges30.stream().mapToInt(i -> i).toArray());\n+\n+        // traverse without limit (cache cold miss)\n+        assertTrue(hasBackendQuery((TraversalMetrics) traversal.get().by(ORDER_AGE_ASC).values(\"age\").profile().next()));\n+        List<Integer> ascAges = traversal.get().by(ORDER_AGE_ASC).values(\"age\").toList();\n+        assertArrayEquals(ascTop100, ascAges.stream().mapToInt(i -> i).toArray());\n+        assertTrue(hasBackendQuery((TraversalMetrics) traversal.get().by(ORDER_AGE_DESC).values(\"age\").profile().next()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599b6b8beed017644ebef8283b69c47c5a11fbc5"}, "originalPosition": 60}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "599b6b8beed017644ebef8283b69c47c5a11fbc5", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/599b6b8beed017644ebef8283b69c47c5a11fbc5", "committedDate": "2020-08-29T08:42:11Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}, "afterCommit": {"oid": "3afb5594d4959d42534ac63dae27fcd91523ab1c", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/3afb5594d4959d42534ac63dae27fcd91523ab1c", "committedDate": "2020-09-26T13:31:45Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3afb5594d4959d42534ac63dae27fcd91523ab1c", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/3afb5594d4959d42534ac63dae27fcd91523ab1c", "committedDate": "2020-09-26T13:31:45Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}, "afterCommit": {"oid": "e2667d4cb40981ec252d66cb2ce5bd4fe68312bb", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/e2667d4cb40981ec252d66cb2ce5bd4fe68312bb", "committedDate": "2020-09-26T13:35:46Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mzc2MzYy", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#pullrequestreview-497376362", "createdAt": "2020-09-28T10:19:17Z", "commit": {"oid": "e2667d4cb40981ec252d66cb2ce5bd4fe68312bb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2667d4cb40981ec252d66cb2ce5bd4fe68312bb", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/e2667d4cb40981ec252d66cb2ce5bd4fe68312bb", "committedDate": "2020-09-26T13:35:46Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}, "afterCommit": {"oid": "d6e2a9ed26441347361a2346456d24995c884aa7", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/d6e2a9ed26441347361a2346456d24995c884aa7", "committedDate": "2020-10-04T04:10:05Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6e2a9ed26441347361a2346456d24995c884aa7", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/d6e2a9ed26441347361a2346456d24995c884aa7", "committedDate": "2020-10-04T04:10:05Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}, "afterCommit": {"oid": "7b194ce3c575e9accac6610ec9e5576eeb26afb3", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/7b194ce3c575e9accac6610ec9e5576eeb26afb3", "committedDate": "2020-12-21T15:29:42Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b194ce3c575e9accac6610ec9e5576eeb26afb3", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/7b194ce3c575e9accac6610ec9e5576eeb26afb3", "committedDate": "2020-12-21T15:29:42Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}, "afterCommit": {"oid": "1f288aad9a06fbc4678c58ca0cbe7a528ff1d6f6", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/1f288aad9a06fbc4678c58ca0cbe7a528ff1d6f6", "committedDate": "2020-12-22T06:46:44Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNjM1MDU0", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#pullrequestreview-560635054", "createdAt": "2021-01-02T12:55:04Z", "commit": {"oid": "1f288aad9a06fbc4678c58ca0cbe7a528ff1d6f6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "745be5f5c60c933c827f9835fee8796d1b4348e1", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/745be5f5c60c933c827f9835fee8796d1b4348e1", "committedDate": "2021-01-02T13:18:38Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f288aad9a06fbc4678c58ca0cbe7a528ff1d6f6", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/1f288aad9a06fbc4678c58ca0cbe7a528ff1d6f6", "committedDate": "2020-12-22T06:46:44Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}, "afterCommit": {"oid": "745be5f5c60c933c827f9835fee8796d1b4348e1", "author": {"user": {"login": "li-boxuan", "name": "Boxuan Li"}}, "url": "https://github.com/JanusGraph/janusgraph/commit/745be5f5c60c933c827f9835fee8796d1b4348e1", "committedDate": "2021-01-02T13:18:38Z", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4617, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}