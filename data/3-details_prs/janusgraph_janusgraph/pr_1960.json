{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MTYxNzQ2", "number": 1960, "title": "Optimize hasId() in the same way as is()", "bodyText": "Solves #1525\nFor all changes:\n\n Is there an issue associated with this PR? Is it referenced in the commit message?\n Does your PR body contain #xyz where xyz is the issue number you are trying to resolve?\n Has your PR been rebased against the latest commit within the target branch (typically master)?\n Is your initial contribution a single, squashed commit?\n\nFor code changes:\n\n Have you written and/or updated unit tests to verify your changes?", "createdAt": "2020-02-12T07:57:46Z", "url": "https://github.com/JanusGraph/janusgraph/pull/1960", "merged": true, "mergeCommit": {"oid": "100a2ee21351c24eedc0bd9533a49870ab16002a"}, "closed": true, "closedAt": "2020-02-20T11:51:26Z", "author": {"login": "rngcntr"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDt7lgAFqTM1Nzc5MzE1Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGJvOEgFqTM2MTgzOTczNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NzkzMTUz", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#pullrequestreview-357793153", "createdAt": "2020-02-12T21:16:46Z", "commit": {"oid": "7d6fc87cf2161fc022b8bef9946caa17e0f46dc6"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMToxNjo0N1rOFo-2LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo0MDo0M1rOFo_ixg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxNzAzNw==", "bodyText": "This comment is now wrong because we check not only is(x) but also hasId(id)", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r378517037", "createdAt": "2020-02-12T21:16:47Z", "author": {"login": "porunov"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexFilterOptimizerStrategy.java", "diffHunk": "@@ -32,73 +32,191 @@\n import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.T;\n import org.apache.tinkerpop.gremlin.structure.Vertex;\n-\n-import java.util.List;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n /**\n  * @author Matthias Broecheler (me@matthiasb.com)\n  */\n-public class AdjacentVertexFilterOptimizerStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy> implements TraversalStrategy.ProviderOptimizationStrategy {\n+public class AdjacentVertexFilterOptimizerStrategy\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n \n-    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE = new AdjacentVertexFilterOptimizerStrategy();\n+    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE =\n+        new AdjacentVertexFilterOptimizerStrategy();\n \n-    private AdjacentVertexFilterOptimizerStrategy() {\n-    }\n+    private AdjacentVertexFilterOptimizerStrategy() {}\n \n-    public static AdjacentVertexFilterOptimizerStrategy instance() {\n-        return INSTANCE;\n-    }\n+    public static AdjacentVertexFilterOptimizerStrategy instance() { return INSTANCE; }\n \n+    private enum OptimizableQueryType { NONE, IS, HASID }\n+    ;\n \n     @Override\n     public void apply(final Traversal.Admin<?, ?> traversal) {\n \n-        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal).forEach(originalStep -> {\n-            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n-            Traversal.Admin<?, ?> filterTraversal = (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n-            List<Step> steps = filterTraversal.getSteps();\n-            if (steps.size() == 2 &&\n-                    (steps.get(0) instanceof EdgeVertexStep || steps.get(0) instanceof EdgeOtherVertexStep) &&\n-                    (steps.get(1) instanceof IsStep)) {\n-                //Get the direction in which we filter on the adjacent vertex (or null if not a valid adjacency filter)\n-                Direction direction = null;\n-                if (steps.get(0) instanceof EdgeVertexStep) {\n-                    EdgeVertexStep evs = (EdgeVertexStep) steps.get(0);\n-                    if (evs.getDirection() != Direction.BOTH) direction = evs.getDirection();\n-                } else {\n-                    assert steps.get(0) instanceof EdgeOtherVertexStep;\n-                    direction = Direction.BOTH;\n-                }\n-                P predicate = ((IsStep) steps.get(1)).getPredicate();\n-                //Check that we have a valid direction and a valid vertex filter predicate\n-                if (direction != null && predicate.getBiPredicate() == Compare.eq && predicate.getValue() instanceof Vertex) {\n-                    Vertex vertex = (Vertex) predicate.getValue();\n-\n-                    //Now, check that this step is preceded by VertexStep that returns edges\n-                    Step<?, ?> currentStep = originalStep.getPreviousStep();\n-                    while (currentStep != EmptyStep.instance()) {\n-                        if (!(currentStep instanceof HasStep) && !(currentStep instanceof IdentityStep)) {\n-                            break;\n-                        } //We can jump over other steps as we move backward\n-                        currentStep = currentStep.getPreviousStep();\n-                    }\n-                    if (currentStep instanceof VertexStep) {\n-                        VertexStep vertexStep = (VertexStep) currentStep;\n-                        if (vertexStep.returnsEdge()\n-                                && (direction == Direction.BOTH || direction.equals(vertexStep.getDirection().opposite()))) {\n-                            //Now replace the step with a has condition\n-                            TraversalHelper.replaceStep(originalStep,\n-                                new HasStep(traversal,\n-                                    new HasContainer(ImplicitKey.ADJACENT_ID.name(), P.eq(vertex))),\n-                                traversal);\n-                        }\n-                    }\n+        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal)\n+            .forEach(originalStep -> {\n+                // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d6fc87cf2161fc022b8bef9946caa17e0f46dc6"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUyODQ1NA==", "bodyText": "(nitpick) default: break; makes no sense here because we are breaking the switch by default already (i.e. no need to write it explicitly). I would just remove this statement", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r378528454", "createdAt": "2020-02-12T21:40:43Z", "author": {"login": "porunov"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexFilterOptimizerStrategy.java", "diffHunk": "@@ -32,73 +32,191 @@\n import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.T;\n import org.apache.tinkerpop.gremlin.structure.Vertex;\n-\n-import java.util.List;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n /**\n  * @author Matthias Broecheler (me@matthiasb.com)\n  */\n-public class AdjacentVertexFilterOptimizerStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy> implements TraversalStrategy.ProviderOptimizationStrategy {\n+public class AdjacentVertexFilterOptimizerStrategy\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n \n-    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE = new AdjacentVertexFilterOptimizerStrategy();\n+    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE =\n+        new AdjacentVertexFilterOptimizerStrategy();\n \n-    private AdjacentVertexFilterOptimizerStrategy() {\n-    }\n+    private AdjacentVertexFilterOptimizerStrategy() {}\n \n-    public static AdjacentVertexFilterOptimizerStrategy instance() {\n-        return INSTANCE;\n-    }\n+    public static AdjacentVertexFilterOptimizerStrategy instance() { return INSTANCE; }\n \n+    private enum OptimizableQueryType { NONE, IS, HASID }\n+    ;\n \n     @Override\n     public void apply(final Traversal.Admin<?, ?> traversal) {\n \n-        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal).forEach(originalStep -> {\n-            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n-            Traversal.Admin<?, ?> filterTraversal = (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n-            List<Step> steps = filterTraversal.getSteps();\n-            if (steps.size() == 2 &&\n-                    (steps.get(0) instanceof EdgeVertexStep || steps.get(0) instanceof EdgeOtherVertexStep) &&\n-                    (steps.get(1) instanceof IsStep)) {\n-                //Get the direction in which we filter on the adjacent vertex (or null if not a valid adjacency filter)\n-                Direction direction = null;\n-                if (steps.get(0) instanceof EdgeVertexStep) {\n-                    EdgeVertexStep evs = (EdgeVertexStep) steps.get(0);\n-                    if (evs.getDirection() != Direction.BOTH) direction = evs.getDirection();\n-                } else {\n-                    assert steps.get(0) instanceof EdgeOtherVertexStep;\n-                    direction = Direction.BOTH;\n-                }\n-                P predicate = ((IsStep) steps.get(1)).getPredicate();\n-                //Check that we have a valid direction and a valid vertex filter predicate\n-                if (direction != null && predicate.getBiPredicate() == Compare.eq && predicate.getValue() instanceof Vertex) {\n-                    Vertex vertex = (Vertex) predicate.getValue();\n-\n-                    //Now, check that this step is preceded by VertexStep that returns edges\n-                    Step<?, ?> currentStep = originalStep.getPreviousStep();\n-                    while (currentStep != EmptyStep.instance()) {\n-                        if (!(currentStep instanceof HasStep) && !(currentStep instanceof IdentityStep)) {\n-                            break;\n-                        } //We can jump over other steps as we move backward\n-                        currentStep = currentStep.getPreviousStep();\n-                    }\n-                    if (currentStep instanceof VertexStep) {\n-                        VertexStep vertexStep = (VertexStep) currentStep;\n-                        if (vertexStep.returnsEdge()\n-                                && (direction == Direction.BOTH || direction.equals(vertexStep.getDirection().opposite()))) {\n-                            //Now replace the step with a has condition\n-                            TraversalHelper.replaceStep(originalStep,\n-                                new HasStep(traversal,\n-                                    new HasContainer(ImplicitKey.ADJACENT_ID.name(), P.eq(vertex))),\n-                                traversal);\n-                        }\n-                    }\n+        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal)\n+            .forEach(originalStep -> {\n+                // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n+                Traversal.Admin<?, ?> filterTraversal =\n+                    (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n+                List<Step> subSteps = filterTraversal.getSteps();\n+\n+                OptimizableQueryType type = analyzeSubSteps(subSteps);\n \n+                switch (type) {\n+                case IS:\n+                    replaceIsStep(traversal, originalStep, subSteps);\n+                    break;\n+                case HASID:\n+                    replaceHasIdStep(traversal, originalStep, subSteps);\n+                    break;\n+                default:\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d6fc87cf2161fc022b8bef9946caa17e0f46dc6"}, "originalPosition": 103}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d6fc87cf2161fc022b8bef9946caa17e0f46dc6", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/7d6fc87cf2161fc022b8bef9946caa17e0f46dc6", "committedDate": "2020-02-12T07:39:38Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}, "afterCommit": {"oid": "42c93310862d302e543399b09a3781bbace34553", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/42c93310862d302e543399b09a3781bbace34553", "committedDate": "2020-02-13T07:39:13Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42c93310862d302e543399b09a3781bbace34553", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/42c93310862d302e543399b09a3781bbace34553", "committedDate": "2020-02-13T07:39:13Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}, "afterCommit": {"oid": "2a814818922778892491c2a4b20023dc57736bbe", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/2a814818922778892491c2a4b20023dc57736bbe", "committedDate": "2020-02-14T07:18:19Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NzUyNzA2", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#pullrequestreview-358752706", "createdAt": "2020-02-14T07:28:18Z", "commit": {"oid": "2a814818922778892491c2a4b20023dc57736bbe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoyODoxOFrOFptoCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoyODoxOFrOFptoCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MzQ2NQ==", "bodyText": "I removed the repeated jumps because issues arose when using this strategy on queries that utilize SideEffectStep.\nThe re-ordering of steps caused logical dependencies between these steps to break.", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r379283465", "createdAt": "2020-02-14T07:28:18Z", "author": {"login": "rngcntr"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexFilterOptimizerStrategy.java", "diffHunk": "@@ -32,73 +32,179 @@\n import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.T;\n import org.apache.tinkerpop.gremlin.structure.Vertex;\n-\n-import java.util.List;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n /**\n  * @author Matthias Broecheler (me@matthiasb.com)\n  */\n-public class AdjacentVertexFilterOptimizerStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy> implements TraversalStrategy.ProviderOptimizationStrategy {\n+public class AdjacentVertexFilterOptimizerStrategy\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n \n-    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE = new AdjacentVertexFilterOptimizerStrategy();\n+    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE =\n+        new AdjacentVertexFilterOptimizerStrategy();\n \n-    private AdjacentVertexFilterOptimizerStrategy() {\n-    }\n+    private AdjacentVertexFilterOptimizerStrategy() {}\n \n-    public static AdjacentVertexFilterOptimizerStrategy instance() {\n-        return INSTANCE;\n-    }\n+    public static AdjacentVertexFilterOptimizerStrategy instance() { return INSTANCE; }\n \n+    private enum OptimizableQueryType { NONE, IS, HASID }\n+    ;\n \n     @Override\n     public void apply(final Traversal.Admin<?, ?> traversal) {\n \n-        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal).forEach(originalStep -> {\n-            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n-            Traversal.Admin<?, ?> filterTraversal = (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n-            List<Step> steps = filterTraversal.getSteps();\n-            if (steps.size() == 2 &&\n-                    (steps.get(0) instanceof EdgeVertexStep || steps.get(0) instanceof EdgeOtherVertexStep) &&\n-                    (steps.get(1) instanceof IsStep)) {\n-                //Get the direction in which we filter on the adjacent vertex (or null if not a valid adjacency filter)\n-                Direction direction = null;\n-                if (steps.get(0) instanceof EdgeVertexStep) {\n-                    EdgeVertexStep evs = (EdgeVertexStep) steps.get(0);\n-                    if (evs.getDirection() != Direction.BOTH) direction = evs.getDirection();\n-                } else {\n-                    assert steps.get(0) instanceof EdgeOtherVertexStep;\n-                    direction = Direction.BOTH;\n-                }\n-                P predicate = ((IsStep) steps.get(1)).getPredicate();\n-                //Check that we have a valid direction and a valid vertex filter predicate\n-                if (direction != null && predicate.getBiPredicate() == Compare.eq && predicate.getValue() instanceof Vertex) {\n-                    Vertex vertex = (Vertex) predicate.getValue();\n-\n-                    //Now, check that this step is preceded by VertexStep that returns edges\n-                    Step<?, ?> currentStep = originalStep.getPreviousStep();\n-                    while (currentStep != EmptyStep.instance()) {\n-                        if (!(currentStep instanceof HasStep) && !(currentStep instanceof IdentityStep)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a814818922778892491c2a4b20023dc57736bbe"}, "originalPosition": 70}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2a814818922778892491c2a4b20023dc57736bbe", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/2a814818922778892491c2a4b20023dc57736bbe", "committedDate": "2020-02-14T07:18:19Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}, "afterCommit": {"oid": "a05102bf9e52acf2df7a8398eed5cba1874f5549", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/a05102bf9e52acf2df7a8398eed5cba1874f5549", "committedDate": "2020-02-17T11:54:14Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a05102bf9e52acf2df7a8398eed5cba1874f5549", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/a05102bf9e52acf2df7a8398eed5cba1874f5549", "committedDate": "2020-02-17T11:54:14Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}, "afterCommit": {"oid": "08c2b5f669b7033132a141f324a94f5759adbc53", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/08c2b5f669b7033132a141f324a94f5759adbc53", "committedDate": "2020-02-17T12:55:22Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "08c2b5f669b7033132a141f324a94f5759adbc53", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/08c2b5f669b7033132a141f324a94f5759adbc53", "committedDate": "2020-02-17T12:55:22Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}, "afterCommit": {"oid": "eccf0a518549350a55aa331a587ecc4f61f8f0ef", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/eccf0a518549350a55aa331a587ecc4f61f8f0ef", "committedDate": "2020-02-17T13:52:25Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5ODAzMjQ5", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#pullrequestreview-359803249", "createdAt": "2020-02-17T15:10:04Z", "commit": {"oid": "eccf0a518549350a55aa331a587ecc4f61f8f0ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTIxOTk1", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#pullrequestreview-359921995", "createdAt": "2020-02-17T18:57:33Z", "commit": {"oid": "eccf0a518549350a55aa331a587ecc4f61f8f0ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxODo1NzozNFrOFqtkGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxODo1NzozNFrOFqtkGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzMTAzMw==", "bodyText": "I didn't find vertexStep.close() in the previous version. I don't know if we should close it here after try with resources but could you explain why you are closing vertexStep here? Is it connected to resources leak or other possible problems?", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r380331033", "createdAt": "2020-02-17T18:57:34Z", "author": {"login": "porunov"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexFilterOptimizerStrategy.java", "diffHunk": "@@ -32,73 +32,161 @@\n import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.T;\n import org.apache.tinkerpop.gremlin.structure.Vertex;\n-\n-import java.util.List;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n /**\n  * @author Matthias Broecheler (me@matthiasb.com)\n  */\n-public class AdjacentVertexFilterOptimizerStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy> implements TraversalStrategy.ProviderOptimizationStrategy {\n+public class AdjacentVertexFilterOptimizerStrategy\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n \n-    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE = new AdjacentVertexFilterOptimizerStrategy();\n+    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE =\n+        new AdjacentVertexFilterOptimizerStrategy();\n \n-    private AdjacentVertexFilterOptimizerStrategy() {\n-    }\n+    private AdjacentVertexFilterOptimizerStrategy() {}\n \n-    public static AdjacentVertexFilterOptimizerStrategy instance() {\n-        return INSTANCE;\n-    }\n+    public static AdjacentVertexFilterOptimizerStrategy instance() { return INSTANCE; }\n \n+    private enum OptimizableQueryType { NONE, IS, HASID }\n+    ;\n \n     @Override\n     public void apply(final Traversal.Admin<?, ?> traversal) {\n \n-        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal).forEach(originalStep -> {\n-            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n-            Traversal.Admin<?, ?> filterTraversal = (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n-            List<Step> steps = filterTraversal.getSteps();\n-            if (steps.size() == 2 &&\n-                    (steps.get(0) instanceof EdgeVertexStep || steps.get(0) instanceof EdgeOtherVertexStep) &&\n-                    (steps.get(1) instanceof IsStep)) {\n-                //Get the direction in which we filter on the adjacent vertex (or null if not a valid adjacency filter)\n-                Direction direction = null;\n-                if (steps.get(0) instanceof EdgeVertexStep) {\n-                    EdgeVertexStep evs = (EdgeVertexStep) steps.get(0);\n-                    if (evs.getDirection() != Direction.BOTH) direction = evs.getDirection();\n-                } else {\n-                    assert steps.get(0) instanceof EdgeOtherVertexStep;\n-                    direction = Direction.BOTH;\n+        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal)\n+            .forEach(originalStep -> {\n+                // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is/hasId(x)\n+                Traversal.Admin<?, ?> filterTraversal =\n+                    (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n+                List<Step> subSteps = filterTraversal.getSteps();\n+\n+                OptimizableQueryType type = analyzeSubSteps(subSteps);\n+\n+                if (type != OptimizableQueryType.NONE) {\n+                    replaceStep(traversal, type, originalStep, subSteps);\n                 }\n-                P predicate = ((IsStep) steps.get(1)).getPredicate();\n-                //Check that we have a valid direction and a valid vertex filter predicate\n-                if (direction != null && predicate.getBiPredicate() == Compare.eq && predicate.getValue() instanceof Vertex) {\n-                    Vertex vertex = (Vertex) predicate.getValue();\n-\n-                    //Now, check that this step is preceded by VertexStep that returns edges\n-                    Step<?, ?> currentStep = originalStep.getPreviousStep();\n-                    while (currentStep != EmptyStep.instance()) {\n-                        if (!(currentStep instanceof HasStep) && !(currentStep instanceof IdentityStep)) {\n-                            break;\n-                        } //We can jump over other steps as we move backward\n-                        currentStep = currentStep.getPreviousStep();\n-                    }\n-                    if (currentStep instanceof VertexStep) {\n-                        VertexStep vertexStep = (VertexStep) currentStep;\n-                        if (vertexStep.returnsEdge()\n-                                && (direction == Direction.BOTH || direction.equals(vertexStep.getDirection().opposite()))) {\n-                            //Now replace the step with a has condition\n-                            TraversalHelper.replaceStep(originalStep,\n-                                new HasStep(traversal,\n-                                    new HasContainer(ImplicitKey.ADJACENT_ID.name(), P.eq(vertex))),\n-                                traversal);\n-                        }\n-                    }\n+            });\n+    }\n+\n+    private void replaceStep(Traversal.Admin<?, ?> traversal, OptimizableQueryType type,\n+                             TraversalFilterStep originalStep, List<Step> steps) {\n+        // Get the direction in which we filter on the adjacent vertex (or null if not a valid\n+        // adjacency filter)\n+        Direction direction = parseDirection(steps);\n+        P predicate = parsePredicate(type, steps);\n+        // Check that we have a valid direction and a valid vertex filter predicate\n+        if (direction != null && isValidPredicate(type, predicate) &&\n+            isPreviousStepValid(originalStep, direction)) {\n+            // Now replace the step with a has condition\n+            HasContainer hc =\n+                new HasContainer(ImplicitKey.ADJACENT_ID.name(), P.eq(predicate.getValue()));\n+            TraversalHelper.replaceStep(originalStep, new HasStep(traversal, hc), traversal);\n+        }\n+    }\n+\n+    private OptimizableQueryType analyzeSubSteps(List<Step> steps) {\n+        if (steps.size() != 2) {\n+            return OptimizableQueryType.NONE;\n+        }\n+\n+        boolean validFirstStep = (steps.get(0) instanceof EdgeVertexStep);\n+        validFirstStep = validFirstStep || (steps.get(0) instanceof EdgeOtherVertexStep);\n \n+        if (!validFirstStep) {\n+            return OptimizableQueryType.NONE;\n+        }\n+\n+        if (steps.get(1) instanceof IsStep) {\n+            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n+            return OptimizableQueryType.IS;\n+        } else if (steps.get(1) instanceof HasStep) {\n+            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.hasId(x)\n+            HasStep hasStep = (HasStep) steps.get(1);\n+            if (hasStep.getHasContainers().size() != 1) {\n+                // TODO does it make sense to allow steps with > 1 containers here?\n+                return OptimizableQueryType.NONE;\n+            }\n+\n+            HasContainer has = (HasContainer) hasStep.getHasContainers().get(0);\n+            if (has.getKey().equals(T.id.getAccessor())) {\n+                return OptimizableQueryType.HASID;\n+            } else {\n+                return OptimizableQueryType.NONE;\n+            }\n+        } else {\n+            return OptimizableQueryType.NONE;\n+        }\n+    }\n+\n+    private boolean isPreviousStepValid(TraversalFilterStep originalStep, Direction direction) {\n+        // check that this step is preceded by VertexStep that returns edges\n+        Step<?, ?> previousStep = originalStep.getPreviousStep();\n+        while (previousStep != EmptyStep.instance()) {\n+            if (!(previousStep instanceof HasStep) && !(previousStep instanceof IdentityStep)) {\n+                break;\n+            }\n+            previousStep = previousStep.getPreviousStep();\n+        }\n+\n+        if (previousStep instanceof VertexStep) {\n+            try (VertexStep<?> vertexStep = (VertexStep<?>) previousStep) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eccf0a518549350a55aa331a587ecc4f61f8f0ef"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMjI5MDkw", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#pullrequestreview-361229090", "createdAt": "2020-02-19T16:17:20Z", "commit": {"oid": "eccf0a518549350a55aa331a587ecc4f61f8f0ef"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38a8b853c479b8951b83bf8b5b8cbf02c650f58e", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/38a8b853c479b8951b83bf8b5b8cbf02c650f58e", "committedDate": "2020-02-20T06:52:40Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eccf0a518549350a55aa331a587ecc4f61f8f0ef", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/eccf0a518549350a55aa331a587ecc4f61f8f0ef", "committedDate": "2020-02-17T13:52:25Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}, "afterCommit": {"oid": "38a8b853c479b8951b83bf8b5b8cbf02c650f58e", "author": {"user": {"login": "rngcntr", "name": null}}, "url": "https://github.com/JanusGraph/janusgraph/commit/38a8b853c479b8951b83bf8b5b8cbf02c650f58e", "committedDate": "2020-02-20T06:52:40Z", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxODM5NzM0", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#pullrequestreview-361839734", "createdAt": "2020-02-20T11:50:21Z", "commit": {"oid": "38a8b853c479b8951b83bf8b5b8cbf02c650f58e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4814, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}