{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MjY5NjA1", "number": 2137, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MTowMlrOEUaYgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0zMFQwOToyNzo0N1rOFUxCAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODM5MjM1OnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MTowMlrOG6nX7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MTowMlrOG6nX7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTY5Mg==", "bodyText": "seems to be unused.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115692", "createdAt": "2020-08-02T19:41:02Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+        getV(graph, c).remove();\n+        \n+    \tclose();\n+    }\n+    \n+\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindOut\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t//add Edge\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \tclose();\n+    }\n+\t\n+\tprivate void initReindexSchema() {\n+\t\tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"vtName\")) {\n+\t\t\tmgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"assocKind\")) {\n+\t\t\tmgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+\t\t}\n+\t}\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tGraphTraversal<Vertex, Edge> result = null; \n+    \t\n+    \tswitch(direction) {\n+    \tcase \"IN\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).inE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"OUT\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).outE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"BOTH\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).bothE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \t}\n+    \t\n+    \torg.junit.Assert.assertNotNull(\"Invalid Direction\",result);\n+    \tint noOfRelations=0;\n+    \twhile(result.hasNext()) {\n+    \t\tEdge next = result.next();\n+    \t\tJanusGraphVertex outVertex = (JanusGraphVertex)next.outVertex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODM5MjU5OnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MToyNFrOG6nYCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MToyNFrOG6nYCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTcyMA==", "bodyText": "could you use junit5 assertions.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115720", "createdAt": "2020-08-02T19:41:24Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+        getV(graph, c).remove();\n+        \n+    \tclose();\n+    }\n+    \n+\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindOut\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t//add Edge\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \tclose();\n+    }\n+\t\n+\tprivate void initReindexSchema() {\n+\t\tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"vtName\")) {\n+\t\t\tmgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"assocKind\")) {\n+\t\t\tmgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+\t\t}\n+\t}\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tGraphTraversal<Vertex, Edge> result = null; \n+    \t\n+    \tswitch(direction) {\n+    \tcase \"IN\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).inE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"OUT\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).outE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"BOTH\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).bothE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \t}\n+    \t\n+    \torg.junit.Assert.assertNotNull(\"Invalid Direction\",result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODM5MzQzOnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0MjoyM1rOG6nYcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwODo1NDoyMFrOIR3cfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg==", "bodyText": "Why do you need to run remove?", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115826", "createdAt": "2020-08-02T19:42:23Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MDk1Nw==", "bodyText": "Im creating the vertex with same properties in other testcases also to test index with different directions. Hence removing the vertex after completion of every testcase to avoid conflicts.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464240957", "createdAt": "2020-08-03T07:32:37Z", "author": {"login": "shkrishn"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg=="}, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0NzA2Mg==", "bodyText": "Tests in this class should be independent.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464247062", "createdAt": "2020-08-03T07:46:18Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg=="}, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYwNTExNg==", "bodyText": "As @farodin91  suggested, please remove getV(graph, a).remove();, getV(graph, b).remove();\nPlease also remove close(). They are not needed.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555605116", "createdAt": "2021-01-12T08:54:20Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg=="}, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODM5NjA4OnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTowNFrOG6nZrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTowNFrOG6nZrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjE0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n          \n          \n            \n                            Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116141", "createdAt": "2020-08-02T19:45:04Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODM5NjMwOnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTozMlrOG6nZzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTozMlrOG6nZzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjE3NA==", "bodyText": "spacing", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116174", "createdAt": "2020-08-02T19:45:32Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); \n+                        }else if(pos==1) {\n+                        \t//Create IN edge index entry. Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                        \tInternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                        \tthrow new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\t\t//Mutating all OUT relationships for the current vertex", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODM5Njc1OnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTo0MVrOG6nZ_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTo0MVrOG6nZ_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjIyMw==", "bodyText": "indent", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116223", "createdAt": "2020-08-02T19:45:41Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); \n+                        }else if(pos==1) {\n+                        \t//Create IN edge index entry. Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                        \tInternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                        \tthrow new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\t\t//Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {\n+                \tStaticBuffer otherVertexKey = entry.getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODM5Njg1OnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTo1OVrOG6naCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxOTo0NTo1OVrOG6naCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjIzNQ==", "bodyText": "indent", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116235", "createdAt": "2020-08-02T19:45:59Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTk0MjIxOnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMDo1NTo0MVrOG61G9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToxNzo0M1rOG61q9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MDcyNw==", "bodyText": "We use space instead of tabs.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464340727", "createdAt": "2020-08-03T10:55:41Z", "author": {"login": "farodin91"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+\t\t\t\t//Create OUT edge index entry. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea2b19e585009dcc8c6d76c4ab399a2549c96fd"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0OTk0Mg==", "bodyText": "Replaced all tabs with spaces.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464349942", "createdAt": "2020-08-03T11:17:43Z", "author": {"login": "shkrishn"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+\t\t\t\t//Create OUT edge index entry. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MDcyNw=="}, "originalCommit": {"oid": "5ea2b19e585009dcc8c6d76c4ab399a2549c96fd"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDAyNjE1OnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToyNjozNlrOG615bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToyNjozNlrOG615bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1MzY0Ng==", "bodyText": "You can remove also close.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464353646", "createdAt": "2020-08-03T11:26:36Z", "author": {"login": "farodin91"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,240 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+\t\tclose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b17c5035da5c745ff4e08368134700ca744382e4"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODU1MTE5OnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTo1NToyMVrOHWo2Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNzowMjoxNVrOIQZ8sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n          \n          \n            \n                                        InternalVertex otherVertex = janusgraphRelation.getVertex(1);", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493499926", "createdAt": "2020-09-23T11:55:21Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3MzI2NQ==", "bodyText": "code modified.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554073265", "createdAt": "2021-01-08T17:02:15Z", "author": {"login": "shkrishn"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkyNg=="}, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODcyNTA2OnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoyNjowNlrOHWqh2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNzowNDoyMFrOIQaA3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyNzUxNQ==", "bodyText": "isReindexed parameter is not used. Anyway, you don't even need a whole method here. I suggest doing\ng.V().has(\"vtName\", \"A\").inE().hasLabel(\"egLabel\").has(\"assoKind\", 1).count().next()\ndirectly, wherever you currently use countOfEdges method.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493527515", "createdAt": "2020-09-23T12:26:06Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {\n+        if(!mgmt.containsEdgeLabel(\"egLabel\")){\n+            mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+        }\n+\n+        if(!mgmt.containsPropertyKey(\"vtName\")) {\n+            mgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+        }\n+\t\t\n+        if(!mgmt.containsPropertyKey(\"assocKind\")) {\n+            mgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+        }\n+    }\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NDMzMw==", "bodyText": "testcase removed as this seems to be unnecessary for this PR", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554074333", "createdAt": "2021-01-08T17:04:20Z", "author": {"login": "shkrishn"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {\n+        if(!mgmt.containsEdgeLabel(\"egLabel\")){\n+            mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+        }\n+\n+        if(!mgmt.containsPropertyKey(\"vtName\")) {\n+            mgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+        }\n+\t\t\n+        if(!mgmt.containsPropertyKey(\"assocKind\")) {\n+            mgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+        }\n+    }\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyNzUxNQ=="}, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODc1NDY4OnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjozMDo1N1rOHWqz5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNzowODoyMVrOIQaJsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMjEzNA==", "bodyText": "When you put an ancillary method which is for one or more specific scenarios, you'd better not use a seemingly generic name like \"assertEdgeCounts\".", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493532134", "createdAt": "2020-09-23T12:30:57Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {\n+        if(!mgmt.containsEdgeLabel(\"egLabel\")){\n+            mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+        }\n+\n+        if(!mgmt.containsPropertyKey(\"vtName\")) {\n+            mgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+        }\n+\t\t\n+        if(!mgmt.containsPropertyKey(\"assocKind\")) {\n+            mgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+        }\n+    }\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NjU5Mw==", "bodyText": "testcase removed as this seems to be unnecessary for this PR", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554076593", "createdAt": "2021-01-08T17:08:21Z", "author": {"login": "shkrishn"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {\n+        if(!mgmt.containsEdgeLabel(\"egLabel\")){\n+            mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+        }\n+\n+        if(!mgmt.containsPropertyKey(\"vtName\")) {\n+            mgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+        }\n+\t\t\n+        if(!mgmt.containsPropertyKey(\"assocKind\")) {\n+            mgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+        }\n+    }\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMjEzNA=="}, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODc4NDEyOnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjozNjowMlrOHWrGJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNzowNDowOFrOIQaAeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNjgwNQ==", "bodyText": "Looks like the three test cases are very similar, except they have different directions. Can you put most of the common logic into one helper method, e.g. \"testReindexingForEdgeIndex(direction)\", and have 3 very short test cases that use that helper method?", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493536805", "createdAt": "2020-09-23T12:36:02Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NDIzMw==", "bodyText": "testcase removed as this seems to be unnecessary for this PR", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554074233", "createdAt": "2021-01-08T17:04:08Z", "author": {"login": "shkrishn"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNjgwNQ=="}, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODgwNzI1OnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjozOTo1OVrOHWrUZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNzowNDowMFrOIQaASg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MDQ1NA==", "bodyText": "Once you extract test logic into a single helper method, e.g. \"testReindexingForEdgeIndex(direction)\", then you should be able to put the preparation work in that method and dismiss this method.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493540454", "createdAt": "2020-09-23T12:39:59Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NDE4Ng==", "bodyText": "testcase removed as this seems to be unnecessary for this PR", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554074186", "createdAt": "2021-01-08T17:04:00Z", "author": {"login": "shkrishn"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MDQ1NA=="}, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODgxNjk1OnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MTozM1rOHWranw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MTozM1rOHWranw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MjA0Nw==", "bodyText": "IllegalStateException sounds more suitable to me.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493542047", "createdAt": "2020-09-23T12:41:33Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODg0MDIzOnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0NToxM1rOHWro_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNzowODowOFrOIQaJGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0NTcyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                totalInAdditions = inAdditions.size();\n          \n          \n            \n                                totalInAdditions += inAdditions.size();", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493545725", "createdAt": "2020-09-23T12:45:13Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\n+                //Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {\n+                    StaticBuffer otherVertexKey = entry.getKey();\n+                    List<Entry> inAdditions = entry.getValue();\n+                    totalInAdditions = inAdditions.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NjQ0Mg==", "bodyText": "code modified", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554076442", "createdAt": "2021-01-08T17:08:08Z", "author": {"login": "shkrishn"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\n+                //Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {\n+                    StaticBuffer otherVertexKey = entry.getKey();\n+                    List<Entry> inAdditions = entry.getValue();\n+                    totalInAdditions = inAdditions.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0NTcyNQ=="}, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODg1MzY4OnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0NzoyNVrOHWrxcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNzowNToyMFrOIQaDCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0Nzg5MQ==", "bodyText": "Can be just Map.Entry, since you have Map imported.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493547891", "createdAt": "2020-09-23T12:47:25Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\n+                //Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NDg5MA==", "bodyText": "code modified", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554074890", "createdAt": "2021-01-08T17:05:20Z", "author": {"login": "shkrishn"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\n+                //Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0Nzg5MQ=="}, "originalCommit": {"oid": "457f0a30e963e273cdf3f9631ce54b206760d236"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5ODA1Mjc0OnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwOTo0NTozNlrOIR5eJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMzoxOTo0NVrOIT_udg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYzODMwOA==", "bodyText": "The clopen here is not needed.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555638308", "createdAt": "2021-01-12T09:45:36Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgzNzk0Mg==", "bodyText": "removed", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r557837942", "createdAt": "2021-01-15T03:19:45Z", "author": {"login": "shkrishn"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYzODMwOA=="}, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5ODUxMzkxOnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxMTo0MjoxMlrOIR9zhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMzoyMzowNVrOIT_xsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcwOTMxOA==", "bodyText": "No need to check. You can just create edge labels, property keys, etc. directly.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555709318", "createdAt": "2021-01-12T11:42:12Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexWithDirectionIn = \"edgesByAssocKindIn\";\n+    \tString indexwithDirectionOut = \"edgesByAssocKindOut\";\n+    \tString indexWithDirectionBoth = \"edgesByAssocKindBoth\";\n+    \t\n+    \tString propertyKeyForIn = \"assocKindForIn\";\n+    \tString propertyKeyForOut = \"assocKindForOut\";\n+    \tString propertyKeyForBoth = \"assocKindForBoth\";\n+    \t\n+    \t\n+    \t//Schema creation\n+    \tif(!mgmt.containsEdgeLabel(\"egLabel\")){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgzODc3MQ==", "bodyText": "done.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r557838771", "createdAt": "2021-01-15T03:23:05Z", "author": {"login": "shkrishn"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexWithDirectionIn = \"edgesByAssocKindIn\";\n+    \tString indexwithDirectionOut = \"edgesByAssocKindOut\";\n+    \tString indexWithDirectionBoth = \"edgesByAssocKindBoth\";\n+    \t\n+    \tString propertyKeyForIn = \"assocKindForIn\";\n+    \tString propertyKeyForOut = \"assocKindForOut\";\n+    \tString propertyKeyForBoth = \"assocKindForBoth\";\n+    \t\n+    \t\n+    \t//Schema creation\n+    \tif(!mgmt.containsEdgeLabel(\"egLabel\")){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcwOTMxOA=="}, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5ODkzMzA5OnYy", "diffSide": "RIGHT", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxMzozNTo0MFrOISBtgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMzoyNDo0NVrOIT_zMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc3MzMxMw==", "bodyText": "You can do this:\nEdgeLabel edgeLabel = mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\nso that you don't need to call getEdgeLabel later. Similar for property keys.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555773313", "createdAt": "2021-01-12T13:35:40Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexWithDirectionIn = \"edgesByAssocKindIn\";\n+    \tString indexwithDirectionOut = \"edgesByAssocKindOut\";\n+    \tString indexWithDirectionBoth = \"edgesByAssocKindBoth\";\n+    \t\n+    \tString propertyKeyForIn = \"assocKindForIn\";\n+    \tString propertyKeyForOut = \"assocKindForOut\";\n+    \tString propertyKeyForBoth = \"assocKindForBoth\";\n+    \t\n+    \t\n+    \t//Schema creation\n+    \tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgzOTE1Mw==", "bodyText": "done.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r557839153", "createdAt": "2021-01-15T03:24:45Z", "author": {"login": "shkrishn"}, "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexWithDirectionIn = \"edgesByAssocKindIn\";\n+    \tString indexwithDirectionOut = \"edgesByAssocKindOut\";\n+    \tString indexWithDirectionBoth = \"edgesByAssocKindBoth\";\n+    \t\n+    \tString propertyKeyForIn = \"assocKindForIn\";\n+    \tString propertyKeyForOut = \"assocKindForOut\";\n+    \tString propertyKeyForBoth = \"assocKindForBoth\";\n+    \t\n+    \t\n+    \t//Schema creation\n+    \tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc3MzMxMw=="}, "originalCommit": {"oid": "91c7be1b61e3efbfe9998703d4a973e62931b272"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3MzE5MTY5OnYy", "diffSide": "RIGHT", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0zMFQwOToyNzo0N1rOIc8ijw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNjowNzo1NFrOI77pcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIyMjkyNw==", "bodyText": "I find that your test case testReindexingForEdgeIndex will pass even if I remove this whole \"else\" branch. There are two possibilities:\n\nYour test case is not effective enough to cover the edge case\nThis is actually not needed. Maybe only the case where pos == 0 is needed.\n\nCan you please investigate if you have some time? Otherwise, I'll take a look later.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r567222927", "createdAt": "2021-01-30T09:27:47Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex(1);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIzNDkwOA==", "bodyText": "@li-boxuan  Sure i ll look into this issue.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r567234908", "createdAt": "2021-01-30T11:35:13Z", "author": {"login": "shkrishn"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex(1);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIyMjkyNw=="}, "originalCommit": {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTcxNDE2Mg==", "bodyText": "Your fix is correct. It's just that your test case is not effective enough. I can provide a subsequent PR to improve the tests.", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r599714162", "createdAt": "2021-03-23T16:07:54Z", "author": {"login": "li-boxuan"}, "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex(1);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIyMjkyNw=="}, "originalCommit": {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1497, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}