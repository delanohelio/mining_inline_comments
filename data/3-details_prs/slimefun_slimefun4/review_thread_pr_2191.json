{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNzgzODE2", "number": 2191, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNDoxM1rOEVdC6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToxNjozNlrOEVdYLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxNDMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/EnergyNetComponent.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNDoxM1rOG8N3GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTo0NDowNFrOG8btAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDg0MQ==", "bodyText": "isChargeable should be used here", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r465794841", "createdAt": "2020-08-05T15:04:13Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/EnergyNetComponent.java", "diffHunk": "@@ -36,4 +43,104 @@\n      */\n     int getCapacity();\n \n+    /**\n+     * This returns whether this {@link EnergyNetComponent} can hold energy charges.\n+     * It returns true if {@link #getCapacity()} returns a number greater than zero.\n+     * \n+     * @return Whether this {@link EnergyNetComponent} can store energy.\n+     */\n+    default boolean isChargeable() {\n+        return getCapacity() > 0;\n+    }\n+\n+    /**\n+     * This returns the currently stored charge at a given {@link Location}.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * \n+     * @return The charge stored at that {@link Location}\n+     */\n+    default int getCharge(Location l) {\n+        String charge = BlockStorage.getLocationInfo(l, \"energy-charge\");\n+\n+        if (charge != null) {\n+            return Integer.parseInt(charge);\n+        }\n+        else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * This method sets the charge which is stored at a given {@link Location}\n+     * If this {@link EnergyNetComponent} is of type {@code EnergyNetComponentType.CAPACITOR}, then\n+     * this method will automatically update the texture of this {@link Capacitor} as well.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * @param charge\n+     *            The new charge\n+     */\n+    default void setCharge(Location l, int charge) {\n+        int capacity = getCapacity();\n+\n+        // This method only makes sense if we can actually store energy\n+        if (capacity > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyMDUyMA==", "bodyText": "That would just be the same call to getCapacity() again. The point of this is to not get the capacity twice.", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r466020520", "createdAt": "2020-08-05T21:41:27Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/EnergyNetComponent.java", "diffHunk": "@@ -36,4 +43,104 @@\n      */\n     int getCapacity();\n \n+    /**\n+     * This returns whether this {@link EnergyNetComponent} can hold energy charges.\n+     * It returns true if {@link #getCapacity()} returns a number greater than zero.\n+     * \n+     * @return Whether this {@link EnergyNetComponent} can store energy.\n+     */\n+    default boolean isChargeable() {\n+        return getCapacity() > 0;\n+    }\n+\n+    /**\n+     * This returns the currently stored charge at a given {@link Location}.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * \n+     * @return The charge stored at that {@link Location}\n+     */\n+    default int getCharge(Location l) {\n+        String charge = BlockStorage.getLocationInfo(l, \"energy-charge\");\n+\n+        if (charge != null) {\n+            return Integer.parseInt(charge);\n+        }\n+        else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * This method sets the charge which is stored at a given {@link Location}\n+     * If this {@link EnergyNetComponent} is of type {@code EnergyNetComponentType.CAPACITOR}, then\n+     * this method will automatically update the texture of this {@link Capacitor} as well.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * @param charge\n+     *            The new charge\n+     */\n+    default void setCharge(Location l, int charge) {\n+        int capacity = getCapacity();\n+\n+        // This method only makes sense if we can actually store energy\n+        if (capacity > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDg0MQ=="}, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyMTYzNA==", "bodyText": "Also, isChargeable() could be overridden. We don't know the internals of that method in that scenario and neither do we know the computational time of that operation.\nFor these methods we assume they are chargeable, otherwise that method shouldn't have been called in the first place, we don't need to know if it actually should be charged or not, this decision should have taken place in advance. We should only care if a valid number was given to work with because of maths...", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r466021634", "createdAt": "2020-08-05T21:44:04Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/EnergyNetComponent.java", "diffHunk": "@@ -36,4 +43,104 @@\n      */\n     int getCapacity();\n \n+    /**\n+     * This returns whether this {@link EnergyNetComponent} can hold energy charges.\n+     * It returns true if {@link #getCapacity()} returns a number greater than zero.\n+     * \n+     * @return Whether this {@link EnergyNetComponent} can store energy.\n+     */\n+    default boolean isChargeable() {\n+        return getCapacity() > 0;\n+    }\n+\n+    /**\n+     * This returns the currently stored charge at a given {@link Location}.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * \n+     * @return The charge stored at that {@link Location}\n+     */\n+    default int getCharge(Location l) {\n+        String charge = BlockStorage.getLocationInfo(l, \"energy-charge\");\n+\n+        if (charge != null) {\n+            return Integer.parseInt(charge);\n+        }\n+        else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * This method sets the charge which is stored at a given {@link Location}\n+     * If this {@link EnergyNetComponent} is of type {@code EnergyNetComponentType.CAPACITOR}, then\n+     * this method will automatically update the texture of this {@link Capacitor} as well.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * @param charge\n+     *            The new charge\n+     */\n+    default void setCharge(Location l, int charge) {\n+        int capacity = getCapacity();\n+\n+        // This method only makes sense if we can actually store energy\n+        if (capacity > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDg0MQ=="}, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxNzk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/EnergyNetComponent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNTowMlrOG8N5TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNTowMlrOG8N5TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NTQwNA==", "bodyText": "Again, isChargeable", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r465795404", "createdAt": "2020-08-05T15:05:02Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/EnergyNetComponent.java", "diffHunk": "@@ -36,4 +43,104 @@\n      */\n     int getCapacity();\n \n+    /**\n+     * This returns whether this {@link EnergyNetComponent} can hold energy charges.\n+     * It returns true if {@link #getCapacity()} returns a number greater than zero.\n+     * \n+     * @return Whether this {@link EnergyNetComponent} can store energy.\n+     */\n+    default boolean isChargeable() {\n+        return getCapacity() > 0;\n+    }\n+\n+    /**\n+     * This returns the currently stored charge at a given {@link Location}.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * \n+     * @return The charge stored at that {@link Location}\n+     */\n+    default int getCharge(Location l) {\n+        String charge = BlockStorage.getLocationInfo(l, \"energy-charge\");\n+\n+        if (charge != null) {\n+            return Integer.parseInt(charge);\n+        }\n+        else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * This method sets the charge which is stored at a given {@link Location}\n+     * If this {@link EnergyNetComponent} is of type {@code EnergyNetComponentType.CAPACITOR}, then\n+     * this method will automatically update the texture of this {@link Capacitor} as well.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * @param charge\n+     *            The new charge\n+     */\n+    default void setCharge(Location l, int charge) {\n+        int capacity = getCapacity();\n+\n+        // This method only makes sense if we can actually store energy\n+        if (capacity > 0) {\n+            charge = NumberUtils.clamp(0, charge, capacity);\n+\n+            // Do we even need to update the value?\n+            if (charge != getCharge(l)) {\n+                BlockStorage.addBlockInfo(l, \"energy-charge\", String.valueOf(charge), false);\n+\n+                // Update the capacitor texture\n+                if (getEnergyComponentType() == EnergyNetComponentType.CAPACITOR) {\n+                    SlimefunUtils.updateCapacitorTexture(l, charge, capacity);\n+                }\n+            }\n+        }\n+    }\n+\n+    default void addCharge(Location l, int charge) {\n+        Validate.isTrue(charge > 0, \"You can only add a positive charge!\");\n+        int capacity = getCapacity();\n+\n+        // This method only makes sense if we can actually store energy\n+        if (capacity > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMyMzc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/EnergyNetComponent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNjoyM1rOG8N9DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowNjoyM1rOG8N9DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NjM2NQ==", "bodyText": "isChargeable", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r465796365", "createdAt": "2020-08-05T15:06:23Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/EnergyNetComponent.java", "diffHunk": "@@ -36,4 +43,104 @@\n      */\n     int getCapacity();\n \n+    /**\n+     * This returns whether this {@link EnergyNetComponent} can hold energy charges.\n+     * It returns true if {@link #getCapacity()} returns a number greater than zero.\n+     * \n+     * @return Whether this {@link EnergyNetComponent} can store energy.\n+     */\n+    default boolean isChargeable() {\n+        return getCapacity() > 0;\n+    }\n+\n+    /**\n+     * This returns the currently stored charge at a given {@link Location}.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * \n+     * @return The charge stored at that {@link Location}\n+     */\n+    default int getCharge(Location l) {\n+        String charge = BlockStorage.getLocationInfo(l, \"energy-charge\");\n+\n+        if (charge != null) {\n+            return Integer.parseInt(charge);\n+        }\n+        else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * This method sets the charge which is stored at a given {@link Location}\n+     * If this {@link EnergyNetComponent} is of type {@code EnergyNetComponentType.CAPACITOR}, then\n+     * this method will automatically update the texture of this {@link Capacitor} as well.\n+     * \n+     * @param l\n+     *            The target {@link Location}\n+     * @param charge\n+     *            The new charge\n+     */\n+    default void setCharge(Location l, int charge) {\n+        int capacity = getCapacity();\n+\n+        // This method only makes sense if we can actually store energy\n+        if (capacity > 0) {\n+            charge = NumberUtils.clamp(0, charge, capacity);\n+\n+            // Do we even need to update the value?\n+            if (charge != getCharge(l)) {\n+                BlockStorage.addBlockInfo(l, \"energy-charge\", String.valueOf(charge), false);\n+\n+                // Update the capacitor texture\n+                if (getEnergyComponentType() == EnergyNetComponentType.CAPACITOR) {\n+                    SlimefunUtils.updateCapacitorTexture(l, charge, capacity);\n+                }\n+            }\n+        }\n+    }\n+\n+    default void addCharge(Location l, int charge) {\n+        Validate.isTrue(charge > 0, \"You can only add a positive charge!\");\n+        int capacity = getCapacity();\n+\n+        // This method only makes sense if we can actually store energy\n+        if (capacity > 0) {\n+            int currentCharge = getCharge(l);\n+\n+            // Check if there is even space for new energy\n+            if (currentCharge < capacity) {\n+                int newCharge = Math.min(capacity, currentCharge + charge);\n+                BlockStorage.addBlockInfo(l, \"energy-charge\", String.valueOf(newCharge), false);\n+\n+                // Update the capacitor texture\n+                if (getEnergyComponentType() == EnergyNetComponentType.CAPACITOR) {\n+                    SlimefunUtils.updateCapacitorTexture(l, charge, capacity);\n+                }\n+            }\n+        }\n+    }\n+\n+    default void removeCharge(Location l, int charge) {\n+        Validate.isTrue(charge > 0, \"The charge to remove must be greater than zero!\");\n+        int capacity = getCapacity();\n+\n+        // This method only makes sense if we can actually store energy\n+        if (capacity > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMzMTI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/energy/EnergyNet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowODoxNlrOG8OB5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTo0NDozMFrOG8bt4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NzYwNw==", "bodyText": "Global variables... not at the top... NotLikeThis", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r465797607", "createdAt": "2020-08-05T15:08:16Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/energy/EnergyNet.java", "diffHunk": "@@ -73,9 +72,9 @@ public static EnergyNet getNetworkFromLocationOrCreate(Location l) {\n         }\n     }\n \n-    private final Set<Location> generators = new HashSet<>();\n-    private final Set<Location> storage = new HashSet<>();\n-    private final Set<Location> consumers = new HashSet<>();\n+    private final Map<Location, EnergyNetComponent> generators = new HashMap<>();\n+    private final Map<Location, EnergyNetComponent> capacitors = new HashMap<>();\n+    private final Map<Location, EnergyNetComponent> consumers = new HashMap<>();\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyMTg1Nw==", "bodyText": "Not my code, I only refactored this. But I can change it", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r466021857", "createdAt": "2020-08-05T21:44:30Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/energy/EnergyNet.java", "diffHunk": "@@ -73,9 +72,9 @@ public static EnergyNet getNetworkFromLocationOrCreate(Location l) {\n         }\n     }\n \n-    private final Set<Location> generators = new HashSet<>();\n-    private final Set<Location> storage = new HashSet<>();\n-    private final Set<Location> consumers = new HashSet<>();\n+    private final Map<Location, EnergyNetComponent> generators = new HashMap<>();\n+    private final Map<Location, EnergyNetComponent> capacitors = new HashMap<>();\n+    private final Map<Location, EnergyNetComponent> consumers = new HashMap<>();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NzYwNw=="}, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTM2ODc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/energy/EnergyNet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToxNjozNlrOG8OZ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTo0NDo1N1rOG8buvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMzczNw==", "bodyText": "Make a variable name less verbose, that's not like you Cookie", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r465803737", "createdAt": "2020-08-05T15:16:36Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/energy/EnergyNet.java", "diffHunk": "@@ -139,138 +149,141 @@ public void tick(Block b) {\n             SimpleHologram.update(b, \"&4No Energy Network found\");\n         }\n         else {\n-            Map<Location, Integer> generatorsWithCapacity = new HashMap<>();\n-            int supply = tickAllGenerators(generatorsWithCapacity, timestamp::getAndAdd) + tickAllCapacitors();\n+            int supply = tickAllGenerators(timestamp::getAndAdd) + tickAllCapacitors();\n             int remainingEnergy = supply;\n             int demand = 0;\n \n-            for (Location machine : consumers) {\n-                int capacity = ChargableBlock.getMaxCharge(machine);\n-                int charge = ChargableBlock.getCharge(machine);\n+            for (Map.Entry<Location, EnergyNetComponent> entry : consumers.entrySet()) {\n+                Location l = entry.getKey();\n+                EnergyNetComponent component = entry.getValue();\n+                int capacity = component.getCapacity();\n+                int charge = component.getCharge(l);\n \n                 if (charge < capacity) {\n                     int availableSpace = capacity - charge;\n                     demand += availableSpace;\n \n                     if (remainingEnergy > 0) {\n                         if (remainingEnergy > availableSpace) {\n-                            ChargableBlock.setUnsafeCharge(machine, capacity, false);\n+                            component.setCharge(l, capacity);\n                             remainingEnergy -= availableSpace;\n                         }\n                         else {\n-                            ChargableBlock.setUnsafeCharge(machine, charge + remainingEnergy, false);\n+                            component.setCharge(l, charge + remainingEnergy);\n                             remainingEnergy = 0;\n                         }\n                     }\n                 }\n             }\n \n-            storeExcessEnergy(generatorsWithCapacity, remainingEnergy);\n+            storeRemainingEnergy(remainingEnergy);\n             updateHologram(b, supply, demand);\n         }\n \n         // We have subtracted the timings from Generators, so they do not show up twice.\n         SlimefunPlugin.getProfiler().closeEntry(b.getLocation(), SlimefunItems.ENERGY_REGULATOR.getItem(), timestamp.get());\n     }\n \n-    private void storeExcessEnergy(Map<Location, Integer> generators, int available) {\n-        for (Location capacitor : storage) {\n-            if (available > 0) {\n-                int capacity = ChargableBlock.getMaxCharge(capacitor);\n+    private void storeRemainingEnergy(int remainingEnergy) {\n+        for (Map.Entry<Location, EnergyNetComponent> entry : capacitors.entrySet()) {\n+            Location l = entry.getKey();\n+            EnergyNetComponent component = entry.getValue();\n+\n+            if (remainingEnergy > 0) {\n+                int capacity = component.getCapacity();\n \n-                if (available > capacity) {\n-                    ChargableBlock.setUnsafeCharge(capacitor, capacity, true);\n-                    available -= capacity;\n+                if (remainingEnergy > capacity) {\n+                    component.setCharge(l, capacity);\n+                    remainingEnergy -= capacity;\n                 }\n                 else {\n-                    ChargableBlock.setUnsafeCharge(capacitor, available, true);\n-                    available = 0;\n+                    component.setCharge(l, remainingEnergy);\n+                    remainingEnergy = 0;\n                 }\n             }\n             else {\n-                ChargableBlock.setUnsafeCharge(capacitor, 0, true);\n+                component.setCharge(l, 0);\n             }\n         }\n \n-        for (Map.Entry<Location, Integer> entry : generators.entrySet()) {\n-            Location generator = entry.getKey();\n-            int capacity = entry.getValue();\n+        for (Map.Entry<Location, EnergyNetComponent> entry : generators.entrySet()) {\n+            Location l = entry.getKey();\n+            EnergyNetComponent component = entry.getValue();\n+            int capacity = component.getCapacity();\n \n-            if (available > 0) {\n-                if (available > capacity) {\n-                    ChargableBlock.setUnsafeCharge(generator, capacity, false);\n-                    available -= capacity;\n+            if (remainingEnergy > 0) {\n+                if (remainingEnergy > capacity) {\n+                    component.setCharge(l, capacity);\n+                    remainingEnergy -= capacity;\n                 }\n                 else {\n-                    ChargableBlock.setUnsafeCharge(generator, available, false);\n-                    available = 0;\n+                    component.setCharge(l, remainingEnergy);\n+                    remainingEnergy = 0;\n                 }\n             }\n             else {\n-                ChargableBlock.setUnsafeCharge(generator, 0, false);\n+                component.setCharge(l, 0);\n             }\n         }\n     }\n \n-    private int tickAllGenerators(Map<Location, Integer> generatorsWithCapacity, LongConsumer timeCallback) {\n+    private int tickAllGenerators(LongConsumer timings) {\n         Set<Location> exploded = new HashSet<>();\n         int supply = 0;\n \n-        for (Location source : generators) {\n+        for (Map.Entry<Location, EnergyNetComponent> entry : generators.entrySet()) {\n             long timestamp = SlimefunPlugin.getProfiler().newEntry();\n-            Config config = BlockStorage.getLocationInfo(source);\n-            SlimefunItem item = SlimefunItem.getByID(config.getString(\"id\"));\n+            Location l = entry.getKey();\n+            EnergyNetComponent component = entry.getValue();\n \n-            if (item instanceof EnergyNetProvider) {\n+            if (component instanceof EnergyNetProvider) {\n+                SlimefunItem item = (SlimefunItem) component;\n                 try {\n-                    EnergyNetProvider provider = (EnergyNetProvider) item;\n-                    int energy = provider.getGeneratedOutput(source, config);\n+                    EnergyNetProvider provider = (EnergyNetProvider) component;\n+                    Config config = BlockStorage.getLocationInfo(l);\n+                    int energy = provider.getGeneratedOutput(l, config);\n \n-                    if (provider.getCapacity() > 0) {\n-                        generatorsWithCapacity.put(source, provider.getCapacity());\n-                        String charge = config.getString(\"energy-charge\");\n-\n-                        if (charge != null) {\n-                            energy += Integer.parseInt(charge);\n-                        }\n+                    if (provider.isChargeable()) {\n+                        energy += provider.getCharge(l);\n                     }\n \n-                    if (provider.willExplode(source, config)) {\n-                        exploded.add(source);\n-                        BlockStorage.clearBlockInfo(source);\n+                    if (provider.willExplode(l, config)) {\n+                        exploded.add(l);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyMjA3OA==", "bodyText": "Do you prefer loc over l...", "url": "https://github.com/Slimefun/Slimefun4/pull/2191#discussion_r466022078", "createdAt": "2020-08-05T21:44:57Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/energy/EnergyNet.java", "diffHunk": "@@ -139,138 +149,141 @@ public void tick(Block b) {\n             SimpleHologram.update(b, \"&4No Energy Network found\");\n         }\n         else {\n-            Map<Location, Integer> generatorsWithCapacity = new HashMap<>();\n-            int supply = tickAllGenerators(generatorsWithCapacity, timestamp::getAndAdd) + tickAllCapacitors();\n+            int supply = tickAllGenerators(timestamp::getAndAdd) + tickAllCapacitors();\n             int remainingEnergy = supply;\n             int demand = 0;\n \n-            for (Location machine : consumers) {\n-                int capacity = ChargableBlock.getMaxCharge(machine);\n-                int charge = ChargableBlock.getCharge(machine);\n+            for (Map.Entry<Location, EnergyNetComponent> entry : consumers.entrySet()) {\n+                Location l = entry.getKey();\n+                EnergyNetComponent component = entry.getValue();\n+                int capacity = component.getCapacity();\n+                int charge = component.getCharge(l);\n \n                 if (charge < capacity) {\n                     int availableSpace = capacity - charge;\n                     demand += availableSpace;\n \n                     if (remainingEnergy > 0) {\n                         if (remainingEnergy > availableSpace) {\n-                            ChargableBlock.setUnsafeCharge(machine, capacity, false);\n+                            component.setCharge(l, capacity);\n                             remainingEnergy -= availableSpace;\n                         }\n                         else {\n-                            ChargableBlock.setUnsafeCharge(machine, charge + remainingEnergy, false);\n+                            component.setCharge(l, charge + remainingEnergy);\n                             remainingEnergy = 0;\n                         }\n                     }\n                 }\n             }\n \n-            storeExcessEnergy(generatorsWithCapacity, remainingEnergy);\n+            storeRemainingEnergy(remainingEnergy);\n             updateHologram(b, supply, demand);\n         }\n \n         // We have subtracted the timings from Generators, so they do not show up twice.\n         SlimefunPlugin.getProfiler().closeEntry(b.getLocation(), SlimefunItems.ENERGY_REGULATOR.getItem(), timestamp.get());\n     }\n \n-    private void storeExcessEnergy(Map<Location, Integer> generators, int available) {\n-        for (Location capacitor : storage) {\n-            if (available > 0) {\n-                int capacity = ChargableBlock.getMaxCharge(capacitor);\n+    private void storeRemainingEnergy(int remainingEnergy) {\n+        for (Map.Entry<Location, EnergyNetComponent> entry : capacitors.entrySet()) {\n+            Location l = entry.getKey();\n+            EnergyNetComponent component = entry.getValue();\n+\n+            if (remainingEnergy > 0) {\n+                int capacity = component.getCapacity();\n \n-                if (available > capacity) {\n-                    ChargableBlock.setUnsafeCharge(capacitor, capacity, true);\n-                    available -= capacity;\n+                if (remainingEnergy > capacity) {\n+                    component.setCharge(l, capacity);\n+                    remainingEnergy -= capacity;\n                 }\n                 else {\n-                    ChargableBlock.setUnsafeCharge(capacitor, available, true);\n-                    available = 0;\n+                    component.setCharge(l, remainingEnergy);\n+                    remainingEnergy = 0;\n                 }\n             }\n             else {\n-                ChargableBlock.setUnsafeCharge(capacitor, 0, true);\n+                component.setCharge(l, 0);\n             }\n         }\n \n-        for (Map.Entry<Location, Integer> entry : generators.entrySet()) {\n-            Location generator = entry.getKey();\n-            int capacity = entry.getValue();\n+        for (Map.Entry<Location, EnergyNetComponent> entry : generators.entrySet()) {\n+            Location l = entry.getKey();\n+            EnergyNetComponent component = entry.getValue();\n+            int capacity = component.getCapacity();\n \n-            if (available > 0) {\n-                if (available > capacity) {\n-                    ChargableBlock.setUnsafeCharge(generator, capacity, false);\n-                    available -= capacity;\n+            if (remainingEnergy > 0) {\n+                if (remainingEnergy > capacity) {\n+                    component.setCharge(l, capacity);\n+                    remainingEnergy -= capacity;\n                 }\n                 else {\n-                    ChargableBlock.setUnsafeCharge(generator, available, false);\n-                    available = 0;\n+                    component.setCharge(l, remainingEnergy);\n+                    remainingEnergy = 0;\n                 }\n             }\n             else {\n-                ChargableBlock.setUnsafeCharge(generator, 0, false);\n+                component.setCharge(l, 0);\n             }\n         }\n     }\n \n-    private int tickAllGenerators(Map<Location, Integer> generatorsWithCapacity, LongConsumer timeCallback) {\n+    private int tickAllGenerators(LongConsumer timings) {\n         Set<Location> exploded = new HashSet<>();\n         int supply = 0;\n \n-        for (Location source : generators) {\n+        for (Map.Entry<Location, EnergyNetComponent> entry : generators.entrySet()) {\n             long timestamp = SlimefunPlugin.getProfiler().newEntry();\n-            Config config = BlockStorage.getLocationInfo(source);\n-            SlimefunItem item = SlimefunItem.getByID(config.getString(\"id\"));\n+            Location l = entry.getKey();\n+            EnergyNetComponent component = entry.getValue();\n \n-            if (item instanceof EnergyNetProvider) {\n+            if (component instanceof EnergyNetProvider) {\n+                SlimefunItem item = (SlimefunItem) component;\n                 try {\n-                    EnergyNetProvider provider = (EnergyNetProvider) item;\n-                    int energy = provider.getGeneratedOutput(source, config);\n+                    EnergyNetProvider provider = (EnergyNetProvider) component;\n+                    Config config = BlockStorage.getLocationInfo(l);\n+                    int energy = provider.getGeneratedOutput(l, config);\n \n-                    if (provider.getCapacity() > 0) {\n-                        generatorsWithCapacity.put(source, provider.getCapacity());\n-                        String charge = config.getString(\"energy-charge\");\n-\n-                        if (charge != null) {\n-                            energy += Integer.parseInt(charge);\n-                        }\n+                    if (provider.isChargeable()) {\n+                        energy += provider.getCharge(l);\n                     }\n \n-                    if (provider.willExplode(source, config)) {\n-                        exploded.add(source);\n-                        BlockStorage.clearBlockInfo(source);\n+                    if (provider.willExplode(l, config)) {\n+                        exploded.add(l);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMzczNw=="}, "originalCommit": {"oid": "32849ca5631f05df6662fed9129bbf2f4a6b4d70"}, "originalPosition": 259}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 297, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}