{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NTk4NzEx", "number": 1892, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxODo1Njo0NlrOD65Gig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxOToxNzoyN1rOD65NXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDc5NTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/categories/LockedCategory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxODo1Njo0NlrOGS9W9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxOToyNDowNlrOGS9iPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzMjg1NQ==", "bodyText": "Probably yeah", "url": "https://github.com/Slimefun/Slimefun4/pull/1892#discussion_r422532855", "createdAt": "2020-05-09T18:56:46Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/categories/LockedCategory.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package io.github.thebusybiscuit.slimefun4.core.categories;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.logging.Level;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.api.player.PlayerProfile;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+\n+/**\n+ * Represents a {@link Category} that cannot be opened until the parent category/categories\n+ * are fully unlocked.\n+ * <p>\n+ * See {@link Category} for the complete documentation.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Category\n+ * @see SeasonalCategory\n+ * \n+ */\n+public class LockedCategory extends Category {\n+\n+    private final NamespacedKey[] keys;\n+    private final Set<Category> parents = new HashSet<>();\n+\n+    /**\n+     * The basic constructor for a LockedCategory.\n+     * Like {@link Category}, the default tier is automatically set to 3.\n+     * \n+     * @param key\n+     *            A unique identifier for this category\n+     * @param item\n+     *            The display item for this category\n+     * @param parents\n+     *            The parent categories for this category\n+     * \n+     */\n+    public LockedCategory(NamespacedKey key, ItemStack item, NamespacedKey... parents) {\n+        this(key, item, 3, parents);\n+    }\n+\n+    /**\n+     * The constructor for a LockedCategory.\n+     * \n+     * @param key\n+     *            A unique identifier for this category\n+     * @param item\n+     *            The display item for this category\n+     * @param tier\n+     *            The tier of this category\n+     * @param parents\n+     *            The parent categories for this category\n+     * \n+     */\n+    public LockedCategory(NamespacedKey key, ItemStack item, int tier, NamespacedKey... parents) {\n+        super(key, item, tier);\n+        Validate.noNullElements(parents, \"A LockedCategory must not have any 'null' parents!\");\n+\n+        this.keys = parents;\n+    }\n+\n+    @Override\n+    public void register() {\n+        super.register();\n+\n+        List<NamespacedKey> namespacedKeys = new ArrayList<>();\n+\n+        for (NamespacedKey key : keys) {\n+            if (key != null) {\n+                namespacedKeys.add(key);\n+            }\n+        }\n+\n+        for (Category category : SlimefunPlugin.getRegistry().getCategories()) {\n+            if (namespacedKeys.remove(category.getKey())) {\n+                addParent(category);\n+            }\n+        }\n+\n+        for (NamespacedKey key : namespacedKeys) {\n+            Slimefun.getLogger().log(Level.INFO, \"Parent \\\"{0}\\\" for Category \\\"{1}\\\" was not found, probably just disabled.\", new Object[] { key, getKey() });\n+        }\n+    }\n+\n+    /**\n+     * Gets the list of parent categories for this {@link LockedCategory}.\n+     * \n+     * @return the list of parent categories\n+     * \n+     * @see #addParent(Category)\n+     * @see #removeParent(Category)\n+     */\n+    public Set<Category> getParents() {\n+        return parents;\n+    }\n+\n+    /**\n+     * Adds a parent {@link Category} to this {@link LockedCategory}.\n+     * \n+     * @param category\n+     *            The {@link Category} to add as a parent\n+     *\n+     * @see #getParents()\n+     * @see #removeParent(Category)\n+     */\n+    public void addParent(Category category) {\n+        if (category == this || category == null) {\n+            throw new IllegalArgumentException(\"Category '\" + item.getItemMeta().getDisplayName() + \"' cannot be a parent of itself or have a 'null' parent.\");\n+        }\n+\n+        parents.add(category);\n+    }\n+\n+    /**\n+     * Removes a {@link Category} from the parents of this {@link LockedCategory}.\n+     * \n+     * @param category\n+     *            The {@link Category} to remove from the parents of this {@link LockedCategory}\n+     * \n+     * @see #getParents()\n+     * @see #addParent(Category)\n+     */\n+    public void removeParent(Category category) {\n+        parents.remove(category);\n+    }\n+\n+    /**\n+     * Checks if the {@link Player} has fully unlocked all parent categories.\n+     * \n+     * @param p\n+     *            The {@link Player} to check\n+     * @param profile\n+     *            The {@link PlayerProfile} that belongs to the given {@link Player}\n+     * @return Whether the {@link Player} has fully completed all parent categories, otherwise false\n+     */\n+    public boolean hasUnlocked(Player p, PlayerProfile profile) {\n+        for (Category category : parents) {\n+            for (SlimefunItem item : category.getItems()) {\n+                // Should we replace this all with Slimefun.hasUnlocked() ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df99b6fd8dadff527a0085da530d9f86aeac691"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzNTc0Mg==", "bodyText": "That comment is from last year or so... It only shows as a diff because the class was relocated", "url": "https://github.com/Slimefun/Slimefun4/pull/1892#discussion_r422535742", "createdAt": "2020-05-09T19:24:06Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/categories/LockedCategory.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package io.github.thebusybiscuit.slimefun4.core.categories;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.logging.Level;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.api.player.PlayerProfile;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+\n+/**\n+ * Represents a {@link Category} that cannot be opened until the parent category/categories\n+ * are fully unlocked.\n+ * <p>\n+ * See {@link Category} for the complete documentation.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Category\n+ * @see SeasonalCategory\n+ * \n+ */\n+public class LockedCategory extends Category {\n+\n+    private final NamespacedKey[] keys;\n+    private final Set<Category> parents = new HashSet<>();\n+\n+    /**\n+     * The basic constructor for a LockedCategory.\n+     * Like {@link Category}, the default tier is automatically set to 3.\n+     * \n+     * @param key\n+     *            A unique identifier for this category\n+     * @param item\n+     *            The display item for this category\n+     * @param parents\n+     *            The parent categories for this category\n+     * \n+     */\n+    public LockedCategory(NamespacedKey key, ItemStack item, NamespacedKey... parents) {\n+        this(key, item, 3, parents);\n+    }\n+\n+    /**\n+     * The constructor for a LockedCategory.\n+     * \n+     * @param key\n+     *            A unique identifier for this category\n+     * @param item\n+     *            The display item for this category\n+     * @param tier\n+     *            The tier of this category\n+     * @param parents\n+     *            The parent categories for this category\n+     * \n+     */\n+    public LockedCategory(NamespacedKey key, ItemStack item, int tier, NamespacedKey... parents) {\n+        super(key, item, tier);\n+        Validate.noNullElements(parents, \"A LockedCategory must not have any 'null' parents!\");\n+\n+        this.keys = parents;\n+    }\n+\n+    @Override\n+    public void register() {\n+        super.register();\n+\n+        List<NamespacedKey> namespacedKeys = new ArrayList<>();\n+\n+        for (NamespacedKey key : keys) {\n+            if (key != null) {\n+                namespacedKeys.add(key);\n+            }\n+        }\n+\n+        for (Category category : SlimefunPlugin.getRegistry().getCategories()) {\n+            if (namespacedKeys.remove(category.getKey())) {\n+                addParent(category);\n+            }\n+        }\n+\n+        for (NamespacedKey key : namespacedKeys) {\n+            Slimefun.getLogger().log(Level.INFO, \"Parent \\\"{0}\\\" for Category \\\"{1}\\\" was not found, probably just disabled.\", new Object[] { key, getKey() });\n+        }\n+    }\n+\n+    /**\n+     * Gets the list of parent categories for this {@link LockedCategory}.\n+     * \n+     * @return the list of parent categories\n+     * \n+     * @see #addParent(Category)\n+     * @see #removeParent(Category)\n+     */\n+    public Set<Category> getParents() {\n+        return parents;\n+    }\n+\n+    /**\n+     * Adds a parent {@link Category} to this {@link LockedCategory}.\n+     * \n+     * @param category\n+     *            The {@link Category} to add as a parent\n+     *\n+     * @see #getParents()\n+     * @see #removeParent(Category)\n+     */\n+    public void addParent(Category category) {\n+        if (category == this || category == null) {\n+            throw new IllegalArgumentException(\"Category '\" + item.getItemMeta().getDisplayName() + \"' cannot be a parent of itself or have a 'null' parent.\");\n+        }\n+\n+        parents.add(category);\n+    }\n+\n+    /**\n+     * Removes a {@link Category} from the parents of this {@link LockedCategory}.\n+     * \n+     * @param category\n+     *            The {@link Category} to remove from the parents of this {@link LockedCategory}\n+     * \n+     * @see #getParents()\n+     * @see #addParent(Category)\n+     */\n+    public void removeParent(Category category) {\n+        parents.remove(category);\n+    }\n+\n+    /**\n+     * Checks if the {@link Player} has fully unlocked all parent categories.\n+     * \n+     * @param p\n+     *            The {@link Player} to check\n+     * @param profile\n+     *            The {@link PlayerProfile} that belongs to the given {@link Player}\n+     * @return Whether the {@link Player} has fully completed all parent categories, otherwise false\n+     */\n+    public boolean hasUnlocked(Player p, PlayerProfile profile) {\n+        for (Category category : parents) {\n+            for (SlimefunItem item : category.getItems()) {\n+                // Should we replace this all with Slimefun.hasUnlocked() ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzMjg1NQ=="}, "originalCommit": {"oid": "4df99b6fd8dadff527a0085da530d9f86aeac691"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDc5OTQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/SoulboundRune.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxOTowMDo1OVrOGS9Yxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxOToyNDozNFrOGS9iaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzMzMxOQ==", "bodyText": "While this is being moved to a method, should add a persistent data tag for this rather than relying on the lore.", "url": "https://github.com/Slimefun/Slimefun4/pull/1892#discussion_r422533319", "createdAt": "2020-05-09T19:00:59Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/SoulboundRune.java", "diffHunk": "@@ -104,6 +102,21 @@ public ItemDropHandler getItemHandler() {\n         };\n     }\n \n+    /**\n+     * This method applies the {@link Soulbound} effect onto a given {@link ItemStack}.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} to apply this effect to\n+     */\n+    public void apply(ItemStack item) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df99b6fd8dadff527a0085da530d9f86aeac691"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzNTc4NQ==", "bodyText": "Definitely agree with this, not my code, just refactored it.", "url": "https://github.com/Slimefun/Slimefun4/pull/1892#discussion_r422535785", "createdAt": "2020-05-09T19:24:34Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/SoulboundRune.java", "diffHunk": "@@ -104,6 +102,21 @@ public ItemDropHandler getItemHandler() {\n         };\n     }\n \n+    /**\n+     * This method applies the {@link Soulbound} effect onto a given {@link ItemStack}.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} to apply this effect to\n+     */\n+    public void apply(ItemStack item) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzMzMxOQ=="}, "originalCommit": {"oid": "4df99b6fd8dadff527a0085da530d9f86aeac691"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDgwNTY5OnYy", "diffSide": "RIGHT", "path": "src/test/java/io/github/thebusybiscuit/slimefun4/tests/items/TestCategories.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxOTowODo0NlrOGS9bzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxOToyNTo0OVrOGS9i4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzNDA5Mw==", "bodyText": "You should also check size after this first one. You're checking the intended initial behaviour and then a checked behaviour (dupe)", "url": "https://github.com/Slimefun/Slimefun4/pull/1892#discussion_r422534093", "createdAt": "2020-05-09T19:08:46Z", "author": {"login": "WalshyDev"}, "path": "src/test/java/io/github/thebusybiscuit/slimefun4/tests/items/TestCategories.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package io.github.thebusybiscuit.slimefun4.tests.items;\n+\n+import java.time.LocalDate;\n+import java.time.Month;\n+\n+import org.bukkit.Material;\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.ItemStack;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import be.seeseemelk.mockbukkit.MockBukkit;\n+import be.seeseemelk.mockbukkit.ServerMock;\n+import io.github.thebusybiscuit.cscorelib2.item.CustomItem;\n+import io.github.thebusybiscuit.slimefun4.api.player.PlayerProfile;\n+import io.github.thebusybiscuit.slimefun4.core.categories.FlexCategory;\n+import io.github.thebusybiscuit.slimefun4.core.categories.LockedCategory;\n+import io.github.thebusybiscuit.slimefun4.core.categories.SeasonalCategory;\n+import io.github.thebusybiscuit.slimefun4.core.guide.SlimefunGuideLayout;\n+import io.github.thebusybiscuit.slimefun4.mocks.SlimefunMocks;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+public class TestCategories {\n+\n+    private static ServerMock server;\n+    private static SlimefunPlugin plugin;\n+\n+    @BeforeAll\n+    public static void load() {\n+        server = MockBukkit.mock();\n+        plugin = MockBukkit.load(SlimefunPlugin.class);\n+    }\n+\n+    @AfterAll\n+    public static void unload() {\n+        MockBukkit.unmock();\n+    }\n+\n+    @Test\n+    public void testCategoryGetters() {\n+        Category category = new Category(new NamespacedKey(plugin, \"getter_test\"), new CustomItem(Material.DIAMOND_AXE, \"&6Testing\"));\n+\n+        Assertions.assertEquals(3, category.getTier());\n+        Assertions.assertEquals(new NamespacedKey(SlimefunPlugin.instance, \"getter_test\"), category.getKey());\n+        Assertions.assertEquals(\"Testing\", category.getUnlocalizedName());\n+        Assertions.assertEquals(0, category.getItems().size());\n+    }\n+\n+    @Test\n+    public void testAddItem() {\n+        Category category = new Category(new NamespacedKey(plugin, \"items_test\"), new CustomItem(Material.DIAMOND_AXE, \"&6Testing\"));\n+        SlimefunItem item = SlimefunMocks.mockSlimefunItem(plugin, \"CATEGORY_ITEMS_TEST_ITEM\", new CustomItem(Material.BAMBOO, \"&6Test Bamboo\"));\n+        item.setCategory(category);\n+        item.register(plugin);\n+        item.load();\n+\n+        Assertions.assertEquals(1, category.getItems().size());\n+\n+        // Size must still be 1 since we disallow duplicates\n+        item.setCategory(category);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df99b6fd8dadff527a0085da530d9f86aeac691"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzNTkwNQ==", "bodyText": "I know I could, doing it twice was just an exaggeration", "url": "https://github.com/Slimefun/Slimefun4/pull/1892#discussion_r422535905", "createdAt": "2020-05-09T19:25:49Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/test/java/io/github/thebusybiscuit/slimefun4/tests/items/TestCategories.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package io.github.thebusybiscuit.slimefun4.tests.items;\n+\n+import java.time.LocalDate;\n+import java.time.Month;\n+\n+import org.bukkit.Material;\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.ItemStack;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import be.seeseemelk.mockbukkit.MockBukkit;\n+import be.seeseemelk.mockbukkit.ServerMock;\n+import io.github.thebusybiscuit.cscorelib2.item.CustomItem;\n+import io.github.thebusybiscuit.slimefun4.api.player.PlayerProfile;\n+import io.github.thebusybiscuit.slimefun4.core.categories.FlexCategory;\n+import io.github.thebusybiscuit.slimefun4.core.categories.LockedCategory;\n+import io.github.thebusybiscuit.slimefun4.core.categories.SeasonalCategory;\n+import io.github.thebusybiscuit.slimefun4.core.guide.SlimefunGuideLayout;\n+import io.github.thebusybiscuit.slimefun4.mocks.SlimefunMocks;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+public class TestCategories {\n+\n+    private static ServerMock server;\n+    private static SlimefunPlugin plugin;\n+\n+    @BeforeAll\n+    public static void load() {\n+        server = MockBukkit.mock();\n+        plugin = MockBukkit.load(SlimefunPlugin.class);\n+    }\n+\n+    @AfterAll\n+    public static void unload() {\n+        MockBukkit.unmock();\n+    }\n+\n+    @Test\n+    public void testCategoryGetters() {\n+        Category category = new Category(new NamespacedKey(plugin, \"getter_test\"), new CustomItem(Material.DIAMOND_AXE, \"&6Testing\"));\n+\n+        Assertions.assertEquals(3, category.getTier());\n+        Assertions.assertEquals(new NamespacedKey(SlimefunPlugin.instance, \"getter_test\"), category.getKey());\n+        Assertions.assertEquals(\"Testing\", category.getUnlocalizedName());\n+        Assertions.assertEquals(0, category.getItems().size());\n+    }\n+\n+    @Test\n+    public void testAddItem() {\n+        Category category = new Category(new NamespacedKey(plugin, \"items_test\"), new CustomItem(Material.DIAMOND_AXE, \"&6Testing\"));\n+        SlimefunItem item = SlimefunMocks.mockSlimefunItem(plugin, \"CATEGORY_ITEMS_TEST_ITEM\", new CustomItem(Material.BAMBOO, \"&6Test Bamboo\"));\n+        item.setCategory(category);\n+        item.register(plugin);\n+        item.load();\n+\n+        Assertions.assertEquals(1, category.getItems().size());\n+\n+        // Size must still be 1 since we disallow duplicates\n+        item.setCategory(category);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzNDA5Mw=="}, "originalCommit": {"oid": "4df99b6fd8dadff527a0085da530d9f86aeac691"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDgxMzExOnYy", "diffSide": "RIGHT", "path": "src/test/java/io/github/thebusybiscuit/slimefun4/tests/services/TextCustomTextureService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxOToxNzoyN1rOGS9fbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxOToyNzowM1rOGS9jcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzNTAyMw==", "bodyText": "Not the biggest fan of using reflection in unit tests. You should be able to access the things you're making sure to test.", "url": "https://github.com/Slimefun/Slimefun4/pull/1892#discussion_r422535023", "createdAt": "2020-05-09T19:17:27Z", "author": {"login": "WalshyDev"}, "path": "src/test/java/io/github/thebusybiscuit/slimefun4/tests/services/TextCustomTextureService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.github.thebusybiscuit.slimefun4.tests.services;\n+\n+import java.util.Arrays;\n+\n+import org.bukkit.Material;\n+import org.bukkit.inventory.ItemStack;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import be.seeseemelk.mockbukkit.MockBukkit;\n+import io.github.thebusybiscuit.cscorelib2.config.Config;\n+import io.github.thebusybiscuit.cscorelib2.reflection.ReflectionUtils;\n+import io.github.thebusybiscuit.slimefun4.core.services.CustomTextureService;\n+import io.github.thebusybiscuit.slimefun4.mocks.SlimefunMocks;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+public class TextCustomTextureService {\n+\n+    private static SlimefunPlugin plugin;\n+\n+    @BeforeAll\n+    public static void load() {\n+        MockBukkit.mock();\n+        plugin = MockBukkit.load(SlimefunPlugin.class);\n+    }\n+\n+    @AfterAll\n+    public static void unload() {\n+        MockBukkit.unmock();\n+    }\n+\n+    @Test\n+    public void testInitialization() {\n+        CustomTextureService service = new CustomTextureService(plugin);\n+        Assertions.assertFalse(service.isActive());\n+        Assertions.assertNull(service.getVersion());\n+\n+        SlimefunItem item = SlimefunMocks.mockSlimefunItem(plugin, \"TEXTURE_TEST\", new ItemStack(Material.LANTERN));\n+        service.register(Arrays.asList(null, item, null), false);\n+\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> service.register(null, false));\n+\n+        // These values should not have changed yet\n+        Assertions.assertFalse(service.isActive());\n+        Assertions.assertNull(service.getVersion());\n+\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> service.getModelData(null));\n+    }\n+\n+    @Test\n+    public void testSetTexture() throws NoSuchFieldException, IllegalAccessException {\n+        CustomTextureService service = new CustomTextureService(plugin);\n+        SlimefunItem item = SlimefunMocks.mockSlimefunItem(plugin, \"TEXTURE_TEST\", new ItemStack(Material.LANTERN));\n+        String version = \"Unit Test v1.0\";\n+\n+        Config config = (Config) ReflectionUtils.getFieldValue(service, \"config\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df99b6fd8dadff527a0085da530d9f86aeac691"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzNjA1MQ==", "bodyText": "Yeah me neither but we shouldn't expose that Config though, so Reflection is the best we can do to inject some values there", "url": "https://github.com/Slimefun/Slimefun4/pull/1892#discussion_r422536051", "createdAt": "2020-05-09T19:27:03Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/test/java/io/github/thebusybiscuit/slimefun4/tests/services/TextCustomTextureService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.github.thebusybiscuit.slimefun4.tests.services;\n+\n+import java.util.Arrays;\n+\n+import org.bukkit.Material;\n+import org.bukkit.inventory.ItemStack;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import be.seeseemelk.mockbukkit.MockBukkit;\n+import io.github.thebusybiscuit.cscorelib2.config.Config;\n+import io.github.thebusybiscuit.cscorelib2.reflection.ReflectionUtils;\n+import io.github.thebusybiscuit.slimefun4.core.services.CustomTextureService;\n+import io.github.thebusybiscuit.slimefun4.mocks.SlimefunMocks;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+public class TextCustomTextureService {\n+\n+    private static SlimefunPlugin plugin;\n+\n+    @BeforeAll\n+    public static void load() {\n+        MockBukkit.mock();\n+        plugin = MockBukkit.load(SlimefunPlugin.class);\n+    }\n+\n+    @AfterAll\n+    public static void unload() {\n+        MockBukkit.unmock();\n+    }\n+\n+    @Test\n+    public void testInitialization() {\n+        CustomTextureService service = new CustomTextureService(plugin);\n+        Assertions.assertFalse(service.isActive());\n+        Assertions.assertNull(service.getVersion());\n+\n+        SlimefunItem item = SlimefunMocks.mockSlimefunItem(plugin, \"TEXTURE_TEST\", new ItemStack(Material.LANTERN));\n+        service.register(Arrays.asList(null, item, null), false);\n+\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> service.register(null, false));\n+\n+        // These values should not have changed yet\n+        Assertions.assertFalse(service.isActive());\n+        Assertions.assertNull(service.getVersion());\n+\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> service.getModelData(null));\n+    }\n+\n+    @Test\n+    public void testSetTexture() throws NoSuchFieldException, IllegalAccessException {\n+        CustomTextureService service = new CustomTextureService(plugin);\n+        SlimefunItem item = SlimefunMocks.mockSlimefunItem(plugin, \"TEXTURE_TEST\", new ItemStack(Material.LANTERN));\n+        String version = \"Unit Test v1.0\";\n+\n+        Config config = (Config) ReflectionUtils.getFieldValue(service, \"config\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzNTAyMw=="}, "originalCommit": {"oid": "4df99b6fd8dadff527a0085da530d9f86aeac691"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 440, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}