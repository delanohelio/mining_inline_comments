{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NDE5MzI5", "number": 1953, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToxMzo1NFrOEDPlFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToyMDowNlrOEDPmuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODM2NDM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/ActiveMiner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToxMzo1NFrOGgKHlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToxMzo1NFrOGgKHlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3MzM5Ng==", "bodyText": "There's BlockPosition in CS-CoreLib2 which would be better for this.", "url": "https://github.com/Slimefun/Slimefun4/pull/1953#discussion_r436373396", "createdAt": "2020-06-07T15:13:54Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/ActiveMiner.java", "diffHunk": "@@ -0,0 +1,362 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.multiblocks.miner;\n+\n+import java.util.UUID;\n+import java.util.logging.Level;\n+\n+import org.bukkit.Bukkit;\n+import org.bukkit.Effect;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.Chest;\n+import org.bukkit.block.data.type.Piston;\n+import org.bukkit.block.data.type.PistonHead;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.Inventory;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.cscorelib2.inventory.InvUtils;\n+import io.github.thebusybiscuit.cscorelib2.inventory.ItemUtils;\n+import io.github.thebusybiscuit.cscorelib2.protection.ProtectableAction;\n+import io.github.thebusybiscuit.cscorelib2.scheduling.TaskQueue;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.abstractItems.MachineFuel;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+\n+/**\n+ * This represents a running instance of an {@link IndustrialMiner}.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see IndustrialMiner\n+ * @see AdvancedIndustrialMiner\n+ *\n+ */\n+class ActiveMiner implements Runnable {\n+\n+    private final IndustrialMiner miner;\n+    private final UUID owner;\n+\n+    private int fuel = 0;\n+    private int ores = 0;\n+    private boolean running = false;\n+\n+    private final Block chest;\n+    private final Block[] pistons;\n+\n+    private final Location start;\n+    private final Location end;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd17d3a5a2b4ed8a1b6599fa724450df03fa7e4"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODM2NjMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/ActiveMiner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToxNjozOFrOGgKIlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToxNjozOFrOGgKIlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3MzY1Mw==", "bodyText": "We should post location info like in cargo. Better yet, have a util method in ErrorCatcher to handle it for us.\nThink we should always post coords if possible, server owners may need them depending on the issue.", "url": "https://github.com/Slimefun/Slimefun4/pull/1953#discussion_r436373653", "createdAt": "2020-06-07T15:16:38Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/ActiveMiner.java", "diffHunk": "@@ -0,0 +1,362 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.multiblocks.miner;\n+\n+import java.util.UUID;\n+import java.util.logging.Level;\n+\n+import org.bukkit.Bukkit;\n+import org.bukkit.Effect;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.Chest;\n+import org.bukkit.block.data.type.Piston;\n+import org.bukkit.block.data.type.PistonHead;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.Inventory;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.cscorelib2.inventory.InvUtils;\n+import io.github.thebusybiscuit.cscorelib2.inventory.ItemUtils;\n+import io.github.thebusybiscuit.cscorelib2.protection.ProtectableAction;\n+import io.github.thebusybiscuit.cscorelib2.scheduling.TaskQueue;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.abstractItems.MachineFuel;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+\n+/**\n+ * This represents a running instance of an {@link IndustrialMiner}.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see IndustrialMiner\n+ * @see AdvancedIndustrialMiner\n+ *\n+ */\n+class ActiveMiner implements Runnable {\n+\n+    private final IndustrialMiner miner;\n+    private final UUID owner;\n+\n+    private int fuel = 0;\n+    private int ores = 0;\n+    private boolean running = false;\n+\n+    private final Block chest;\n+    private final Block[] pistons;\n+\n+    private final Location start;\n+    private final Location end;\n+    private final int height;\n+\n+    private int x;\n+    private int z;\n+\n+    public ActiveMiner(IndustrialMiner miner, UUID owner, Block chest, Block[] pistons, Location start, Location end) {\n+        this.miner = miner;\n+        this.owner = owner;\n+\n+        this.chest = chest;\n+        this.pistons = pistons;\n+\n+        this.start = start;\n+        this.end = end;\n+\n+        this.height = start.getBlockY();\n+        this.x = start.getBlockX();\n+        this.z = start.getBlockZ();\n+    }\n+\n+    /**\n+     * This starts the {@link IndustrialMiner} at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block} which marks the center of this {@link IndustrialMiner}\n+     */\n+    public void start(Block b) {\n+        miner.activeMiners.put(b.getLocation(), this);\n+        running = true;\n+\n+        warmUp();\n+    }\n+\n+    /**\n+     * This method stops the {@link IndustrialMiner}.\n+     */\n+    public void stop() {\n+        running = false;\n+        miner.activeMiners.remove(chest.getRelative(BlockFace.DOWN).getLocation());\n+    }\n+\n+    /**\n+     * This method stops the {@link IndustrialMiner} with an error message.\n+     * The error message is a path to the location in Slimefun's localization files.\n+     * \n+     * @param error\n+     *            The error message to send\n+     */\n+    public void stop(String error) {\n+        Player p = Bukkit.getPlayer(owner);\n+\n+        if (p != null) {\n+            SlimefunPlugin.getLocal().sendMessage(p, error);\n+        }\n+\n+        stop();\n+    }\n+\n+    /**\n+     * This method starts the warm-up animation for the {@link IndustrialMiner}.\n+     */\n+    private void warmUp() {\n+        fuel = consumeFuel();\n+\n+        if (fuel <= 0) {\n+            // This Miner has not enough fuel.\n+            stop(\"machines.INDUSTRIAL_MINER.no-fuel\");\n+            return;\n+        }\n+\n+        // This is our warm up animation\n+        // The pistons will push after another in decreasing intervals\n+        TaskQueue queue = new TaskQueue();\n+\n+        queue.thenRun(4, () -> setPistonState(pistons[0], true));\n+        queue.thenRun(10, () -> setPistonState(pistons[0], false));\n+\n+        queue.thenRun(8, () -> setPistonState(pistons[1], true));\n+        queue.thenRun(10, () -> setPistonState(pistons[1], false));\n+\n+        queue.thenRun(6, () -> setPistonState(pistons[0], true));\n+        queue.thenRun(9, () -> setPistonState(pistons[0], false));\n+\n+        queue.thenRun(4, () -> setPistonState(pistons[1], true));\n+        queue.thenRun(7, () -> setPistonState(pistons[1], false));\n+\n+        queue.thenRun(3, () -> setPistonState(pistons[0], true));\n+        queue.thenRun(5, () -> setPistonState(pistons[0], false));\n+\n+        queue.thenRun(2, () -> setPistonState(pistons[1], true));\n+        queue.thenRun(4, () -> setPistonState(pistons[1], false));\n+\n+        queue.thenRun(1, () -> setPistonState(pistons[0], true));\n+        queue.thenRun(3, () -> setPistonState(pistons[0], false));\n+\n+        queue.thenRun(1, () -> setPistonState(pistons[1], true));\n+        queue.thenRun(2, () -> setPistonState(pistons[1], false));\n+\n+        queue.thenRun(1, this);\n+        queue.execute(SlimefunPlugin.instance);\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (!running) {\n+            // Don't continue if the machine has stopped\n+            return;\n+        }\n+\n+        try {\n+            TaskQueue queue = new TaskQueue();\n+\n+            queue.thenRun(1, () -> setPistonState(pistons[0], true));\n+            queue.thenRun(3, () -> setPistonState(pistons[0], false));\n+\n+            queue.thenRun(1, () -> setPistonState(pistons[1], true));\n+            queue.thenRun(3, () -> setPistonState(pistons[1], false));\n+\n+            queue.thenRun(() -> {\n+                Block furnace = chest.getRelative(BlockFace.DOWN);\n+                furnace.getWorld().playEffect(furnace.getLocation(), Effect.STEP_SOUND, Material.STONE);\n+\n+                for (int y = height; y > 0; y--) {\n+                    Block b = start.getWorld().getBlockAt(x, y, z);\n+\n+                    if (!SlimefunPlugin.getProtectionManager().hasPermission(Bukkit.getOfflinePlayer(owner), b, ProtectableAction.BREAK_BLOCK)) {\n+                        stop(\"machines.INDUSTRIAL_MINER.no-permission\");\n+                        return;\n+                    }\n+\n+                    if (miner.canMine(b.getType()) && push(miner.getOutcome(b.getType()))) {\n+                        furnace.getWorld().playEffect(furnace.getLocation(), Effect.STEP_SOUND, b.getType());\n+                        furnace.getWorld().playSound(furnace.getLocation(), Sound.ENTITY_ARROW_HIT_PLAYER, 0.2F, 1F);\n+\n+                        b.setType(Material.AIR);\n+                        fuel--;\n+                        ores++;\n+\n+                        // Repeat the same column when we hit an ore.\n+                        Slimefun.runSync(this, 4);\n+                        return;\n+                    }\n+                }\n+\n+                nextColumn();\n+            });\n+\n+            queue.execute(SlimefunPlugin.instance);\n+        }\n+        catch (Exception e) {\n+            Slimefun.getLogger().log(Level.SEVERE, \"An Error occured while running an Industrial Miner\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd17d3a5a2b4ed8a1b6599fa724450df03fa7e4"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODM2Nzc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/ActiveMiner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToxODo0M1rOGgKJTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToxODo0M1rOGgKJTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3MzgzOA==", "bodyText": "same as said above", "url": "https://github.com/Slimefun/Slimefun4/pull/1953#discussion_r436373838", "createdAt": "2020-06-07T15:18:43Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/ActiveMiner.java", "diffHunk": "@@ -0,0 +1,362 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.multiblocks.miner;\n+\n+import java.util.UUID;\n+import java.util.logging.Level;\n+\n+import org.bukkit.Bukkit;\n+import org.bukkit.Effect;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.Chest;\n+import org.bukkit.block.data.type.Piston;\n+import org.bukkit.block.data.type.PistonHead;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.Inventory;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.cscorelib2.inventory.InvUtils;\n+import io.github.thebusybiscuit.cscorelib2.inventory.ItemUtils;\n+import io.github.thebusybiscuit.cscorelib2.protection.ProtectableAction;\n+import io.github.thebusybiscuit.cscorelib2.scheduling.TaskQueue;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.abstractItems.MachineFuel;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+\n+/**\n+ * This represents a running instance of an {@link IndustrialMiner}.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see IndustrialMiner\n+ * @see AdvancedIndustrialMiner\n+ *\n+ */\n+class ActiveMiner implements Runnable {\n+\n+    private final IndustrialMiner miner;\n+    private final UUID owner;\n+\n+    private int fuel = 0;\n+    private int ores = 0;\n+    private boolean running = false;\n+\n+    private final Block chest;\n+    private final Block[] pistons;\n+\n+    private final Location start;\n+    private final Location end;\n+    private final int height;\n+\n+    private int x;\n+    private int z;\n+\n+    public ActiveMiner(IndustrialMiner miner, UUID owner, Block chest, Block[] pistons, Location start, Location end) {\n+        this.miner = miner;\n+        this.owner = owner;\n+\n+        this.chest = chest;\n+        this.pistons = pistons;\n+\n+        this.start = start;\n+        this.end = end;\n+\n+        this.height = start.getBlockY();\n+        this.x = start.getBlockX();\n+        this.z = start.getBlockZ();\n+    }\n+\n+    /**\n+     * This starts the {@link IndustrialMiner} at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block} which marks the center of this {@link IndustrialMiner}\n+     */\n+    public void start(Block b) {\n+        miner.activeMiners.put(b.getLocation(), this);\n+        running = true;\n+\n+        warmUp();\n+    }\n+\n+    /**\n+     * This method stops the {@link IndustrialMiner}.\n+     */\n+    public void stop() {\n+        running = false;\n+        miner.activeMiners.remove(chest.getRelative(BlockFace.DOWN).getLocation());\n+    }\n+\n+    /**\n+     * This method stops the {@link IndustrialMiner} with an error message.\n+     * The error message is a path to the location in Slimefun's localization files.\n+     * \n+     * @param error\n+     *            The error message to send\n+     */\n+    public void stop(String error) {\n+        Player p = Bukkit.getPlayer(owner);\n+\n+        if (p != null) {\n+            SlimefunPlugin.getLocal().sendMessage(p, error);\n+        }\n+\n+        stop();\n+    }\n+\n+    /**\n+     * This method starts the warm-up animation for the {@link IndustrialMiner}.\n+     */\n+    private void warmUp() {\n+        fuel = consumeFuel();\n+\n+        if (fuel <= 0) {\n+            // This Miner has not enough fuel.\n+            stop(\"machines.INDUSTRIAL_MINER.no-fuel\");\n+            return;\n+        }\n+\n+        // This is our warm up animation\n+        // The pistons will push after another in decreasing intervals\n+        TaskQueue queue = new TaskQueue();\n+\n+        queue.thenRun(4, () -> setPistonState(pistons[0], true));\n+        queue.thenRun(10, () -> setPistonState(pistons[0], false));\n+\n+        queue.thenRun(8, () -> setPistonState(pistons[1], true));\n+        queue.thenRun(10, () -> setPistonState(pistons[1], false));\n+\n+        queue.thenRun(6, () -> setPistonState(pistons[0], true));\n+        queue.thenRun(9, () -> setPistonState(pistons[0], false));\n+\n+        queue.thenRun(4, () -> setPistonState(pistons[1], true));\n+        queue.thenRun(7, () -> setPistonState(pistons[1], false));\n+\n+        queue.thenRun(3, () -> setPistonState(pistons[0], true));\n+        queue.thenRun(5, () -> setPistonState(pistons[0], false));\n+\n+        queue.thenRun(2, () -> setPistonState(pistons[1], true));\n+        queue.thenRun(4, () -> setPistonState(pistons[1], false));\n+\n+        queue.thenRun(1, () -> setPistonState(pistons[0], true));\n+        queue.thenRun(3, () -> setPistonState(pistons[0], false));\n+\n+        queue.thenRun(1, () -> setPistonState(pistons[1], true));\n+        queue.thenRun(2, () -> setPistonState(pistons[1], false));\n+\n+        queue.thenRun(1, this);\n+        queue.execute(SlimefunPlugin.instance);\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (!running) {\n+            // Don't continue if the machine has stopped\n+            return;\n+        }\n+\n+        try {\n+            TaskQueue queue = new TaskQueue();\n+\n+            queue.thenRun(1, () -> setPistonState(pistons[0], true));\n+            queue.thenRun(3, () -> setPistonState(pistons[0], false));\n+\n+            queue.thenRun(1, () -> setPistonState(pistons[1], true));\n+            queue.thenRun(3, () -> setPistonState(pistons[1], false));\n+\n+            queue.thenRun(() -> {\n+                Block furnace = chest.getRelative(BlockFace.DOWN);\n+                furnace.getWorld().playEffect(furnace.getLocation(), Effect.STEP_SOUND, Material.STONE);\n+\n+                for (int y = height; y > 0; y--) {\n+                    Block b = start.getWorld().getBlockAt(x, y, z);\n+\n+                    if (!SlimefunPlugin.getProtectionManager().hasPermission(Bukkit.getOfflinePlayer(owner), b, ProtectableAction.BREAK_BLOCK)) {\n+                        stop(\"machines.INDUSTRIAL_MINER.no-permission\");\n+                        return;\n+                    }\n+\n+                    if (miner.canMine(b.getType()) && push(miner.getOutcome(b.getType()))) {\n+                        furnace.getWorld().playEffect(furnace.getLocation(), Effect.STEP_SOUND, b.getType());\n+                        furnace.getWorld().playSound(furnace.getLocation(), Sound.ENTITY_ARROW_HIT_PLAYER, 0.2F, 1F);\n+\n+                        b.setType(Material.AIR);\n+                        fuel--;\n+                        ores++;\n+\n+                        // Repeat the same column when we hit an ore.\n+                        Slimefun.runSync(this, 4);\n+                        return;\n+                    }\n+                }\n+\n+                nextColumn();\n+            });\n+\n+            queue.execute(SlimefunPlugin.instance);\n+        }\n+        catch (Exception e) {\n+            Slimefun.getLogger().log(Level.SEVERE, \"An Error occured while running an Industrial Miner\", e);\n+            stop();\n+        }\n+    }\n+\n+    /**\n+     * This advanced the {@link IndustrialMiner} to the next column\n+     */\n+    private void nextColumn() {\n+        if (x < end.getBlockX()) {\n+            x++;\n+        }\n+        else if (z < end.getBlockZ()) {\n+            x = start.getBlockX();\n+            z++;\n+        }\n+        else {\n+            // The Miner has finished\n+            stop();\n+\n+            Player p = Bukkit.getPlayer(owner);\n+\n+            if (p != null) {\n+                p.playSound(p.getLocation(), Sound.ENTITY_ARROW_HIT_PLAYER, 0.4F, 1F);\n+                SlimefunPlugin.getLocal().sendMessage(p, \"machines.INDUSTRIAL_MINER.finished\", msg -> msg.replace(\"%ores%\", String.valueOf(ores)));\n+            }\n+\n+            return;\n+        }\n+\n+        Slimefun.runSync(this, 5);\n+    }\n+\n+    /**\n+     * This refuels the {@link IndustrialMiner} and pushes the given {@link ItemStack} to\n+     * its {@link Chest}.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} to push to the {@link Chest}.\n+     * \n+     * @return Whether the operation was successful\n+     */\n+    private boolean push(ItemStack item) {\n+        if (fuel < 1) {\n+            // Restock fuel\n+            fuel = consumeFuel();\n+        }\n+\n+        // Check if there is enough fuel to run\n+        if (fuel > 0) {\n+            if (chest.getType() == Material.CHEST) {\n+                Inventory inv = ((Chest) chest.getState()).getBlockInventory();\n+\n+                if (InvUtils.fits(inv, item)) {\n+                    inv.addItem(item);\n+                    return true;\n+                }\n+                else {\n+                    stop(\"machines.INDUSTRIAL_MINER.chest-full\");\n+                }\n+            }\n+            else {\n+                // The chest has been destroyed\n+                stop(\"machines.INDUSTRIAL_MINER.destroyed\");\n+            }\n+        }\n+        else {\n+            stop(\"machines.INDUSTRIAL_MINER.no-fuel\");\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * This consumes fuel from the given {@link Chest}.\n+     * \n+     * @return The gained fuel value\n+     */\n+    private int consumeFuel() {\n+        if (chest.getType() == Material.CHEST) {\n+            Inventory inv = ((Chest) chest.getState()).getBlockInventory();\n+\n+            for (int i = 0; i < inv.getSize(); i++) {\n+                for (MachineFuel fuelType : miner.fuelTypes) {\n+                    ItemStack item = inv.getContents()[i];\n+\n+                    if (fuelType.test(item)) {\n+                        ItemUtils.consumeItem(item, false);\n+\n+                        if (miner instanceof AdvancedIndustrialMiner) {\n+                            inv.addItem(new ItemStack(Material.BUCKET));\n+                        }\n+\n+                        return fuelType.getTicks();\n+                    }\n+                }\n+            }\n+        }\n+\n+        return 0;\n+    }\n+\n+    private void setPistonState(Block block, boolean extended) {\n+        if (!running) {\n+            return;\n+        }\n+\n+        try {\n+            // Smoke Particles around the Chest for dramatic effect\n+            Location particleLoc = chest.getLocation().clone().add(0, -1, 0);\n+            block.getWorld().spawnParticle(Particle.SMOKE_NORMAL, particleLoc, 20, 0.7, 0.7, 0.7, 0);\n+\n+            if (block.getType() == Material.MOVING_PISTON) {\n+                // Yeah it isn't really cool when this happens\n+                block.getRelative(BlockFace.UP).setType(Material.AIR);\n+            }\n+            else if (block.getType() == Material.PISTON) {\n+                Block above = block.getRelative(BlockFace.UP);\n+\n+                if (above.isEmpty() || above.getType() == Material.PISTON_HEAD) {\n+                    Piston piston = (Piston) block.getBlockData();\n+\n+                    if (piston.getFacing() == BlockFace.UP) {\n+                        piston.setExtended(extended);\n+                        block.setBlockData(piston, false);\n+\n+                        // Updating the Piston Head\n+                        if (extended) {\n+                            PistonHead head = (PistonHead) Material.PISTON_HEAD.createBlockData();\n+                            head.setFacing(BlockFace.UP);\n+\n+                            block.getRelative(BlockFace.UP).setBlockData(head, false);\n+                        }\n+                        else {\n+                            block.getRelative(BlockFace.UP).setType(Material.AIR);\n+                        }\n+\n+                        block.getWorld().playSound(block.getLocation(), extended ? Sound.BLOCK_PISTON_EXTEND : Sound.BLOCK_PISTON_CONTRACT, 0.1F, 1F);\n+                    }\n+                    else {\n+                        // The pistons must be facing upwards\n+                        stop(\"machines.INDUSTRIAL_MINER.piston-facing\");\n+                    }\n+                }\n+                else {\n+                    // The pistons must be facing upwards\n+                    stop(\"machines.INDUSTRIAL_MINER.piston-space\");\n+                }\n+            }\n+            else {\n+                // The piston has been destroyed\n+                stop(\"machines.INDUSTRIAL_MINER.destroyed\");\n+            }\n+        }\n+        catch (Exception e) {\n+            Slimefun.getLogger().log(Level.SEVERE, \"An Error occured while moving a Piston for an Industrial Miner\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd17d3a5a2b4ed8a1b6599fa724450df03fa7e4"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODM2ODU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/IndustrialMiner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToyMDowNlrOGgKJuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNToyOToxNFrOGgKM3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3Mzk0NQ==", "bodyText": "does this need to be a list? If you need order a LinkedHashSet may be better.", "url": "https://github.com/Slimefun/Slimefun4/pull/1953#discussion_r436373945", "createdAt": "2020-06-07T15:20:06Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/IndustrialMiner.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.multiblocks.miner;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Tag;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.cscorelib2.item.CustomItem;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.abstractItems.MachineFuel;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.multiblocks.MultiBlockMachine;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * The {@link IndustrialMiner} is a {@link MultiBlockMachine} that can mine any\n+ * ores it finds in a given range underneath where it was placed.\n+ * \n+ * <i>And for those of you who are wondering... yes this is the replacement for the\n+ * long-time deprecated Digital Miner.</i>\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see AdvancedIndustrialMiner\n+ * @see ActiveMiner\n+ *\n+ */\n+public class IndustrialMiner extends MultiBlockMachine {\n+\n+    protected final Map<Location, ActiveMiner> activeMiners = new HashMap<>();\n+    protected final List<MachineFuel> fuelTypes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd17d3a5a2b4ed8a1b6599fa724450df03fa7e4"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3NDc1MA==", "bodyText": "It does need to be consistently ordered, don't really see the benefits of using a LinkedHashSet though here, an ArrayList is just fine for this purpose.", "url": "https://github.com/Slimefun/Slimefun4/pull/1953#discussion_r436374750", "createdAt": "2020-06-07T15:29:14Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/multiblocks/miner/IndustrialMiner.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.multiblocks.miner;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Tag;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Player;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.cscorelib2.item.CustomItem;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.abstractItems.MachineFuel;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.multiblocks.MultiBlockMachine;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * The {@link IndustrialMiner} is a {@link MultiBlockMachine} that can mine any\n+ * ores it finds in a given range underneath where it was placed.\n+ * \n+ * <i>And for those of you who are wondering... yes this is the replacement for the\n+ * long-time deprecated Digital Miner.</i>\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see AdvancedIndustrialMiner\n+ * @see ActiveMiner\n+ *\n+ */\n+public class IndustrialMiner extends MultiBlockMachine {\n+\n+    protected final Map<Location, ActiveMiner> activeMiners = new HashMap<>();\n+    protected final List<MachineFuel> fuelTypes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3Mzk0NQ=="}, "originalCommit": {"oid": "fcd17d3a5a2b4ed8a1b6599fa724450df03fa7e4"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 461, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}