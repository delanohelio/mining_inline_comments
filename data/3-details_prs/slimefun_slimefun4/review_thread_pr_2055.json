{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNTkwMTgz", "number": 2055, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo0NToxNlrOEJI3Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDo1NDoxMVrOEJTKjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDE3ODYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo0NToxNlrOGphe_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMToyNzoxOVrOGpyNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzQwNA==", "bodyText": "I make an API to make this smaller but you do this :PepeHands:", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446193404", "createdAt": "2020-06-26T13:45:16Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffa5ab9a7d42e1cb40b2d56720f41564198bc58"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NTQxMg==", "bodyText": "For very good reasons: Your API loads in classes on startup which will crash the entire plugin, if on 1.13", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446465412", "createdAt": "2020-06-27T01:07:11Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzQwNA=="}, "originalCommit": {"oid": "6ffa5ab9a7d42e1cb40b2d56720f41564198bc58"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzExNA==", "bodyText": "True... why do you insist on 1.13 support :NotLikeThis:", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467114", "createdAt": "2020-06-27T01:23:39Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzQwNA=="}, "originalCommit": {"oid": "6ffa5ab9a7d42e1cb40b2d56720f41564198bc58"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzE5Mw==", "bodyText": "Because all that's required for 1.13 support is throwing out your API >.>", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467193", "createdAt": "2020-06-27T01:24:33Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzQwNA=="}, "originalCommit": {"oid": "6ffa5ab9a7d42e1cb40b2d56720f41564198bc58"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzUyOA==", "bodyText": "1.8% of servers by the way LUL\nAlso means you can throw out these damn if (atLeast(1_14))", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467528", "createdAt": "2020-06-27T01:27:19Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzQwNA=="}, "originalCommit": {"oid": "6ffa5ab9a7d42e1cb40b2d56720f41564198bc58"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDIyODQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/SlimefunItemSetup.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo1ODozMVrOGph9hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMToyMzoxNVrOGpyL-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIwMTIyMw==", "bodyText": "Still into this pattern eh? Implementing abstract method here...\nPlease just accept a param and pass it. It's really quite ugly and unneeded having these methods implemented in here", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446201223", "createdAt": "2020-06-26T13:58:31Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/SlimefunItemSetup.java", "diffHunk": "@@ -1975,15 +1975,22 @@ public int getCapacity() {\n \t\t\tnew AutoDrier(categories.electricity, SlimefunItems.AUTO_DRIER, RecipeType.ENHANCED_CRAFTING_TABLE,\n \t\t\tnew ItemStack[]{null, null, null, SlimefunItems.HEATING_COIL, new ItemStack(Material.SMOKER), SlimefunItems.HEATING_COIL, null, new ItemStack(Material.CAMPFIRE), null})\n \t\t\t.register(plugin);\n-\t\t} else {\n+\t\t} \n+\t\telse {\n \t\t\tnew AutoDrier(categories.electricity, SlimefunItems.AUTO_DRIER, RecipeType.ENHANCED_CRAFTING_TABLE,\n \t\t\tnew ItemStack[]{null, null, null, SlimefunItems.HEATING_COIL, new ItemStack(Material.FURNACE), SlimefunItems.HEATING_COIL, null, new ItemStack(Material.TORCH), null})\n \t\t\t.register(plugin);\n \t\t}\n \n \t\tnew AutoBrewer(categories.electricity, SlimefunItems.AUTO_BREWER, RecipeType.ENHANCED_CRAFTING_TABLE,\n-\t\tnew ItemStack[] {null, SlimefunItems.HEATING_COIL, null, SlimefunItems.REINFORCED_PLATE, new ItemStack(Material.BREWING_STAND), SlimefunItems.REINFORCED_PLATE, null, SlimefunItems.ELECTRIC_MOTOR, null})\n-\t\t.register(plugin);\n+\t\tnew ItemStack[] {null, SlimefunItems.HEATING_COIL, null, SlimefunItems.REINFORCED_PLATE, new ItemStack(Material.BREWING_STAND), SlimefunItems.REINFORCED_PLATE, null, SlimefunItems.ELECTRIC_MOTOR, null}) {\n+\n+            @Override\n+            public int getSpeed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ffa5ab9a7d42e1cb40b2d56720f41564198bc58"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NTgyMA==", "bodyText": "I'd much prefer a parameter too. But this has nothing to do with this PR. I simply exposed it instead of having it hard-coded.\nAgain, not in scope of this PR.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446465820", "createdAt": "2020-06-27T01:10:58Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/SlimefunItemSetup.java", "diffHunk": "@@ -1975,15 +1975,22 @@ public int getCapacity() {\n \t\t\tnew AutoDrier(categories.electricity, SlimefunItems.AUTO_DRIER, RecipeType.ENHANCED_CRAFTING_TABLE,\n \t\t\tnew ItemStack[]{null, null, null, SlimefunItems.HEATING_COIL, new ItemStack(Material.SMOKER), SlimefunItems.HEATING_COIL, null, new ItemStack(Material.CAMPFIRE), null})\n \t\t\t.register(plugin);\n-\t\t} else {\n+\t\t} \n+\t\telse {\n \t\t\tnew AutoDrier(categories.electricity, SlimefunItems.AUTO_DRIER, RecipeType.ENHANCED_CRAFTING_TABLE,\n \t\t\tnew ItemStack[]{null, null, null, SlimefunItems.HEATING_COIL, new ItemStack(Material.FURNACE), SlimefunItems.HEATING_COIL, null, new ItemStack(Material.TORCH), null})\n \t\t\t.register(plugin);\n \t\t}\n \n \t\tnew AutoBrewer(categories.electricity, SlimefunItems.AUTO_BREWER, RecipeType.ENHANCED_CRAFTING_TABLE,\n-\t\tnew ItemStack[] {null, SlimefunItems.HEATING_COIL, null, SlimefunItems.REINFORCED_PLATE, new ItemStack(Material.BREWING_STAND), SlimefunItems.REINFORCED_PLATE, null, SlimefunItems.ELECTRIC_MOTOR, null})\n-\t\t.register(plugin);\n+\t\tnew ItemStack[] {null, SlimefunItems.HEATING_COIL, null, SlimefunItems.REINFORCED_PLATE, new ItemStack(Material.BREWING_STAND), SlimefunItems.REINFORCED_PLATE, null, SlimefunItems.ELECTRIC_MOTOR, null}) {\n+\n+            @Override\n+            public int getSpeed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIwMTIyMw=="}, "originalCommit": {"oid": "6ffa5ab9a7d42e1cb40b2d56720f41564198bc58"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzA2Ng==", "bodyText": "roll eyes you changed it, makes it in scope", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467066", "createdAt": "2020-06-27T01:23:15Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/SlimefunItemSetup.java", "diffHunk": "@@ -1975,15 +1975,22 @@ public int getCapacity() {\n \t\t\tnew AutoDrier(categories.electricity, SlimefunItems.AUTO_DRIER, RecipeType.ENHANCED_CRAFTING_TABLE,\n \t\t\tnew ItemStack[]{null, null, null, SlimefunItems.HEATING_COIL, new ItemStack(Material.SMOKER), SlimefunItems.HEATING_COIL, null, new ItemStack(Material.CAMPFIRE), null})\n \t\t\t.register(plugin);\n-\t\t} else {\n+\t\t} \n+\t\telse {\n \t\t\tnew AutoDrier(categories.electricity, SlimefunItems.AUTO_DRIER, RecipeType.ENHANCED_CRAFTING_TABLE,\n \t\t\tnew ItemStack[]{null, null, null, SlimefunItems.HEATING_COIL, new ItemStack(Material.FURNACE), SlimefunItems.HEATING_COIL, null, new ItemStack(Material.TORCH), null})\n \t\t\t.register(plugin);\n \t\t}\n \n \t\tnew AutoBrewer(categories.electricity, SlimefunItems.AUTO_BREWER, RecipeType.ENHANCED_CRAFTING_TABLE,\n-\t\tnew ItemStack[] {null, SlimefunItems.HEATING_COIL, null, SlimefunItems.REINFORCED_PLATE, new ItemStack(Material.BREWING_STAND), SlimefunItems.REINFORCED_PLATE, null, SlimefunItems.ELECTRIC_MOTOR, null})\n-\t\t.register(plugin);\n+\t\tnew ItemStack[] {null, SlimefunItems.HEATING_COIL, null, SlimefunItems.REINFORCED_PLATE, new ItemStack(Material.BREWING_STAND), SlimefunItems.REINFORCED_PLATE, null, SlimefunItems.ELECTRIC_MOTOR, null}) {\n+\n+            @Override\n+            public int getSpeed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIwMTIyMw=="}, "originalCommit": {"oid": "6ffa5ab9a7d42e1cb40b2d56720f41564198bc58"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTgzNTkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/Rechargeable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDoyNDo1OFrOGpxwNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMTowODowNFrOGpyF4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1OTk1Nw==", "bodyText": "Should we just make these SlimefunItemStacks? I don't see a world where this would ever be on a normal item and that way we're also enforcing ID (so performance improvements) to be there.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446459957", "createdAt": "2020-06-27T00:24:58Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/Rechargeable.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import org.bukkit.Material;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+\n+import io.github.thebusybiscuit.slimefun4.core.networks.energy.EnergyNet;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.Jetpack;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.MultiTool;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.machines.ChargingBench;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+/**\n+ * A {@link Rechargeable} {@link SlimefunItem} can hold energy and is able to\n+ * be recharged using a {@link ChargingBench}.\n+ * Any {@link SlimefunItem} which is supposed to be chargeable <b>must</b> implement this interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see ChargingBench\n+ * @see EnergyNet\n+ * @see Jetpack\n+ * @see MultiTool\n+ *\n+ */\n+@FunctionalInterface\n+public interface Rechargeable extends ItemAttribute {\n+\n+    /**\n+     * This method returns the maximum charge the given {@link ItemStack} is capable of holding.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} for which to determine the maximum charge\n+     * \n+     * @return The maximum energy charge for this {@link ItemStack}\n+     */\n+    float getMaxItemCharge(ItemStack item);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e081d15c6d6643d40d46c1adb4275df80ac69d9c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NTUwNA==", "bodyText": "This will almost never be a SlimefunItemStack, unless it's factory new.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446465504", "createdAt": "2020-06-27T01:08:04Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/Rechargeable.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import org.bukkit.Material;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+\n+import io.github.thebusybiscuit.slimefun4.core.networks.energy.EnergyNet;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.Jetpack;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.MultiTool;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.machines.ChargingBench;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+/**\n+ * A {@link Rechargeable} {@link SlimefunItem} can hold energy and is able to\n+ * be recharged using a {@link ChargingBench}.\n+ * Any {@link SlimefunItem} which is supposed to be chargeable <b>must</b> implement this interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see ChargingBench\n+ * @see EnergyNet\n+ * @see Jetpack\n+ * @see MultiTool\n+ *\n+ */\n+@FunctionalInterface\n+public interface Rechargeable extends ItemAttribute {\n+\n+    /**\n+     * This method returns the maximum charge the given {@link ItemStack} is capable of holding.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} for which to determine the maximum charge\n+     * \n+     * @return The maximum energy charge for this {@link ItemStack}\n+     */\n+    float getMaxItemCharge(ItemStack item);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1OTk1Nw=="}, "originalCommit": {"oid": "e081d15c6d6643d40d46c1adb4275df80ac69d9c"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTgzODg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/Rechargeable.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDoyNzozOFrOGpxx2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMToyNjoxNVrOGpyNaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDM3OQ==", "bodyText": "How come you never just use Preconditions for these? Bit nicer to look at and generally more consistent with Bukkit internals which I like.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446460379", "createdAt": "2020-06-27T00:27:38Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/Rechargeable.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import org.bukkit.Material;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+\n+import io.github.thebusybiscuit.slimefun4.core.networks.energy.EnergyNet;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.Jetpack;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.MultiTool;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.machines.ChargingBench;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+/**\n+ * A {@link Rechargeable} {@link SlimefunItem} can hold energy and is able to\n+ * be recharged using a {@link ChargingBench}.\n+ * Any {@link SlimefunItem} which is supposed to be chargeable <b>must</b> implement this interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see ChargingBench\n+ * @see EnergyNet\n+ * @see Jetpack\n+ * @see MultiTool\n+ *\n+ */\n+@FunctionalInterface\n+public interface Rechargeable extends ItemAttribute {\n+\n+    /**\n+     * This method returns the maximum charge the given {@link ItemStack} is capable of holding.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} for which to determine the maximum charge\n+     * \n+     * @return The maximum energy charge for this {@link ItemStack}\n+     */\n+    float getMaxItemCharge(ItemStack item);\n+\n+    /**\n+     * This method sets the stored energy charge for a given {@link ItemStack}.\n+     * The charge must be at least zero and at most {@link #getMaxItemCharge(ItemStack)}.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} to charge\n+     * @param charge\n+     *            The amount of charge to store\n+     */\n+    default void setItemCharge(ItemStack item, float charge) {\n+        if (item == null || item.getType() == Material.AIR) {\n+            throw new IllegalArgumentException(\"Cannot set Item charge for null or AIR\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e081d15c6d6643d40d46c1adb4275df80ac69d9c"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NjIwOA==", "bodyText": "Did you ever look at Slimefuns code? I use Validate literally everywhere to check for nulls, but if the expresssions get longer, I stick with an if.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446466208", "createdAt": "2020-06-27T01:14:54Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/Rechargeable.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import org.bukkit.Material;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+\n+import io.github.thebusybiscuit.slimefun4.core.networks.energy.EnergyNet;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.Jetpack;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.MultiTool;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.machines.ChargingBench;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+/**\n+ * A {@link Rechargeable} {@link SlimefunItem} can hold energy and is able to\n+ * be recharged using a {@link ChargingBench}.\n+ * Any {@link SlimefunItem} which is supposed to be chargeable <b>must</b> implement this interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see ChargingBench\n+ * @see EnergyNet\n+ * @see Jetpack\n+ * @see MultiTool\n+ *\n+ */\n+@FunctionalInterface\n+public interface Rechargeable extends ItemAttribute {\n+\n+    /**\n+     * This method returns the maximum charge the given {@link ItemStack} is capable of holding.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} for which to determine the maximum charge\n+     * \n+     * @return The maximum energy charge for this {@link ItemStack}\n+     */\n+    float getMaxItemCharge(ItemStack item);\n+\n+    /**\n+     * This method sets the stored energy charge for a given {@link ItemStack}.\n+     * The charge must be at least zero and at most {@link #getMaxItemCharge(ItemStack)}.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} to charge\n+     * @param charge\n+     *            The amount of charge to store\n+     */\n+    default void setItemCharge(ItemStack item, float charge) {\n+        if (item == null || item.getType() == Material.AIR) {\n+            throw new IllegalArgumentException(\"Cannot set Item charge for null or AIR\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDM3OQ=="}, "originalCommit": {"oid": "e081d15c6d6643d40d46c1adb4275df80ac69d9c"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzQzNQ==", "bodyText": "Yes I know. Hence why I said \"never\".", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467435", "createdAt": "2020-06-27T01:26:15Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/Rechargeable.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import org.bukkit.Material;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+\n+import io.github.thebusybiscuit.slimefun4.core.networks.energy.EnergyNet;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.Jetpack;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.gadgets.MultiTool;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.electric.machines.ChargingBench;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+\n+/**\n+ * A {@link Rechargeable} {@link SlimefunItem} can hold energy and is able to\n+ * be recharged using a {@link ChargingBench}.\n+ * Any {@link SlimefunItem} which is supposed to be chargeable <b>must</b> implement this interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see ChargingBench\n+ * @see EnergyNet\n+ * @see Jetpack\n+ * @see MultiTool\n+ *\n+ */\n+@FunctionalInterface\n+public interface Rechargeable extends ItemAttribute {\n+\n+    /**\n+     * This method returns the maximum charge the given {@link ItemStack} is capable of holding.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} for which to determine the maximum charge\n+     * \n+     * @return The maximum energy charge for this {@link ItemStack}\n+     */\n+    float getMaxItemCharge(ItemStack item);\n+\n+    /**\n+     * This method sets the stored energy charge for a given {@link ItemStack}.\n+     * The charge must be at least zero and at most {@link #getMaxItemCharge(ItemStack)}.\n+     * \n+     * @param item\n+     *            The {@link ItemStack} to charge\n+     * @param charge\n+     *            The amount of charge to store\n+     */\n+    default void setItemCharge(ItemStack item, float charge) {\n+        if (item == null || item.getType() == Material.AIR) {\n+            throw new IllegalArgumentException(\"Cannot set Item charge for null or AIR\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDM3OQ=="}, "originalCommit": {"oid": "e081d15c6d6643d40d46c1adb4275df80ac69d9c"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTg0ODMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDozNToyN1rOGpx2nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMToxMTowOVrOGpyHLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU5Ng==", "bodyText": "This comment is a little misleading. It makes it seem like the data doesn't exist here and will fall back to the lore. Yes you can see the code and tell but, should still be better.\nI'd simply say \"There's persistent data luckily so we return it rather than parsing the lore\"", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446461596", "createdAt": "2020-06-27T00:35:27Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);\n+        }\n+\n+        List<String> lore = meta.hasLore() ? meta.getLore() : new ArrayList<>();\n+        for (int i = 0; i < lore.size(); i++) {\n+            String line = lore.get(i);\n+\n+            if (line.startsWith(LORE_PREFIX)) {\n+                lore.set(i, LORE_PREFIX + value + \" / \" + capacity + \" J\");\n+                meta.setLore(lore);\n+                return;\n+            }\n+        }\n+\n+        lore.add(LORE_PREFIX + value + \" / \" + capacity + \" J\");\n+        meta.setLore(lore);\n+    }\n+\n+    static float getCharge(ItemMeta meta) {\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            Float value = meta.getPersistentDataContainer().get(CHARGE_KEY, PersistentDataType.FLOAT);\n+\n+            // If no persistent data exists, we will just fall back to the lore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6f09d2e2eef4d34c2cff586e6b477899301a1dd"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NTgzOA==", "bodyText": "Yeah, can change that.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446465838", "createdAt": "2020-06-27T01:11:09Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);\n+        }\n+\n+        List<String> lore = meta.hasLore() ? meta.getLore() : new ArrayList<>();\n+        for (int i = 0; i < lore.size(); i++) {\n+            String line = lore.get(i);\n+\n+            if (line.startsWith(LORE_PREFIX)) {\n+                lore.set(i, LORE_PREFIX + value + \" / \" + capacity + \" J\");\n+                meta.setLore(lore);\n+                return;\n+            }\n+        }\n+\n+        lore.add(LORE_PREFIX + value + \" / \" + capacity + \" J\");\n+        meta.setLore(lore);\n+    }\n+\n+    static float getCharge(ItemMeta meta) {\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            Float value = meta.getPersistentDataContainer().get(CHARGE_KEY, PersistentDataType.FLOAT);\n+\n+            // If no persistent data exists, we will just fall back to the lore", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU5Ng=="}, "originalCommit": {"oid": "f6f09d2e2eef4d34c2cff586e6b477899301a1dd"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTg1MDgzOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDozODo0N1rOGpx4Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMTowOTozNlrOGpyGhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTk1NA==", "bodyText": "Not a fan this doesn't set the meta. It will for sure lead to human error of not setting it after calling.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446461954", "createdAt": "2020-06-27T00:38:47Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);\n+        }\n+\n+        List<String> lore = meta.hasLore() ? meta.getLore() : new ArrayList<>();\n+        for (int i = 0; i < lore.size(); i++) {\n+            String line = lore.get(i);\n+\n+            if (line.startsWith(LORE_PREFIX)) {\n+                lore.set(i, LORE_PREFIX + value + \" / \" + capacity + \" J\");\n+                meta.setLore(lore);\n+                return;\n+            }\n+        }\n+\n+        lore.add(LORE_PREFIX + value + \" / \" + capacity + \" J\");\n+        meta.setLore(lore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NTY2OQ==", "bodyText": "You really didn't read through this, did you?\nThe method only takes the ItemMeta and modifies that, it's only for ItemMeta modification, not ItemStacks.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446465669", "createdAt": "2020-06-27T01:09:36Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/attributes/RechargeableHelper.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package io.github.thebusybiscuit.slimefun4.core.attributes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+\n+/**\n+ * This is just a simple helper class to provide static methods to the {@link Rechargeable}\n+ * interface.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see Rechargeable\n+ *\n+ */\n+final class RechargeableHelper {\n+\n+    private static final NamespacedKey CHARGE_KEY = new NamespacedKey(SlimefunPlugin.instance, \"item_charge\");\n+    private static final String LORE_PREFIX = ChatColors.color(\"&c&o&8\\u21E8 &e\\u26A1 &7\");\n+\n+    private RechargeableHelper() {}\n+\n+    static void setCharge(ItemMeta meta, float charge, float capacity) {\n+        BigDecimal decimal = BigDecimal.valueOf(charge).setScale(2, RoundingMode.HALF_UP);\n+        float value = decimal.floatValue();\n+\n+        if (SlimefunPlugin.getMinecraftVersion().isAtLeast(MinecraftVersion.MINECRAFT_1_14)) {\n+            meta.getPersistentDataContainer().set(CHARGE_KEY, PersistentDataType.FLOAT, value);\n+        }\n+\n+        List<String> lore = meta.hasLore() ? meta.getLore() : new ArrayList<>();\n+        for (int i = 0; i < lore.size(); i++) {\n+            String line = lore.get(i);\n+\n+            if (line.startsWith(LORE_PREFIX)) {\n+                lore.set(i, LORE_PREFIX + value + \" / \" + capacity + \" J\");\n+                meta.setLore(lore);\n+                return;\n+            }\n+        }\n+\n+        lore.add(LORE_PREFIX + value + \" / \" + capacity + \" J\");\n+        meta.setLore(lore);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTk1NA=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTg1ODYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDo0NjowNlrOGpx8AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMToyODo0MlrOGpyOOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mjk3Ng==", "bodyText": "I'd probably check if env is end (or check the default world) and return 0 (also, could return true in nether, not sunlight but it's supposed to be a \"hell\" thing. I like to do it this way but dealers choice).\nThis will be quicker than the block initialisation which is done below.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446462976", "createdAt": "2020-06-27T00:46:06Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NTg1OA==", "bodyText": "??", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446465858", "createdAt": "2020-06-27T01:11:21Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mjk3Ng=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NjkwNQ==", "bodyText": "The end isn't ever light level 15 and considering initialising the block is slow anyway you may as well check the env (or the world) to just insta return false. Small optimisation but optimisations are good.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446466905", "createdAt": "2020-06-27T01:21:44Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mjk3Ng=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzEyMg==", "bodyText": "I really have no idea what you mean, I know the Block call is slow but I don't understand what exact opimization you are trying to describe.\nIf you can outline it as code or make a follow up commit, it'd be awesome.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467122", "createdAt": "2020-06-27T01:23:48Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mjk3Ng=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzM0MQ==", "bodyText": "if (world.getEnvironment() == Envrionment.END) return false; (Or check if end world and do the same)", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467341", "createdAt": "2020-06-27T01:25:32Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mjk3Ng=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzQ5Ng==", "bodyText": "And true in the nether?\nI am just confused as you said \"return 0\" when this is a boolean method.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467496", "createdAt": "2020-06-27T01:26:59Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mjk3Ng=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzYzMg==", "bodyText": "Shh.\nAnd I'd say return true in nether since it's supposed to be a \"hell\" kinda thing. But, that's really up to you. Not sure the normal light levels of the nether but yeah. Just dealers choice in this regard.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467632", "createdAt": "2020-06-27T01:28:38Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mjk3Ng=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzY0MQ==", "bodyText": "I'll probably make both false for now.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467641", "createdAt": "2020-06-27T01:28:42Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mjk3Ng=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTg2MDc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDo0ODowNVrOGpx9FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMToyNTozMFrOGpyNCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MzI1Mw==", "bodyText": ":LULW:", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446463253", "createdAt": "2020-06-27T00:48:05Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();\n+        return (world.getTime() < 12300 || world.getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n     }\n \n     private void checkForRadiation(Player p) {\n         // Check for a Hazmat Suit\n-        if (!SlimefunUtils.isItemSimilar(SlimefunItems.SCUBA_HELMET, p.getInventory().getHelmet(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.HAZMAT_CHESTPLATE, p.getInventory().getChestplate(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.HAZMAT_LEGGINGS, p.getInventory().getLeggings(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.RUBBER_BOOTS, p.getInventory().getBoots(), true)) {\n+        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SCUBA_HELMET, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getChestplate(), SlimefunItems.HAZMAT_CHESTPLATE, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getLeggings(), SlimefunItems.HAZMAT_LEGGINGS, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getBoots(), SlimefunItems.RUBBER_BOOTS, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NTg2Mg==", "bodyText": "??", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446465862", "createdAt": "2020-06-27T01:11:25Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();\n+        return (world.getTime() < 12300 || world.getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n     }\n \n     private void checkForRadiation(Player p) {\n         // Check for a Hazmat Suit\n-        if (!SlimefunUtils.isItemSimilar(SlimefunItems.SCUBA_HELMET, p.getInventory().getHelmet(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.HAZMAT_CHESTPLATE, p.getInventory().getChestplate(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.HAZMAT_LEGGINGS, p.getInventory().getLeggings(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.RUBBER_BOOTS, p.getInventory().getBoots(), true)) {\n+        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SCUBA_HELMET, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getChestplate(), SlimefunItems.HAZMAT_CHESTPLATE, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getLeggings(), SlimefunItems.HAZMAT_LEGGINGS, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getBoots(), SlimefunItems.RUBBER_BOOTS, true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MzI1Mw=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NjkyNw==", "bodyText": "Wrong order. It was funny.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446466927", "createdAt": "2020-06-27T01:21:55Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();\n+        return (world.getTime() < 12300 || world.getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n     }\n \n     private void checkForRadiation(Player p) {\n         // Check for a Hazmat Suit\n-        if (!SlimefunUtils.isItemSimilar(SlimefunItems.SCUBA_HELMET, p.getInventory().getHelmet(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.HAZMAT_CHESTPLATE, p.getInventory().getChestplate(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.HAZMAT_LEGGINGS, p.getInventory().getLeggings(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.RUBBER_BOOTS, p.getInventory().getBoots(), true)) {\n+        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SCUBA_HELMET, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getChestplate(), SlimefunItems.HAZMAT_CHESTPLATE, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getLeggings(), SlimefunItems.HAZMAT_LEGGINGS, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getBoots(), SlimefunItems.RUBBER_BOOTS, true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MzI1Mw=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NzMzOQ==", "bodyText": "Yeah, god knows for how long this must have been there...", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446467339", "createdAt": "2020-06-27T01:25:30Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/ArmorTask.java", "diffHunk": "@@ -89,25 +93,28 @@ private void handleSlimefunArmor(Player p, ItemStack[] armor, HashedArmorpiece[]\n     }\n \n     private void checkForSolarHelmet(Player p) {\n-        // Temporary performance improvement\n-        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SOLAR_HELMET, true)) {\n+        ItemStack helmet = p.getInventory().getHelmet();\n+\n+        if (SlimefunPlugin.getRegistry().isBackwardsCompatible() && !SlimefunUtils.isItemSimilar(helmet, SlimefunItems.SOLAR_HELMET, true, false)) {\n+            // Performance saver for slow backwards-compatible versions of Slimefun\n             return;\n         }\n \n-        SlimefunItem item = SlimefunItem.getByItem(p.getInventory().getHelmet());\n+        SlimefunItem item = SlimefunItem.getByItem(helmet);\n \n-        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true) && hasSunlight(p)) {\n-            ItemEnergy.chargeInventory(p, (float) ((SolarHelmet) item).getChargeAmount());\n+        if (item instanceof SolarHelmet && Slimefun.hasUnlocked(p, item, true)) {\n+            ((SolarHelmet) item).rechargeItems(p);\n         }\n     }\n \n     private boolean hasSunlight(Player p) {\n-        return (p.getWorld().getTime() < 12300 || p.getWorld().getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n+        World world = p.getWorld();\n+        return (world.getTime() < 12300 || world.getTime() > 23850) && p.getEyeLocation().getBlock().getLightFromSky() == 15;\n     }\n \n     private void checkForRadiation(Player p) {\n         // Check for a Hazmat Suit\n-        if (!SlimefunUtils.isItemSimilar(SlimefunItems.SCUBA_HELMET, p.getInventory().getHelmet(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.HAZMAT_CHESTPLATE, p.getInventory().getChestplate(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.HAZMAT_LEGGINGS, p.getInventory().getLeggings(), true) || !SlimefunUtils.isItemSimilar(SlimefunItems.RUBBER_BOOTS, p.getInventory().getBoots(), true)) {\n+        if (!SlimefunUtils.isItemSimilar(p.getInventory().getHelmet(), SlimefunItems.SCUBA_HELMET, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getChestplate(), SlimefunItems.HAZMAT_CHESTPLATE, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getLeggings(), SlimefunItems.HAZMAT_LEGGINGS, true) || !SlimefunUtils.isItemSimilar(p.getInventory().getBoots(), SlimefunItems.RUBBER_BOOTS, true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MzI1Mw=="}, "originalCommit": {"oid": "0dfd40e4079448db5e6d48910566084f3b7cfe14"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTg2NjM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/me/mrCookieSlime/Slimefun/api/BlockStorage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDo1NDoxMVrOGpx_-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMToxMjoxOVrOGpyHkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mzk5Mg==", "bodyText": "I would also check a space. Spaces can mess up quite a bit on different systems. We've had someone in the past who downloaded a world and it messed up on the shared Linux server due to that", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446463992", "createdAt": "2020-06-27T00:54:11Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/me/mrCookieSlime/Slimefun/api/BlockStorage.java", "diffHunk": "@@ -97,6 +97,10 @@ private static Location deserializeLocation(String l) {\n     public BlockStorage(World w) {\n         this.world = w;\n \n+        if (world.getName().indexOf('.') != -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44c0029587805a0721655ce52149c5af0bfa5993"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2NTkzNw==", "bodyText": "Never heard of that happening. If someone reports it, it can be added. Otherwise, feel free to make a PR. This is just a dirty band aid for a much deeper problem anyway.", "url": "https://github.com/Slimefun/Slimefun4/pull/2055#discussion_r446465937", "createdAt": "2020-06-27T01:12:19Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/me/mrCookieSlime/Slimefun/api/BlockStorage.java", "diffHunk": "@@ -97,6 +97,10 @@ private static Location deserializeLocation(String l) {\n     public BlockStorage(World w) {\n         this.world = w;\n \n+        if (world.getName().indexOf('.') != -1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2Mzk5Mg=="}, "originalCommit": {"oid": "44c0029587805a0721655ce52149c5af0bfa5993"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 393, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}