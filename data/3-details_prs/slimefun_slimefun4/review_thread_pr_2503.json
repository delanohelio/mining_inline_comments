{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5NTY4Njk3", "number": 2503, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMTo0ODoxMlrOE7VDUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDowOTowMlrOE_yjtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNjQ2MzUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/AbstractItemNetwork.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMTo0ODoxMlrOH26ZnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMTo0ODoxMlrOH26ZnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM0MTk4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This will markt the {@link ItemFilter} of the given node dirty.\n          \n          \n            \n                 * This will mark the {@link ItemFilter} of the given node dirty.", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r527341980", "createdAt": "2020-11-20T01:48:12Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/AbstractItemNetwork.java", "diffHunk": "@@ -326,10 +337,27 @@ protected long updateTerminals(@Nonnull Set<Location> providers) {\n \n     @Override\n     public void markDirty(@Nonnull Location l) {\n-        connectorCache.remove(l);\n+        markCargoNodeConfigurationDirty(l);\n         super.markDirty(l);\n     }\n \n+    /**\n+     * This will markt the {@link ItemFilter} of the given node dirty.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9ad3ee3574d80d7fe20718e60890172aa034d27"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNjQ2OTU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/AbstractItemNetwork.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMTo1MDoyOFrOH26c2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMTo1MDoyOFrOH26c2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM0MjgwOQ==", "bodyText": "Im not a fan of the name is because when reading it reads like:\nif is is not null\nHowever this is just my opinion", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r527342809", "createdAt": "2020-11-20T01:50:28Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/AbstractItemNetwork.java", "diffHunk": "@@ -432,7 +460,7 @@ private void gatherItemsFromBarrel(Location l, BlockMenu blockMenu, List<ItemSta\n             for (int slot : blockMenu.getPreset().getSlotsAccessedByItemTransport((DirtyChestMenu) blockMenu, ItemTransportFlow.WITHDRAW, null)) {\n                 ItemStack is = blockMenu.getItemInSlot(slot);\n \n-                if (is != null && CargoUtils.matchesFilter(l.getBlock(), is)) {\n+                if (is != null && CargoUtils.matchesFilter(this, l.getBlock(), is)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9ad3ee3574d80d7fe20718e60890172aa034d27"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNjQ3NDA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/AbstractItemNetwork.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMTo1Mjo0MVrOH26ffw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMzoyMzo1OVrOH3PeeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM0MzQ4Nw==", "bodyText": "Not sure what the default here is\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (filter.isDirty()) {\n          \n          \n            \n                        filter.update(node);\n          \n          \n            \n                        return filter;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return filter;\n          \n          \n            \n                    } else if (filter.isDirty()) {\n          \n          \n            \n                        filter.update(node);\n          \n          \n            \n                    }\n          \n          \n            \n                    return filter;", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r527343487", "createdAt": "2020-11-20T01:52:41Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/AbstractItemNetwork.java", "diffHunk": "@@ -477,4 +505,21 @@ private void filter(@Nullable ItemStack stack, List<ItemStackAndInteger> items,\n         }\n     }\n \n+    @Nonnull\n+    protected ItemFilter getItemFilter(@Nonnull Block node) {\n+        Location loc = node.getLocation();\n+        ItemFilter filter = filterCache.get(loc);\n+\n+        if (filter == null) {\n+            ItemFilter newFilter = new ItemFilter(node);\n+            filterCache.put(loc, newFilter);\n+            return newFilter;\n+        } else if (filter.isDirty()) {\n+            filter.update(node);\n+            return filter;\n+        } else {\n+            return filter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9ad3ee3574d80d7fe20718e60890172aa034d27"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM0NTgwMA==", "bodyText": "Just no...", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r527345800", "createdAt": "2020-11-20T02:00:03Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/AbstractItemNetwork.java", "diffHunk": "@@ -477,4 +505,21 @@ private void filter(@Nullable ItemStack stack, List<ItemStackAndInteger> items,\n         }\n     }\n \n+    @Nonnull\n+    protected ItemFilter getItemFilter(@Nonnull Block node) {\n+        Location loc = node.getLocation();\n+        ItemFilter filter = filterCache.get(loc);\n+\n+        if (filter == null) {\n+            ItemFilter newFilter = new ItemFilter(node);\n+            filterCache.put(loc, newFilter);\n+            return newFilter;\n+        } else if (filter.isDirty()) {\n+            filter.update(node);\n+            return filter;\n+        } else {\n+            return filter;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM0MzQ4Nw=="}, "originalCommit": {"oid": "e9ad3ee3574d80d7fe20718e60890172aa034d27"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzI4OQ==", "bodyText": "lol", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r527687289", "createdAt": "2020-11-20T13:23:59Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/AbstractItemNetwork.java", "diffHunk": "@@ -477,4 +505,21 @@ private void filter(@Nullable ItemStack stack, List<ItemStackAndInteger> items,\n         }\n     }\n \n+    @Nonnull\n+    protected ItemFilter getItemFilter(@Nonnull Block node) {\n+        Location loc = node.getLocation();\n+        ItemFilter filter = filterCache.get(loc);\n+\n+        if (filter == null) {\n+            ItemFilter newFilter = new ItemFilter(node);\n+            filterCache.put(loc, newFilter);\n+            return newFilter;\n+        } else if (filter.isDirty()) {\n+            filter.update(node);\n+            return filter;\n+        } else {\n+            return filter;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM0MzQ4Nw=="}, "originalCommit": {"oid": "e9ad3ee3574d80d7fe20718e60890172aa034d27"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzIyMDExOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDowMzowOVrOH9sA4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMjo1NDozN1rOH-aP-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0NjMwNA==", "bodyText": "Not sure I'm the biggest fan of having another loop just for the sake of saving 1 #getItemMeta call on item. Especially since both the loops are for an Array meaning O(n). If it was a hash table and be O(1) then sure maybe but yeah. I feel like we're losing performance to try and improve performance.\nEdit: Not saying this should be using a hash table as there's no real way to use it here. Just saying I'd understand a bit more in that case", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r534446304", "createdAt": "2020-12-02T20:03:09Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.github.thebusybiscuit.slimefun4.core.networks.cargo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.utils.SlimefunUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.itemstack.ItemStackWrapper;\n+import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.BlockStorage;\n+import me.mrCookieSlime.Slimefun.api.inventory.BlockMenu;\n+\n+/**\n+ * The {@link ItemFilter} is a performance-optimization for our {@link CargoNet}.\n+ * It is a snapshot of a cargo node's configuration.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+class ItemFilter implements Predicate<ItemStack> {\n+\n+    /**\n+     * Our {@link List} of items to check against, might be empty.\n+     */\n+    private final List<ItemStackWrapper> items = new ArrayList<>();\n+\n+    /**\n+     * Our default value for this {@link ItemFilter}.\n+     * A default value of {@literal true} will mean that it returns true if no\n+     * match was found. It will deny any items that match.\n+     * A default value of {@literal false} means that it will return false if no\n+     * match was found. Only items that match will make it past this {@link ItemFilter}.\n+     */\n+    private boolean defaultValue;\n+\n+    /**\n+     * Whether we should also compare the lore.\n+     */\n+    private boolean checkLore;\n+\n+    /**\n+     * If an {@link ItemFilter} is marked as dirty / outdated, then it will be updated\n+     * on the next tick.\n+     */\n+    private boolean dirty = false;\n+\n+    /**\n+     * This creates a new {@link ItemFilter} for the given {@link Block}.\n+     * This will copy all settings from that {@link Block} to this filter.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public ItemFilter(@Nonnull Block b) {\n+        update(b);\n+    }\n+\n+    /**\n+     * This updates or refreshes the {@link ItemFilter} to copy the settings\n+     * from the given {@link Block}. It takes a new snapshot.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public void update(@Nonnull Block b) {\n+        // Store the returned Config instance to avoid heavy calls\n+        Config blockData = BlockStorage.getLocationInfo(b.getLocation());\n+        String id = blockData.getString(\"id\");\n+        SlimefunItem item = SlimefunItem.getByID(id);\n+        BlockMenu menu = BlockStorage.getInventory(b.getLocation());\n+\n+        if (item == null || menu == null) {\n+            // Don't filter for a non-existing item (safety check)\n+            clear(false);\n+        } else if (id.equals(\"CARGO_NODE_OUTPUT\")) {\n+            // Output Nodes have no filter, allow everything\n+            clear(true);\n+        } else {\n+            this.items.clear();\n+            this.checkLore = Objects.equals(blockData.getString(\"filter-lore\"), \"true\");\n+            this.defaultValue = !Objects.equals(blockData.getString(\"filter-type\"), \"whitelist\");\n+\n+            for (int slot : CargoUtils.FILTER_SLOTS) {\n+                ItemStack stack = menu.getItemInSlot(slot);\n+\n+                if (stack != null && stack.getType() != Material.AIR) {\n+                    this.items.add(new ItemStackWrapper(stack));\n+                }\n+            }\n+        }\n+\n+        this.dirty = false;\n+    }\n+\n+    /**\n+     * This will clear the {@link ItemFilter} and reject <strong>any</strong>\n+     * {@link ItemStack}.\n+     * \n+     * @param defaultValue\n+     *            The new default value.\n+     */\n+    private void clear(boolean defaultValue) {\n+        this.items.clear();\n+        this.checkLore = false;\n+        this.defaultValue = defaultValue;\n+    }\n+\n+    /**\n+     * Whether this {@link ItemFilter} is outdated and needs to be refreshed.\n+     * \n+     * @return Whether the filter is outdated.\n+     */\n+    public boolean isDirty() {\n+        return dirty;\n+    }\n+\n+    /**\n+     * This marks this {@link ItemFilter} as dirty / outdated.\n+     */\n+    public void markDirty() {\n+        this.dirty = true;\n+    }\n+\n+    @Override\n+    public boolean test(@Nonnull ItemStack item) {\n+        // An empty Filter does not need to be iterated over.\n+        if (items.isEmpty()) {\n+            return defaultValue;\n+        }\n+\n+        int potentialMatches = 0;\n+\n+        // This is a first check for materials to see if we might even have any match.\n+        // If there is no potential match then we won't need to perform the quite\n+        // intense operation .getItemMeta()\n+        for (ItemStackWrapper stack : items) {\n+            if (stack.getType() == item.getType()) {\n+                // We found a potential match based on the Material\n+                potentialMatches++;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f32b160a57523d407bb05eaef36e86d62c46507"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUzNzkyNw==", "bodyText": "getItemMeta() is a very heavy function that can explode quite quickly.\nThis is a bit ugly but it does improve performance overall actually.\nThe horror of ItemMeta cloning is really worth this sacrifice here sadly.", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r534537927", "createdAt": "2020-12-02T22:56:01Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.github.thebusybiscuit.slimefun4.core.networks.cargo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.utils.SlimefunUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.itemstack.ItemStackWrapper;\n+import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.BlockStorage;\n+import me.mrCookieSlime.Slimefun.api.inventory.BlockMenu;\n+\n+/**\n+ * The {@link ItemFilter} is a performance-optimization for our {@link CargoNet}.\n+ * It is a snapshot of a cargo node's configuration.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+class ItemFilter implements Predicate<ItemStack> {\n+\n+    /**\n+     * Our {@link List} of items to check against, might be empty.\n+     */\n+    private final List<ItemStackWrapper> items = new ArrayList<>();\n+\n+    /**\n+     * Our default value for this {@link ItemFilter}.\n+     * A default value of {@literal true} will mean that it returns true if no\n+     * match was found. It will deny any items that match.\n+     * A default value of {@literal false} means that it will return false if no\n+     * match was found. Only items that match will make it past this {@link ItemFilter}.\n+     */\n+    private boolean defaultValue;\n+\n+    /**\n+     * Whether we should also compare the lore.\n+     */\n+    private boolean checkLore;\n+\n+    /**\n+     * If an {@link ItemFilter} is marked as dirty / outdated, then it will be updated\n+     * on the next tick.\n+     */\n+    private boolean dirty = false;\n+\n+    /**\n+     * This creates a new {@link ItemFilter} for the given {@link Block}.\n+     * This will copy all settings from that {@link Block} to this filter.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public ItemFilter(@Nonnull Block b) {\n+        update(b);\n+    }\n+\n+    /**\n+     * This updates or refreshes the {@link ItemFilter} to copy the settings\n+     * from the given {@link Block}. It takes a new snapshot.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public void update(@Nonnull Block b) {\n+        // Store the returned Config instance to avoid heavy calls\n+        Config blockData = BlockStorage.getLocationInfo(b.getLocation());\n+        String id = blockData.getString(\"id\");\n+        SlimefunItem item = SlimefunItem.getByID(id);\n+        BlockMenu menu = BlockStorage.getInventory(b.getLocation());\n+\n+        if (item == null || menu == null) {\n+            // Don't filter for a non-existing item (safety check)\n+            clear(false);\n+        } else if (id.equals(\"CARGO_NODE_OUTPUT\")) {\n+            // Output Nodes have no filter, allow everything\n+            clear(true);\n+        } else {\n+            this.items.clear();\n+            this.checkLore = Objects.equals(blockData.getString(\"filter-lore\"), \"true\");\n+            this.defaultValue = !Objects.equals(blockData.getString(\"filter-type\"), \"whitelist\");\n+\n+            for (int slot : CargoUtils.FILTER_SLOTS) {\n+                ItemStack stack = menu.getItemInSlot(slot);\n+\n+                if (stack != null && stack.getType() != Material.AIR) {\n+                    this.items.add(new ItemStackWrapper(stack));\n+                }\n+            }\n+        }\n+\n+        this.dirty = false;\n+    }\n+\n+    /**\n+     * This will clear the {@link ItemFilter} and reject <strong>any</strong>\n+     * {@link ItemStack}.\n+     * \n+     * @param defaultValue\n+     *            The new default value.\n+     */\n+    private void clear(boolean defaultValue) {\n+        this.items.clear();\n+        this.checkLore = false;\n+        this.defaultValue = defaultValue;\n+    }\n+\n+    /**\n+     * Whether this {@link ItemFilter} is outdated and needs to be refreshed.\n+     * \n+     * @return Whether the filter is outdated.\n+     */\n+    public boolean isDirty() {\n+        return dirty;\n+    }\n+\n+    /**\n+     * This marks this {@link ItemFilter} as dirty / outdated.\n+     */\n+    public void markDirty() {\n+        this.dirty = true;\n+    }\n+\n+    @Override\n+    public boolean test(@Nonnull ItemStack item) {\n+        // An empty Filter does not need to be iterated over.\n+        if (items.isEmpty()) {\n+            return defaultValue;\n+        }\n+\n+        int potentialMatches = 0;\n+\n+        // This is a first check for materials to see if we might even have any match.\n+        // If there is no potential match then we won't need to perform the quite\n+        // intense operation .getItemMeta()\n+        for (ItemStackWrapper stack : items) {\n+            if (stack.getType() == item.getType()) {\n+                // We found a potential match based on the Material\n+                potentialMatches++;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0NjMwNA=="}, "originalCommit": {"oid": "1f32b160a57523d407bb05eaef36e86d62c46507"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwMjQxMg==", "bodyText": "Also, keep in mind that items has a maximum capacity of 9. So the impact will be quite small.", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r535002412", "createdAt": "2020-12-03T09:30:13Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.github.thebusybiscuit.slimefun4.core.networks.cargo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.utils.SlimefunUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.itemstack.ItemStackWrapper;\n+import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.BlockStorage;\n+import me.mrCookieSlime.Slimefun.api.inventory.BlockMenu;\n+\n+/**\n+ * The {@link ItemFilter} is a performance-optimization for our {@link CargoNet}.\n+ * It is a snapshot of a cargo node's configuration.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+class ItemFilter implements Predicate<ItemStack> {\n+\n+    /**\n+     * Our {@link List} of items to check against, might be empty.\n+     */\n+    private final List<ItemStackWrapper> items = new ArrayList<>();\n+\n+    /**\n+     * Our default value for this {@link ItemFilter}.\n+     * A default value of {@literal true} will mean that it returns true if no\n+     * match was found. It will deny any items that match.\n+     * A default value of {@literal false} means that it will return false if no\n+     * match was found. Only items that match will make it past this {@link ItemFilter}.\n+     */\n+    private boolean defaultValue;\n+\n+    /**\n+     * Whether we should also compare the lore.\n+     */\n+    private boolean checkLore;\n+\n+    /**\n+     * If an {@link ItemFilter} is marked as dirty / outdated, then it will be updated\n+     * on the next tick.\n+     */\n+    private boolean dirty = false;\n+\n+    /**\n+     * This creates a new {@link ItemFilter} for the given {@link Block}.\n+     * This will copy all settings from that {@link Block} to this filter.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public ItemFilter(@Nonnull Block b) {\n+        update(b);\n+    }\n+\n+    /**\n+     * This updates or refreshes the {@link ItemFilter} to copy the settings\n+     * from the given {@link Block}. It takes a new snapshot.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public void update(@Nonnull Block b) {\n+        // Store the returned Config instance to avoid heavy calls\n+        Config blockData = BlockStorage.getLocationInfo(b.getLocation());\n+        String id = blockData.getString(\"id\");\n+        SlimefunItem item = SlimefunItem.getByID(id);\n+        BlockMenu menu = BlockStorage.getInventory(b.getLocation());\n+\n+        if (item == null || menu == null) {\n+            // Don't filter for a non-existing item (safety check)\n+            clear(false);\n+        } else if (id.equals(\"CARGO_NODE_OUTPUT\")) {\n+            // Output Nodes have no filter, allow everything\n+            clear(true);\n+        } else {\n+            this.items.clear();\n+            this.checkLore = Objects.equals(blockData.getString(\"filter-lore\"), \"true\");\n+            this.defaultValue = !Objects.equals(blockData.getString(\"filter-type\"), \"whitelist\");\n+\n+            for (int slot : CargoUtils.FILTER_SLOTS) {\n+                ItemStack stack = menu.getItemInSlot(slot);\n+\n+                if (stack != null && stack.getType() != Material.AIR) {\n+                    this.items.add(new ItemStackWrapper(stack));\n+                }\n+            }\n+        }\n+\n+        this.dirty = false;\n+    }\n+\n+    /**\n+     * This will clear the {@link ItemFilter} and reject <strong>any</strong>\n+     * {@link ItemStack}.\n+     * \n+     * @param defaultValue\n+     *            The new default value.\n+     */\n+    private void clear(boolean defaultValue) {\n+        this.items.clear();\n+        this.checkLore = false;\n+        this.defaultValue = defaultValue;\n+    }\n+\n+    /**\n+     * Whether this {@link ItemFilter} is outdated and needs to be refreshed.\n+     * \n+     * @return Whether the filter is outdated.\n+     */\n+    public boolean isDirty() {\n+        return dirty;\n+    }\n+\n+    /**\n+     * This marks this {@link ItemFilter} as dirty / outdated.\n+     */\n+    public void markDirty() {\n+        this.dirty = true;\n+    }\n+\n+    @Override\n+    public boolean test(@Nonnull ItemStack item) {\n+        // An empty Filter does not need to be iterated over.\n+        if (items.isEmpty()) {\n+            return defaultValue;\n+        }\n+\n+        int potentialMatches = 0;\n+\n+        // This is a first check for materials to see if we might even have any match.\n+        // If there is no potential match then we won't need to perform the quite\n+        // intense operation .getItemMeta()\n+        for (ItemStackWrapper stack : items) {\n+            if (stack.getType() == item.getType()) {\n+                // We found a potential match based on the Material\n+                potentialMatches++;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0NjMwNA=="}, "originalCommit": {"oid": "1f32b160a57523d407bb05eaef36e86d62c46507"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIwMzgzMg==", "bodyText": "(In the meantime I approved since I assume we're just waiting on Walshy to decide he believes you, take this as a bump for the blob)", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r535203832", "createdAt": "2020-12-03T12:54:37Z", "author": {"login": "Sfiguz7"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.github.thebusybiscuit.slimefun4.core.networks.cargo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.utils.SlimefunUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.itemstack.ItemStackWrapper;\n+import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.BlockStorage;\n+import me.mrCookieSlime.Slimefun.api.inventory.BlockMenu;\n+\n+/**\n+ * The {@link ItemFilter} is a performance-optimization for our {@link CargoNet}.\n+ * It is a snapshot of a cargo node's configuration.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+class ItemFilter implements Predicate<ItemStack> {\n+\n+    /**\n+     * Our {@link List} of items to check against, might be empty.\n+     */\n+    private final List<ItemStackWrapper> items = new ArrayList<>();\n+\n+    /**\n+     * Our default value for this {@link ItemFilter}.\n+     * A default value of {@literal true} will mean that it returns true if no\n+     * match was found. It will deny any items that match.\n+     * A default value of {@literal false} means that it will return false if no\n+     * match was found. Only items that match will make it past this {@link ItemFilter}.\n+     */\n+    private boolean defaultValue;\n+\n+    /**\n+     * Whether we should also compare the lore.\n+     */\n+    private boolean checkLore;\n+\n+    /**\n+     * If an {@link ItemFilter} is marked as dirty / outdated, then it will be updated\n+     * on the next tick.\n+     */\n+    private boolean dirty = false;\n+\n+    /**\n+     * This creates a new {@link ItemFilter} for the given {@link Block}.\n+     * This will copy all settings from that {@link Block} to this filter.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public ItemFilter(@Nonnull Block b) {\n+        update(b);\n+    }\n+\n+    /**\n+     * This updates or refreshes the {@link ItemFilter} to copy the settings\n+     * from the given {@link Block}. It takes a new snapshot.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public void update(@Nonnull Block b) {\n+        // Store the returned Config instance to avoid heavy calls\n+        Config blockData = BlockStorage.getLocationInfo(b.getLocation());\n+        String id = blockData.getString(\"id\");\n+        SlimefunItem item = SlimefunItem.getByID(id);\n+        BlockMenu menu = BlockStorage.getInventory(b.getLocation());\n+\n+        if (item == null || menu == null) {\n+            // Don't filter for a non-existing item (safety check)\n+            clear(false);\n+        } else if (id.equals(\"CARGO_NODE_OUTPUT\")) {\n+            // Output Nodes have no filter, allow everything\n+            clear(true);\n+        } else {\n+            this.items.clear();\n+            this.checkLore = Objects.equals(blockData.getString(\"filter-lore\"), \"true\");\n+            this.defaultValue = !Objects.equals(blockData.getString(\"filter-type\"), \"whitelist\");\n+\n+            for (int slot : CargoUtils.FILTER_SLOTS) {\n+                ItemStack stack = menu.getItemInSlot(slot);\n+\n+                if (stack != null && stack.getType() != Material.AIR) {\n+                    this.items.add(new ItemStackWrapper(stack));\n+                }\n+            }\n+        }\n+\n+        this.dirty = false;\n+    }\n+\n+    /**\n+     * This will clear the {@link ItemFilter} and reject <strong>any</strong>\n+     * {@link ItemStack}.\n+     * \n+     * @param defaultValue\n+     *            The new default value.\n+     */\n+    private void clear(boolean defaultValue) {\n+        this.items.clear();\n+        this.checkLore = false;\n+        this.defaultValue = defaultValue;\n+    }\n+\n+    /**\n+     * Whether this {@link ItemFilter} is outdated and needs to be refreshed.\n+     * \n+     * @return Whether the filter is outdated.\n+     */\n+    public boolean isDirty() {\n+        return dirty;\n+    }\n+\n+    /**\n+     * This marks this {@link ItemFilter} as dirty / outdated.\n+     */\n+    public void markDirty() {\n+        this.dirty = true;\n+    }\n+\n+    @Override\n+    public boolean test(@Nonnull ItemStack item) {\n+        // An empty Filter does not need to be iterated over.\n+        if (items.isEmpty()) {\n+            return defaultValue;\n+        }\n+\n+        int potentialMatches = 0;\n+\n+        // This is a first check for materials to see if we might even have any match.\n+        // If there is no potential match then we won't need to perform the quite\n+        // intense operation .getItemMeta()\n+        for (ItemStackWrapper stack : items) {\n+            if (stack.getType() == item.getType()) {\n+                // We found a potential match based on the Material\n+                potentialMatches++;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0NjMwNA=="}, "originalCommit": {"oid": "1f32b160a57523d407bb05eaef36e86d62c46507"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzIyMjA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDowMzo0OFrOH9sCIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDowMzo0OFrOH9sCIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0NjYyNw==", "bodyText": "this. for consistency", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r534446627", "createdAt": "2020-12-02T20:03:48Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.github.thebusybiscuit.slimefun4.core.networks.cargo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.utils.SlimefunUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.itemstack.ItemStackWrapper;\n+import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.BlockStorage;\n+import me.mrCookieSlime.Slimefun.api.inventory.BlockMenu;\n+\n+/**\n+ * The {@link ItemFilter} is a performance-optimization for our {@link CargoNet}.\n+ * It is a snapshot of a cargo node's configuration.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+class ItemFilter implements Predicate<ItemStack> {\n+\n+    /**\n+     * Our {@link List} of items to check against, might be empty.\n+     */\n+    private final List<ItemStackWrapper> items = new ArrayList<>();\n+\n+    /**\n+     * Our default value for this {@link ItemFilter}.\n+     * A default value of {@literal true} will mean that it returns true if no\n+     * match was found. It will deny any items that match.\n+     * A default value of {@literal false} means that it will return false if no\n+     * match was found. Only items that match will make it past this {@link ItemFilter}.\n+     */\n+    private boolean defaultValue;\n+\n+    /**\n+     * Whether we should also compare the lore.\n+     */\n+    private boolean checkLore;\n+\n+    /**\n+     * If an {@link ItemFilter} is marked as dirty / outdated, then it will be updated\n+     * on the next tick.\n+     */\n+    private boolean dirty = false;\n+\n+    /**\n+     * This creates a new {@link ItemFilter} for the given {@link Block}.\n+     * This will copy all settings from that {@link Block} to this filter.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public ItemFilter(@Nonnull Block b) {\n+        update(b);\n+    }\n+\n+    /**\n+     * This updates or refreshes the {@link ItemFilter} to copy the settings\n+     * from the given {@link Block}. It takes a new snapshot.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public void update(@Nonnull Block b) {\n+        // Store the returned Config instance to avoid heavy calls\n+        Config blockData = BlockStorage.getLocationInfo(b.getLocation());\n+        String id = blockData.getString(\"id\");\n+        SlimefunItem item = SlimefunItem.getByID(id);\n+        BlockMenu menu = BlockStorage.getInventory(b.getLocation());\n+\n+        if (item == null || menu == null) {\n+            // Don't filter for a non-existing item (safety check)\n+            clear(false);\n+        } else if (id.equals(\"CARGO_NODE_OUTPUT\")) {\n+            // Output Nodes have no filter, allow everything\n+            clear(true);\n+        } else {\n+            this.items.clear();\n+            this.checkLore = Objects.equals(blockData.getString(\"filter-lore\"), \"true\");\n+            this.defaultValue = !Objects.equals(blockData.getString(\"filter-type\"), \"whitelist\");\n+\n+            for (int slot : CargoUtils.FILTER_SLOTS) {\n+                ItemStack stack = menu.getItemInSlot(slot);\n+\n+                if (stack != null && stack.getType() != Material.AIR) {\n+                    this.items.add(new ItemStackWrapper(stack));\n+                }\n+            }\n+        }\n+\n+        this.dirty = false;\n+    }\n+\n+    /**\n+     * This will clear the {@link ItemFilter} and reject <strong>any</strong>\n+     * {@link ItemStack}.\n+     * \n+     * @param defaultValue\n+     *            The new default value.\n+     */\n+    private void clear(boolean defaultValue) {\n+        this.items.clear();\n+        this.checkLore = false;\n+        this.defaultValue = defaultValue;\n+    }\n+\n+    /**\n+     * Whether this {@link ItemFilter} is outdated and needs to be refreshed.\n+     * \n+     * @return Whether the filter is outdated.\n+     */\n+    public boolean isDirty() {\n+        return dirty;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f32b160a57523d407bb05eaef36e86d62c46507"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzIzMjU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDowNjozNlrOH9sIkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDowNjozNlrOH9sIkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0ODI3NA==", "bodyText": "I don't really like the name of this variable. rejectItemIfMatched or something would be a bit clearer.", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r534448274", "createdAt": "2020-12-02T20:06:36Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.github.thebusybiscuit.slimefun4.core.networks.cargo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.utils.SlimefunUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.itemstack.ItemStackWrapper;\n+import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.BlockStorage;\n+import me.mrCookieSlime.Slimefun.api.inventory.BlockMenu;\n+\n+/**\n+ * The {@link ItemFilter} is a performance-optimization for our {@link CargoNet}.\n+ * It is a snapshot of a cargo node's configuration.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+class ItemFilter implements Predicate<ItemStack> {\n+\n+    /**\n+     * Our {@link List} of items to check against, might be empty.\n+     */\n+    private final List<ItemStackWrapper> items = new ArrayList<>();\n+\n+    /**\n+     * Our default value for this {@link ItemFilter}.\n+     * A default value of {@literal true} will mean that it returns true if no\n+     * match was found. It will deny any items that match.\n+     * A default value of {@literal false} means that it will return false if no\n+     * match was found. Only items that match will make it past this {@link ItemFilter}.\n+     */\n+    private boolean defaultValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f32b160a57523d407bb05eaef36e86d62c46507"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzI0MDg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDowOTowMlrOH9sNiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDowOTowMlrOH9sNiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0OTU0Nw==", "bodyText": "Not an issue just cool to see Objects.equals used here \ud83d\udc4d", "url": "https://github.com/Slimefun/Slimefun4/pull/2503#discussion_r534449547", "createdAt": "2020-12-02T20:09:02Z", "author": {"login": "WalshyDev"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/networks/cargo/ItemFilter.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.github.thebusybiscuit.slimefun4.core.networks.cargo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.utils.SlimefunUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.itemstack.ItemStackWrapper;\n+import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.BlockStorage;\n+import me.mrCookieSlime.Slimefun.api.inventory.BlockMenu;\n+\n+/**\n+ * The {@link ItemFilter} is a performance-optimization for our {@link CargoNet}.\n+ * It is a snapshot of a cargo node's configuration.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+class ItemFilter implements Predicate<ItemStack> {\n+\n+    /**\n+     * Our {@link List} of items to check against, might be empty.\n+     */\n+    private final List<ItemStackWrapper> items = new ArrayList<>();\n+\n+    /**\n+     * Our default value for this {@link ItemFilter}.\n+     * A default value of {@literal true} will mean that it returns true if no\n+     * match was found. It will deny any items that match.\n+     * A default value of {@literal false} means that it will return false if no\n+     * match was found. Only items that match will make it past this {@link ItemFilter}.\n+     */\n+    private boolean defaultValue;\n+\n+    /**\n+     * Whether we should also compare the lore.\n+     */\n+    private boolean checkLore;\n+\n+    /**\n+     * If an {@link ItemFilter} is marked as dirty / outdated, then it will be updated\n+     * on the next tick.\n+     */\n+    private boolean dirty = false;\n+\n+    /**\n+     * This creates a new {@link ItemFilter} for the given {@link Block}.\n+     * This will copy all settings from that {@link Block} to this filter.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public ItemFilter(@Nonnull Block b) {\n+        update(b);\n+    }\n+\n+    /**\n+     * This updates or refreshes the {@link ItemFilter} to copy the settings\n+     * from the given {@link Block}. It takes a new snapshot.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     */\n+    public void update(@Nonnull Block b) {\n+        // Store the returned Config instance to avoid heavy calls\n+        Config blockData = BlockStorage.getLocationInfo(b.getLocation());\n+        String id = blockData.getString(\"id\");\n+        SlimefunItem item = SlimefunItem.getByID(id);\n+        BlockMenu menu = BlockStorage.getInventory(b.getLocation());\n+\n+        if (item == null || menu == null) {\n+            // Don't filter for a non-existing item (safety check)\n+            clear(false);\n+        } else if (id.equals(\"CARGO_NODE_OUTPUT\")) {\n+            // Output Nodes have no filter, allow everything\n+            clear(true);\n+        } else {\n+            this.items.clear();\n+            this.checkLore = Objects.equals(blockData.getString(\"filter-lore\"), \"true\");\n+            this.defaultValue = !Objects.equals(blockData.getString(\"filter-type\"), \"whitelist\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f32b160a57523d407bb05eaef36e86d62c46507"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 287, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}