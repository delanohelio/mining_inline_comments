{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgwNTQ0MTQ5", "number": 2290, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMDoyOFrOEgoP5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yN1QxMTo0OTozMlrOF3DGZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5MzE4OnYy", "diffSide": "RIGHT", "path": "CHANGELOG.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMDoyOFrOHNkCVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMDoyOFrOHNkCVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4Mzk1OQ==", "bodyText": "Please remove this from the change log.\nThere is no way such a drastic change, especially when it's about threading and concurrency... will make it into the next RC.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483983959", "createdAt": "2020-09-05T20:10:28Z", "author": {"login": "TheBusyBiscuit"}, "path": "CHANGELOG.md", "diffHunk": "@@ -62,6 +62,7 @@\n * Small performance improvements for radiation\n * Small performance improvements for Auto Disenchanters\n * Magnesium Salt in Magnesium-Salt generators now lasts longer\n+* Performance improvements for TickerTask(Slimefun ticking)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5MzY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMTowOFrOHNkCjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQwOTowNjozNVrOHNnsMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDAxMg==", "bodyText": "No need to mark this parameter as final really.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984012", "createdAt": "2020-09-05T20:11:08Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -57,66 +74,169 @@\n      *            The instance of our {@link SlimefunPlugin}\n      */\n     public void start(@Nonnull SlimefunPlugin plugin) {\n+\n         this.tickRate = SlimefunPlugin.getCfg().getInt(\"URID.custom-ticker-delay\");\n \n         BukkitScheduler scheduler = plugin.getServer().getScheduler();\n-        scheduler.runTaskTimerAsynchronously(plugin, this, 100L, tickRate);\n+        scheduler.runTaskLater(plugin, this, 100L);\n     }\n \n-    /**\n-     * This method resets this {@link TickerTask} to run again.\n-     */\n-    public void reset() {\n-        running = false;\n+    @Override \n+    public final void run() {\n+\n+        // This should not happen. Only case where this may happen is if this task is scheduled or started multiple times.\n+        if (running) {\n+            return;\n+        }\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Don't overload the Bukkit scheduler with a thousand runnables. It doesn't like that. This way, we can spread the\n+        // time cost over several game ticks and adapt ticker rate to server performance.\n+        final ArrayBlockingQueue<Runnable> syncTasks = new ArrayBlockingQueue<>(32);\n+\n+        // Iterate over the ticker tasks. Process the asynchronous ones on the Bukkit async task thread, and queue the sync\n+        // tasks to the queue.\n+        Bukkit.getScheduler().runTaskAsynchronously(\n+                SlimefunPlugin.instance(),\n+                () -> this.tick(syncTasks)\n+        );\n+\n+        // Process the synchronous ticker tasks on the main thread.\n+        processSyncTasks(syncTasks);\n     }\n \n-    @Override\n-    public void run() {\n+    private void processSyncTasks(final @Nonnull BlockingQueue<Runnable> tasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4ODM3OQ==", "bodyText": "It is needed. We use it in a lambda which requires it as final.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483988379", "createdAt": "2020-09-05T20:52:10Z", "author": {"login": "LinoxGH"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -57,66 +74,169 @@\n      *            The instance of our {@link SlimefunPlugin}\n      */\n     public void start(@Nonnull SlimefunPlugin plugin) {\n+\n         this.tickRate = SlimefunPlugin.getCfg().getInt(\"URID.custom-ticker-delay\");\n \n         BukkitScheduler scheduler = plugin.getServer().getScheduler();\n-        scheduler.runTaskTimerAsynchronously(plugin, this, 100L, tickRate);\n+        scheduler.runTaskLater(plugin, this, 100L);\n     }\n \n-    /**\n-     * This method resets this {@link TickerTask} to run again.\n-     */\n-    public void reset() {\n-        running = false;\n+    @Override \n+    public final void run() {\n+\n+        // This should not happen. Only case where this may happen is if this task is scheduled or started multiple times.\n+        if (running) {\n+            return;\n+        }\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Don't overload the Bukkit scheduler with a thousand runnables. It doesn't like that. This way, we can spread the\n+        // time cost over several game ticks and adapt ticker rate to server performance.\n+        final ArrayBlockingQueue<Runnable> syncTasks = new ArrayBlockingQueue<>(32);\n+\n+        // Iterate over the ticker tasks. Process the asynchronous ones on the Bukkit async task thread, and queue the sync\n+        // tasks to the queue.\n+        Bukkit.getScheduler().runTaskAsynchronously(\n+                SlimefunPlugin.instance(),\n+                () -> this.tick(syncTasks)\n+        );\n+\n+        // Process the synchronous ticker tasks on the main thread.\n+        processSyncTasks(syncTasks);\n     }\n \n-    @Override\n-    public void run() {\n+    private void processSyncTasks(final @Nonnull BlockingQueue<Runnable> tasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDAxMg=="}, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA0MzgyNg==", "bodyText": "Ah okay, can you at least put the annotation before the final then?", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r484043826", "createdAt": "2020-09-06T09:06:35Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -57,66 +74,169 @@\n      *            The instance of our {@link SlimefunPlugin}\n      */\n     public void start(@Nonnull SlimefunPlugin plugin) {\n+\n         this.tickRate = SlimefunPlugin.getCfg().getInt(\"URID.custom-ticker-delay\");\n \n         BukkitScheduler scheduler = plugin.getServer().getScheduler();\n-        scheduler.runTaskTimerAsynchronously(plugin, this, 100L, tickRate);\n+        scheduler.runTaskLater(plugin, this, 100L);\n     }\n \n-    /**\n-     * This method resets this {@link TickerTask} to run again.\n-     */\n-    public void reset() {\n-        running = false;\n+    @Override \n+    public final void run() {\n+\n+        // This should not happen. Only case where this may happen is if this task is scheduled or started multiple times.\n+        if (running) {\n+            return;\n+        }\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Don't overload the Bukkit scheduler with a thousand runnables. It doesn't like that. This way, we can spread the\n+        // time cost over several game ticks and adapt ticker rate to server performance.\n+        final ArrayBlockingQueue<Runnable> syncTasks = new ArrayBlockingQueue<>(32);\n+\n+        // Iterate over the ticker tasks. Process the asynchronous ones on the Bukkit async task thread, and queue the sync\n+        // tasks to the queue.\n+        Bukkit.getScheduler().runTaskAsynchronously(\n+                SlimefunPlugin.instance(),\n+                () -> this.tick(syncTasks)\n+        );\n+\n+        // Process the synchronous ticker tasks on the main thread.\n+        processSyncTasks(syncTasks);\n     }\n \n-    @Override\n-    public void run() {\n+    private void processSyncTasks(final @Nonnull BlockingQueue<Runnable> tasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDAxMg=="}, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5Mzk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMTozNVrOHNkCtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMTozNVrOHNkCtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDA1Mw==", "bodyText": "This magic number should definitely be a static final constant for easier tweaking.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984053", "createdAt": "2020-09-05T20:11:35Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -57,66 +74,169 @@\n      *            The instance of our {@link SlimefunPlugin}\n      */\n     public void start(@Nonnull SlimefunPlugin plugin) {\n+\n         this.tickRate = SlimefunPlugin.getCfg().getInt(\"URID.custom-ticker-delay\");\n \n         BukkitScheduler scheduler = plugin.getServer().getScheduler();\n-        scheduler.runTaskTimerAsynchronously(plugin, this, 100L, tickRate);\n+        scheduler.runTaskLater(plugin, this, 100L);\n     }\n \n-    /**\n-     * This method resets this {@link TickerTask} to run again.\n-     */\n-    public void reset() {\n-        running = false;\n+    @Override \n+    public final void run() {\n+\n+        // This should not happen. Only case where this may happen is if this task is scheduled or started multiple times.\n+        if (running) {\n+            return;\n+        }\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Don't overload the Bukkit scheduler with a thousand runnables. It doesn't like that. This way, we can spread the\n+        // time cost over several game ticks and adapt ticker rate to server performance.\n+        final ArrayBlockingQueue<Runnable> syncTasks = new ArrayBlockingQueue<>(32);\n+\n+        // Iterate over the ticker tasks. Process the asynchronous ones on the Bukkit async task thread, and queue the sync\n+        // tasks to the queue.\n+        Bukkit.getScheduler().runTaskAsynchronously(\n+                SlimefunPlugin.instance(),\n+                () -> this.tick(syncTasks)\n+        );\n+\n+        // Process the synchronous ticker tasks on the main thread.\n+        processSyncTasks(syncTasks);\n     }\n \n-    @Override\n-    public void run() {\n+    private void processSyncTasks(final @Nonnull BlockingQueue<Runnable> tasks) {\n+\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Let's not lag the main thread. Spikes suck. Steady time usage is much better.\n+        long endNs = System.nanoTime() + 1_500_000L;\n+\n         try {\n-            // If this method is actually still running... DON'T\n-            if (running) {\n-                return;\n+            while (endNs > System.nanoTime()) {\n+\n+                // Don't wait on an empty queue for too long.\n+                long s = System.nanoTime();\n+                Runnable r = tasks.poll(250_000L, TimeUnit.NANOSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5NDIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMTo0OFrOHNkC1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMTo0OFrOHNkC1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDA4NA==", "bodyText": "Please give your variable a more meaningful name.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984084", "createdAt": "2020-09-05T20:11:48Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -57,66 +74,169 @@\n      *            The instance of our {@link SlimefunPlugin}\n      */\n     public void start(@Nonnull SlimefunPlugin plugin) {\n+\n         this.tickRate = SlimefunPlugin.getCfg().getInt(\"URID.custom-ticker-delay\");\n \n         BukkitScheduler scheduler = plugin.getServer().getScheduler();\n-        scheduler.runTaskTimerAsynchronously(plugin, this, 100L, tickRate);\n+        scheduler.runTaskLater(plugin, this, 100L);\n     }\n \n-    /**\n-     * This method resets this {@link TickerTask} to run again.\n-     */\n-    public void reset() {\n-        running = false;\n+    @Override \n+    public final void run() {\n+\n+        // This should not happen. Only case where this may happen is if this task is scheduled or started multiple times.\n+        if (running) {\n+            return;\n+        }\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Don't overload the Bukkit scheduler with a thousand runnables. It doesn't like that. This way, we can spread the\n+        // time cost over several game ticks and adapt ticker rate to server performance.\n+        final ArrayBlockingQueue<Runnable> syncTasks = new ArrayBlockingQueue<>(32);\n+\n+        // Iterate over the ticker tasks. Process the asynchronous ones on the Bukkit async task thread, and queue the sync\n+        // tasks to the queue.\n+        Bukkit.getScheduler().runTaskAsynchronously(\n+                SlimefunPlugin.instance(),\n+                () -> this.tick(syncTasks)\n+        );\n+\n+        // Process the synchronous ticker tasks on the main thread.\n+        processSyncTasks(syncTasks);\n     }\n \n-    @Override\n-    public void run() {\n+    private void processSyncTasks(final @Nonnull BlockingQueue<Runnable> tasks) {\n+\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Let's not lag the main thread. Spikes suck. Steady time usage is much better.\n+        long endNs = System.nanoTime() + 1_500_000L;\n+\n         try {\n-            // If this method is actually still running... DON'T\n-            if (running) {\n-                return;\n+            while (endNs > System.nanoTime()) {\n+\n+                // Don't wait on an empty queue for too long.\n+                long s = System.nanoTime();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5NDM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMTo1N1rOHNkC4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMTo1N1rOHNkC4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDA5OQ==", "bodyText": "Please give your variable a more meaningful name.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984099", "createdAt": "2020-09-05T20:11:57Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -57,66 +74,169 @@\n      *            The instance of our {@link SlimefunPlugin}\n      */\n     public void start(@Nonnull SlimefunPlugin plugin) {\n+\n         this.tickRate = SlimefunPlugin.getCfg().getInt(\"URID.custom-ticker-delay\");\n \n         BukkitScheduler scheduler = plugin.getServer().getScheduler();\n-        scheduler.runTaskTimerAsynchronously(plugin, this, 100L, tickRate);\n+        scheduler.runTaskLater(plugin, this, 100L);\n     }\n \n-    /**\n-     * This method resets this {@link TickerTask} to run again.\n-     */\n-    public void reset() {\n-        running = false;\n+    @Override \n+    public final void run() {\n+\n+        // This should not happen. Only case where this may happen is if this task is scheduled or started multiple times.\n+        if (running) {\n+            return;\n+        }\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Don't overload the Bukkit scheduler with a thousand runnables. It doesn't like that. This way, we can spread the\n+        // time cost over several game ticks and adapt ticker rate to server performance.\n+        final ArrayBlockingQueue<Runnable> syncTasks = new ArrayBlockingQueue<>(32);\n+\n+        // Iterate over the ticker tasks. Process the asynchronous ones on the Bukkit async task thread, and queue the sync\n+        // tasks to the queue.\n+        Bukkit.getScheduler().runTaskAsynchronously(\n+                SlimefunPlugin.instance(),\n+                () -> this.tick(syncTasks)\n+        );\n+\n+        // Process the synchronous ticker tasks on the main thread.\n+        processSyncTasks(syncTasks);\n     }\n \n-    @Override\n-    public void run() {\n+    private void processSyncTasks(final @Nonnull BlockingQueue<Runnable> tasks) {\n+\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Let's not lag the main thread. Spikes suck. Steady time usage is much better.\n+        long endNs = System.nanoTime() + 1_500_000L;\n+\n         try {\n-            // If this method is actually still running... DON'T\n-            if (running) {\n-                return;\n+            while (endNs > System.nanoTime()) {\n+\n+                // Don't wait on an empty queue for too long.\n+                long s = System.nanoTime();\n+                Runnable r = tasks.poll(250_000L, TimeUnit.NANOSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5NDY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMjozOFrOHNkDFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoyMzo1OVrOHNkGVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDE0OA==", "bodyText": "What's with the two empty lines here...?", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984148", "createdAt": "2020-09-05T20:12:38Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -136,7 +256,9 @@ private void tickChunk(@Nonnull Set<BlockTicker> tickers, @Nonnull String chunk)\n         }\n     }\n \n-    private void tickLocation(@Nonnull Set<BlockTicker> tickers, @Nonnull Location l) {\n+    private void tickLocation(@Nonnull List<BlockTicker> tickers, @Nonnull Location l, @Nonnull BlockingQueue<Runnable> syncTasks) {\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDk4MA==", "bodyText": "Traces from removes debug messages", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984980", "createdAt": "2020-09-05T20:23:59Z", "author": {"login": "LinoxGH"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -136,7 +256,9 @@ private void tickChunk(@Nonnull Set<BlockTicker> tickers, @Nonnull String chunk)\n         }\n     }\n \n-    private void tickLocation(@Nonnull Set<BlockTicker> tickers, @Nonnull Location l) {\n+    private void tickLocation(@Nonnull List<BlockTicker> tickers, @Nonnull Location l, @Nonnull BlockingQueue<Runnable> syncTasks) {\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDE0OA=="}, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5NDk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMjo1N1rOHNkDNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoyMzo0M1rOHNkGPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDE4MQ==", "bodyText": "Why are you printing a stacktrace here...?", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984181", "createdAt": "2020-09-05T20:12:57Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -215,12 +341,28 @@ public void halt() {\n \n     @ParametersAreNonnullByDefault\n     public void queueMove(Location from, Location to) {\n-        movingQueue.put(from, to);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDk1Nw==", "bodyText": "This is from debugging. I just forgot to remove it", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984957", "createdAt": "2020-09-05T20:23:43Z", "author": {"login": "LinoxGH"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -215,12 +341,28 @@ public void halt() {\n \n     @ParametersAreNonnullByDefault\n     public void queueMove(Location from, Location to) {\n-        movingQueue.put(from, to);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDE4MQ=="}, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5NDk5OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMzowMVrOHNkDOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoyMzoxOFrOHNkGJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDE4NQ==", "bodyText": "Why are you printing a stacktrace here...?", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984185", "createdAt": "2020-09-05T20:13:01Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -215,12 +341,28 @@ public void halt() {\n \n     @ParametersAreNonnullByDefault\n     public void queueMove(Location from, Location to) {\n-        movingQueue.put(from, to);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();\n+        queueLock.readLock().lock();\n+        try {\n+            movingQueue.put(from, to);\n+        }\n+        finally {\n+            queueLock.readLock().unlock();\n+        }\n     }\n \n     @ParametersAreNonnullByDefault\n     public void queueDelete(Location l, boolean destroy) {\n-        deletionQueue.put(l, destroy);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDkzMg==", "bodyText": "Oops that's from debugging", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984932", "createdAt": "2020-09-05T20:23:18Z", "author": {"login": "LinoxGH"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -215,12 +341,28 @@ public void halt() {\n \n     @ParametersAreNonnullByDefault\n     public void queueMove(Location from, Location to) {\n-        movingQueue.put(from, to);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();\n+        queueLock.readLock().lock();\n+        try {\n+            movingQueue.put(from, to);\n+        }\n+        finally {\n+            queueLock.readLock().unlock();\n+        }\n     }\n \n     @ParametersAreNonnullByDefault\n     public void queueDelete(Location l, boolean destroy) {\n-        deletionQueue.put(l, destroy);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDE4NQ=="}, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjQ5NTI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDoxMzo0OVrOHNkDWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQyMDo1Mzo0NFrOHNkWHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDIxOQ==", "bodyText": "Also is it really sensible to re-use the same lock for moving and deleting operations?", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483984219", "createdAt": "2020-09-05T20:13:49Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -215,12 +341,28 @@ public void halt() {\n \n     @ParametersAreNonnullByDefault\n     public void queueMove(Location from, Location to) {\n-        movingQueue.put(from, to);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();\n+        queueLock.readLock().lock();\n+        try {\n+            movingQueue.put(from, to);\n+        }\n+        finally {\n+            queueLock.readLock().unlock();\n+        }\n     }\n \n     @ParametersAreNonnullByDefault\n     public void queueDelete(Location l, boolean destroy) {\n-        deletionQueue.put(l, destroy);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();\n+        queueLock.readLock().lock();\n+        try {\n+            deletionQueue.put(l, destroy);\n+        }\n+        finally {\n+            queueLock.readLock().unlock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 356}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4OTAyMg==", "bodyText": "Since we lock and then unlock in finally blocks the lock won't be used by both of them at the same time. Also there's no need for a 2nd one.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r483989022", "createdAt": "2020-09-05T20:53:44Z", "author": {"login": "LinoxGH"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -215,12 +341,28 @@ public void halt() {\n \n     @ParametersAreNonnullByDefault\n     public void queueMove(Location from, Location to) {\n-        movingQueue.put(from, to);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();\n+        queueLock.readLock().lock();\n+        try {\n+            movingQueue.put(from, to);\n+        }\n+        finally {\n+            queueLock.readLock().unlock();\n+        }\n     }\n \n     @ParametersAreNonnullByDefault\n     public void queueDelete(Location l, boolean destroy) {\n-        deletionQueue.put(l, destroy);\n+        // This collection is iterated over in a different thread. Need to lock it.\n+        new Throwable().printStackTrace();\n+        queueLock.readLock().lock();\n+        try {\n+            deletionQueue.put(l, destroy);\n+        }\n+        finally {\n+            queueLock.readLock().unlock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk4NDIxOQ=="}, "originalCommit": {"oid": "e682760c87cba8a9f7d5f478bdadddde6d81c918"}, "originalPosition": 356}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Nzk2MjM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMDowNzowMlrOHQsUgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMzowMDowMVrOHQ0_lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI2NTQxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!SlimefunPlugin.isEnabled()) {\n          \n          \n            \n                    if (!SlimefunPlugin.instance().isEnabled()) {", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r487265411", "createdAt": "2020-09-11T20:07:02Z", "author": {"login": "poma123"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -92,6 +92,10 @@ public final void run() {\n         if (!Bukkit.isPrimaryThread()) {\n             return;\n         }\n+        \n+        if (!SlimefunPlugin.isEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f3390f2205d010b53ad68187a8337275bd604c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDQ0OA==", "bodyText": "instance() is nullable. So a static isEnabled() method might be a good idea, check if it isnt null and then do the normal isEnabled call.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r487314448", "createdAt": "2020-09-11T22:16:27Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -92,6 +92,10 @@ public final void run() {\n         if (!Bukkit.isPrimaryThread()) {\n             return;\n         }\n+        \n+        if (!SlimefunPlugin.isEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI2NTQxMQ=="}, "originalCommit": {"oid": "c4f3390f2205d010b53ad68187a8337275bd604c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNTM2NA==", "bodyText": "instance will never be null, because before we set it to null, we cancel tasks anyway.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r487315364", "createdAt": "2020-09-11T22:19:59Z", "author": {"login": "LinoxGH"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -92,6 +92,10 @@ public final void run() {\n         if (!Bukkit.isPrimaryThread()) {\n             return;\n         }\n+        \n+        if (!SlimefunPlugin.isEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI2NTQxMQ=="}, "originalCommit": {"oid": "c4f3390f2205d010b53ad68187a8337275bd604c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMTA0Mw==", "bodyText": "Cancelling will only cancel the scheduling of new tasks, it won't terminate tasks which have already been started. And since this is running asynchronously, it may run just in time when instance is null and tasks have already been cancelled.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r487321043", "createdAt": "2020-09-11T22:41:38Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -92,6 +92,10 @@ public final void run() {\n         if (!Bukkit.isPrimaryThread()) {\n             return;\n         }\n+        \n+        if (!SlimefunPlugin.isEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI2NTQxMQ=="}, "originalCommit": {"oid": "c4f3390f2205d010b53ad68187a8337275bd604c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQwNzUxMQ==", "bodyText": "Cancelling will only cancel the scheduling of new tasks, it won't terminate tasks which have already been started. And since this is running asynchronously, it may run just in time when instance is null and tasks have already been cancelled.\n\nThis isn't run asynchronously.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r487407511", "createdAt": "2020-09-12T13:00:01Z", "author": {"login": "LinoxGH"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -92,6 +92,10 @@ public final void run() {\n         if (!Bukkit.isPrimaryThread()) {\n             return;\n         }\n+        \n+        if (!SlimefunPlugin.isEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI2NTQxMQ=="}, "originalCommit": {"oid": "c4f3390f2205d010b53ad68187a8337275bd604c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDg0MDkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMjozMDo0NlrOIFuh0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMjo0ODoyNVrOIFvnHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3NjExNA==", "bodyText": ":NotLikeThis:", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r542876114", "createdAt": "2020-12-14T22:30:46Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -333,8 +424,8 @@ public void enableTicker(@Nonnull Location l) {\n     public void disableTicker(@Nonnull Location l) {\n         Validate.notNull(l, \"Location cannot be null!\");\n \n-        ChunkPosition chunk = new ChunkPosition(l.getWorld(), l.getBlockX() >> 4, l.getBlockZ() >> 4);\n-        Set<Location> locations = tickingLocations.get(chunk);\n+        String chunk = l.getWorld().getName() + \";\" + l.getChunk().getX() + \";\" + l.getChunk().getZ();\n+        Set<Location> locations = activeTickers.get(chunk);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f7c3f5e61283fdca13c066c4af0eb8248b7ef52"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5Mzg1Mg==", "bodyText": "I don't have time to non-fatal or beauty changes. Feel free to do it yourself though.", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r542893852", "createdAt": "2020-12-14T22:48:25Z", "author": {"login": "LinoxGH"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -333,8 +424,8 @@ public void enableTicker(@Nonnull Location l) {\n     public void disableTicker(@Nonnull Location l) {\n         Validate.notNull(l, \"Location cannot be null!\");\n \n-        ChunkPosition chunk = new ChunkPosition(l.getWorld(), l.getBlockX() >> 4, l.getBlockZ() >> 4);\n-        Set<Location> locations = tickingLocations.get(chunk);\n+        String chunk = l.getWorld().getName() + \";\" + l.getChunk().getX() + \";\" + l.getChunk().getZ();\n+        Set<Location> locations = activeTickers.get(chunk);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3NjExNA=="}, "originalCommit": {"oid": "8f7c3f5e61283fdca13c066c4af0eb8248b7ef52"}, "originalPosition": 505}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkzMjY2Nzg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yN1QxMTo0OTozMlrOJQW6cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yN1QxMTo1OTo1N1rOJQXWcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTEzMjQwMg==", "bodyText": "cant these if's be combined with &&", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r621132402", "createdAt": "2021-04-27T11:49:32Z", "author": {"login": "J3fftw1"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -68,76 +128,162 @@ public void start(@Nonnull SlimefunPlugin plugin) {\n         this.tickRate = SlimefunPlugin.getCfg().getInt(\"URID.custom-ticker-delay\");\n \n         BukkitScheduler scheduler = plugin.getServer().getScheduler();\n-        scheduler.runTaskTimerAsynchronously(plugin, this, 100L, tickRate);\n+        scheduler.runTaskLater(plugin, this, 100L);\n     }\n \n-    /**\n-     * This method resets this {@link TickerTask} to run again.\n-     */\n-    private void reset() {\n-        running = false;\n+    @Override\n+    public final void run() {\n+        /*\n+         * This should only happen when the plugin gets disabled and the\n+         * task is already running.\n+         * Process all sync tasks before returning, blocking the main thread until\n+         * the task is complete.\n+         */\n+        if (running) {\n+            processSyncTasks();\n+            return;\n+        }\n+\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        /*\n+         * Iterate over the ticker tasks.\n+         * Process the asynchronous ones on the new thread\n+         * and queue the sync tasks to the queue.\n+         */\n+        new Thread(this::tick, \"Slimefun Async Ticker Thread\").start();\n+\n+        // Process the synchronous ticker tasks on the main thread.\n+        processSyncTasks();\n     }\n \n-    @Override\n-    public void run() {\n+    private void processSyncTasks() {\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Let's not lag the main thread. Spikes suck. Steady time usage is much better.\n+        long endNs = System.nanoTime() + MAX_TICK_NS;\n+\n         try {\n-            // If this method is actually still running... DON'T\n-            if (running) {\n-                return;\n+            while (endNs > System.nanoTime() || !SlimefunPlugin.instance().isEnabled()) {\n+                // Don't wait on an empty queue for too long.\n+                Runnable task = syncTasks.poll(MAX_POLL_NS, TimeUnit.NANOSECONDS);\n+\n+                if (task == null) {\n+                    if (SlimefunPlugin.instance().isEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ce90ac3a24cd977fdac7106ee64829209b1d36"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTEzOTU2OA==", "bodyText": "No...", "url": "https://github.com/Slimefun/Slimefun4/pull/2290#discussion_r621139568", "createdAt": "2021-04-27T11:59:57Z", "author": {"login": "TheBusyBiscuit"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -68,76 +128,162 @@ public void start(@Nonnull SlimefunPlugin plugin) {\n         this.tickRate = SlimefunPlugin.getCfg().getInt(\"URID.custom-ticker-delay\");\n \n         BukkitScheduler scheduler = plugin.getServer().getScheduler();\n-        scheduler.runTaskTimerAsynchronously(plugin, this, 100L, tickRate);\n+        scheduler.runTaskLater(plugin, this, 100L);\n     }\n \n-    /**\n-     * This method resets this {@link TickerTask} to run again.\n-     */\n-    private void reset() {\n-        running = false;\n+    @Override\n+    public final void run() {\n+        /*\n+         * This should only happen when the plugin gets disabled and the\n+         * task is already running.\n+         * Process all sync tasks before returning, blocking the main thread until\n+         * the task is complete.\n+         */\n+        if (running) {\n+            processSyncTasks();\n+            return;\n+        }\n+\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        /*\n+         * Iterate over the ticker tasks.\n+         * Process the asynchronous ones on the new thread\n+         * and queue the sync tasks to the queue.\n+         */\n+        new Thread(this::tick, \"Slimefun Async Ticker Thread\").start();\n+\n+        // Process the synchronous ticker tasks on the main thread.\n+        processSyncTasks();\n     }\n \n-    @Override\n-    public void run() {\n+    private void processSyncTasks() {\n+        if (!Bukkit.isPrimaryThread()) {\n+            return;\n+        }\n+\n+        // Let's not lag the main thread. Spikes suck. Steady time usage is much better.\n+        long endNs = System.nanoTime() + MAX_TICK_NS;\n+\n         try {\n-            // If this method is actually still running... DON'T\n-            if (running) {\n-                return;\n+            while (endNs > System.nanoTime() || !SlimefunPlugin.instance().isEnabled()) {\n+                // Don't wait on an empty queue for too long.\n+                Runnable task = syncTasks.poll(MAX_POLL_NS, TimeUnit.NANOSECONDS);\n+\n+                if (task == null) {\n+                    if (SlimefunPlugin.instance().isEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTEzMjQwMg=="}, "originalCommit": {"oid": "23ce90ac3a24cd977fdac7106ee64829209b1d36"}, "originalPosition": 181}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 335, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}