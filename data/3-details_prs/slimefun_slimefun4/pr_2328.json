{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MTU1MTk4", "number": 2328, "title": "Programmable Android Optimization: Infinite Block Generators", "bodyText": "Description\n\nThis Pull Request proposes an optimization for Androids which shall reduce block updates and lag.\nInstead of continously setting the block to AIR, it will simply play particles and sound effects as if the block had just been \"generated\". This also calls a BlockFromToEvent, so that custom cobble generator plugins won't be disturbed by this.\nI will probably add Unit Tests for the various Generators too (or make a Hacktoberfest issue for it ;D )\nThe generator detection will probably not be 100% accurate but it doesn't have to be, this is only to reduce lag for servers who use this excessively. And people with massive cobblestone farms are likely to use a pretty basic set up anyway.\nhere is a showcase of the detection in action:\nhttps://youtu.be/oe7tu5WyUuw\nChecklist\n\n\n\n I have fully tested the proposed changes and promise that they will not break everything into chaos.\n I have also tested the proposed changes in combination with various popular addons and can confirm my changes do not break them.\n I followed the existing code standards and didn't mess up the formatting.\n I did my best to add documentation to any public classes or methods I added.\n I have added Nonnull and Nullable annotations to my methods to indicate their behaviour for null values\n I added sufficient Unit Tests to cover my code.", "createdAt": "2020-09-15T09:14:48Z", "url": "https://github.com/Slimefun/Slimefun4/pull/2328", "merged": true, "mergeCommit": {"oid": "4b5ad219ecf98e7db209d04f9db52a87efaca049"}, "closed": true, "closedAt": "2021-03-11T00:52:42Z", "author": {"login": "TheBusyBiscuit"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJD8myAH2gAyNDg3MTU1MTk4OjgxNmU5MDA0Y2EzYTc2NjczYzc5ZjUyYjBmODdhYTk2MzY0ZTg5MWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd83lC6AFqTU5NjA2NzU5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "816e9004ca3a76673c79f52b0f87aa96364e891c", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/816e9004ca3a76673c79f52b0f87aa96364e891c", "committedDate": "2020-09-15T08:58:28Z", "message": "Added the enum"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eeff9411a35f865c71889dd87eb4a84affe10745", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/eeff9411a35f865c71889dd87eb4a84affe10745", "committedDate": "2020-09-15T09:09:15Z", "message": "Implemented this for androids"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11c0faf376014a8105d7f42e7da54f868e08c69b", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/11c0faf376014a8105d7f42e7da54f868e08c69b", "committedDate": "2020-09-15T09:43:05Z", "message": "Updated changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2810019dbe67b892f540c1b2c171929509980003", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/2810019dbe67b892f540c1b2c171929509980003", "committedDate": "2020-09-15T10:08:30Z", "message": "Visual improvements + config setting for event calling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a7de82c4556de698110b35982529f35346eb7d3", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/1a7de82c4556de698110b35982529f35346eb7d3", "committedDate": "2020-09-15T17:42:52Z", "message": "Added Unit Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b062da47a9d54eb1f125e23009c034179021c36", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/2b062da47a9d54eb1f125e23009c034179021c36", "committedDate": "2020-09-15T17:44:01Z", "message": "Default changed to false"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4OTc2NDQy", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-488976442", "createdAt": "2020-09-15T18:55:36Z", "commit": {"oid": "2b062da47a9d54eb1f125e23009c034179021c36"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxODo1NTozNlrOHSPwgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxODo1NTozNlrOHSPwgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg5NDU5Mw==", "bodyText": "Are we not checking if drops fit anymore? Old code had a if (menu.fits(drop, getOutputSlots())) check, I don't see why we would skip it", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r488894593", "createdAt": "2020-09-15T18:55:36Z", "author": {"login": "Sfiguz7"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/androids/MinerAndroid.java", "diffHunk": "@@ -106,4 +99,23 @@ protected void moveAndDig(Block b, BlockMenu menu, BlockFace face, Block block)\n         }\n     }\n \n+    @ParametersAreNonnullByDefault\n+    private void breakBlock(BlockMenu menu, Collection<ItemStack> drops, Block block) {\n+        // Push our drops to the inventory\n+        for (ItemStack drop : drops) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b062da47a9d54eb1f125e23009c034179021c36"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4OTg0Njcz", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-488984673", "createdAt": "2020-09-15T19:06:55Z", "commit": {"oid": "2b062da47a9d54eb1f125e23009c034179021c36"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4OTkzNzI0", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-488993724", "createdAt": "2020-09-15T19:16:40Z", "commit": {"oid": "2b062da47a9d54eb1f125e23009c034179021c36"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOToxNjo0MFrOHSQjTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOToxNjo0MFrOHSQjTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzU5Nw==", "bodyText": "Can't seem to link to this line so I'm just commenting, these two arguments. I'm not sure how Unit Tests handle args but if water and lava refer to the same BlockFace you get no ValidCobblestoneGenerator\nEDIT: of course the same would apply below", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r488907597", "createdAt": "2020-09-15T19:16:40Z", "author": {"login": "Sfiguz7"}, "path": "src/test/java/io/github/thebusybiscuit/slimefun4/testing/tests/utils/TestInfiniteBlockGenerators.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package io.github.thebusybiscuit.slimefun4.testing.tests.utils;\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.event.block.BlockFromToEvent;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import be.seeseemelk.mockbukkit.MockBukkit;\n+import be.seeseemelk.mockbukkit.ServerMock;\n+import be.seeseemelk.mockbukkit.WorldMock;\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunPlugin;\n+import io.github.thebusybiscuit.slimefun4.utils.InfiniteBlockGenerator;\n+\n+class TestInfiniteBlockGenerators {\n+\n+    private static ServerMock server;\n+\n+    @BeforeAll\n+    public static void load() {\n+        server = MockBukkit.mock();\n+        MockBukkit.load(SlimefunPlugin.class);\n+    }\n+\n+    @AfterAll\n+    public static void unload() {\n+        MockBukkit.unmock();\n+    }\n+\n+    @Test\n+    @DisplayName(\"Test if invalid Cobblestone generators are ignored\")\n+    void testInvalidCobblestoneGenerator() {\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.STONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.COBBLESTONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block, false));\n+\n+        block.setType(Material.COBBLESTONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.COBBLESTONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block, false));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(value = \"provideFaces\")\n+    @DisplayName(\"Test if a Cobblestone Generator can be detected\")\n+    void testValidCobblestoneGenerator(BlockFace water, BlockFace lava) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b062da47a9d54eb1f125e23009c034179021c36"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MDQ0NTE5", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-489044519", "createdAt": "2020-09-15T20:27:09Z", "commit": {"oid": "2b062da47a9d54eb1f125e23009c034179021c36"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwNzgwODI3", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-490780827", "createdAt": "2020-09-17T16:25:59Z", "commit": {"oid": "2b062da47a9d54eb1f125e23009c034179021c36"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "775275c6613a8b954a5e21a2c86fa5fe9b54312a", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/775275c6613a8b954a5e21a2c86fa5fe9b54312a", "committedDate": "2020-09-29T18:59:10Z", "message": "Merge branch 'master' into performance/cobblestone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9605ed4d1f8632d68c5664007f13d044d8ba7938", "author": {"user": {"login": "poma123", "name": null}}, "url": "https://github.com/Slimefun/Slimefun4/commit/9605ed4d1f8632d68c5664007f13d044d8ba7938", "committedDate": "2020-10-02T12:51:18Z", "message": "Merge branch 'master' into performance/cobblestone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43284f1534bad0f3efb860d43d7a6a12690618ea", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/43284f1534bad0f3efb860d43d7a6a12690618ea", "committedDate": "2020-10-08T14:19:03Z", "message": "Merge branch 'master' into performance/cobblestone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d63d6189a937540fc564c3844a017cce685251d4", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/d63d6189a937540fc564c3844a017cce685251d4", "committedDate": "2020-10-10T11:49:10Z", "message": "Merge branch 'master' into performance/cobblestone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b07a54d51545533f97b353c60161dc64a3d830ea", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/b07a54d51545533f97b353c60161dc64a3d830ea", "committedDate": "2020-12-10T11:04:48Z", "message": "Merge branch 'master' of https://github.com/Slimefun/Slimefun4.git into performance/cobblestone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eac09eea9eea71ba6aadbc7d38ede96c9948b410", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/eac09eea9eea71ba6aadbc7d38ede96c9948b410", "committedDate": "2020-12-10T11:11:25Z", "message": "Switched to BlockFormEvent"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4MjQ4MDU3", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-558248057", "createdAt": "2020-12-23T22:06:06Z", "commit": {"oid": "eac09eea9eea71ba6aadbc7d38ede96c9948b410"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMjowNjowNlrOIK4Y7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMjo1NDo0NVrOIK6DlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI4MDU1OA==", "bodyText": "variable is never used", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548280558", "createdAt": "2020-12-23T22:06:06Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/listeners/BlockPhysicsListener.java", "diffHunk": "@@ -84,6 +84,7 @@ public void onPistonRetract(BlockPistonRetractEvent e) {\n     @EventHandler(ignoreCancelled = true)\n     public void onLiquidFlow(BlockFromToEvent e) {\n         Block block = e.getToBlock();\n+        Material type = block.getType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac09eea9eea71ba6aadbc7d38ede96c9948b410"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI4MDcyOQ==", "bodyText": "or you forgot to replace block.getType() here, either one works", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548280729", "createdAt": "2020-12-23T22:06:25Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/listeners/BlockPhysicsListener.java", "diffHunk": "@@ -84,6 +84,7 @@ public void onPistonRetract(BlockPistonRetractEvent e) {\n     @EventHandler(ignoreCancelled = true)\n     public void onLiquidFlow(BlockFromToEvent e) {\n         Block block = e.getToBlock();\n+        Material type = block.getType();\n \n         // Check if this Material can be destroyed by fluids\n         if (SlimefunTag.FLUID_SENSITIVE_MATERIALS.isTagged(block.getType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac09eea9eea71ba6aadbc7d38ede96c9948b410"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI5MzQwNw==", "bodyText": "naming wise I feel like InfiniteBlockGenerator#checkForAt(Block b) would fit better than InfiniteBlockGenerator#test(Block b)", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548293407", "createdAt": "2020-12-23T22:24:35Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/utils/InfiniteBlockGenerator.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package io.github.thebusybiscuit.slimefun4.utils;\n+\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import javax.annotation.ParametersAreNonnullByDefault;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.BlockState;\n+import org.bukkit.event.block.BlockFormEvent;\n+\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.androids.MinerAndroid;\n+import io.papermc.lib.PaperLib;\n+\n+/**\n+ * This enum holds various ways of infinite block generators.\n+ * The most prominent member of these is the standard Cobblestone Generator.\n+ * We use this enum for performance optimizations for the {@link MinerAndroid}.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+public enum InfiniteBlockGenerator implements Predicate<Block> {\n+\n+    /**\n+     * Your standard Cobblestone Generator with flowing lava and water.\n+     */\n+    COBBLESTONE_GENERATOR(\"COBBLESTONE\"),\n+\n+    /**\n+     * When lava flows onto a stationary water block it generates normal stone.\n+     */\n+    STONE_GENERATOR(\"STONE\"),\n+\n+    /**\n+     * The Basalt Generator (1.16+ only) allows you to generate infinite Basalt!\n+     */\n+    BASALT_GENERATOR(\"BASALT\");\n+\n+    public static final InfiniteBlockGenerator[] values = values();\n+    private static final BlockFace[] sameLevelFaces = { BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST };\n+\n+    private final Material material;\n+\n+    InfiniteBlockGenerator(@Nonnull String type) {\n+        this.material = Material.matchMaterial(type);\n+    }\n+\n+    /**\n+     * This returns the generated {@link Material} of this {@link InfiniteBlockGenerator}.\n+     * This method can return null if the associated {@link Material} is not available in the current\n+     * {@link MinecraftVersion}.\n+     * \n+     * @return The generated {@link Material} or null\n+     */\n+    @Nullable\n+    public Material getGeneratedMaterial() {\n+        return material;\n+    }\n+\n+    /**\n+     * Similar to {@link #test(Block)} this tests whether this {@link InfiniteBlockGenerator}\n+     * exists at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     * \n+     * @return Whether this {@link InfiniteBlockGenerator} exists at the given {@link Block}\n+     */\n+    @Override\n+    public boolean test(@Nonnull Block b) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac09eea9eea71ba6aadbc7d38ede96c9948b410"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNTE0MQ==", "bodyText": "Public method so Validate#notNull here? Or am I still getting this wrong xD", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548305141", "createdAt": "2020-12-23T22:44:03Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/utils/InfiniteBlockGenerator.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package io.github.thebusybiscuit.slimefun4.utils;\n+\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import javax.annotation.ParametersAreNonnullByDefault;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.BlockState;\n+import org.bukkit.event.block.BlockFormEvent;\n+\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.androids.MinerAndroid;\n+import io.papermc.lib.PaperLib;\n+\n+/**\n+ * This enum holds various ways of infinite block generators.\n+ * The most prominent member of these is the standard Cobblestone Generator.\n+ * We use this enum for performance optimizations for the {@link MinerAndroid}.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+public enum InfiniteBlockGenerator implements Predicate<Block> {\n+\n+    /**\n+     * Your standard Cobblestone Generator with flowing lava and water.\n+     */\n+    COBBLESTONE_GENERATOR(\"COBBLESTONE\"),\n+\n+    /**\n+     * When lava flows onto a stationary water block it generates normal stone.\n+     */\n+    STONE_GENERATOR(\"STONE\"),\n+\n+    /**\n+     * The Basalt Generator (1.16+ only) allows you to generate infinite Basalt!\n+     */\n+    BASALT_GENERATOR(\"BASALT\");\n+\n+    public static final InfiniteBlockGenerator[] values = values();\n+    private static final BlockFace[] sameLevelFaces = { BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST };\n+\n+    private final Material material;\n+\n+    InfiniteBlockGenerator(@Nonnull String type) {\n+        this.material = Material.matchMaterial(type);\n+    }\n+\n+    /**\n+     * This returns the generated {@link Material} of this {@link InfiniteBlockGenerator}.\n+     * This method can return null if the associated {@link Material} is not available in the current\n+     * {@link MinecraftVersion}.\n+     * \n+     * @return The generated {@link Material} or null\n+     */\n+    @Nullable\n+    public Material getGeneratedMaterial() {\n+        return material;\n+    }\n+\n+    /**\n+     * Similar to {@link #test(Block)} this tests whether this {@link InfiniteBlockGenerator}\n+     * exists at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     * \n+     * @return Whether this {@link InfiniteBlockGenerator} exists at the given {@link Block}\n+     */\n+    @Override\n+    public boolean test(@Nonnull Block b) {\n+        Validate.notNull(b, \"Block cannot be null!\");\n+\n+        /*\n+         * This will eliminate non-matching base materials If we\n+         * are on a version without Basalt, it will be null here and not match.\n+         */\n+        if (b.getType() == getGeneratedMaterial()) {\n+            switch (this) {\n+            case COBBLESTONE_GENERATOR:\n+                return hasSurroundingMaterials(b, Material.WATER, Material.LAVA);\n+            case STONE_GENERATOR:\n+                if (b.getRelative(BlockFace.UP).getType() == Material.LAVA) {\n+                    return hasSurroundingMaterials(b, Material.WATER);\n+                } else {\n+                    return false;\n+                }\n+            case BASALT_GENERATOR:\n+                if (b.getRelative(BlockFace.DOWN).getType() == Material.SOUL_SOIL) {\n+                    return hasSurroundingMaterials(b, Material.LAVA, Material.BLUE_ICE);\n+                } else {\n+                    return false;\n+                }\n+            default:\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @ParametersAreNonnullByDefault\n+    private boolean hasSurroundingMaterials(Block b, Material... materials) {\n+        Validate.notNull(b, \"The Block cannot be null!\");\n+        Validate.notEmpty(materials, \"Materials need to have a size of at least one!\");\n+\n+        boolean[] matches = new boolean[materials.length];\n+        int count = 0;\n+\n+        for (BlockFace face : sameLevelFaces) {\n+            Block neighbour = b.getRelative(face);\n+            Material neighbourType = neighbour.getType();\n+\n+            for (int i = 0; i < materials.length; i++) {\n+                if (neighbourType == materials[i] && !matches[i]) {\n+                    matches[i] = true;\n+                    count++;\n+                    break;\n+                }\n+            }\n+\n+            if (count == materials.length) {\n+                return true;\n+            }\n+        }\n+\n+        return count == materials.length;\n+    }\n+\n+    /**\n+     * This method calls a {@link BlockFormEvent} for this {@link InfiniteBlockGenerator}.\n+     * There are a few plugins who catch these events to inject custom {@link Material Materials} into\n+     * Cobblestone Generators, so we wanna give them the oppurtunity to catch this as well.\n+     * \n+     * @param from\n+     *            The {@link Block} where our liquid is coming from.\n+     * @param to\n+     *            The {@link Block} our liquid has flown to / solidified at.\n+     * \n+     * @return Our called {@link BlockFormEvent}\n+     */\n+    @Nonnull\n+    public BlockFormEvent callEvent(@Nonnull Block block) {\n+        BlockState state = PaperLib.getBlockState(block, false).getState();\n+        BlockFormEvent event = new BlockFormEvent(block, state);\n+        Bukkit.getPluginManager().callEvent(event);\n+        return event;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac09eea9eea71ba6aadbc7d38ede96c9948b410"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNzg2MA==", "bodyText": "extra empty line", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548307860", "createdAt": "2020-12-23T22:54:45Z", "author": {"login": "svr333"}, "path": "src/test/java/io/github/thebusybiscuit/slimefun4/testing/tests/utils/TestInfiniteBlockGenerators.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package io.github.thebusybiscuit.slimefun4.testing.tests.utils;\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.event.block.BlockFormEvent;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import be.seeseemelk.mockbukkit.MockBukkit;\n+import be.seeseemelk.mockbukkit.ServerMock;\n+import be.seeseemelk.mockbukkit.WorldMock;\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunPlugin;\n+import io.github.thebusybiscuit.slimefun4.utils.InfiniteBlockGenerator;\n+\n+class TestInfiniteBlockGenerators {\n+\n+    private static ServerMock server;\n+\n+    @BeforeAll\n+    public static void load() {\n+        server = MockBukkit.mock();\n+        MockBukkit.load(SlimefunPlugin.class);\n+    }\n+\n+    @AfterAll\n+    public static void unload() {\n+        MockBukkit.unmock();\n+    }\n+\n+    @Test\n+    @DisplayName(\"Test if invalid Cobblestone generators are ignored\")\n+    void testInvalidCobblestoneGenerator() {\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.STONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.COBBLESTONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.setType(Material.COBBLESTONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.COBBLESTONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(value = \"provideFaces\")\n+    @DisplayName(\"Test if a Cobblestone Generator can be detected\")\n+    void testValidCobblestoneGenerator(BlockFace water, BlockFace lava) {\n+        InfiniteBlockGenerator generator = InfiniteBlockGenerator.COBBLESTONE_GENERATOR;\n+\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.COBBLESTONE);\n+        block.getRelative(water).setType(Material.WATER);\n+        block.getRelative(lava).setType(Material.LAVA);\n+\n+        Assertions.assertTrue(generator.test(block));\n+        Assertions.assertNotNull(generator.callEvent(block));\n+\n+        server.getPluginManager().assertEventFired(BlockFormEvent.class);\n+        server.getPluginManager().clearEvents();\n+\n+        Assertions.assertEquals(generator, InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @Test\n+    @DisplayName(\"Test if invalid Basalt generators are ignored\")\n+    void testInvalidBasaltGenerator() {\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.COBBLESTONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.BASALT_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.setType(Material.BASALT);\n+        Assertions.assertFalse(InfiniteBlockGenerator.BASALT_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.getRelative(BlockFace.DOWN).setType(Material.SOUL_SOIL);\n+        Assertions.assertFalse(InfiniteBlockGenerator.BASALT_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(value = \"provideFaces\")\n+    @DisplayName(\"Test if a Basalt Generator can be detected\")\n+    void testValidBasaltGenerator(BlockFace ice, BlockFace lava) {\n+        InfiniteBlockGenerator generator = InfiniteBlockGenerator.BASALT_GENERATOR;\n+\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.BASALT);\n+        block.getRelative(BlockFace.DOWN).setType(Material.SOUL_SOIL);\n+        block.getRelative(ice).setType(Material.BLUE_ICE);\n+        block.getRelative(lava).setType(Material.LAVA);\n+\n+        Assertions.assertTrue(generator.test(block));\n+        Assertions.assertNotNull(generator.callEvent(block));\n+\n+        server.getPluginManager().assertEventFired(BlockFormEvent.class);\n+        server.getPluginManager().clearEvents();\n+\n+        Assertions.assertEquals(generator, InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @Test\n+    @DisplayName(\"Test if invalid Stone generators are ignored\")\n+    void testInvalidStoneGenerator() {\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.COBBLESTONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.STONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.setType(Material.STONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.STONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.getRelative(BlockFace.UP).setType(Material.LAVA);\n+        Assertions.assertFalse(InfiniteBlockGenerator.STONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(value = BlockFace.class, names = { \"NORTH\", \"EAST\", \"SOUTH\", \"WEST\" })\n+    @DisplayName(\"Test if a Stone Generator can be detected\")\n+    void testValidStoneGenerator(BlockFace water) {\n+        InfiniteBlockGenerator generator = InfiniteBlockGenerator.STONE_GENERATOR;\n+\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.STONE);\n+        block.getRelative(BlockFace.UP).setType(Material.LAVA);\n+        block.getRelative(water).setType(Material.WATER);\n+\n+        Assertions.assertTrue(generator.test(block));\n+        Assertions.assertNotNull(generator.callEvent(block));\n+\n+        server.getPluginManager().assertEventFired(BlockFormEvent.class);\n+        server.getPluginManager().clearEvents();\n+\n+        Assertions.assertEquals(generator, InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    private static Stream<Arguments> provideFaces() {\n+        BlockFace[] faces = { BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST };\n+        Stream<BlockFace> stream = Arrays.stream(faces);\n+        return stream.flatMap(a -> Arrays.stream(faces).filter(b -> a != b).map(b -> Arguments.of(a, b)));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac09eea9eea71ba6aadbc7d38ede96c9948b410"}, "originalPosition": 167}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2199fb2cd0da3f6c58d2692d25abccf4c88b4d92", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/2199fb2cd0da3f6c58d2692d25abccf4c88b4d92", "committedDate": "2020-12-24T15:15:47Z", "message": "Update src/main/java/io/github/thebusybiscuit/slimefun4/implementation/listeners/BlockPhysicsListener.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e88682c13b629f4459d6ba4ed71919b9dbea8f7a", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/e88682c13b629f4459d6ba4ed71919b9dbea8f7a", "committedDate": "2020-12-24T15:17:20Z", "message": "Update src/main/java/io/github/thebusybiscuit/slimefun4/utils/InfiniteBlockGenerator.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9725d63cf048d2419547205ff9e82b63a2acf454", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/9725d63cf048d2419547205ff9e82b63a2acf454", "committedDate": "2020-12-24T15:17:33Z", "message": "Update src/test/java/io/github/thebusybiscuit/slimefun4/testing/tests/utils/TestInfiniteBlockGenerators.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NjgyMjcy", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-558682272", "createdAt": "2020-12-24T16:41:36Z", "commit": {"oid": "9725d63cf048d2419547205ff9e82b63a2acf454"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxNjo0MTozNlrOILMZnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxNjo0MTozNlrOILMZnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYwODQxMg==", "bodyText": "Suggested change", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548608412", "createdAt": "2020-12-24T16:41:36Z", "author": {"login": "svr333"}, "path": "src/main/java/io/github/thebusybiscuit/slimefun4/utils/InfiniteBlockGenerator.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package io.github.thebusybiscuit.slimefun4.utils;\n+\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import javax.annotation.ParametersAreNonnullByDefault;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.BlockState;\n+import org.bukkit.event.block.BlockFormEvent;\n+\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.androids.MinerAndroid;\n+import io.papermc.lib.PaperLib;\n+\n+/**\n+ * This enum holds various ways of infinite block generators.\n+ * The most prominent member of these is the standard Cobblestone Generator.\n+ * We use this enum for performance optimizations for the {@link MinerAndroid}.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+public enum InfiniteBlockGenerator implements Predicate<Block> {\n+\n+    /**\n+     * Your standard Cobblestone Generator with flowing lava and water.\n+     */\n+    COBBLESTONE_GENERATOR(\"COBBLESTONE\"),\n+\n+    /**\n+     * When lava flows onto a stationary water block it generates normal stone.\n+     */\n+    STONE_GENERATOR(\"STONE\"),\n+\n+    /**\n+     * The Basalt Generator (1.16+ only) allows you to generate infinite Basalt!\n+     */\n+    BASALT_GENERATOR(\"BASALT\");\n+\n+    public static final InfiniteBlockGenerator[] values = values();\n+    private static final BlockFace[] sameLevelFaces = { BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST };\n+\n+    private final Material material;\n+\n+    InfiniteBlockGenerator(@Nonnull String type) {\n+        this.material = Material.matchMaterial(type);\n+    }\n+\n+    /**\n+     * This returns the generated {@link Material} of this {@link InfiniteBlockGenerator}.\n+     * This method can return null if the associated {@link Material} is not available in the current\n+     * {@link MinecraftVersion}.\n+     * \n+     * @return The generated {@link Material} or null\n+     */\n+    @Nullable\n+    public Material getGeneratedMaterial() {\n+        return material;\n+    }\n+\n+    /**\n+     * Similar to {@link #test(Block)} this tests whether this {@link InfiniteBlockGenerator}\n+     * exists at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     * \n+     * @return Whether this {@link InfiniteBlockGenerator} exists at the given {@link Block}\n+     */\n+    @Override\n+    public boolean test(@Nonnull Block b) {\n+        Validate.notNull(b, \"Block cannot be null!\");\n+\n+        /*\n+         * This will eliminate non-matching base materials If we\n+         * are on a version without Basalt, it will be null here and not match.\n+         */\n+        if (b.getType() == getGeneratedMaterial()) {\n+            switch (this) {\n+            case COBBLESTONE_GENERATOR:\n+                return hasSurroundingMaterials(b, Material.WATER, Material.LAVA);\n+            case STONE_GENERATOR:\n+                if (b.getRelative(BlockFace.UP).getType() == Material.LAVA) {\n+                    return hasSurroundingMaterials(b, Material.WATER);\n+                } else {\n+                    return false;\n+                }\n+            case BASALT_GENERATOR:\n+                if (b.getRelative(BlockFace.DOWN).getType() == Material.SOUL_SOIL) {\n+                    return hasSurroundingMaterials(b, Material.LAVA, Material.BLUE_ICE);\n+                } else {\n+                    return false;\n+                }\n+            default:\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @ParametersAreNonnullByDefault\n+    private boolean hasSurroundingMaterials(Block b, Material... materials) {\n+        Validate.notNull(b, \"The Block cannot be null!\");\n+        Validate.notEmpty(materials, \"Materials need to have a size of at least one!\");\n+\n+        boolean[] matches = new boolean[materials.length];\n+        int count = 0;\n+\n+        for (BlockFace face : sameLevelFaces) {\n+            Block neighbour = b.getRelative(face);\n+            Material neighbourType = neighbour.getType();\n+\n+            for (int i = 0; i < materials.length; i++) {\n+                if (neighbourType == materials[i] && !matches[i]) {\n+                    matches[i] = true;\n+                    count++;\n+                    break;\n+                }\n+            }\n+\n+            if (count == materials.length) {\n+                return true;\n+            }\n+        }\n+\n+        return count == materials.length;\n+    }\n+\n+    /**\n+     * This method calls a {@link BlockFormEvent} for this {@link InfiniteBlockGenerator}.\n+     * There are a few plugins who catch these events to inject custom {@link Material Materials} into\n+     * Cobblestone Generators, so we wanna give them the oppurtunity to catch this as well.\n+     * \n+     * @param from\n+     *            The {@link Block} where our liquid is coming from.\n+     * @param to\n+     *            The {@link Block} our liquid has flown to / solidified at.\n+     * \n+     * @return Our called {@link BlockFormEvent}\n+     */\n+    @Nonnull\n+    public BlockFormEvent callEvent(@Nonnull Block block) {\n+        Validate.notNull(block, \"The Block cannot be null!\");\n+        BlockState state = PaperLib.getBlockState(block, false).getState();\n+        BlockFormEvent event = new BlockFormEvent(block, state);\n+        Bukkit.getPluginManager().callEvent(event);\n+        return event;\n+    }\n+\n+    /**\n+     * This will attempt to find an {@link InfiniteBlockGenerator} at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     * \n+     * @return An {@link InfiniteBlockGenerator} or null if none was found.\n+     */\n+    @Nullable\n+    public static InfiniteBlockGenerator findAt(@Nonnull Block b) {\n+        Validate.notNull(b, \"Cannot find a generator without a Location!\");\n+\n+        for (InfiniteBlockGenerator generator : values) {\n+            if (generator.test(b)) {\n+                return generator;\n+            }\n+        }\n+\n+        return null;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9725d63cf048d2419547205ff9e82b63a2acf454"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c53837a0de1f3dfd2005233595d39fb88414689b", "author": {"user": {"login": "svr333", "name": "svr333"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/c53837a0de1f3dfd2005233595d39fb88414689b", "committedDate": "2020-12-24T16:43:11Z", "message": "Remove redundant whiteline"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NjgyNjc0", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-558682674", "createdAt": "2020-12-24T16:43:42Z", "commit": {"oid": "c53837a0de1f3dfd2005233595d39fb88414689b"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e773e68b4a8b48c7561dd48f2dbd6bf5322d7bfc", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/e773e68b4a8b48c7561dd48f2dbd6bf5322d7bfc", "committedDate": "2021-01-06T19:24:54Z", "message": "Merge branch 'master' into performance/cobblestone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c92ba89d9aecbf385ccb2b511296cf93b9a44feb", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/c92ba89d9aecbf385ccb2b511296cf93b9a44feb", "committedDate": "2021-01-11T12:58:21Z", "message": "Merge branch 'master' into performance/cobblestone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43109ab2d39625b534329b1bf78e4dbb781013ec", "author": {"user": {"login": "TheBusyBiscuit", "name": "TheBusyBiscuit"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/43109ab2d39625b534329b1bf78e4dbb781013ec", "committedDate": "2021-01-14T10:16:39Z", "message": "Merge branch 'master' into performance/cobblestone"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5OTMzNTI5", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-569933529", "createdAt": "2021-01-16T12:01:37Z", "commit": {"oid": "43109ab2d39625b534329b1bf78e4dbb781013ec"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffef8350b113305f50a01cf59633cf4f511a1c73", "author": {"user": {"login": "svr333", "name": "svr333"}}, "url": "https://github.com/Slimefun/Slimefun4/commit/ffef8350b113305f50a01cf59633cf4f511a1c73", "committedDate": "2021-01-18T21:18:02Z", "message": "Merge branch 'master' into performance/cobblestone"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzgxNjI5", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-570781629", "createdAt": "2021-01-18T21:18:17Z", "commit": {"oid": "ffef8350b113305f50a01cf59633cf4f511a1c73"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2MDY3NTk4", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#pullrequestreview-596067598", "createdAt": "2021-02-23T07:57:56Z", "commit": {"oid": "ffef8350b113305f50a01cf59633cf4f511a1c73"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2467, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}