{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxNTE2NDI0", "number": 3663, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjowNzoxMlrOEbBjUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjowNzoxMlrOEbBjUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NzcyNDMyOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/alibaba/nacos/common/task/engine/AbstractNacosTaskExecuteEngine.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjowNzoxMlrOHEy-FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQwNTo1MzoxMVrOHFC0Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MTQ0NQ==", "bodyText": "\u8fd9\u91cc\u5982\u679c\u4e0d\u9ebb\u70e6\u7684\u8bdd\uff0c\u53ef\u4ee5\u7528\u8fd9\u79cd\u65b9\u5f0f\nfinal Lock lock = this.lock;\nlock.lock()", "url": "https://github.com/alibaba/nacos/pull/3663#discussion_r474791445", "createdAt": "2020-08-21T16:07:12Z", "author": {"login": "chuntaojun"}, "path": "common/src/main/java/com/alibaba/nacos/common/task/engine/AbstractNacosTaskExecuteEngine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.alibaba.nacos.common.task.engine;\n+\n+import com.alibaba.nacos.api.exception.NacosException;\n+import com.alibaba.nacos.common.executor.ExecutorFactory;\n+import com.alibaba.nacos.common.executor.NameThreadFactory;\n+import com.alibaba.nacos.common.task.NacosTask;\n+import com.alibaba.nacos.common.task.NacosTaskProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Abstract nacos task execute engine.\n+ *\n+ * @author xiweng.yy\n+ */\n+public abstract class AbstractNacosTaskExecuteEngine<T extends NacosTask> implements NacosTaskExecuteEngine<T> {\n+    \n+    private final Logger log;\n+    \n+    private final ScheduledExecutorService processingExecutor;\n+    \n+    private final ConcurrentHashMap<Object, NacosTaskProcessor> taskProcessors = new ConcurrentHashMap<Object, NacosTaskProcessor>();\n+    \n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    \n+    protected final ConcurrentHashMap<Object, T> tasks;\n+    \n+    protected final ReentrantLock lock = new ReentrantLock();\n+    \n+    private NacosTaskProcessor defaultTaskProcessor;\n+    \n+    public AbstractNacosTaskExecuteEngine(String name) {\n+        this(name, 32, null, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger) {\n+        this(name, 32, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger, long processInterval) {\n+        this(name, 32, logger, processInterval);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger) {\n+        this(name, initCapacity, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger, long processInterval) {\n+        this.log = null != logger ? logger : LoggerFactory.getLogger(AbstractNacosTaskExecuteEngine.class.getName());\n+        tasks = new ConcurrentHashMap<Object, T>(initCapacity);\n+        processingExecutor = ExecutorFactory.newSingleScheduledExecutorService(new NameThreadFactory(name));\n+        processingExecutor.scheduleWithFixedDelay(new ProcessRunnable(), processInterval, processInterval, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    @Override\n+    public int size() {\n+        lock.lock();\n+        try {\n+            return tasks.size();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public boolean isEmpty() {\n+        lock.lock();\n+        try {\n+            return tasks.isEmpty();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public void addProcessor(Object key, NacosTaskProcessor taskProcessor) {\n+        taskProcessors.putIfAbsent(key, taskProcessor);\n+    }\n+    \n+    @Override\n+    public void removeProcessor(Object key) {\n+        taskProcessors.remove(key);\n+    }\n+    \n+    @Override\n+    public NacosTaskProcessor getProcessor(Object key) {\n+        return taskProcessors.containsKey(key) ? taskProcessors.get(key) : defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public Collection<Object> getAllProcessorKey() {\n+        return taskProcessors.keySet();\n+    }\n+    \n+    @Override\n+    public void setDefaultTaskProcessor(NacosTaskProcessor defaultTaskProcessor) {\n+        this.defaultTaskProcessor = defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public T removeTask(Object key) {\n+        lock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a458bfd83c4de6bb70f10a9ccb7a0b0078e96bd4"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAzMzUwMg==", "bodyText": "final Lock lock = this.lock;\n\n\u8bf7\u6559\u4e00\u4e0b\uff0c\u4e3a\u4ec0\u4e48\u8981\u52a0\u90a3\u4e00\u884c\u5462\uff1f\u4e3a\u4e86\u907f\u514d\u539f\u672clock\u5f15\u7528\u88ab\u66ff\u6362\u5417", "url": "https://github.com/alibaba/nacos/pull/3663#discussion_r475033502", "createdAt": "2020-08-22T02:09:47Z", "author": {"login": "horizonzy"}, "path": "common/src/main/java/com/alibaba/nacos/common/task/engine/AbstractNacosTaskExecuteEngine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.alibaba.nacos.common.task.engine;\n+\n+import com.alibaba.nacos.api.exception.NacosException;\n+import com.alibaba.nacos.common.executor.ExecutorFactory;\n+import com.alibaba.nacos.common.executor.NameThreadFactory;\n+import com.alibaba.nacos.common.task.NacosTask;\n+import com.alibaba.nacos.common.task.NacosTaskProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Abstract nacos task execute engine.\n+ *\n+ * @author xiweng.yy\n+ */\n+public abstract class AbstractNacosTaskExecuteEngine<T extends NacosTask> implements NacosTaskExecuteEngine<T> {\n+    \n+    private final Logger log;\n+    \n+    private final ScheduledExecutorService processingExecutor;\n+    \n+    private final ConcurrentHashMap<Object, NacosTaskProcessor> taskProcessors = new ConcurrentHashMap<Object, NacosTaskProcessor>();\n+    \n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    \n+    protected final ConcurrentHashMap<Object, T> tasks;\n+    \n+    protected final ReentrantLock lock = new ReentrantLock();\n+    \n+    private NacosTaskProcessor defaultTaskProcessor;\n+    \n+    public AbstractNacosTaskExecuteEngine(String name) {\n+        this(name, 32, null, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger) {\n+        this(name, 32, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger, long processInterval) {\n+        this(name, 32, logger, processInterval);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger) {\n+        this(name, initCapacity, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger, long processInterval) {\n+        this.log = null != logger ? logger : LoggerFactory.getLogger(AbstractNacosTaskExecuteEngine.class.getName());\n+        tasks = new ConcurrentHashMap<Object, T>(initCapacity);\n+        processingExecutor = ExecutorFactory.newSingleScheduledExecutorService(new NameThreadFactory(name));\n+        processingExecutor.scheduleWithFixedDelay(new ProcessRunnable(), processInterval, processInterval, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    @Override\n+    public int size() {\n+        lock.lock();\n+        try {\n+            return tasks.size();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public boolean isEmpty() {\n+        lock.lock();\n+        try {\n+            return tasks.isEmpty();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public void addProcessor(Object key, NacosTaskProcessor taskProcessor) {\n+        taskProcessors.putIfAbsent(key, taskProcessor);\n+    }\n+    \n+    @Override\n+    public void removeProcessor(Object key) {\n+        taskProcessors.remove(key);\n+    }\n+    \n+    @Override\n+    public NacosTaskProcessor getProcessor(Object key) {\n+        return taskProcessors.containsKey(key) ? taskProcessors.get(key) : defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public Collection<Object> getAllProcessorKey() {\n+        return taskProcessors.keySet();\n+    }\n+    \n+    @Override\n+    public void setDefaultTaskProcessor(NacosTaskProcessor defaultTaskProcessor) {\n+        this.defaultTaskProcessor = defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public T removeTask(Object key) {\n+        lock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MTQ0NQ=="}, "originalCommit": {"oid": "a458bfd83c4de6bb70f10a9ccb7a0b0078e96bd4"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA1MDM3NQ==", "bodyText": "final Lock lock = this.lock;\n\n\u8bf7\u6559\u4e00\u4e0b\uff0c\u4e3a\u4ec0\u4e48\u8981\u52a0\u90a3\u4e00\u884c\u5462\uff1f\u4e3a\u4e86\u907f\u514d\u539f\u672clock\u5f15\u7528\u88ab\u66ff\u6362\u5417\n\n\u8fd9\u91cc\u9700\u8981\u4f9d\u9760\u5b57\u8282\u7801\u5206\u6790\u4e86\uff0c\u672c\u8d28\u53ea\u662f\u5c11\u4e86\u4e00\u6b21\u6839\u636ethis\u7684\u6307\u9488\u67e5\u8be2\u800c\u5df2", "url": "https://github.com/alibaba/nacos/pull/3663#discussion_r475050375", "createdAt": "2020-08-22T05:44:18Z", "author": {"login": "chuntaojun"}, "path": "common/src/main/java/com/alibaba/nacos/common/task/engine/AbstractNacosTaskExecuteEngine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.alibaba.nacos.common.task.engine;\n+\n+import com.alibaba.nacos.api.exception.NacosException;\n+import com.alibaba.nacos.common.executor.ExecutorFactory;\n+import com.alibaba.nacos.common.executor.NameThreadFactory;\n+import com.alibaba.nacos.common.task.NacosTask;\n+import com.alibaba.nacos.common.task.NacosTaskProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Abstract nacos task execute engine.\n+ *\n+ * @author xiweng.yy\n+ */\n+public abstract class AbstractNacosTaskExecuteEngine<T extends NacosTask> implements NacosTaskExecuteEngine<T> {\n+    \n+    private final Logger log;\n+    \n+    private final ScheduledExecutorService processingExecutor;\n+    \n+    private final ConcurrentHashMap<Object, NacosTaskProcessor> taskProcessors = new ConcurrentHashMap<Object, NacosTaskProcessor>();\n+    \n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    \n+    protected final ConcurrentHashMap<Object, T> tasks;\n+    \n+    protected final ReentrantLock lock = new ReentrantLock();\n+    \n+    private NacosTaskProcessor defaultTaskProcessor;\n+    \n+    public AbstractNacosTaskExecuteEngine(String name) {\n+        this(name, 32, null, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger) {\n+        this(name, 32, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger, long processInterval) {\n+        this(name, 32, logger, processInterval);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger) {\n+        this(name, initCapacity, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger, long processInterval) {\n+        this.log = null != logger ? logger : LoggerFactory.getLogger(AbstractNacosTaskExecuteEngine.class.getName());\n+        tasks = new ConcurrentHashMap<Object, T>(initCapacity);\n+        processingExecutor = ExecutorFactory.newSingleScheduledExecutorService(new NameThreadFactory(name));\n+        processingExecutor.scheduleWithFixedDelay(new ProcessRunnable(), processInterval, processInterval, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    @Override\n+    public int size() {\n+        lock.lock();\n+        try {\n+            return tasks.size();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public boolean isEmpty() {\n+        lock.lock();\n+        try {\n+            return tasks.isEmpty();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public void addProcessor(Object key, NacosTaskProcessor taskProcessor) {\n+        taskProcessors.putIfAbsent(key, taskProcessor);\n+    }\n+    \n+    @Override\n+    public void removeProcessor(Object key) {\n+        taskProcessors.remove(key);\n+    }\n+    \n+    @Override\n+    public NacosTaskProcessor getProcessor(Object key) {\n+        return taskProcessors.containsKey(key) ? taskProcessors.get(key) : defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public Collection<Object> getAllProcessorKey() {\n+        return taskProcessors.keySet();\n+    }\n+    \n+    @Override\n+    public void setDefaultTaskProcessor(NacosTaskProcessor defaultTaskProcessor) {\n+        this.defaultTaskProcessor = defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public T removeTask(Object key) {\n+        lock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MTQ0NQ=="}, "originalCommit": {"oid": "a458bfd83c4de6bb70f10a9ccb7a0b0078e96bd4"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA1MDczOA==", "bodyText": "final Lock lock = this.lock;\n\n\u8bf7\u6559\u4e00\u4e0b\uff0c\u4e3a\u4ec0\u4e48\u8981\u52a0\u90a3\u4e00\u884c\u5462\uff1f\u4e3a\u4e86\u907f\u514d\u539f\u672clock\u5f15\u7528\u88ab\u66ff\u6362\u5417\n\n\u8fd9\u91cc\u9700\u8981\u4f9d\u9760\u5b57\u8282\u7801\u5206\u6790\u4e86\uff0c\u672c\u8d28\u53ea\u662f\u5c11\u4e86\u4e00\u6b21\u6839\u636ethis\u7684\u6307\u9488\u67e5\u8be2\u800c\u5df2\n\n\u8fd9\u4e2a\u5e94\u8be5\u4e00\u6837\u5427\uff0c\u7f16\u8bd1\u4e4b\u540e\u7684class\u81ea\u52a8\u4f1a\u52a0\u4e0athis\u7684", "url": "https://github.com/alibaba/nacos/pull/3663#discussion_r475050738", "createdAt": "2020-08-22T05:48:50Z", "author": {"login": "horizonzy"}, "path": "common/src/main/java/com/alibaba/nacos/common/task/engine/AbstractNacosTaskExecuteEngine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.alibaba.nacos.common.task.engine;\n+\n+import com.alibaba.nacos.api.exception.NacosException;\n+import com.alibaba.nacos.common.executor.ExecutorFactory;\n+import com.alibaba.nacos.common.executor.NameThreadFactory;\n+import com.alibaba.nacos.common.task.NacosTask;\n+import com.alibaba.nacos.common.task.NacosTaskProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Abstract nacos task execute engine.\n+ *\n+ * @author xiweng.yy\n+ */\n+public abstract class AbstractNacosTaskExecuteEngine<T extends NacosTask> implements NacosTaskExecuteEngine<T> {\n+    \n+    private final Logger log;\n+    \n+    private final ScheduledExecutorService processingExecutor;\n+    \n+    private final ConcurrentHashMap<Object, NacosTaskProcessor> taskProcessors = new ConcurrentHashMap<Object, NacosTaskProcessor>();\n+    \n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    \n+    protected final ConcurrentHashMap<Object, T> tasks;\n+    \n+    protected final ReentrantLock lock = new ReentrantLock();\n+    \n+    private NacosTaskProcessor defaultTaskProcessor;\n+    \n+    public AbstractNacosTaskExecuteEngine(String name) {\n+        this(name, 32, null, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger) {\n+        this(name, 32, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger, long processInterval) {\n+        this(name, 32, logger, processInterval);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger) {\n+        this(name, initCapacity, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger, long processInterval) {\n+        this.log = null != logger ? logger : LoggerFactory.getLogger(AbstractNacosTaskExecuteEngine.class.getName());\n+        tasks = new ConcurrentHashMap<Object, T>(initCapacity);\n+        processingExecutor = ExecutorFactory.newSingleScheduledExecutorService(new NameThreadFactory(name));\n+        processingExecutor.scheduleWithFixedDelay(new ProcessRunnable(), processInterval, processInterval, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    @Override\n+    public int size() {\n+        lock.lock();\n+        try {\n+            return tasks.size();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public boolean isEmpty() {\n+        lock.lock();\n+        try {\n+            return tasks.isEmpty();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public void addProcessor(Object key, NacosTaskProcessor taskProcessor) {\n+        taskProcessors.putIfAbsent(key, taskProcessor);\n+    }\n+    \n+    @Override\n+    public void removeProcessor(Object key) {\n+        taskProcessors.remove(key);\n+    }\n+    \n+    @Override\n+    public NacosTaskProcessor getProcessor(Object key) {\n+        return taskProcessors.containsKey(key) ? taskProcessors.get(key) : defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public Collection<Object> getAllProcessorKey() {\n+        return taskProcessors.keySet();\n+    }\n+    \n+    @Override\n+    public void setDefaultTaskProcessor(NacosTaskProcessor defaultTaskProcessor) {\n+        this.defaultTaskProcessor = defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public T removeTask(Object key) {\n+        lock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MTQ0NQ=="}, "originalCommit": {"oid": "a458bfd83c4de6bb70f10a9ccb7a0b0078e96bd4"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA1MDg3Nw==", "bodyText": "final Lock lock = this.lock;\n\n\u8bf7\u6559\u4e00\u4e0b\uff0c\u4e3a\u4ec0\u4e48\u8981\u52a0\u90a3\u4e00\u884c\u5462\uff1f\u4e3a\u4e86\u907f\u514d\u539f\u672clock\u5f15\u7528\u88ab\u66ff\u6362\u5417\n\n\u8fd9\u91cc\u9700\u8981\u4f9d\u9760\u5b57\u8282\u7801\u5206\u6790\u4e86\uff0c\u672c\u8d28\u53ea\u662f\u5c11\u4e86\u4e00\u6b21\u6839\u636ethis\u7684\u6307\u9488\u67e5\u8be2\u800c\u5df2\n\n\u8fd9\u4e2a\u5e94\u8be5\u4e00\u6837\u5427\uff0c\u7f16\u8bd1\u4e4b\u540e\u7684class\u81ea\u52a8\u4f1a\u52a0\u4e0athis\u7684\n\n\u4f60\u53ef\u4ee5\u81ea\u5df1\u67e5\u770b\u5b57\u8282\u7801\u7814\u7a76\u4e0b", "url": "https://github.com/alibaba/nacos/pull/3663#discussion_r475050877", "createdAt": "2020-08-22T05:50:12Z", "author": {"login": "chuntaojun"}, "path": "common/src/main/java/com/alibaba/nacos/common/task/engine/AbstractNacosTaskExecuteEngine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.alibaba.nacos.common.task.engine;\n+\n+import com.alibaba.nacos.api.exception.NacosException;\n+import com.alibaba.nacos.common.executor.ExecutorFactory;\n+import com.alibaba.nacos.common.executor.NameThreadFactory;\n+import com.alibaba.nacos.common.task.NacosTask;\n+import com.alibaba.nacos.common.task.NacosTaskProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Abstract nacos task execute engine.\n+ *\n+ * @author xiweng.yy\n+ */\n+public abstract class AbstractNacosTaskExecuteEngine<T extends NacosTask> implements NacosTaskExecuteEngine<T> {\n+    \n+    private final Logger log;\n+    \n+    private final ScheduledExecutorService processingExecutor;\n+    \n+    private final ConcurrentHashMap<Object, NacosTaskProcessor> taskProcessors = new ConcurrentHashMap<Object, NacosTaskProcessor>();\n+    \n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    \n+    protected final ConcurrentHashMap<Object, T> tasks;\n+    \n+    protected final ReentrantLock lock = new ReentrantLock();\n+    \n+    private NacosTaskProcessor defaultTaskProcessor;\n+    \n+    public AbstractNacosTaskExecuteEngine(String name) {\n+        this(name, 32, null, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger) {\n+        this(name, 32, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger, long processInterval) {\n+        this(name, 32, logger, processInterval);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger) {\n+        this(name, initCapacity, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger, long processInterval) {\n+        this.log = null != logger ? logger : LoggerFactory.getLogger(AbstractNacosTaskExecuteEngine.class.getName());\n+        tasks = new ConcurrentHashMap<Object, T>(initCapacity);\n+        processingExecutor = ExecutorFactory.newSingleScheduledExecutorService(new NameThreadFactory(name));\n+        processingExecutor.scheduleWithFixedDelay(new ProcessRunnable(), processInterval, processInterval, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    @Override\n+    public int size() {\n+        lock.lock();\n+        try {\n+            return tasks.size();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public boolean isEmpty() {\n+        lock.lock();\n+        try {\n+            return tasks.isEmpty();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public void addProcessor(Object key, NacosTaskProcessor taskProcessor) {\n+        taskProcessors.putIfAbsent(key, taskProcessor);\n+    }\n+    \n+    @Override\n+    public void removeProcessor(Object key) {\n+        taskProcessors.remove(key);\n+    }\n+    \n+    @Override\n+    public NacosTaskProcessor getProcessor(Object key) {\n+        return taskProcessors.containsKey(key) ? taskProcessors.get(key) : defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public Collection<Object> getAllProcessorKey() {\n+        return taskProcessors.keySet();\n+    }\n+    \n+    @Override\n+    public void setDefaultTaskProcessor(NacosTaskProcessor defaultTaskProcessor) {\n+        this.defaultTaskProcessor = defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public T removeTask(Object key) {\n+        lock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MTQ0NQ=="}, "originalCommit": {"oid": "a458bfd83c4de6bb70f10a9ccb7a0b0078e96bd4"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA1MTA5MQ==", "bodyText": "\u55ef", "url": "https://github.com/alibaba/nacos/pull/3663#discussion_r475051091", "createdAt": "2020-08-22T05:53:11Z", "author": {"login": "horizonzy"}, "path": "common/src/main/java/com/alibaba/nacos/common/task/engine/AbstractNacosTaskExecuteEngine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.alibaba.nacos.common.task.engine;\n+\n+import com.alibaba.nacos.api.exception.NacosException;\n+import com.alibaba.nacos.common.executor.ExecutorFactory;\n+import com.alibaba.nacos.common.executor.NameThreadFactory;\n+import com.alibaba.nacos.common.task.NacosTask;\n+import com.alibaba.nacos.common.task.NacosTaskProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Abstract nacos task execute engine.\n+ *\n+ * @author xiweng.yy\n+ */\n+public abstract class AbstractNacosTaskExecuteEngine<T extends NacosTask> implements NacosTaskExecuteEngine<T> {\n+    \n+    private final Logger log;\n+    \n+    private final ScheduledExecutorService processingExecutor;\n+    \n+    private final ConcurrentHashMap<Object, NacosTaskProcessor> taskProcessors = new ConcurrentHashMap<Object, NacosTaskProcessor>();\n+    \n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    \n+    protected final ConcurrentHashMap<Object, T> tasks;\n+    \n+    protected final ReentrantLock lock = new ReentrantLock();\n+    \n+    private NacosTaskProcessor defaultTaskProcessor;\n+    \n+    public AbstractNacosTaskExecuteEngine(String name) {\n+        this(name, 32, null, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger) {\n+        this(name, 32, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, Logger logger, long processInterval) {\n+        this(name, 32, logger, processInterval);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger) {\n+        this(name, initCapacity, logger, 100L);\n+    }\n+    \n+    public AbstractNacosTaskExecuteEngine(String name, int initCapacity, Logger logger, long processInterval) {\n+        this.log = null != logger ? logger : LoggerFactory.getLogger(AbstractNacosTaskExecuteEngine.class.getName());\n+        tasks = new ConcurrentHashMap<Object, T>(initCapacity);\n+        processingExecutor = ExecutorFactory.newSingleScheduledExecutorService(new NameThreadFactory(name));\n+        processingExecutor.scheduleWithFixedDelay(new ProcessRunnable(), processInterval, processInterval, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    @Override\n+    public int size() {\n+        lock.lock();\n+        try {\n+            return tasks.size();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public boolean isEmpty() {\n+        lock.lock();\n+        try {\n+            return tasks.isEmpty();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    @Override\n+    public void addProcessor(Object key, NacosTaskProcessor taskProcessor) {\n+        taskProcessors.putIfAbsent(key, taskProcessor);\n+    }\n+    \n+    @Override\n+    public void removeProcessor(Object key) {\n+        taskProcessors.remove(key);\n+    }\n+    \n+    @Override\n+    public NacosTaskProcessor getProcessor(Object key) {\n+        return taskProcessors.containsKey(key) ? taskProcessors.get(key) : defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public Collection<Object> getAllProcessorKey() {\n+        return taskProcessors.keySet();\n+    }\n+    \n+    @Override\n+    public void setDefaultTaskProcessor(NacosTaskProcessor defaultTaskProcessor) {\n+        this.defaultTaskProcessor = defaultTaskProcessor;\n+    }\n+    \n+    @Override\n+    public T removeTask(Object key) {\n+        lock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MTQ0NQ=="}, "originalCommit": {"oid": "a458bfd83c4de6bb70f10a9ccb7a0b0078e96bd4"}, "originalPosition": 126}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4340, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}