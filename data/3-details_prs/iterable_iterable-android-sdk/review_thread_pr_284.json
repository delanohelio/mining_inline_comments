{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5NTYwMDM4", "number": 284, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxODowOToyMFrOE5nQnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDo1MTo1OVrOE9BJGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4ODQ3NTE2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableDataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxODowOToyMFrOH0LOuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxODowOToyMFrOH0LOuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MTk5Mw==", "bodyText": "I think this class has various levels of abstraction. It manages/create a database (low level), but also manages tasks. Tasks seem to be a higher level abstraction that may be better placed in its own class, especially if we're planning to use the database for other things in the future.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r524471993", "createdAt": "2020-11-16T18:09:20Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableDataManager.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+public class IterableDataManager {\n+\n+    private static IterableDataManager sharedInstance;\n+\n+    private static final String TAG = \"IterableDataManager\";\n+    private static final String DATABASE_NAME = \"iterable_sdk.db\";\n+    private static final int DATABASE_VERSION = 1;\n+    private static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+\n+    private static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableDataManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableDataManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableDataManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    void createTask(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784ce12393d904547be5c4216a52a5eeefa11d76"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk2MDY2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1MzowMFrOH3lJLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1MzowMFrOH3lJLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjI4NA==", "bodyText": "Remove", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042284", "createdAt": "2020-11-21T00:53:00Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -35,6 +38,7 @@\n      * {@link IterableApi} singleton instance\n      */\n     static volatile IterableApi sharedInstance = new IterableApi();\n+    private static IterableTaskManager dataManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk2MDgxOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1MzowNlrOH3lJQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1MzowNlrOH3lJQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjMwNg==", "bodyText": "Remove", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042306", "createdAt": "2020-11-21T00:53:06Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -307,6 +311,24 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n         IterablePushActionReceiver.processPendingAction(context);\n+\n+        //TODO: Temporary code to test. Datamanger would eventually either go to IterableRequest or apiInternal as architecture concretes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk2MjUxOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1NDoyNVrOH3lKMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNjozMTozNFrOH4Akjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjU0Ng==", "bodyText": "How/when is this going to be used?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042546", "createdAt": "2020-11-21T00:54:25Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.iterable.iterableapi;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+class IterableTask {\n+\n+    //String columns as stored in DB\n+    static final String TASK_ID = \"task_id\";\n+    static final String NAME = \"name\";\n+    static final String VERSION = \"version\";\n+    static final String CREATED_AT = \"created\";\n+    static final String MODIFIED_AT = \"modified\";\n+    static final String LAST_ATTEMPTED_AT = \"last_attempt\";\n+    static final String SCHEDULED_AT = \"scheduled\";\n+    static final String REQUESTED_AT = \"requested\";\n+    static final String PROCESSING = \"processing\";\n+    static final String FAILED = \"failed\";\n+    static final String BLOCKING = \"blocking\";\n+    static final String DATA = \"data\";\n+    static final String ERROR = \"error\";\n+    static final String TYPE = \"type\";\n+    static final String ATTEMPTS = \"attempts\";\n+\n+    int currentVersion = 1;\n+\n+    String id; //uuid generated for each task when getting created\n+    String name;//name of the api\n+    int version;//version for the task? Not sure. replicating as on iOS\n+    Date createdAt;\n+    Date modifiedAt;\n+    Date lastAttemptedAt;\n+    Date scheduledAt;\n+    Date requestedAt;\n+\n+    Boolean processing;\n+    Boolean failed;\n+    Boolean blocking;\n+\n+    //TODO: Confirm if data and failure data would be String converted from JSONObjects.\n+    Object data;\n+    Object taskFailureData;\n+    IterableTaskType taskType;\n+    int attempts;\n+\n+    //To be used when creating IterableTask from database\n+    public IterableTask(String id, @NonNull String name, @NonNull int version, @NonNull Date createdAt, Date modifiedAt, Date lastAttemptedAt, Date scheduledAt, Date requestedAt, Boolean processing, Boolean failed, Boolean blocking, Object data, Object taskFailureData, IterableTaskType taskType, int attempts) {\n+\n+        this.id = id;\n+        this.name = name;\n+        this.version = version;\n+        this.createdAt = createdAt;\n+        this.modifiedAt = modifiedAt;\n+        this.lastAttemptedAt = lastAttemptedAt;\n+        this.scheduledAt = scheduledAt;\n+        this.requestedAt = requestedAt;\n+        this.processing = processing;\n+        this.failed = failed;\n+        this.blocking = blocking;\n+        this.data = data;\n+        this.taskFailureData = taskFailureData;\n+        this.taskType = taskType;\n+        this.attempts = attempts;\n+    }\n+\n+    //Bare minimum one to be used when creating the Task\n+    public IterableTask(String name, IterableTaskType taskType) {\n+\n+        this.id = UUID.randomUUID().toString();\n+        this.name = name;\n+        this.createdAt = new Date();\n+        this.scheduledAt = new Date();\n+        this.requestedAt = new Date();\n+        this.taskType = taskType;\n+\n+    }\n+\n+    IterableTask updateTask(int attempts, Date lastAttemptedAt, Boolean processing, Date scheduledAt, Object data, Object taskFailureData) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTY2Mw==", "bodyText": "Not gonna be used. Deleting.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491663", "createdAt": "2020-11-23T06:31:34Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.iterable.iterableapi;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+class IterableTask {\n+\n+    //String columns as stored in DB\n+    static final String TASK_ID = \"task_id\";\n+    static final String NAME = \"name\";\n+    static final String VERSION = \"version\";\n+    static final String CREATED_AT = \"created\";\n+    static final String MODIFIED_AT = \"modified\";\n+    static final String LAST_ATTEMPTED_AT = \"last_attempt\";\n+    static final String SCHEDULED_AT = \"scheduled\";\n+    static final String REQUESTED_AT = \"requested\";\n+    static final String PROCESSING = \"processing\";\n+    static final String FAILED = \"failed\";\n+    static final String BLOCKING = \"blocking\";\n+    static final String DATA = \"data\";\n+    static final String ERROR = \"error\";\n+    static final String TYPE = \"type\";\n+    static final String ATTEMPTS = \"attempts\";\n+\n+    int currentVersion = 1;\n+\n+    String id; //uuid generated for each task when getting created\n+    String name;//name of the api\n+    int version;//version for the task? Not sure. replicating as on iOS\n+    Date createdAt;\n+    Date modifiedAt;\n+    Date lastAttemptedAt;\n+    Date scheduledAt;\n+    Date requestedAt;\n+\n+    Boolean processing;\n+    Boolean failed;\n+    Boolean blocking;\n+\n+    //TODO: Confirm if data and failure data would be String converted from JSONObjects.\n+    Object data;\n+    Object taskFailureData;\n+    IterableTaskType taskType;\n+    int attempts;\n+\n+    //To be used when creating IterableTask from database\n+    public IterableTask(String id, @NonNull String name, @NonNull int version, @NonNull Date createdAt, Date modifiedAt, Date lastAttemptedAt, Date scheduledAt, Date requestedAt, Boolean processing, Boolean failed, Boolean blocking, Object data, Object taskFailureData, IterableTaskType taskType, int attempts) {\n+\n+        this.id = id;\n+        this.name = name;\n+        this.version = version;\n+        this.createdAt = createdAt;\n+        this.modifiedAt = modifiedAt;\n+        this.lastAttemptedAt = lastAttemptedAt;\n+        this.scheduledAt = scheduledAt;\n+        this.requestedAt = requestedAt;\n+        this.processing = processing;\n+        this.failed = failed;\n+        this.blocking = blocking;\n+        this.data = data;\n+        this.taskFailureData = taskFailureData;\n+        this.taskType = taskType;\n+        this.attempts = attempts;\n+    }\n+\n+    //Bare minimum one to be used when creating the Task\n+    public IterableTask(String name, IterableTaskType taskType) {\n+\n+        this.id = UUID.randomUUID().toString();\n+        this.name = name;\n+        this.createdAt = new Date();\n+        this.scheduledAt = new Date();\n+        this.requestedAt = new Date();\n+        this.taskType = taskType;\n+\n+    }\n+\n+    IterableTask updateTask(int attempts, Date lastAttemptedAt, Boolean processing, Date scheduledAt, Object data, Object taskFailureData) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjU0Ng=="}, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk2NDAzOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1NToxMFrOH3lK4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNjozMDoyMlrOH4AjXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjcyMQ==", "bodyText": "Is this designed just for the tasks? If we need to store something else, are we going to create a separate db or reuse this one?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042721", "createdAt": "2020-11-21T00:55:10Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.Context;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+class IterableTaskDatabaseManager extends SQLiteOpenHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTM1Nw==", "bodyText": "Made it generic.. Creation of all the tables can go here in its onCreate", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491357", "createdAt": "2020-11-23T06:30:22Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.Context;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+class IterableTaskDatabaseManager extends SQLiteOpenHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjcyMQ=="}, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk2NDU1OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1NTozNVrOH3lLLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNjozMToxNVrOH4AkQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Mjc5Ng==", "bodyText": "Depending on the answer to above, we probably need to scope the name to tasks only, or rename the class itself.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042796", "createdAt": "2020-11-21T00:55:35Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.Context;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+class IterableTaskDatabaseManager extends SQLiteOpenHelper {\n+    private static final String DATABASE_NAME = \"iterable_sdk.db\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTU4NA==", "bodyText": "Not changing the Iterable_sdk. Will keep it like this assuming we will need only one db and tables could be added in this class as feature set requiring table grows", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491584", "createdAt": "2020-11-23T06:31:15Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.Context;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+class IterableTaskDatabaseManager extends SQLiteOpenHelper {\n+    private static final String DATABASE_NAME = \"iterable_sdk.db\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Mjc5Ng=="}, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk2ODAwOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1ODoyM1rOH3lNFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNjoyOTowNVrOH4Ah-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzI4Nw==", "bodyText": "Why is it using a class field vs. local variable for contentValues?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528043287", "createdAt": "2020-11-21T00:58:23Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,335 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\"+REPLACING_STRING+\"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableTaskDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableTaskDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    String createTask(String name) {\n+\n+        if(database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if(iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if(iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if(iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if(iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if(iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if(iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if(iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if(iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if(iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME,null,contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        Object data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getBlob(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getBlob(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error,IterableTaskType.API,attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    ArrayList<String> getAllTaskIds() {\n+        if(!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if(cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            }while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+\n+        return taskIds;\n+    }\n+    /**\n+     * Gets number of rows in the event table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+            hasDatabaseError = false;\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    Boolean deleteAllTasks () {\n+        if (!precheck()) return false;\n+\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return true;\n+    }\n+\n+    Boolean deleteTask(String id) {\n+        if (! precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTAwMA==", "bodyText": "had it referenced from a website previously.. having it local is safe and prevent possible data leak. Thanks. Made them local", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491000", "createdAt": "2020-11-23T06:29:05Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,335 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\"+REPLACING_STRING+\"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableTaskDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableTaskDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    String createTask(String name) {\n+\n+        if(database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if(iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if(iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if(iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if(iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if(iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if(iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if(iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if(iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if(iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME,null,contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        Object data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getBlob(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getBlob(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error,IterableTaskType.API,attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    ArrayList<String> getAllTaskIds() {\n+        if(!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if(cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            }while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+\n+        return taskIds;\n+    }\n+    /**\n+     * Gets number of rows in the event table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+            hasDatabaseError = false;\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    Boolean deleteAllTasks () {\n+        if (!precheck()) return false;\n+\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return true;\n+    }\n+\n+    Boolean deleteTask(String id) {\n+        if (! precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzI4Nw=="}, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk2ODc3OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1OTowNVrOH3lNiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNjoyNzo0NVrOH4Ag3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzQwMQ==", "bodyText": "Do we need to check for task count before running queries? I think in that case it'll just return nothing, which should be a valid return value.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528043401", "createdAt": "2020-11-21T00:59:05Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,335 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\"+REPLACING_STRING+\"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableTaskDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableTaskDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    String createTask(String name) {\n+\n+        if(database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if(iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if(iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if(iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if(iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if(iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if(iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if(iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if(iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if(iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME,null,contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        Object data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getBlob(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getBlob(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error,IterableTaskType.API,attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    ArrayList<String> getAllTaskIds() {\n+        if(!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if(cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            }while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+\n+        return taskIds;\n+    }\n+    /**\n+     * Gets number of rows in the event table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+            hasDatabaseError = false;\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    Boolean deleteAllTasks () {\n+        if (!precheck()) return false;\n+\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return true;\n+    }\n+\n+    Boolean deleteTask(String id) {\n+        if (! precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.FAILED, state);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    private Boolean updateTaskWithContentValues(String id) {\n+        int result = database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id});\n+        contentValues.clear();\n+        if (result > 0) return true;\n+        else return false;\n+    }\n+\n+    private boolean precheck() {\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return false;\n+        }\n+        if (getTaskCount() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MDcxNw==", "bodyText": "Removing.. unnecessary overhead", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528490717", "createdAt": "2020-11-23T06:27:45Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,335 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\"+REPLACING_STRING+\"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableTaskDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableTaskDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    String createTask(String name) {\n+\n+        if(database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if(iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if(iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if(iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if(iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if(iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if(iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if(iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if(iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if(iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME,null,contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        Object data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getBlob(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getBlob(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error,IterableTaskType.API,attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    ArrayList<String> getAllTaskIds() {\n+        if(!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if(cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            }while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+\n+        return taskIds;\n+    }\n+    /**\n+     * Gets number of rows in the event table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+            hasDatabaseError = false;\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    Boolean deleteAllTasks () {\n+        if (!precheck()) return false;\n+\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return true;\n+    }\n+\n+    Boolean deleteTask(String id) {\n+        if (! precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.FAILED, state);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    private Boolean updateTaskWithContentValues(String id) {\n+        int result = database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id});\n+        contentValues.clear();\n+        if (result > 0) return true;\n+        else return false;\n+    }\n+\n+    private boolean precheck() {\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return false;\n+        }\n+        if (getTaskCount() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzQwMQ=="}, "originalCommit": {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODY1Mzk2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjozMTowOFrOH4pMDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjozMTowOFrOH4pMDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE1NzEzNQ==", "bodyText": "What are the required fields for createTask? Are type and data required? If so, they should be arguments for this function.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529157135", "createdAt": "2020-11-24T02:31:08Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODY1NzcxOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjozMTo1NFrOH4pO3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjozMTo1NFrOH4pO3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE1Nzg1NQ==", "bodyText": "Add nullability annotations to methods in this class", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529157855", "createdAt": "2020-11-24T02:31:54Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODcwOTE1OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1MTowNFrOH4pxWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMDo0NToxOFrOH5Ufuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NjY4Mw==", "bodyText": "Is there a datetime type we can use?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529166683", "createdAt": "2020-11-24T02:51:04Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2NjY4Mw==", "bodyText": "No it seems.\nhttps://sqlite.org/datatype3.html#date_and_time_datatype", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529866683", "createdAt": "2020-11-24T20:45:18Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NjY4Mw=="}, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODcxMzEwOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1MzowOFrOH4pz3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1MzowOFrOH4pz3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzMyNA==", "bodyText": "Return an empty array if the check failed", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167324", "createdAt": "2020-11-24T02:53:08Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODcxNDI2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1Mzo0OFrOH4p0pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMDo0NToyOFrOH5UgEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzUyNA==", "bodyText": "What do we need this for?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167524", "createdAt": "2020-11-24T02:53:48Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2Njc3MA==", "bodyText": "Just a left over method I thought could be useful. Will remove", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529866770", "createdAt": "2020-11-24T20:45:28Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzUyNA=="}, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODcxNjEzOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1NDozNVrOH4p1wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1NDozNVrOH4p1wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzgxMA==", "bodyText": "incrementAttempts?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167810", "createdAt": "2020-11-24T02:54:35Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODcxNzAxOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1NTowMVrOH4p2WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1NTowMVrOH4p2WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2Nzk2MQ==", "bodyText": "Can we extract this line into a separate method? Looks like we're doing the same thing for every update method.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167961", "createdAt": "2020-11-24T02:55:01Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 370}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODcxOTgyOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo1NjoxNlrOH4p4Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzoxODozNlrOH5cOfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA==", "bodyText": "I think this should have a clearer name: isDatabaseReady/isDatabaseAvailable or something like that.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529168398", "createdAt": "2020-11-24T02:56:16Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates task with error data OfflineTask table\n+     *\n+     * @param id        Unique id for the task\n+     * @param errorData error received after processing the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateError(String id, String errorData) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ERROR, errorData);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates data for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param data required for the task. JSONObject converted to string\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateData(String id, String data) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.DATA, data);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    private boolean precheck() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2NzM0NA==", "bodyText": "isOpen and inTransaction() can be a good check to have \ud83d\udc4d", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529867344", "createdAt": "2020-11-24T20:46:37Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates task with error data OfflineTask table\n+     *\n+     * @param id        Unique id for the task\n+     * @param errorData error received after processing the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateError(String id, String errorData) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ERROR, errorData);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates data for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param data required for the task. JSONObject converted to string\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateData(String id, String data) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.DATA, data);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    private boolean precheck() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MTc1NQ==", "bodyText": "Looks like it still has the same name. inTransaction I think is not a good name as it would imply it's in an SQL transaction, and this code doesn't use transactions.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529971755", "createdAt": "2020-11-24T22:56:39Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates task with error data OfflineTask table\n+     *\n+     * @param id        Unique id for the task\n+     * @param errorData error received after processing the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateError(String id, String errorData) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ERROR, errorData);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates data for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param data required for the task. JSONObject converted to string\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateData(String id, String data) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.DATA, data);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    private boolean precheck() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3NDY1Nw==", "bodyText": "Basically I don't know what precheck does without looking at its code. Ideally the name should tell what it checks for (in high level terms).", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529974657", "createdAt": "2020-11-24T22:59:31Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates task with error data OfflineTask table\n+     *\n+     * @param id        Unique id for the task\n+     * @param errorData error received after processing the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateError(String id, String errorData) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ERROR, errorData);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates data for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param data required for the task. JSONObject converted to string\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateData(String id, String data) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.DATA, data);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    private boolean precheck() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MzM0MA==", "bodyText": "oh I misread the comment made. I thought you were suggesting of having additional checks inside the method precheck \ud83e\udd26\u200d\u2642\ufe0f .. my bad", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529993340", "createdAt": "2020-11-24T23:18:36Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates task with error data OfflineTask table\n+     *\n+     * @param id        Unique id for the task\n+     * @param errorData error received after processing the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateError(String id, String errorData) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ERROR, errorData);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates data for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param data required for the task. JSONObject converted to string\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateData(String id, String data) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.DATA, data);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    private boolean precheck() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 401}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTIzNjMxOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNzoxNTowMVrOH4uvRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNzoxNTowMVrOH4uvRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI0ODA3MQ==", "bodyText": "Ideally this should not have an implicit dependency on IterableApi.. One alternative is to just pass Context around in the constructor and in sharedInstance.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529248071", "createdAt": "2020-11-24T07:15:01Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzczNTgwOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo1NDowMlrOH5avjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo1NDowMlrOH5avjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTAzNw==", "bodyText": "@NonNull", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529969037", "createdAt": "2020-11-24T22:54:02Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42f6e0900fd0061b134ca93817fb444cfce78e07"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzczNzM2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo1NDoxN1rOH5awjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzozMDoxNlrOH5c6gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTI5NQ==", "bodyText": "Why Boolean and not boolean?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529969295", "createdAt": "2020-11-24T22:54:17Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (!precheck()) return taskIds;\n+\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42f6e0900fd0061b134ca93817fb444cfce78e07"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwNDYwOQ==", "bodyText": "No particular reason to choose Boolean. Changing it to primitive to keep it simple and consistent.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530004609", "createdAt": "2020-11-24T23:30:16Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (!precheck()) return taskIds;\n+\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTI5NQ=="}, "originalCommit": {"oid": "42f6e0900fd0061b134ca93817fb444cfce78e07"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzc1NzU2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo1NzozMlrOH5a9vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo1NzozMlrOH5a9vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MjY3MQ==", "bodyText": "Why is it calling a method (precheck) elsewhere and using a direct check here?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529972671", "createdAt": "2020-11-24T22:57:32Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42f6e0900fd0061b134ca93817fb444cfce78e07"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDE3MTY4OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDo1MToxOFrOH5e9Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDo1MToxOFrOH5e9Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzODA3OQ==", "bodyText": "type is not used anywhere. Is it needed?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530038079", "createdAt": "2020-11-25T00:51:18Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,394 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+        if (!isDatabaseReady()) return null;\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        if (!isDatabaseReady()) return null;\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "473738ab19ad6f21d07ea3b4f7f2e5642f435b7e"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDE3MzA2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDo1MTo1OVrOH5e-Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDo1MTo1OVrOH5e-Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzODI4Mw==", "bodyText": "Catch Exception instead of Throwable\nSee CodeClimate: https://codeclimate.com/github/Iterable/iterable-android-sdk/pull/284#", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530038283", "createdAt": "2020-11-25T00:51:59Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,394 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "473738ab19ad6f21d07ea3b4f7f2e5642f435b7e"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2208, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}