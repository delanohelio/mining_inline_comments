{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM4NDk3NTkz", "number": 296, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxODozMToyNFrOFEssjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNzowMzoyN1rOFFs-cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNDcwOTI2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxODozMToyNFrOIE3wig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwMzoxNzoyMVrOIE-Mbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3ODc2Mg==", "bodyText": "Yeah.. this is the delete I was initially talking about.\nShould the delete operation happen here? Or should we move it to taskCompletion handler?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r541978762", "createdAt": "2020-12-13T18:31:24Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {\n+        handler.removeCallbacksAndMessages(this);\n+        handler.sendEmptyMessage(OPERATION_PROCESS_TASKS);\n+    }\n+\n+    @WorkerThread\n+    @Override\n+    public boolean handleMessage(@NonNull Message msg) {\n+        if (msg.what == OPERATION_PROCESS_TASKS) {\n+            processTasks();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @WorkerThread\n+    private void processTasks() {\n+        while (true) {\n+            boolean proceed = processNextTask();\n+            if (!proceed) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @WorkerThread\n+    private boolean processNextTask() {\n+        IterableTask task = taskStorage.nextTask();\n+\n+        if (task == null) {\n+            return false;\n+        }\n+\n+        if (task.taskType == IterableTaskType.API) {\n+            try {\n+                IterableApiRequest request = IterableApiRequest.fromJSON(new JSONObject(task.data), null, null);\n+                IterableApiResponse response = IterableRequestTask.executeApiRequest(request);\n+            } catch (Exception e) {\n+                IterableLogger.e(TAG, \"Error while processing request task\", e);\n+            }\n+            taskStorage.deleteTask(task.id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003bf4ebf3a62749d5efac801b31366c1edb2532"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4NDIwNw==", "bodyText": "Since the Runner is getting the next task immediately afterwards, if we move deletion farther away from it, it'd be heavily dependent on behavior of another class (if we remove or break deleteTask in another class, it'll make IterableTaskRunner get stuck in an infinite loop). I think it makes sense to have deletion here for now, unless we decide to add some more complicated conditional logic.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r542084207", "createdAt": "2020-12-14T03:17:21Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {\n+        handler.removeCallbacksAndMessages(this);\n+        handler.sendEmptyMessage(OPERATION_PROCESS_TASKS);\n+    }\n+\n+    @WorkerThread\n+    @Override\n+    public boolean handleMessage(@NonNull Message msg) {\n+        if (msg.what == OPERATION_PROCESS_TASKS) {\n+            processTasks();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @WorkerThread\n+    private void processTasks() {\n+        while (true) {\n+            boolean proceed = processNextTask();\n+            if (!proceed) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @WorkerThread\n+    private boolean processNextTask() {\n+        IterableTask task = taskStorage.nextTask();\n+\n+        if (task == null) {\n+            return false;\n+        }\n+\n+        if (task.taskType == IterableTaskType.API) {\n+            try {\n+                IterableApiRequest request = IterableApiRequest.fromJSON(new JSONObject(task.data), null, null);\n+                IterableApiResponse response = IterableRequestTask.executeApiRequest(request);\n+            } catch (Exception e) {\n+                IterableLogger.e(TAG, \"Error while processing request task\", e);\n+            }\n+            taskStorage.deleteTask(task.id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3ODc2Mg=="}, "originalCommit": {"oid": "003bf4ebf3a62749d5efac801b31366c1edb2532"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNDcxMTkwOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/OfflineRequestProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxODozMjo0OFrOIE3xpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxODozMjo0OFrOIE3xpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3OTA0Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r541979046", "createdAt": "2020-12-13T18:32:48Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/OfflineRequestProcessor.java", "diffHunk": "@@ -1,38 +1,50 @@\n package com.iterable.iterableapi;\n \n+import android.content.Context;\n+\n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n \n import org.json.JSONException;\n import org.json.JSONObject;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n \n class OfflineRequestProcessor implements RequestProcessor {\n+    private TaskScheduler taskScheduler;\n+    private IterableTaskRunner taskRunner;\n \n+    OfflineRequestProcessor(Context context) {\n+        IterableTaskStorage taskStorage = IterableTaskStorage.sharedInstance(context);\n+        taskScheduler = new TaskScheduler(taskStorage);\n+        taskRunner = new IterableTaskRunner(taskStorage, IterableActivityMonitor.getInstance());\n+    }\n \n     @Override\n     public void processGetRequest(@Nullable String apiKey, @NonNull String resourcePath, @NonNull JSONObject json, String authToken, @Nullable IterableHelper.IterableActionHandler onCallback) {\n-        //Invoke taskScheduler and add task to database\n+        // Call GET requests directly, without using the queue\n+        IterableApiRequest request = new IterableApiRequest(apiKey, resourcePath, json, IterableApiRequest.GET, authToken, onCallback);\n+        new IterableRequestTask().execute(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003bf4ebf3a62749d5efac801b31366c1edb2532"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTEzMDc4OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjo0Mzo0NlrOIGVA0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTo1NTo1OFrOIGdbbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwNjY0MA==", "bodyText": "May be we can also think of some name for this method too...\nnotifyTaskListener/ notifyHandler/ handleCallBackAndMessage", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r543506640", "createdAt": "2020-12-15T16:43:46Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9a8208cb556781ad784bab12a3c4d12a0b53b87"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0NDUyNA==", "bodyText": "This is not what it's doing though", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r543644524", "createdAt": "2020-12-15T19:55:58Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwNjY0MA=="}, "originalCommit": {"oid": "f9a8208cb556781ad784bab12a3c4d12a0b53b87"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTI0MDgzOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNzowMzoyN1rOIGWBIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTo1Njo1MVrOIGddog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUyMzEwNA==", "bodyText": "Thinking of a condition here... If in some case, our getNextScheduledTask fails to create a Task (because of improper data) and returns null, other entries in DB wont get a chance to run at all and we might not delete the one causing problem.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r543523104", "createdAt": "2020-12-15T17:03:27Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {\n+        handler.removeCallbacksAndMessages(this);\n+        handler.sendEmptyMessage(OPERATION_PROCESS_TASKS);\n+    }\n+\n+    @WorkerThread\n+    @Override\n+    public boolean handleMessage(@NonNull Message msg) {\n+        if (msg.what == OPERATION_PROCESS_TASKS) {\n+            processTasks();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @WorkerThread\n+    private void processTasks() {\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9a8208cb556781ad784bab12a3c4d12a0b53b87"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0NTA5MA==", "bodyText": "Good idea. I think I'll handle this in a follow-up PR, since we'll have to deal with this when implementing network error handling anyway.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r543645090", "createdAt": "2020-12-15T19:56:51Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {\n+        handler.removeCallbacksAndMessages(this);\n+        handler.sendEmptyMessage(OPERATION_PROCESS_TASKS);\n+    }\n+\n+    @WorkerThread\n+    @Override\n+    public boolean handleMessage(@NonNull Message msg) {\n+        if (msg.what == OPERATION_PROCESS_TASKS) {\n+            processTasks();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @WorkerThread\n+    private void processTasks() {\n+        while (true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUyMzEwNA=="}, "originalCommit": {"oid": "f9a8208cb556781ad784bab12a3c4d12a0b53b87"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2225, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}