{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NTE5ODQ3", "number": 265, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTozMDo1OVrOEmwHeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDozMDoxMVrOEr12Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDY5NjkwOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTozMDo1OVrOHW93gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTozMDo1OVrOHW93gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NDM1Mw==", "bodyText": "setAuthToken? I think on* doesn't apply here because it's not an even we do side effects on, but a direct call to set the token.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r493844353", "createdAt": "2020-09-23T19:30:59Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -205,6 +219,12 @@ void setNotificationData(IterableNotificationData data) {\n         }\n     }\n \n+    void onSetAuthToken(String authToken) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDY5ODE3OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTozMToyNFrOHW94TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNDo1MDozNlrOHYG8Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NDU1Nw==", "bodyText": "Do we need to do this if the token is the same as the one we already had?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r493844557", "createdAt": "2020-09-23T19:31:24Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -205,6 +219,12 @@ void setNotificationData(IterableNotificationData data) {\n         }\n     }\n \n+    void onSetAuthToken(String authToken) {\n+        _authToken = authToken;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0MTU1NQ==", "bodyText": "We should be able to do a check for authToken and not set it or call storeAuthData. However we will still need to call onLogIn.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r495041555", "createdAt": "2020-09-25T14:50:36Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -205,6 +219,12 @@ void setNotificationData(IterableNotificationData data) {\n         }\n     }\n \n+    void onSetAuthToken(String authToken) {\n+        _authToken = authToken;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NDU1Nw=="}, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDcwMTk1OnYy", "diffSide": "LEFT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTozMjozM1rOHW96nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoxNzowMFrOHYvvnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NTE0OA==", "bodyText": "Why did you remove this?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r493845148", "createdAt": "2020-09-23T19:32:33Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -276,54 +296,21 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzNTIwMw==", "bodyText": "I removed it so that we would require a single place to fetch the auth token for maintainability. However thinking about it more, having this in there should be fine since it achieves the same behavior and we call will call the same setAuthToken function which should handle all of the expirations.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r495035203", "createdAt": "2020-09-25T14:40:41Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -276,54 +296,21 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NTE0OA=="}, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEyNzg5Mw==", "bodyText": "What do you think would be the benefit of having this call signature? When a new token requested from our SDK via onAuthTokenRequested, they would need to implement that handler as well.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r495127893", "createdAt": "2020-09-25T17:20:19Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -276,54 +296,21 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NTE0OA=="}, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcwODk5Mg==", "bodyText": "Oh, I meant the checks that'd skip if the email is the same as it is, etc. Without those, it triggers token refresh and login code every time setEmail is called, even if the email didn't change.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r495708992", "createdAt": "2020-09-28T06:13:32Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -276,54 +296,21 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NTE0OA=="}, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxMDExMQ==", "bodyText": "The current version calls onLogOut even if the email/userId hasn't changed, triggering disableDevice call.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r495710111", "createdAt": "2020-09-28T06:17:00Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -276,54 +296,21 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NTE0OA=="}, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDc2MjQ2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTo0OTo1MlrOHW-frw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNDo1MjoxNFrOHYHABw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NDYzOQ==", "bodyText": "Hmm, if we always do the same thing in SuccessAuthHandler, maybe we don't need it, the auth manager could call the method on IterableApi directly to pass the token.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r493854639", "createdAt": "2020-09-23T19:49:52Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -332,34 +319,23 @@ public void setUserId(@Nullable String userId) {\n      *\n      * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n      * @param userId User ID\n-     * @param authToken Authorization token\n      */\n-    void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            if (_authToken == null && authToken == null) {\n-                return;\n-            }\n-\n-            if (_authToken != null && _authToken.equals(authToken)) {\n-                return;\n-            }\n-\n-            _authToken = authToken;\n-            storeAuthData();\n-\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n+    public void setUserId(@Nullable String userId) {\n         onLogOut();\n         _email = null;\n         _userId = userId;\n-        _authToken = authToken;\n         storeAuthData();\n-        onLogIn();\n+\n+        if (userId != null) {\n+            getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n+                @Override\n+                public void onSuccess(@NonNull String authToken) {\n+                    onSetAuthToken(authToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0MjU2Nw==", "bodyText": "Makes sense, this is unnecessary now since the implementation of requestNewAuthToken is now asynchronous.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r495042567", "createdAt": "2020-09-25T14:52:14Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -332,34 +319,23 @@ public void setUserId(@Nullable String userId) {\n      *\n      * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n      * @param userId User ID\n-     * @param authToken Authorization token\n      */\n-    void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            if (_authToken == null && authToken == null) {\n-                return;\n-            }\n-\n-            if (_authToken != null && _authToken.equals(authToken)) {\n-                return;\n-            }\n-\n-            _authToken = authToken;\n-            storeAuthData();\n-\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n+    public void setUserId(@Nullable String userId) {\n         onLogOut();\n         _email = null;\n         _userId = userId;\n-        _authToken = authToken;\n         storeAuthData();\n-        onLogIn();\n+\n+        if (userId != null) {\n+            getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n+                @Override\n+                public void onSuccess(@NonNull String authToken) {\n+                    onSetAuthToken(authToken);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NDYzOQ=="}, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDgwNzAzOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterablePushRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDowMzowMVrOHW-7jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDowMzowMVrOHW-7jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2MTc3NA==", "bodyText": "I think we should just store authToken with email and userId everywhere in this class, to keep it more consistent. Basically, if we're being passed email and userId, authToken should also be there, because it is tightly coupled with email and userId.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r493861774", "createdAt": "2020-09-23T20:03:01Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterablePushRegistration.java", "diffHunk": "@@ -41,9 +41,13 @@ protected Void doInBackground(IterablePushRegistrationData... params) {\n                     IterableApi.sharedInstance.disableToken(\n                             iterablePushRegistrationData.email,\n                             iterablePushRegistrationData.userId,\n-                            pushRegistrationObject.token);\n+                            pushRegistrationObject.token,\n+                            null,\n+                            null,\n+                            iterablePushRegistrationData.priorAuthToken", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDg0MjMxOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterablePushRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDoxMzoyOFrOHW_RWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNToyNToxM1rOHYIRjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2NzM1NQ==", "bodyText": "We're using iterablePushRegistrationData to get the email/userId. Passing priorAuthToken should not be necessary since it's also available in iterablePushRegistrationData.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r493867355", "createdAt": "2020-09-23T20:13:28Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterablePushRegistration.java", "diffHunk": "@@ -97,7 +101,7 @@ private void disableOldDeviceIfNeeded() {\n                             public void onSuccess(@NonNull JSONObject data) {\n                                 sharedPref.edit().putBoolean(IterableConstants.SHARED_PREFS_FCM_MIGRATION_DONE_KEY, true).apply();\n                             }\n-                        }, null);\n+                        }, null, priorAuthToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA2MzQzNg==", "bodyText": "Ah yes, I missed that, Good catch.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r495063436", "createdAt": "2020-09-25T15:25:13Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterablePushRegistration.java", "diffHunk": "@@ -97,7 +101,7 @@ private void disableOldDeviceIfNeeded() {\n                             public void onSuccess(@NonNull JSONObject data) {\n                                 sharedPref.edit().putBoolean(IterableConstants.SHARED_PREFS_FCM_MIGRATION_DONE_KEY, true).apply();\n                             }\n-                        }, null);\n+                        }, null, priorAuthToken);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2NzM1NQ=="}, "originalCommit": {"oid": "9c87f7dda9e6994e4a2ede6c1ae1f96ab03891f1"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzEzNTcxOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoyMzo1NFrOHYv4cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODoxNDoyOVrOHZKLEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxMjM3MQ==", "bodyText": "Note: this code will run in a background thread vs. other places where requestNewAuthToken is generally called from the main thread.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r495712371", "createdAt": "2020-09-28T06:23:54Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.iterable.iterableapi;\n+\n+import android.util.Base64;\n+\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.iterable.iterableapi.util.Future;\n+\n+import org.json.JSONObject;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+\n+public class IterableAuthManager {\n+    private static final String TAG = \"IterableAuth\";\n+    private static final String expirationString = \"exp\";\n+\n+    private final IterableApi api;\n+    private final IterableAuthHandler authHandler;\n+    private final long authRefreshPeriod;\n+\n+    @VisibleForTesting\n+    Timer timer;\n+    private boolean hasFailedPriorAuth;\n+\n+    IterableAuthManager(IterableApi api, IterableAuthHandler authHandler, long authRefreshPeriod) {\n+        timer = new Timer(true);\n+        this.api = api;\n+        this.authHandler = authHandler;\n+        this.authRefreshPeriod = authRefreshPeriod;\n+    }\n+\n+    public void requestNewAuthToken(boolean hasFailedPriorAuth) {\n+        if (!this.hasFailedPriorAuth || !hasFailedPriorAuth) {\n+            this.hasFailedPriorAuth = hasFailedPriorAuth;\n+            if (authHandler != null) {\n+                Future.runAsync(new Callable<String>() {\n+                    @Override\n+                    public String call() throws Exception {\n+                        return authHandler.onAuthTokenRequested();\n+                    }\n+                })\n+                .onSuccess(new Future.SuccessCallback<String>() {\n+                    @Override\n+                    public void onSuccess(String authToken) {\n+                        if (authToken != null) {\n+                            queueExpirationRefresh(authToken);\n+                        }\n+                        IterableApi.getInstance().setAuthToken(authToken);\n+                    }\n+                })\n+                .onFailure(new Future.FailureCallback() {\n+                    @Override\n+                    public void onFailure(Throwable throwable) {\n+                        IterableLogger.e(TAG, \"Error while requesting Auth Token\", throwable);\n+                    }\n+                });\n+            } else {\n+                IterableApi.getInstance().setAuthToken(null);\n+            }\n+        }\n+    }\n+\n+    public void queueExpirationRefresh(String encodedJWT) {\n+        long expirationTimeSeconds = decodedExpiration(encodedJWT);\n+        long triggerExpirationRefreshTime = expirationTimeSeconds * 1000L - authRefreshPeriod - IterableUtil.currentTimeMillis();\n+        if (triggerExpirationRefreshTime > 0) {\n+            scheduleAuthTokenRefresh(triggerExpirationRefreshTime);\n+        }\n+    }\n+\n+    void resetFailedAuth() {\n+        hasFailedPriorAuth = false;\n+    }\n+\n+    private void scheduleAuthTokenRefresh(long timeDuration) {\n+        timer.cancel();\n+        timer = new Timer(true);\n+        try {\n+            timer.schedule(new TimerTask() {\n+                @Override\n+                public void run() {\n+                    api.getAuthManager().requestNewAuthToken(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510883b7c8c86d72d8ffa9ff22ae88e3c834536a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MzEyMw==", "bodyText": "This should be fine since a majority the functionality in requestNewAuthToken runs in a background thread as well.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r496143123", "createdAt": "2020-09-28T18:14:29Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.iterable.iterableapi;\n+\n+import android.util.Base64;\n+\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.iterable.iterableapi.util.Future;\n+\n+import org.json.JSONObject;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+\n+public class IterableAuthManager {\n+    private static final String TAG = \"IterableAuth\";\n+    private static final String expirationString = \"exp\";\n+\n+    private final IterableApi api;\n+    private final IterableAuthHandler authHandler;\n+    private final long authRefreshPeriod;\n+\n+    @VisibleForTesting\n+    Timer timer;\n+    private boolean hasFailedPriorAuth;\n+\n+    IterableAuthManager(IterableApi api, IterableAuthHandler authHandler, long authRefreshPeriod) {\n+        timer = new Timer(true);\n+        this.api = api;\n+        this.authHandler = authHandler;\n+        this.authRefreshPeriod = authRefreshPeriod;\n+    }\n+\n+    public void requestNewAuthToken(boolean hasFailedPriorAuth) {\n+        if (!this.hasFailedPriorAuth || !hasFailedPriorAuth) {\n+            this.hasFailedPriorAuth = hasFailedPriorAuth;\n+            if (authHandler != null) {\n+                Future.runAsync(new Callable<String>() {\n+                    @Override\n+                    public String call() throws Exception {\n+                        return authHandler.onAuthTokenRequested();\n+                    }\n+                })\n+                .onSuccess(new Future.SuccessCallback<String>() {\n+                    @Override\n+                    public void onSuccess(String authToken) {\n+                        if (authToken != null) {\n+                            queueExpirationRefresh(authToken);\n+                        }\n+                        IterableApi.getInstance().setAuthToken(authToken);\n+                    }\n+                })\n+                .onFailure(new Future.FailureCallback() {\n+                    @Override\n+                    public void onFailure(Throwable throwable) {\n+                        IterableLogger.e(TAG, \"Error while requesting Auth Token\", throwable);\n+                    }\n+                });\n+            } else {\n+                IterableApi.getInstance().setAuthToken(null);\n+            }\n+        }\n+    }\n+\n+    public void queueExpirationRefresh(String encodedJWT) {\n+        long expirationTimeSeconds = decodedExpiration(encodedJWT);\n+        long triggerExpirationRefreshTime = expirationTimeSeconds * 1000L - authRefreshPeriod - IterableUtil.currentTimeMillis();\n+        if (triggerExpirationRefreshTime > 0) {\n+            scheduleAuthTokenRefresh(triggerExpirationRefreshTime);\n+        }\n+    }\n+\n+    void resetFailedAuth() {\n+        hasFailedPriorAuth = false;\n+    }\n+\n+    private void scheduleAuthTokenRefresh(long timeDuration) {\n+        timer.cancel();\n+        timer = new Timer(true);\n+        try {\n+            timer.schedule(new TimerTask() {\n+                @Override\n+                public void run() {\n+                    api.getAuthManager().requestNewAuthToken(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxMjM3MQ=="}, "originalCommit": {"oid": "510883b7c8c86d72d8ffa9ff22ae88e3c834536a"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTczNTg1OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoyMDozOFrOHZIUmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTozNjowNlrOHZMz9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMjc5NQ==", "bodyText": "@davidtruong It seems like it will request a new token multiple times in parallel if multiple network calls fail in sequence. I think it should only request once and wait until it completes before spawning new requests.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r496112795", "createdAt": "2020-09-28T17:20:38Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.iterable.iterableapi;\n+\n+import android.util.Base64;\n+\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.iterable.iterableapi.util.Future;\n+\n+import org.json.JSONObject;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+\n+public class IterableAuthManager {\n+    private static final String TAG = \"IterableAuth\";\n+    private static final String expirationString = \"exp\";\n+\n+    private final IterableApi api;\n+    private final IterableAuthHandler authHandler;\n+    private final long authRefreshPeriod;\n+\n+    @VisibleForTesting\n+    Timer timer;\n+    private boolean hasFailedPriorAuth;\n+\n+    IterableAuthManager(IterableApi api, IterableAuthHandler authHandler, long authRefreshPeriod) {\n+        timer = new Timer(true);\n+        this.api = api;\n+        this.authHandler = authHandler;\n+        this.authRefreshPeriod = authRefreshPeriod;\n+    }\n+\n+    public void requestNewAuthToken(boolean hasFailedPriorAuth) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510883b7c8c86d72d8ffa9ff22ae88e3c834536a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDUyOQ==", "bodyText": "On receiving a 401 from the backend. the network calls should all call the same authManager which should have the same reference to the hasFailedPriorAuth flag, so it should skip additional calls to onAuthTokenRequested. LMK if I'm not understanding your concern correctly.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r496140529", "createdAt": "2020-09-28T18:09:41Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.iterable.iterableapi;\n+\n+import android.util.Base64;\n+\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.iterable.iterableapi.util.Future;\n+\n+import org.json.JSONObject;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+\n+public class IterableAuthManager {\n+    private static final String TAG = \"IterableAuth\";\n+    private static final String expirationString = \"exp\";\n+\n+    private final IterableApi api;\n+    private final IterableAuthHandler authHandler;\n+    private final long authRefreshPeriod;\n+\n+    @VisibleForTesting\n+    Timer timer;\n+    private boolean hasFailedPriorAuth;\n+\n+    IterableAuthManager(IterableApi api, IterableAuthHandler authHandler, long authRefreshPeriod) {\n+        timer = new Timer(true);\n+        this.api = api;\n+        this.authHandler = authHandler;\n+        this.authRefreshPeriod = authRefreshPeriod;\n+    }\n+\n+    public void requestNewAuthToken(boolean hasFailedPriorAuth) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMjc5NQ=="}, "originalCommit": {"oid": "510883b7c8c86d72d8ffa9ff22ae88e3c834536a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0ODI2Nw==", "bodyText": "Hm, yeah, you're right, but I've seen two parallel calls to requestNewAuthToken. Refreshes from failed requests have a limit of 1, but anything that calls with hasFailedPriorAuth = false will result in multiple parallel requests. Since those are asynchronous, there is no guarantee of ordering. A call that was triggered first might return last and vice versa.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r496148267", "createdAt": "2020-09-28T18:24:11Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.iterable.iterableapi;\n+\n+import android.util.Base64;\n+\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.iterable.iterableapi.util.Future;\n+\n+import org.json.JSONObject;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+\n+public class IterableAuthManager {\n+    private static final String TAG = \"IterableAuth\";\n+    private static final String expirationString = \"exp\";\n+\n+    private final IterableApi api;\n+    private final IterableAuthHandler authHandler;\n+    private final long authRefreshPeriod;\n+\n+    @VisibleForTesting\n+    Timer timer;\n+    private boolean hasFailedPriorAuth;\n+\n+    IterableAuthManager(IterableApi api, IterableAuthHandler authHandler, long authRefreshPeriod) {\n+        timer = new Timer(true);\n+        this.api = api;\n+        this.authHandler = authHandler;\n+        this.authRefreshPeriod = authRefreshPeriod;\n+    }\n+\n+    public void requestNewAuthToken(boolean hasFailedPriorAuth) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMjc5NQ=="}, "originalCommit": {"oid": "510883b7c8c86d72d8ffa9ff22ae88e3c834536a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NjM1OA==", "bodyText": "Gotcha, that makes sense for the non-401 case for standard initialization: setEmail. I'll add back in the pending auth flag to skip to restrict simultaneous the calls.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r496186358", "createdAt": "2020-09-28T19:36:06Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.iterable.iterableapi;\n+\n+import android.util.Base64;\n+\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.iterable.iterableapi.util.Future;\n+\n+import org.json.JSONObject;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+\n+public class IterableAuthManager {\n+    private static final String TAG = \"IterableAuth\";\n+    private static final String expirationString = \"exp\";\n+\n+    private final IterableApi api;\n+    private final IterableAuthHandler authHandler;\n+    private final long authRefreshPeriod;\n+\n+    @VisibleForTesting\n+    Timer timer;\n+    private boolean hasFailedPriorAuth;\n+\n+    IterableAuthManager(IterableApi api, IterableAuthHandler authHandler, long authRefreshPeriod) {\n+        timer = new Timer(true);\n+        this.api = api;\n+        this.authHandler = authHandler;\n+        this.authRefreshPeriod = authRefreshPeriod;\n+    }\n+\n+    public void requestNewAuthToken(boolean hasFailedPriorAuth) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMjc5NQ=="}, "originalCommit": {"oid": "510883b7c8c86d72d8ffa9ff22ae88e3c834536a"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTc0NDU2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoyMjo1NVrOHZIZsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODoxMDo0MVrOHZKDZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExNDA5OA==", "bodyText": "What is this line for? Looks like it's only going to be executed if error == null and requestResult.length < 0, which will never be true.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r496114098", "createdAt": "2020-09-28T17:22:55Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "diffHunk": "@@ -187,6 +192,8 @@ protected String doInBackground(IterableApiRequest... params) {\n                         handleFailure(\"No data received\", jsonResponse);\n                     } else if (error != null) {\n                         handleFailure(error, null);\n+                    } else {\n+                        IterableApi.getInstance().getAuthManager().resetFailedAuth();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510883b7c8c86d72d8ffa9ff22ae88e3c834536a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MTE1OQ==", "bodyText": "Ah, missed the case statement above for the success for error ==null and equestResult.length() > 0.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r496141159", "createdAt": "2020-09-28T18:10:41Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "diffHunk": "@@ -187,6 +192,8 @@ protected String doInBackground(IterableApiRequest... params) {\n                         handleFailure(\"No data received\", jsonResponse);\n                     } else if (error != null) {\n                         handleFailure(error, null);\n+                    } else {\n+                        IterableApi.getInstance().getAuthManager().resetFailedAuth();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExNDA5OA=="}, "originalCommit": {"oid": "510883b7c8c86d72d8ffa9ff22ae88e3c834536a"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTYxMzk2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDo0NzoxOFrOHaA-oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDo1NToyOVrOHaBfrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0MTA1Ng==", "bodyText": "Do we need to request a new token if the email stays the same?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r497041056", "createdAt": "2020-09-29T20:47:18Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -276,30 +298,8 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n-            if (_authToken == null && authToken == null) {\n-                return;\n-            }\n-\n-            if (_authToken != null && _authToken.equals(authToken)) {\n-                return;\n-            }\n-\n-            _authToken = authToken;\n-            storeAuthData();\n-\n+            getAuthManager().requestNewAuthToken(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e195f7b41799381b1bd91560e4a5127b9046c7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0MTczMQ==", "bodyText": "There are very likely some apps that call setEmail on every app launch. This will cause it to re-request the token on every launch.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r497041731", "createdAt": "2020-09-29T20:48:00Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -276,30 +298,8 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n-            if (_authToken == null && authToken == null) {\n-                return;\n-            }\n-\n-            if (_authToken != null && _authToken.equals(authToken)) {\n-                return;\n-            }\n-\n-            _authToken = authToken;\n-            storeAuthData();\n-\n+            getAuthManager().requestNewAuthToken(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0MTA1Ng=="}, "originalCommit": {"oid": "56e195f7b41799381b1bd91560e4a5127b9046c7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0OTUxNg==", "bodyText": "I'm fine with removing this call if the email is the same as the stored _email. However are there any alternatives for re-requesting a new auth token manually from the app without changing the email?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r497049516", "createdAt": "2020-09-29T20:55:29Z", "author": {"login": "davidtruong"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -276,30 +298,8 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n-            if (_authToken == null && authToken == null) {\n-                return;\n-            }\n-\n-            if (_authToken != null && _authToken.equals(authToken)) {\n-                return;\n-            }\n-\n-            _authToken = authToken;\n-            storeAuthData();\n-\n+            getAuthManager().requestNewAuthToken(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0MTA1Ng=="}, "originalCommit": {"oid": "56e195f7b41799381b1bd91560e4a5127b9046c7"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjQ0NjIwOnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMDoyMzo1NFrOHaJOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMDoyMzo1NFrOHaJOOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE3NjEyMA==", "bodyText": "Thinking if checking email/userId exists can help before assigning the authToken can avoid situation where\n\nValid setEmail was called with email xyz.\nsetEmail (null) got called before getting response to previous one.\n\nBy the time we get response, email could be set to null and we would have received a auth token.\nSaw the test failure and thought could this be a case?", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r497176120", "createdAt": "2020-09-30T00:23:54Z", "author": {"login": "Ayyanchira"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableAuthManager.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.iterable.iterableapi;\n+\n+import android.util.Base64;\n+\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.iterable.iterableapi.util.Future;\n+\n+import org.json.JSONObject;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+\n+public class IterableAuthManager {\n+    private static final String TAG = \"IterableAuth\";\n+    private static final String expirationString = \"exp\";\n+\n+    private final IterableApi api;\n+    private final IterableAuthHandler authHandler;\n+    private final long expiringAuthTokenRefreshPeriod;\n+\n+    @VisibleForTesting\n+    Timer timer;\n+    private boolean hasFailedPriorAuth;\n+    private boolean pendingAuth;\n+    private boolean requiresAuthRefresh;\n+\n+    IterableAuthManager(IterableApi api, IterableAuthHandler authHandler, long expiringAuthTokenRefreshPeriod) {\n+        timer = new Timer(true);\n+        this.api = api;\n+        this.authHandler = authHandler;\n+        this.expiringAuthTokenRefreshPeriod = expiringAuthTokenRefreshPeriod;\n+    }\n+\n+    public synchronized void requestNewAuthToken(boolean hasFailedPriorAuth) {\n+        if (authHandler != null) {\n+            if (!pendingAuth) {\n+                if (!(this.hasFailedPriorAuth && hasFailedPriorAuth)) {\n+                    this.hasFailedPriorAuth = hasFailedPriorAuth;\n+                    pendingAuth = true;\n+                    Future.runAsync(new Callable<String>() {\n+                        @Override\n+                        public String call() throws Exception {\n+                            return authHandler.onAuthTokenRequested();\n+                        }\n+                    }).onSuccess(new Future.SuccessCallback<String>() {\n+                        @Override\n+                        public void onSuccess(String authToken) {\n+                            if (authToken != null) {\n+                                queueExpirationRefresh(authToken);\n+                            }\n+                            IterableApi.getInstance().setAuthToken(authToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661573ebbe5fd64ea9853270d4bd79d784586ab"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDA2MzI5OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDoyOToyOFrOHe1WqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDoyOToyOFrOHe1WqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MzQ4MA==", "bodyText": "We should not be calling onLogIn() if it's just a token refresh and the email/userId did not change.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r502093480", "createdAt": "2020-10-09T00:29:28Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -205,6 +219,16 @@ void setNotificationData(IterableNotificationData data) {\n         }\n     }\n \n+    void setAuthToken(String authToken) {\n+        if (isInitialized()) {\n+            if (_authToken != authToken) {\n+                _authToken = authToken;\n+                storeAuthData();\n+            }\n+            onLogIn();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cc5f98008821dde997f4732f692588b8c490ab0"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDA2NDY2OnYy", "diffSide": "RIGHT", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDozMDoxMVrOHe1XZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDozMDoxMVrOHe1XZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MzY2OQ==", "bodyText": "This is doing object comparison instead of string comparison, this will be false for identical strings if they're not the same object.", "url": "https://github.com/Iterable/iterable-android-sdk/pull/265#discussion_r502093669", "createdAt": "2020-10-09T00:30:11Z", "author": {"login": "vbabenkoru"}, "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -205,6 +219,16 @@ void setNotificationData(IterableNotificationData data) {\n         }\n     }\n \n+    void setAuthToken(String authToken) {\n+        if (isInitialized()) {\n+            if (_authToken != authToken) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cc5f98008821dde997f4732f692588b8c490ab0"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2192, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}