{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1NTQ0NzMw", "number": 285, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMDoyNTozNFrOFMR-7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoyNToyMlrOFSFOgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDIxODcxOnYy", "diffSide": "RIGHT", "path": "jniFaiss/CMakeLists.txt", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMDoyNTozNFrOIP7Law==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxMjo0N1rOIYvrAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU2OTEzMQ==", "bodyText": "Design question: Should we have separate JNI libraries for FAISS and nmslib, or should they be contained in one?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r553569131", "createdAt": "2021-01-07T20:25:34Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,144 @@\n+cmake_minimum_required(VERSION 2.8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU3MDUzMA==", "bodyText": "i am not sure which is better.\nAt this, i separate libraries just to elaborate this faiss engine can work with knn-plugin.\nmay be one jni interface can make jni code more simple to maintain", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r554570530", "createdAt": "2021-01-10T13:50:41Z", "author": {"login": "luyuncheng"}, "path": "jniFaiss/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,144 @@\n+cmake_minimum_required(VERSION 2.8)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU2OTEzMQ=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ4NjI4Nw==", "bodyText": "I feel having seperate JNI would be more cleaner and easy to abstract out the underlying business logic to dedicated files.  I like the current approach.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555486287", "createdAt": "2021-01-12T03:24:20Z", "author": {"login": "vamshin"}, "path": "jniFaiss/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,144 @@\n+cmake_minimum_required(VERSION 2.8)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU2OTEzMQ=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxNzc5Mw==", "bodyText": "I think having 2 separate libraries is okay.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562817793", "createdAt": "2021-01-22T18:12:47Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,144 @@\n+cmake_minimum_required(VERSION 2.8)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU2OTEzMQ=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDI1Mjg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMDozNzowMVrOIP7gBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoyMzozNlrOIY3jmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU3NDQwNQ==", "bodyText": "What do you mean by this?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r553574405", "createdAt": "2021-01-07T20:37:01Z", "author": {"login": "jmazanec15"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -151,12 +153,22 @@ private void onRemoval(RemovalNotification<String, KNNIndexCacheEntry> removalNo\n      */\n     public KNNIndex getIndex(String key, final String indexName) {\n         try {\n+            //TODO if Type Not consistent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU2Nzk0OA==", "bodyText": "when cached an Index, should we verify which engine for this index, and then load the exactly library?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r554567948", "createdAt": "2021-01-10T13:29:33Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -151,12 +153,22 @@ private void onRemoval(RemovalNotification<String, KNNIndexCacheEntry> removalNo\n      */\n     public KNNIndex getIndex(String key, final String indexName) {\n         try {\n+            //TODO if Type Not consistent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU3NDQwNQ=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0Njk3MQ==", "bodyText": "I see. I think we should add a different file extension for faiss graphs as opposed to nmslib graphs. Maybe .faiss_hnsw.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562946971", "createdAt": "2021-01-22T22:23:36Z", "author": {"login": "jmazanec15"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -151,12 +153,22 @@ private void onRemoval(RemovalNotification<String, KNNIndexCacheEntry> removalNo\n      */\n     public KNNIndex getIndex(String key, final String indexName) {\n         try {\n+            //TODO if Type Not consistent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU3NDQwNQ=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDI1NzM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNSettings.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMDozODo0M1rOIP7iuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxMzozMToyNFrOIQ4J3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU3NTA5OQ==", "bodyText": "I think we should keep nmslib as the default engine.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r553575099", "createdAt": "2021-01-07T20:38:43Z", "author": {"login": "jmazanec15"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNSettings.java", "diffHunk": "@@ -83,6 +85,7 @@\n     /**\n      * Default setting values\n      */\n+    public static final String INDEX_KNN_DEFAULT_ENGINE = \"Faiss\"; // nmslib, faiss", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU2ODE1Nw==", "bodyText": "Yes, you are right. this is just for integration test can cover the faiss engine code.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r554568157", "createdAt": "2021-01-10T13:31:24Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNSettings.java", "diffHunk": "@@ -83,6 +85,7 @@\n     /**\n      * Default setting values\n      */\n+    public static final String INDEX_KNN_DEFAULT_ENGINE = \"Faiss\"; // nmslib, faiss", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU3NTA5OQ=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjkxODU5OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMjoyMDoxMFrOIRvFhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNjoxOToyMVrOISJXRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ2ODE2NA==", "bodyText": "You could remove  dependsOn cmakeJniLib and just rely on dependsOn buildJniNmsLib dependsOn buildJniFaissLib as they internally depends on cmakeJniNmsLib and cmakeJniFaissLib", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555468164", "createdAt": "2021-01-12T02:20:10Z", "author": {"login": "vamshin"}, "path": "build.gradle", "diffHunk": "@@ -120,21 +120,37 @@ loggerUsageCheck.enabled = false\n def es_tmp_dir = rootProject.file('build/private/es_tmp').absoluteFile\n es_tmp_dir.mkdirs()\n \n-task cmakeJniLib(type:Exec) {\n+task cmakeJniNmsLib(type:Exec) {\n     workingDir 'jni'\n     commandLine 'cmake', '.'\n }\n-\n-task buildJniLib(type:Exec) {\n-    dependsOn cmakeJniLib\n+task cmakeJniFaissLib(type:Exec) {\n+    workingDir 'jniFaiss'\n+    commandLine 'cmake', '.'\n+}\n+task cmakeJniLib() {\n+    dependsOn cmakeJniNmsLib\n+    dependsOn cmakeJniFaissLib\n+}\n+task buildJniNmsLib(type:Exec) {\n+    dependsOn cmakeJniNmsLib\n     workingDir 'jni'\n     commandLine 'make'\n }\n-\n+task buildJniFaissLib(type:Exec) {\n+    dependsOn cmakeJniFaissLib\n+    workingDir 'jniFaiss'\n+    commandLine 'make'\n+}\n+task buildJniLib() {\n+    dependsOn cmakeJniLib\n+    dependsOn buildJniNmsLib\n+    dependsOn buildJniFaissLib\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg5ODY5Mw==", "bodyText": "Thanks, I fixed it", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555898693", "createdAt": "2021-01-12T16:19:21Z", "author": {"login": "luyuncheng"}, "path": "build.gradle", "diffHunk": "@@ -120,21 +120,37 @@ loggerUsageCheck.enabled = false\n def es_tmp_dir = rootProject.file('build/private/es_tmp').absoluteFile\n es_tmp_dir.mkdirs()\n \n-task cmakeJniLib(type:Exec) {\n+task cmakeJniNmsLib(type:Exec) {\n     workingDir 'jni'\n     commandLine 'cmake', '.'\n }\n-\n-task buildJniLib(type:Exec) {\n-    dependsOn cmakeJniLib\n+task cmakeJniFaissLib(type:Exec) {\n+    workingDir 'jniFaiss'\n+    commandLine 'cmake', '.'\n+}\n+task cmakeJniLib() {\n+    dependsOn cmakeJniNmsLib\n+    dependsOn cmakeJniFaissLib\n+}\n+task buildJniNmsLib(type:Exec) {\n+    dependsOn cmakeJniNmsLib\n     workingDir 'jni'\n     commandLine 'make'\n }\n-\n+task buildJniFaissLib(type:Exec) {\n+    dependsOn cmakeJniFaissLib\n+    workingDir 'jniFaiss'\n+    commandLine 'make'\n+}\n+task buildJniLib() {\n+    dependsOn cmakeJniLib\n+    dependsOn buildJniNmsLib\n+    dependsOn buildJniFaissLib\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ2ODE2NA=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjkyMzU0OnYy", "diffSide": "RIGHT", "path": "jniFaiss/include/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.h", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMjoyMzowNVrOIRvIhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNjoyMDoxNFrOISJZ3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ2ODkzNA==", "bodyText": "Is faiss library backward compatible?\nWe should have faiss library version in the function names to support backward compatibility issues if any arises in the future? You could refer nmslib apis.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555468934", "createdAt": "2021-01-12T02:23:05Z", "author": {"login": "vamshin"}, "path": "jniFaiss/include/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.h", "diffHunk": "@@ -0,0 +1,53 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+/* Header for class com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex */\n+\n+#ifndef _Included_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex\n+#define _Included_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex\n+ * Method:    saveIndex\n+ * Signature: ([I[[FLjava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_saveIndex", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg5OTM1OQ==", "bodyText": "Yes, your are right. i will add the version number into it.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555899359", "createdAt": "2021-01-12T16:20:14Z", "author": {"login": "luyuncheng"}, "path": "jniFaiss/include/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.h", "diffHunk": "@@ -0,0 +1,53 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+/* Header for class com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex */\n+\n+#ifndef _Included_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex\n+#define _Included_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex\n+ * Method:    saveIndex\n+ * Signature: ([I[[FLjava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_saveIndex", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ2ODkzNA=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjkzNTUwOnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMjoyODozNlrOIRvPNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQyMDowMDo0M1rOIYHk5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3MDY0NA==", "bodyText": "We should run memory leak tests for faiss jni code. @jmazanec15 ran some memory leak tests for nmslib, we could probably ran it on the faiss branch once we create. Lets see if we can test it as part of this PR or atleast we can create an issue to track all TODOs later.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555470644", "createdAt": "2021-01-12T02:28:36Z", "author": {"login": "vamshin"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {\n+                indexDescription=\"HNSW\"+std::to_string(M);\n+            }\n+            env->ReleaseStringUTFChars(param, rawString);\n+\n+        }\n+\t\thas_exception_in_stack(env);\n+\n+\n+\t\t//---- space\n+\t\tconst char *spaceTypeCStr = env->GetStringUTFChars(spaceType, 0);\n+        string spaceTypeString(spaceTypeCStr);\n+        env->ReleaseStringUTFChars(spaceType, spaceTypeCStr);\n+        has_exception_in_stack(env);\n+\t\t// space mapping faiss::MetricType\n+\t\tif(mapMetric.find(spaceTypeString) != mapMetric.end()) {\n+\t\t\tmetric = mapMetric[spaceTypeString];\n+\t\t}\n+\n+\t\t//---- Create IndexWriter from faiss index_factory\n+\t\tindexWriter.reset(faiss::index_factory(dim, indexDescription.data(), metric));\n+\n+\t\t//Preparation And TODO Verify IndexWriter\n+\t\t//Some Param Can not Create from IndexFactory, Like HNSW efSearch and efCOnstruction\n+\t\t//----FOR HNSW 1st PARAM: M(HNSW32->M=32), efConstruction, efSearch\n+\t\tif(indexDescription.find(\"HNSW\") != std::string::npos) {\n+\t\t    for(int i = 0; i < paramsCount; ++i) {\n+\t\t        const string& param = paramsList[i];\n+\t\t        int efConstruction = 40; //default\n+\t\t        int efSearch = 16;//default\n+\t\t        if(param.find(\"efConstruction\") != std::string::npos &&\n+\t\t            sscanf(param.data(), \"efConstruction=%d\", &efConstruction) == 1) {\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efConstruction = efConstruction;\n+\t\t        } else if (param.find(\"efSearch\") != std::string::npos &&\n+                            sscanf(param.data(), \"efSearch=%d\", &efSearch) == 1){\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efSearch = efSearch;\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\n+\t\t//---- Do Index\n+\t\t//----- 1. Train\n+        if(!indexWriter->is_trained) {\n+\t\t\t//TODO if we use like PQ, we have to train dataset\n+\t\t\t// but when a lucene segment only one document, it\n+\t\t\t// can not train the data.\n+\t\t}\n+\t\t//----- 2. Add IDMap\n+\t\t// default all use self defined IndexIDMap cause some class no add_with_ids\n+\t\tfaiss::IndexIDMap idMap =  faiss::IndexIDMap(indexWriter.get());\n+\t\tidMap.add_with_ids(idVector.size(), dataset.data(), idVector.data());\n+\n+\t\t//----- 3. WriteIndex\n+\t\tfaiss::write_index(&idMap, indexPathString.c_str());\n+\t\t\n+\t\t//Explicit delete object\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\n+\t}\n+\tcatch(...) {\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\t\tcatch_cpp_exception_and_throw_java(env);\n+\t}\n+}\n+\n+\n+JNIEXPORT jobjectArray JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_queryIndex\n+(JNIEnv* env, jclass cls, jlong indexPointer, jfloatArray queryVector, jint k)\n+{\n+\tfaiss::Index *indexReader = nullptr;\n+\ttry {\n+\t\tindexReader = reinterpret_cast<faiss::Index*>(indexPointer);\n+\t\tfloat* rawQueryvector = env->GetFloatArrayElements(queryVector, 0);\n+\t\tint dim\t= env->GetArrayLength(queryVector);\n+\n+\t\tstd::vector<float> dis(k * dim);\n+\t\tstd::vector<faiss::Index::idx_t> ids( k * dim);\n+\t\tindexReader->search(1, rawQueryvector, k, dis.data(), ids.data());\n+\t\tenv->ReleaseFloatArrayElements(queryVector, rawQueryvector, 0);\n+\t\thas_exception_in_stack(env);\n+\n+\t\tint resultSize = k;\n+\t\t//if result is not enough, padded with -1s\n+\t\tfor(int i = 0; i < k; i++) {\n+\t\t\tif(ids[i] == -1) {\n+\t\t\t\tresultSize = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tjclass resultClass = env->FindClass(\"com/amazon/opendistroforelasticsearch/knn/index/KNNQueryResult\");\n+\t\tjmethodID allArgs = env->GetMethodID(resultClass, \"<init>\", \"(IF)V\");\n+\t\tjobjectArray results = env->NewObjectArray(resultSize, resultClass, NULL);\n+\t\tfor(int i = 0; i < resultSize; ++i) {\n+\t\t\tfloat distance = dis[i];\n+\t\t\tlong  id = ids[i];\n+\t\t\tenv->SetObjectArrayElement(results, i, env->NewObject(resultClass, allArgs, id, distance));\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+        return results;\n+\n+\t}\n+\tcatch(...) {\n+\t\tif(indexReader) delete indexReader;\n+\t\tcatch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+JNIEXPORT jlong JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_init\n+(JNIEnv* env, jclass cls,  jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\n+\tfaiss::Index* indexReader = nullptr;\n+\ttry {\n+        const char *indexPathCStr = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexPathCStr);\n+        env->ReleaseStringUTFChars(indexPath, indexPathCStr);\n+        has_exception_in_stack(env);\n+\t\t//whether set IO_FLAGS = 0 or IO_FLAG_READ_ONLYfaiss::IO_FLAG_READ_ONLY\n+\t\tindexReader = faiss::read_index(indexPathString.c_str(), faiss::IO_FLAG_READ_ONLY);\n+\t\treturn (jlong) indexReader;\n+\t} \n+\tcatch(...) {\n+        if (indexReader) delete indexReader;\n+        catch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+/**\n+ * When autoclose class do close, then delete the pointer\n+ * Method GC pointer\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_gc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM3MDY1MQ==", "bodyText": "is there any tools to detect memory leak in JNI code?\nwhen i submit the faiss jni code, i have been writed a demo with valgrind to detect memory leak. but i do not know how to detect it from java test code.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r556370651", "createdAt": "2021-01-13T09:16:42Z", "author": {"login": "luyuncheng"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {\n+                indexDescription=\"HNSW\"+std::to_string(M);\n+            }\n+            env->ReleaseStringUTFChars(param, rawString);\n+\n+        }\n+\t\thas_exception_in_stack(env);\n+\n+\n+\t\t//---- space\n+\t\tconst char *spaceTypeCStr = env->GetStringUTFChars(spaceType, 0);\n+        string spaceTypeString(spaceTypeCStr);\n+        env->ReleaseStringUTFChars(spaceType, spaceTypeCStr);\n+        has_exception_in_stack(env);\n+\t\t// space mapping faiss::MetricType\n+\t\tif(mapMetric.find(spaceTypeString) != mapMetric.end()) {\n+\t\t\tmetric = mapMetric[spaceTypeString];\n+\t\t}\n+\n+\t\t//---- Create IndexWriter from faiss index_factory\n+\t\tindexWriter.reset(faiss::index_factory(dim, indexDescription.data(), metric));\n+\n+\t\t//Preparation And TODO Verify IndexWriter\n+\t\t//Some Param Can not Create from IndexFactory, Like HNSW efSearch and efCOnstruction\n+\t\t//----FOR HNSW 1st PARAM: M(HNSW32->M=32), efConstruction, efSearch\n+\t\tif(indexDescription.find(\"HNSW\") != std::string::npos) {\n+\t\t    for(int i = 0; i < paramsCount; ++i) {\n+\t\t        const string& param = paramsList[i];\n+\t\t        int efConstruction = 40; //default\n+\t\t        int efSearch = 16;//default\n+\t\t        if(param.find(\"efConstruction\") != std::string::npos &&\n+\t\t            sscanf(param.data(), \"efConstruction=%d\", &efConstruction) == 1) {\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efConstruction = efConstruction;\n+\t\t        } else if (param.find(\"efSearch\") != std::string::npos &&\n+                            sscanf(param.data(), \"efSearch=%d\", &efSearch) == 1){\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efSearch = efSearch;\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\n+\t\t//---- Do Index\n+\t\t//----- 1. Train\n+        if(!indexWriter->is_trained) {\n+\t\t\t//TODO if we use like PQ, we have to train dataset\n+\t\t\t// but when a lucene segment only one document, it\n+\t\t\t// can not train the data.\n+\t\t}\n+\t\t//----- 2. Add IDMap\n+\t\t// default all use self defined IndexIDMap cause some class no add_with_ids\n+\t\tfaiss::IndexIDMap idMap =  faiss::IndexIDMap(indexWriter.get());\n+\t\tidMap.add_with_ids(idVector.size(), dataset.data(), idVector.data());\n+\n+\t\t//----- 3. WriteIndex\n+\t\tfaiss::write_index(&idMap, indexPathString.c_str());\n+\t\t\n+\t\t//Explicit delete object\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\n+\t}\n+\tcatch(...) {\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\t\tcatch_cpp_exception_and_throw_java(env);\n+\t}\n+}\n+\n+\n+JNIEXPORT jobjectArray JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_queryIndex\n+(JNIEnv* env, jclass cls, jlong indexPointer, jfloatArray queryVector, jint k)\n+{\n+\tfaiss::Index *indexReader = nullptr;\n+\ttry {\n+\t\tindexReader = reinterpret_cast<faiss::Index*>(indexPointer);\n+\t\tfloat* rawQueryvector = env->GetFloatArrayElements(queryVector, 0);\n+\t\tint dim\t= env->GetArrayLength(queryVector);\n+\n+\t\tstd::vector<float> dis(k * dim);\n+\t\tstd::vector<faiss::Index::idx_t> ids( k * dim);\n+\t\tindexReader->search(1, rawQueryvector, k, dis.data(), ids.data());\n+\t\tenv->ReleaseFloatArrayElements(queryVector, rawQueryvector, 0);\n+\t\thas_exception_in_stack(env);\n+\n+\t\tint resultSize = k;\n+\t\t//if result is not enough, padded with -1s\n+\t\tfor(int i = 0; i < k; i++) {\n+\t\t\tif(ids[i] == -1) {\n+\t\t\t\tresultSize = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tjclass resultClass = env->FindClass(\"com/amazon/opendistroforelasticsearch/knn/index/KNNQueryResult\");\n+\t\tjmethodID allArgs = env->GetMethodID(resultClass, \"<init>\", \"(IF)V\");\n+\t\tjobjectArray results = env->NewObjectArray(resultSize, resultClass, NULL);\n+\t\tfor(int i = 0; i < resultSize; ++i) {\n+\t\t\tfloat distance = dis[i];\n+\t\t\tlong  id = ids[i];\n+\t\t\tenv->SetObjectArrayElement(results, i, env->NewObject(resultClass, allArgs, id, distance));\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+        return results;\n+\n+\t}\n+\tcatch(...) {\n+\t\tif(indexReader) delete indexReader;\n+\t\tcatch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+JNIEXPORT jlong JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_init\n+(JNIEnv* env, jclass cls,  jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\n+\tfaiss::Index* indexReader = nullptr;\n+\ttry {\n+        const char *indexPathCStr = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexPathCStr);\n+        env->ReleaseStringUTFChars(indexPath, indexPathCStr);\n+        has_exception_in_stack(env);\n+\t\t//whether set IO_FLAGS = 0 or IO_FLAG_READ_ONLYfaiss::IO_FLAG_READ_ONLY\n+\t\tindexReader = faiss::read_index(indexPathString.c_str(), faiss::IO_FLAG_READ_ONLY);\n+\t\treturn (jlong) indexReader;\n+\t} \n+\tcatch(...) {\n+        if (indexReader) delete indexReader;\n+        catch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+/**\n+ * When autoclose class do close, then delete the pointer\n+ * Method GC pointer\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_gc", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3MDY0NA=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE2MDg2OA==", "bodyText": "Good point. We used valgrind to detect memory leaks. Last time I remember we build C++ class to call the functions directly and then build the artifact for running valgrind. We could probably help here.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562160868", "createdAt": "2021-01-21T20:00:43Z", "author": {"login": "vamshin"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {\n+                indexDescription=\"HNSW\"+std::to_string(M);\n+            }\n+            env->ReleaseStringUTFChars(param, rawString);\n+\n+        }\n+\t\thas_exception_in_stack(env);\n+\n+\n+\t\t//---- space\n+\t\tconst char *spaceTypeCStr = env->GetStringUTFChars(spaceType, 0);\n+        string spaceTypeString(spaceTypeCStr);\n+        env->ReleaseStringUTFChars(spaceType, spaceTypeCStr);\n+        has_exception_in_stack(env);\n+\t\t// space mapping faiss::MetricType\n+\t\tif(mapMetric.find(spaceTypeString) != mapMetric.end()) {\n+\t\t\tmetric = mapMetric[spaceTypeString];\n+\t\t}\n+\n+\t\t//---- Create IndexWriter from faiss index_factory\n+\t\tindexWriter.reset(faiss::index_factory(dim, indexDescription.data(), metric));\n+\n+\t\t//Preparation And TODO Verify IndexWriter\n+\t\t//Some Param Can not Create from IndexFactory, Like HNSW efSearch and efCOnstruction\n+\t\t//----FOR HNSW 1st PARAM: M(HNSW32->M=32), efConstruction, efSearch\n+\t\tif(indexDescription.find(\"HNSW\") != std::string::npos) {\n+\t\t    for(int i = 0; i < paramsCount; ++i) {\n+\t\t        const string& param = paramsList[i];\n+\t\t        int efConstruction = 40; //default\n+\t\t        int efSearch = 16;//default\n+\t\t        if(param.find(\"efConstruction\") != std::string::npos &&\n+\t\t            sscanf(param.data(), \"efConstruction=%d\", &efConstruction) == 1) {\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efConstruction = efConstruction;\n+\t\t        } else if (param.find(\"efSearch\") != std::string::npos &&\n+                            sscanf(param.data(), \"efSearch=%d\", &efSearch) == 1){\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efSearch = efSearch;\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\n+\t\t//---- Do Index\n+\t\t//----- 1. Train\n+        if(!indexWriter->is_trained) {\n+\t\t\t//TODO if we use like PQ, we have to train dataset\n+\t\t\t// but when a lucene segment only one document, it\n+\t\t\t// can not train the data.\n+\t\t}\n+\t\t//----- 2. Add IDMap\n+\t\t// default all use self defined IndexIDMap cause some class no add_with_ids\n+\t\tfaiss::IndexIDMap idMap =  faiss::IndexIDMap(indexWriter.get());\n+\t\tidMap.add_with_ids(idVector.size(), dataset.data(), idVector.data());\n+\n+\t\t//----- 3. WriteIndex\n+\t\tfaiss::write_index(&idMap, indexPathString.c_str());\n+\t\t\n+\t\t//Explicit delete object\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\n+\t}\n+\tcatch(...) {\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\t\tcatch_cpp_exception_and_throw_java(env);\n+\t}\n+}\n+\n+\n+JNIEXPORT jobjectArray JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_queryIndex\n+(JNIEnv* env, jclass cls, jlong indexPointer, jfloatArray queryVector, jint k)\n+{\n+\tfaiss::Index *indexReader = nullptr;\n+\ttry {\n+\t\tindexReader = reinterpret_cast<faiss::Index*>(indexPointer);\n+\t\tfloat* rawQueryvector = env->GetFloatArrayElements(queryVector, 0);\n+\t\tint dim\t= env->GetArrayLength(queryVector);\n+\n+\t\tstd::vector<float> dis(k * dim);\n+\t\tstd::vector<faiss::Index::idx_t> ids( k * dim);\n+\t\tindexReader->search(1, rawQueryvector, k, dis.data(), ids.data());\n+\t\tenv->ReleaseFloatArrayElements(queryVector, rawQueryvector, 0);\n+\t\thas_exception_in_stack(env);\n+\n+\t\tint resultSize = k;\n+\t\t//if result is not enough, padded with -1s\n+\t\tfor(int i = 0; i < k; i++) {\n+\t\t\tif(ids[i] == -1) {\n+\t\t\t\tresultSize = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tjclass resultClass = env->FindClass(\"com/amazon/opendistroforelasticsearch/knn/index/KNNQueryResult\");\n+\t\tjmethodID allArgs = env->GetMethodID(resultClass, \"<init>\", \"(IF)V\");\n+\t\tjobjectArray results = env->NewObjectArray(resultSize, resultClass, NULL);\n+\t\tfor(int i = 0; i < resultSize; ++i) {\n+\t\t\tfloat distance = dis[i];\n+\t\t\tlong  id = ids[i];\n+\t\t\tenv->SetObjectArrayElement(results, i, env->NewObject(resultClass, allArgs, id, distance));\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+        return results;\n+\n+\t}\n+\tcatch(...) {\n+\t\tif(indexReader) delete indexReader;\n+\t\tcatch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+JNIEXPORT jlong JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_init\n+(JNIEnv* env, jclass cls,  jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\n+\tfaiss::Index* indexReader = nullptr;\n+\ttry {\n+        const char *indexPathCStr = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexPathCStr);\n+        env->ReleaseStringUTFChars(indexPath, indexPathCStr);\n+        has_exception_in_stack(env);\n+\t\t//whether set IO_FLAGS = 0 or IO_FLAG_READ_ONLYfaiss::IO_FLAG_READ_ONLY\n+\t\tindexReader = faiss::read_index(indexPathString.c_str(), faiss::IO_FLAG_READ_ONLY);\n+\t\treturn (jlong) indexReader;\n+\t} \n+\tcatch(...) {\n+        if (indexReader) delete indexReader;\n+        catch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+/**\n+ * When autoclose class do close, then delete the pointer\n+ * Method GC pointer\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex_gc", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3MDY0NA=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5Njk1MzU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/util/NmsLibVersion.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMjozNzo0OFrOIRvZrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNFQxNjo1NjoyNVrOIZOTdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3MzMyNg==", "bodyText": "Having Faiss part of NmsLibVersion class would add confusion. We should probably have dedicated enum class for Faiss versions? Intension of this class is to hold different versions of same library and refer them from this class incase we happen to maintain more than one version of the library because of compatability issues.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555473326", "createdAt": "2021-01-12T02:37:48Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/util/NmsLibVersion.java", "diffHunk": "@@ -25,9 +28,17 @@\n         public String indexLibraryVersion() {\n             return \"KNNIndexV2_0_6\";\n         }\n+    },\n+    VFaiss(\"Faiss\") {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTkwMDM5OA==", "bodyText": "Nice idea! i'll do it", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555900398", "createdAt": "2021-01-12T16:21:43Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/util/NmsLibVersion.java", "diffHunk": "@@ -25,9 +28,17 @@\n         public String indexLibraryVersion() {\n             return \"KNNIndexV2_0_6\";\n         }\n+    },\n+    VFaiss(\"Faiss\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3MzMyNg=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1OTQ1NQ==", "bodyText": "How about make\nnmslib: KNNIndex_NMSLIB_V2_0_6,\nfaiss: KNNIndex_FAISS_V1_6_4\nlike this:\npublic enum NmsLibVersion {\n    VNMSLIB_208(\"NMSLIB_208\"){\n        @Override\n        public String indexLibraryVersion() {\n            return \"KNNIndex_NMSLIB_V2_0_8\";\n        }\n    },\n    VFAISS_164(\"FAISS_164\") {\n        @Override\n        public String indexLibraryVersion() {\n            return \"KNNIndex_FAISS_V1_6_4\";\n        }\n    };\n}\n\nor do you have any idea to distinguish the name between nmslib and faiss library.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r556359455", "createdAt": "2021-01-13T08:58:50Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/util/NmsLibVersion.java", "diffHunk": "@@ -25,9 +28,17 @@\n         public String indexLibraryVersion() {\n             return \"KNNIndexV2_0_6\";\n         }\n+    },\n+    VFaiss(\"Faiss\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3MzMyNg=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE2MjY0Ng==", "bodyText": "We could have new enum class for FAISS that just holds FAISS versions.  Example\npublic enum FAISSLibVersion {\n\n    /**\n     * Latest available faiss version\n     */\n    V_164(\"164\"){\n        @Override\n        public String indexLibraryVersion() {\n            return \"KNNIndexV2_0_11\";\n        }\n    };\n\n    public static final FAISSLibVersion LATEST = V164;\n\n    public String buildVersion;\n\n    FAISSLibVersion(String buildVersion) {\n        this.buildVersion = buildVersion;\n    }\n\n    /**\n     * FAISS library version used by the KNN codec\n     * @return name\n     */\n    public abstract String indexLibraryVersion();\n}", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562162646", "createdAt": "2021-01-21T20:04:02Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/util/NmsLibVersion.java", "diffHunk": "@@ -25,9 +28,17 @@\n         public String indexLibraryVersion() {\n             return \"KNNIndexV2_0_6\";\n         }\n+    },\n+    VFaiss(\"Faiss\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3MzMyNg=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMxOTY3MQ==", "bodyText": "We could have new enum class for FAISS that just holds FAISS versions. Example\n\nyes, it is great. i added FAISSLibVersion in the latest commits", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563319671", "createdAt": "2021-01-24T16:56:25Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/util/NmsLibVersion.java", "diffHunk": "@@ -25,9 +28,17 @@\n         public String indexLibraryVersion() {\n             return \"KNNIndexV2_0_6\";\n         }\n+    },\n+    VFaiss(\"Faiss\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3MzMyNg=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5Njk1OTk1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistroforelasticsearch/knn/index/KNNJNIFaissTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMjo0MTowNVrOIRvdQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQwODowNzowN1rOIZa1pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3NDI0Mg==", "bodyText": "We should also have some tests that create both nmslib and faiss indices and perform search in the same test and assert right values are retrieved. This is to verify we are not mixing up between library calls.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555474242", "createdAt": "2021-01-12T02:41:05Z", "author": {"login": "vamshin"}, "path": "src/test/java/com/amazon/opendistroforelasticsearch/knn/index/KNNJNIFaissTests.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.amazon.opendistroforelasticsearch.knn.index;\n+\n+import com.amazon.opendistroforelasticsearch.knn.KNNTestCase;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.faiss.KNNFIndex;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FSDirectory;\n+import org.apache.lucene.store.FilterDirectory;\n+\n+import java.nio.file.Paths;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class KNNJNIFaissTests extends KNNTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUyNTAzMQ==", "bodyText": "yes, i would add tests for mixed engine and test with exceptions case", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563525031", "createdAt": "2021-01-25T08:07:07Z", "author": {"login": "luyuncheng"}, "path": "src/test/java/com/amazon/opendistroforelasticsearch/knn/index/KNNJNIFaissTests.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.amazon.opendistroforelasticsearch.knn.index;\n+\n+import com.amazon.opendistroforelasticsearch.knn.KNNTestCase;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.faiss.KNNFIndex;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FSDirectory;\n+import org.apache.lucene.store.FilterDirectory;\n+\n+import java.nio.file.Paths;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class KNNJNIFaissTests extends KNNTestCase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3NDI0Mg=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5Njk3MjIzOnYy", "diffSide": "RIGHT", "path": "src/main/plugin-metadata/plugin-security.policy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMjo0NzoxOFrOIRvkRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwODo0OTo0N1rOISlI_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3NjAzOA==", "bodyText": "We should add version information similar to NMSlib to keep it consistent and provides ability to load certain version of the library.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555476038", "createdAt": "2021-01-12T02:47:18Z", "author": {"login": "vamshin"}, "path": "src/main/plugin-metadata/plugin-security.policy", "diffHunk": "@@ -1,3 +1,4 @@\n grant {\n     permission java.lang.RuntimePermission \"loadLibrary.KNNIndexV2_0_6\";\n+    permission java.lang.RuntimePermission \"loadLibrary.KNNIndexVFaiss\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1Mzc4OA==", "bodyText": "How about make\nnmslib: KNNIndex_NMSLIB_V2_0_6,\nfaiss: KNNIndex_FAISS_V1_6_4\nlike this:\npublic enum NmsLibVersion {\n    VNMSLIB_208(\"NMSLIB_208\"){\n        @Override\n        public String indexLibraryVersion() {\n            return \"KNNIndex_NMSLIB_V2_0_8\";\n        }\n    },\n    VFAISS_164(\"FAISS_164\") {\n        @Override\n        public String indexLibraryVersion() {\n            return \"KNNIndex_FAISS_V1_6_4\";\n        }\n    };\n}\n\nor do you have any idea to distinguish the name between nmslib and faiss library.\nWith this, we may need to change the package\ncom.amazon.opendistroforelasticsearch.knn.index.v208 to com.amazon.opendistroforelasticsearch.knn.index.nmslib.v208 and com.amazon.opendistroforelasticsearch.knn.index.faiss to com.amazon.opendistroforelasticsearch.knn.index.faiss.v164\nLoad Library:\n    permission java.lang.RuntimePermission \"loadLibrary.KNNIndex_NMSLIB_V2_0_8\";\n    permission java.lang.RuntimePermission \"loadLibrary.KNNIndex_FAISS_V1_6_4\";", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r556353788", "createdAt": "2021-01-13T08:49:47Z", "author": {"login": "luyuncheng"}, "path": "src/main/plugin-metadata/plugin-security.policy", "diffHunk": "@@ -1,3 +1,4 @@\n grant {\n     permission java.lang.RuntimePermission \"loadLibrary.KNNIndexV2_0_6\";\n+    permission java.lang.RuntimePermission \"loadLibrary.KNNIndexVFaiss\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3NjAzOA=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5Njk3NzUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/faiss/KNNFIndex.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMjo1MDowMlrOIRvnTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNFQxNjo1NTowMlrOIZOStw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3NjgxNA==", "bodyText": "package name should have version information similar to nmslib.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555476814", "createdAt": "2021-01-12T02:50:02Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/faiss/KNNFIndex.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package com.amazon.opendistroforelasticsearch.knn.index.faiss;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMxOTQ3OQ==", "bodyText": "in the latest commits, i add faiss version into package and function names.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563319479", "createdAt": "2021-01-24T16:55:02Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/faiss/KNNFIndex.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package com.amazon.opendistroforelasticsearch.knn.index.faiss;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3NjgxNA=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NzAwODk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/codec/KNN80Codec/KNN80DocValuesConsumer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMzowNTo0NVrOIRv43Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMzowNTo0NVrOIRv43Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ4MTMwOQ==", "bodyText": "How about we move if else check inside the AccessController.doPrivileged. Something like below example\n                AccessController.doPrivileged(\n                        new PrivilegedAction<Void>() {\n                            public Void run() {\n                                if(knnindex)\n                                      KNNIndex.saveIndex(pair.docs, pair.vectors, tempIndexPath, algoParams, spaceType);\n                                if(faissindex)\n                                     KNNFIndex.saveIndex(pair.docs, pair.vectors, tempIndexPath, algoParams, spaceType);      \n                               return null;\n                            }\n      ```", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555481309", "createdAt": "2021-01-12T03:05:45Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/codec/KNN80Codec/KNN80DocValuesConsumer.java", "diffHunk": "@@ -98,16 +99,29 @@ public void addKNNBinaryField(FieldInfo field, DocValuesProducer valuesProducer)\n             // Pass the path for the nms library to save the file\n             String tempIndexPath = indexPath + TEMP_SUFFIX;\n             Map<String, String> fieldAttributes = field.attributes();\n+            String knnEngine = fieldAttributes.getOrDefault(KNNConstants.KNNEngine, KNNSettings.INDEX_KNN_DEFAULT_ENGINE);\n             String spaceType = fieldAttributes.getOrDefault(KNNConstants.SPACE_TYPE, SpaceTypes.l2.getValue());\n             String[] algoParams = getKNNIndexParams(fieldAttributes);\n-            AccessController.doPrivileged(\n-                    new PrivilegedAction<Void>() {\n-                        public Void run() {\n-                            KNNIndex.saveIndex(pair.docs, pair.vectors, tempIndexPath, algoParams, spaceType);\n-                            return null;\n+\n+            if(knnEngine.contains(NmsLibVersion.VFaiss.getBuildVersion())) {\n+                AccessController.doPrivileged(\n+                        new PrivilegedAction<Void>() {\n+                            public Void run() {\n+                                KNNFIndex.saveIndex(pair.docs, pair.vectors, tempIndexPath, algoParams, spaceType);\n+                                return null;\n+                            }\n+                        }\n+                );\n+            } else {\n+                AccessController.doPrivileged(\n+                        new PrivilegedAction<Void>() {\n+                            public Void run() {\n+                                KNNIndex.saveIndex(pair.docs, pair.vectors, tempIndexPath, algoParams, spaceType);\n+                                return null;\n+                            }\n                         }\n-                    }\n-            );\n+                );\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NzAzODgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNWeight.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMzoyMTozMFrOIRwJfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQwODozMjo0NFrOIZbsCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ4NTU2NA==", "bodyText": "How about we pull out the methods in KNNFIndex and KNNIndex to interface so that we could refer with one object to keep it more cleaner? Something like\nKNNIndex index;\nif (fieldAttributes.containsValue(NmsLibVersion.V206.getBuildVersion())) {\n       index = knnIndexCache.getIndex(indexPath.toString(), knnQuery.getIndexName());\n} else {\n       index = knnIndexCache.getFIndex(indexPath.toString(), knnQuery.getIndexName());\n}\nresults = index.queryIndex(knnQuery.getQueryVector(), knnQuery.getK());", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555485564", "createdAt": "2021-01-12T03:21:30Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNWeight.java", "diffHunk": "@@ -97,11 +100,21 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n              */\n \n             Path indexPath = PathUtils.get(directory, hnswFiles.get(0));\n-            final KNNIndex index = knnIndexCache.getIndex(indexPath.toString(), knnQuery.getIndexName());\n-            final KNNQueryResult[] results = index.queryIndex(\n-                    knnQuery.getQueryVector(),\n-                    knnQuery.getK()\n-            );\n+            final KNNQueryResult[] results;\n+\n+            if (fieldAttributes.containsValue(NmsLibVersion.V206.getBuildVersion())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM0OTI3Nw==", "bodyText": "this is may make the log of changes in KNNIndex. In KNNIndex class, it would load the specific library, if we want to pull out the methods getIndex, we need an abstraction of KNNIndex and verify the engine we are using.\nLet me think about it how to do it.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r556349277", "createdAt": "2021-01-13T08:42:11Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNWeight.java", "diffHunk": "@@ -97,11 +100,21 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n              */\n \n             Path indexPath = PathUtils.get(directory, hnswFiles.get(0));\n-            final KNNIndex index = knnIndexCache.getIndex(indexPath.toString(), knnQuery.getIndexName());\n-            final KNNQueryResult[] results = index.queryIndex(\n-                    knnQuery.getQueryVector(),\n-                    knnQuery.getK()\n-            );\n+            final KNNQueryResult[] results;\n+\n+            if (fieldAttributes.containsValue(NmsLibVersion.V206.getBuildVersion())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ4NTU2NA=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUzODk1Mg==", "bodyText": "How about we pull out the methods in KNNFIndex and KNNIndex to interface so that we could refer with one object to keep it more cleaner? Something like\n\nin the latest commits, I used KNNIndex as abstract class. KNNFaissIndex and KNNNmsLibIndex extends the KNNINdex.\nKNNIndexCacheEntry only save the KNNIndex.\nif you have any other idea, pls let me know", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563538952", "createdAt": "2021-01-25T08:32:44Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNWeight.java", "diffHunk": "@@ -97,11 +100,21 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n              */\n \n             Path indexPath = PathUtils.get(directory, hnswFiles.get(0));\n-            final KNNIndex index = knnIndexCache.getIndex(indexPath.toString(), knnQuery.getIndexName());\n-            final KNNQueryResult[] results = index.queryIndex(\n-                    knnQuery.getQueryVector(),\n-                    knnQuery.getK()\n-            );\n+            final KNNQueryResult[] results;\n+\n+            if (fieldAttributes.containsValue(NmsLibVersion.V206.getBuildVersion())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ4NTU2NA=="}, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NzA0MDk5OnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMzoyMjo0NlrOIRwKrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMzoyMjo0NlrOIRwKrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ4NTg3MA==", "bodyText": "This class has core logic and would need some insights into way faiss library operates to review the code. I plan to visit this code once I have understanding of faiss interface.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r555485870", "createdAt": "2021-01-12T03:22:46Z", "author": {"login": "vamshin"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_KNNFIndex.h\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a44194c9439c15bf073e62a0e61137ab5b9a301"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MDU3MjE0OnYy", "diffSide": "RIGHT", "path": ".github/workflows/CI.yml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQyMzoxNDowM1rOIYNkqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNFQxMjoxNDoyMlrOIZMFNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjI1OTExMg==", "bodyText": "I dont think we need to add this branch to CI action, given that it is a development branch. Please remove. Once review finishes, we will check into faiss branch and develop/test from there. Then, once we are ready, we can create another PR to master.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562259112", "createdAt": "2021-01-21T23:14:03Z", "author": {"login": "jmazanec15"}, "path": ".github/workflows/CI.yml", "diffHunk": "@@ -4,6 +4,7 @@ on:\n     branches:\n       - master\n       - opendistro-*\n+      - faiss*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI4MzI1NQ==", "bodyText": "ok\uff0ci'll fix it", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563283255", "createdAt": "2021-01-24T12:14:22Z", "author": {"login": "luyuncheng"}, "path": ".github/workflows/CI.yml", "diffHunk": "@@ -4,6 +4,7 @@ on:\n     branches:\n       - master\n       - opendistro-*\n+      - faiss*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjI1OTExMg=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MDU3NzcxOnYy", "diffSide": "RIGHT", "path": ".github/workflows/test-workflow.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQyMzoxNjowMVrOIYNn4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQyMzoxNjowMVrOIYNn4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjI1OTkzOQ==", "bodyText": "Same as above. Please remove.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562259939", "createdAt": "2021-01-21T23:16:01Z", "author": {"login": "jmazanec15"}, "path": ".github/workflows/test-workflow.yml", "diffHunk": "@@ -5,10 +5,12 @@ on:\n     branches:\n       - master\n       - opendistro-*\n+      - faiss*\n   push:\n     branches:\n       - master\n       - opendistro-*\n+      - faiss*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAwNjkyOnYy", "diffSide": "RIGHT", "path": "jniFaiss/CMakeLists.txt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjowOTo0MlrOIY3Ppg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNFQxMjoxNTozN1rOIZMFzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0MTg2Mg==", "bodyText": "I think this might be better for CMakeLists.txt: https://gist.github.com/jmazanec15/da1e68aed9073c7d4706597ba8ef2087.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562941862", "createdAt": "2021-01-22T22:09:42Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,108 @@\n+cmake_minimum_required(VERSION 2.8)\n+\n+project(KNNIndex_FAISS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI4MzQwNQ==", "bodyText": "nice code! i'll use this one", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563283405", "createdAt": "2021-01-24T12:15:37Z", "author": {"login": "luyuncheng"}, "path": "jniFaiss/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,108 @@\n+cmake_minimum_required(VERSION 2.8)\n+\n+project(KNNIndex_FAISS)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0MTg2Mg=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAxMTk1OnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxMTozNlrOIY3Ssg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMzoxMToyMVrOIZ-TUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0MjY0Mg==", "bodyText": "Doesn't FAISS also have cosine space?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562942642", "createdAt": "2021-01-22T22:11:36Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI5NTg1Mw==", "bodyText": "In Doc Faiss-indexes , i added inner product, which means If we have normalized vectors, the inner product becomes cosine similarity.\nAnd there is some issues talk about this: facebookresearch/faiss#593", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563295853", "createdAt": "2021-01-24T13:50:32Z", "author": {"login": "luyuncheng"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0MjY0Mg=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDEwNjA2Nw==", "bodyText": "Oh interesting. That makes sense.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r564106067", "createdAt": "2021-01-25T23:11:21Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0MjY0Mg=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAxNDYxOnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxMjo1MFrOIY3UdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxMjo1MFrOIY3UdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0MzA5Mg==", "bodyText": "Can you add a TODO for future to abstract out common logic from JNI levels? This does not have to be completed in this PR, but we should do it in the future.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562943092", "createdAt": "2021-01-22T22:12:50Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAxODM2OnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxNDozNlrOIY3W0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQwNToyNjoyNVrOIZXeyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0MzY5Nw==", "bodyText": "I think instead of setting L2 as default, we should just make sure that spaceType is passed in and is valid. Setting L2 as default here could lead to silent failures.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562943697", "createdAt": "2021-01-22T22:14:36Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ3MDAyNA==", "bodyText": "L72 just init a default value. at L121 i verify the Metric Space:\nif(mapMetric.find(spaceTypeString) != mapMetric.end()) {\n    metric = mapMetric[spaceTypeString];\n}\n\nI have a question: if we verify the metricSpace in the jni code. this may cause ES shard failed assert when an invalid space param passed in jni code.  should i throw an exception when mapMetric can not find spaceTypeString?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563470024", "createdAt": "2021-01-25T05:26:25Z", "author": {"login": "luyuncheng"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0MzY5Nw=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAxOTYzOnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxNToxMFrOIY3XlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxNToxMFrOIY3XlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0Mzg5Mw==", "bodyText": "Indentation in this file looks off. Could you please fix?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562943893", "createdAt": "2021-01-22T22:15:10Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAyMzI4OnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxNjozNVrOIY3Zww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxNjozNVrOIY3Zww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NDQ1MQ==", "bodyText": "Could you add a TODO here to eventually parametrize this? I think we should be able to support any Faiss index in the future.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562944451", "createdAt": "2021-01-22T22:16:35Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAyNzQ1OnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxODoxMFrOIY3cKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMzoxMDoxM1rOIZ-RXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NTA2NQ==", "bodyText": "Why do we need to sscanf here?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562945065", "createdAt": "2021-01-22T22:18:10Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMxOTI0NQ==", "bodyText": "Why do we need to sscanf here?\n\nIn the KNN plugin we would make algoParam like: M=32, efSearch=20, As faiss index factory docs shows, if M=32 we need use string: HNSW32 for index Description. so i use sscanf to get M.\ni think we need an adapter to match different knnEngine algorithms params. if you have good idea, pls let me know.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563319245", "createdAt": "2021-01-24T16:52:34Z", "author": {"login": "luyuncheng"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NTA2NQ=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDEwNTU2NA==", "bodyText": "Ah got it. I think makes sense.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r564105564", "createdAt": "2021-01-25T23:10:13Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NTA2NQ=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAzMDQ4OnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxOToxOFrOIY3eDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxOToxOFrOIY3eDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NTU0OQ==", "bodyText": "Yeah I was thinking about this a little bit. It seems like it might make sense to fall back to a flat index if we do not have enough points to train. But we can think about this later.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562945549", "createdAt": "2021-01-22T22:19:18Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {\n+                indexDescription=\"HNSW\"+std::to_string(M);\n+            }\n+            env->ReleaseStringUTFChars(param, rawString);\n+\n+        }\n+\t\thas_exception_in_stack(env);\n+\n+\n+\t\t//---- space\n+\t\tconst char *spaceTypeCStr = env->GetStringUTFChars(spaceType, 0);\n+        string spaceTypeString(spaceTypeCStr);\n+        env->ReleaseStringUTFChars(spaceType, spaceTypeCStr);\n+        has_exception_in_stack(env);\n+\t\t// space mapping faiss::MetricType\n+\t\tif(mapMetric.find(spaceTypeString) != mapMetric.end()) {\n+\t\t\tmetric = mapMetric[spaceTypeString];\n+\t\t}\n+\n+\t\t//---- Create IndexWriter from faiss index_factory\n+\t\tindexWriter.reset(faiss::index_factory(dim, indexDescription.data(), metric));\n+\n+\t\t//Preparation And TODO Verify IndexWriter\n+\t\t//Some Param Can not Create from IndexFactory, Like HNSW efSearch and efCOnstruction\n+\t\t//----FOR HNSW 1st PARAM: M(HNSW32->M=32), efConstruction, efSearch\n+\t\tif(indexDescription.find(\"HNSW\") != std::string::npos) {\n+\t\t    for(int i = 0; i < paramsCount; ++i) {\n+\t\t        const string& param = paramsList[i];\n+\t\t        int efConstruction = 40; //default\n+\t\t        int efSearch = 16;//default\n+\t\t        if(param.find(\"efConstruction\") != std::string::npos &&\n+\t\t            sscanf(param.data(), \"efConstruction=%d\", &efConstruction) == 1) {\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efConstruction = efConstruction;\n+\t\t        } else if (param.find(\"efSearch\") != std::string::npos &&\n+                            sscanf(param.data(), \"efSearch=%d\", &efSearch) == 1){\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efSearch = efSearch;\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\n+\t\t//---- Do Index\n+\t\t//----- 1. Train\n+        if(!indexWriter->is_trained) {\n+\t\t\t//TODO if we use like PQ, we have to train dataset", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTAzMTU0OnYy", "diffSide": "RIGHT", "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoxOTo0NlrOIY3euA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMzowOTo0MFrOIZ-Qgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NTcyMA==", "bodyText": "Why is this commented out?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562945720", "createdAt": "2021-01-22T22:19:46Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {\n+                indexDescription=\"HNSW\"+std::to_string(M);\n+            }\n+            env->ReleaseStringUTFChars(param, rawString);\n+\n+        }\n+\t\thas_exception_in_stack(env);\n+\n+\n+\t\t//---- space\n+\t\tconst char *spaceTypeCStr = env->GetStringUTFChars(spaceType, 0);\n+        string spaceTypeString(spaceTypeCStr);\n+        env->ReleaseStringUTFChars(spaceType, spaceTypeCStr);\n+        has_exception_in_stack(env);\n+\t\t// space mapping faiss::MetricType\n+\t\tif(mapMetric.find(spaceTypeString) != mapMetric.end()) {\n+\t\t\tmetric = mapMetric[spaceTypeString];\n+\t\t}\n+\n+\t\t//---- Create IndexWriter from faiss index_factory\n+\t\tindexWriter.reset(faiss::index_factory(dim, indexDescription.data(), metric));\n+\n+\t\t//Preparation And TODO Verify IndexWriter\n+\t\t//Some Param Can not Create from IndexFactory, Like HNSW efSearch and efCOnstruction\n+\t\t//----FOR HNSW 1st PARAM: M(HNSW32->M=32), efConstruction, efSearch\n+\t\tif(indexDescription.find(\"HNSW\") != std::string::npos) {\n+\t\t    for(int i = 0; i < paramsCount; ++i) {\n+\t\t        const string& param = paramsList[i];\n+\t\t        int efConstruction = 40; //default\n+\t\t        int efSearch = 16;//default\n+\t\t        if(param.find(\"efConstruction\") != std::string::npos &&\n+\t\t            sscanf(param.data(), \"efConstruction=%d\", &efConstruction) == 1) {\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efConstruction = efConstruction;\n+\t\t        } else if (param.find(\"efSearch\") != std::string::npos &&\n+                            sscanf(param.data(), \"efSearch=%d\", &efSearch) == 1){\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efSearch = efSearch;\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\n+\t\t//---- Do Index\n+\t\t//----- 1. Train\n+        if(!indexWriter->is_trained) {\n+\t\t\t//TODO if we use like PQ, we have to train dataset\n+\t\t\t// but when a lucene segment only one document, it\n+\t\t\t// can not train the data.\n+\t\t}\n+\t\t//----- 2. Add IDMap\n+\t\t// default all use self defined IndexIDMap cause some class no add_with_ids\n+\t\tfaiss::IndexIDMap idMap =  faiss::IndexIDMap(indexWriter.get());\n+\t\tidMap.add_with_ids(idVector.size(), dataset.data(), idVector.data());\n+\n+\t\t//----- 3. WriteIndex\n+\t\tfaiss::write_index(&idMap, indexPathString.c_str());\n+\t\t\n+\t\t//Explicit delete object\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\n+\t}\n+\tcatch(...) {\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\t\tcatch_cpp_exception_and_throw_java(env);\n+\t}\n+}\n+\n+\n+JNIEXPORT jobjectArray JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_queryIndex\n+(JNIEnv* env, jclass cls, jlong indexPointer, jfloatArray queryVector, jint k)\n+{\n+\tfaiss::Index *indexReader = nullptr;\n+\ttry {\n+\t\tindexReader = reinterpret_cast<faiss::Index*>(indexPointer);\n+\t\tfloat* rawQueryvector = env->GetFloatArrayElements(queryVector, 0);\n+\t\tint dim\t= env->GetArrayLength(queryVector);\n+\n+\t\tstd::vector<float> dis(k * dim);\n+\t\tstd::vector<faiss::Index::idx_t> ids( k * dim);\n+\t\tindexReader->search(1, rawQueryvector, k, dis.data(), ids.data());\n+\t\tenv->ReleaseFloatArrayElements(queryVector, rawQueryvector, 0);\n+\t\thas_exception_in_stack(env);\n+\n+\t\tint resultSize = k;\n+\t\t//if result is not enough, padded with -1s\n+\t\tfor(int i = 0; i < k; i++) {\n+\t\t\tif(ids[i] == -1) {\n+\t\t\t\tresultSize = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tjclass resultClass = env->FindClass(\"com/amazon/opendistroforelasticsearch/knn/index/KNNQueryResult\");\n+\t\tjmethodID allArgs = env->GetMethodID(resultClass, \"<init>\", \"(IF)V\");\n+\t\tjobjectArray results = env->NewObjectArray(resultSize, resultClass, NULL);\n+\t\tfor(int i = 0; i < resultSize; ++i) {\n+\t\t\tfloat distance = dis[i];\n+\t\t\tlong  id = ids[i];\n+\t\t\tenv->SetObjectArrayElement(results, i, env->NewObject(resultClass, allArgs, id, distance));\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+        return results;\n+\n+\t}\n+\tcatch(...) {\n+\t\tif(indexReader) delete indexReader;\n+\t\tcatch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+JNIEXPORT jlong JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_init\n+(JNIEnv* env, jclass cls,  jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\n+\tfaiss::Index* indexReader = nullptr;\n+\ttry {\n+        const char *indexPathCStr = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexPathCStr);\n+        env->ReleaseStringUTFChars(indexPath, indexPathCStr);\n+        has_exception_in_stack(env);\n+\t\t//whether set IO_FLAGS = 0 or IO_FLAG_READ_ONLYfaiss::IO_FLAG_READ_ONLY\n+\t\tindexReader = faiss::read_index(indexPathString.c_str(), faiss::IO_FLAG_READ_ONLY);\n+\t\treturn (jlong) indexReader;\n+\t} \n+\tcatch(...) {\n+        if (indexReader) delete indexReader;\n+        catch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+/**\n+ * When autoclose class do close, then delete the pointer\n+ * Method GC pointer\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_gc\n+(JNIEnv* env, jclass cls,  jlong indexPointer)\n+{\n+\ttry {\n+\t\tfaiss::Index *indexWrapper = reinterpret_cast<faiss::Index*>(indexPointer);\n+        has_exception_in_stack(env);\n+        delete indexWrapper;\n+        has_exception_in_stack(env);\n+    }\n+    catch (...) {\n+        catch_cpp_exception_and_throw_java(env);\n+    }\n+}\n+\n+/**\n+ * Method: Global Init\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_initLibrary(JNIEnv *, jclass)\n+{\n+\t//set thread 1 cause ES has Search thread\n+\t//TODO make it different at search and write\n+//\tomp_set_num_threads(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI5Njg3MA==", "bodyText": "i am no sure is it appropriate to set threads as 1 or  reuse the settings:\npublic static final String KNN_ALGO_PARAM_INDEX_THREAD_QTY = \"knn.algo_param.index_thread_qty\";", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563296870", "createdAt": "2021-01-24T13:58:41Z", "author": {"login": "luyuncheng"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {\n+                indexDescription=\"HNSW\"+std::to_string(M);\n+            }\n+            env->ReleaseStringUTFChars(param, rawString);\n+\n+        }\n+\t\thas_exception_in_stack(env);\n+\n+\n+\t\t//---- space\n+\t\tconst char *spaceTypeCStr = env->GetStringUTFChars(spaceType, 0);\n+        string spaceTypeString(spaceTypeCStr);\n+        env->ReleaseStringUTFChars(spaceType, spaceTypeCStr);\n+        has_exception_in_stack(env);\n+\t\t// space mapping faiss::MetricType\n+\t\tif(mapMetric.find(spaceTypeString) != mapMetric.end()) {\n+\t\t\tmetric = mapMetric[spaceTypeString];\n+\t\t}\n+\n+\t\t//---- Create IndexWriter from faiss index_factory\n+\t\tindexWriter.reset(faiss::index_factory(dim, indexDescription.data(), metric));\n+\n+\t\t//Preparation And TODO Verify IndexWriter\n+\t\t//Some Param Can not Create from IndexFactory, Like HNSW efSearch and efCOnstruction\n+\t\t//----FOR HNSW 1st PARAM: M(HNSW32->M=32), efConstruction, efSearch\n+\t\tif(indexDescription.find(\"HNSW\") != std::string::npos) {\n+\t\t    for(int i = 0; i < paramsCount; ++i) {\n+\t\t        const string& param = paramsList[i];\n+\t\t        int efConstruction = 40; //default\n+\t\t        int efSearch = 16;//default\n+\t\t        if(param.find(\"efConstruction\") != std::string::npos &&\n+\t\t            sscanf(param.data(), \"efConstruction=%d\", &efConstruction) == 1) {\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efConstruction = efConstruction;\n+\t\t        } else if (param.find(\"efSearch\") != std::string::npos &&\n+                            sscanf(param.data(), \"efSearch=%d\", &efSearch) == 1){\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efSearch = efSearch;\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\n+\t\t//---- Do Index\n+\t\t//----- 1. Train\n+        if(!indexWriter->is_trained) {\n+\t\t\t//TODO if we use like PQ, we have to train dataset\n+\t\t\t// but when a lucene segment only one document, it\n+\t\t\t// can not train the data.\n+\t\t}\n+\t\t//----- 2. Add IDMap\n+\t\t// default all use self defined IndexIDMap cause some class no add_with_ids\n+\t\tfaiss::IndexIDMap idMap =  faiss::IndexIDMap(indexWriter.get());\n+\t\tidMap.add_with_ids(idVector.size(), dataset.data(), idVector.data());\n+\n+\t\t//----- 3. WriteIndex\n+\t\tfaiss::write_index(&idMap, indexPathString.c_str());\n+\t\t\n+\t\t//Explicit delete object\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\n+\t}\n+\tcatch(...) {\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\t\tcatch_cpp_exception_and_throw_java(env);\n+\t}\n+}\n+\n+\n+JNIEXPORT jobjectArray JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_queryIndex\n+(JNIEnv* env, jclass cls, jlong indexPointer, jfloatArray queryVector, jint k)\n+{\n+\tfaiss::Index *indexReader = nullptr;\n+\ttry {\n+\t\tindexReader = reinterpret_cast<faiss::Index*>(indexPointer);\n+\t\tfloat* rawQueryvector = env->GetFloatArrayElements(queryVector, 0);\n+\t\tint dim\t= env->GetArrayLength(queryVector);\n+\n+\t\tstd::vector<float> dis(k * dim);\n+\t\tstd::vector<faiss::Index::idx_t> ids( k * dim);\n+\t\tindexReader->search(1, rawQueryvector, k, dis.data(), ids.data());\n+\t\tenv->ReleaseFloatArrayElements(queryVector, rawQueryvector, 0);\n+\t\thas_exception_in_stack(env);\n+\n+\t\tint resultSize = k;\n+\t\t//if result is not enough, padded with -1s\n+\t\tfor(int i = 0; i < k; i++) {\n+\t\t\tif(ids[i] == -1) {\n+\t\t\t\tresultSize = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tjclass resultClass = env->FindClass(\"com/amazon/opendistroforelasticsearch/knn/index/KNNQueryResult\");\n+\t\tjmethodID allArgs = env->GetMethodID(resultClass, \"<init>\", \"(IF)V\");\n+\t\tjobjectArray results = env->NewObjectArray(resultSize, resultClass, NULL);\n+\t\tfor(int i = 0; i < resultSize; ++i) {\n+\t\t\tfloat distance = dis[i];\n+\t\t\tlong  id = ids[i];\n+\t\t\tenv->SetObjectArrayElement(results, i, env->NewObject(resultClass, allArgs, id, distance));\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+        return results;\n+\n+\t}\n+\tcatch(...) {\n+\t\tif(indexReader) delete indexReader;\n+\t\tcatch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+JNIEXPORT jlong JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_init\n+(JNIEnv* env, jclass cls,  jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\n+\tfaiss::Index* indexReader = nullptr;\n+\ttry {\n+        const char *indexPathCStr = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexPathCStr);\n+        env->ReleaseStringUTFChars(indexPath, indexPathCStr);\n+        has_exception_in_stack(env);\n+\t\t//whether set IO_FLAGS = 0 or IO_FLAG_READ_ONLYfaiss::IO_FLAG_READ_ONLY\n+\t\tindexReader = faiss::read_index(indexPathString.c_str(), faiss::IO_FLAG_READ_ONLY);\n+\t\treturn (jlong) indexReader;\n+\t} \n+\tcatch(...) {\n+        if (indexReader) delete indexReader;\n+        catch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+/**\n+ * When autoclose class do close, then delete the pointer\n+ * Method GC pointer\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_gc\n+(JNIEnv* env, jclass cls,  jlong indexPointer)\n+{\n+\ttry {\n+\t\tfaiss::Index *indexWrapper = reinterpret_cast<faiss::Index*>(indexPointer);\n+        has_exception_in_stack(env);\n+        delete indexWrapper;\n+        has_exception_in_stack(env);\n+    }\n+    catch (...) {\n+        catch_cpp_exception_and_throw_java(env);\n+    }\n+}\n+\n+/**\n+ * Method: Global Init\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_initLibrary(JNIEnv *, jclass)\n+{\n+\t//set thread 1 cause ES has Search thread\n+\t//TODO make it different at search and write\n+//\tomp_set_num_threads(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NTcyMA=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDEwNTM0Nw==", "bodyText": "I think it probably makes sense to reuse KNN_ALGO_PARAM_INDEX_THREAD_QTY.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r564105347", "createdAt": "2021-01-25T23:09:40Z", "author": {"login": "jmazanec15"}, "path": "jniFaiss/src/com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.cpp", "diffHunk": "@@ -0,0 +1,272 @@\n+#include \"com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex.h\"\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+#include <sys/time.h>\n+#include <omp.h>\n+\n+#include \"faiss/index_factory.h\"\n+#include \"faiss/MetaIndexes.h\"\n+#include \"faiss/index_io.h\"\n+#include \"faiss/IndexHNSW.h\"\n+\n+\n+using std::string;\n+using std::vector;\n+\n+std::unordered_map<string, faiss::MetricType> mapMetric = {\n+        {\"l2\", faiss::METRIC_L2},\n+        {\"innerproduct\", faiss::METRIC_INNER_PRODUCT}\n+};\n+\n+extern \"C\"\n+\n+struct JavaException {\n+    JavaException(JNIEnv* env, const char* type = \"\", const char* message = \"\")\n+    {\n+        jclass newExcCls = env->FindClass(type);\n+        if (newExcCls != NULL)\n+            env->ThrowNew(newExcCls, message);\n+    }\n+};\n+\n+inline void has_exception_in_stack(JNIEnv* env)\n+{\n+    if (env->ExceptionCheck() == JNI_TRUE)\n+        throw std::runtime_error(\"Exception Occured\");\n+}\n+\n+void catch_cpp_exception_and_throw_java(JNIEnv* env)\n+{\n+    try {\n+        throw;\n+    }\n+    catch (const std::bad_alloc& rhs) {\n+        JavaException(env, \"java/io/IOException\", rhs.what());\n+    }\n+    catch (const std::runtime_error& re) {\n+        JavaException(env, \"java/lang/Exception\", re.what());\n+    }\n+    catch (const std::exception& e) {\n+        JavaException(env, \"java/lang/Exception\", e.what());\n+    }\n+    catch (...) {\n+        JavaException(env, \"java/lang/Exception\", \"Unknown exception occured\");\n+    }\n+}\n+\n+/**\n+ * Method: saveIndex\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_saveIndex\n+(JNIEnv* env, jclass cls, jintArray ids, jobjectArray vectors, jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\tvector<int64_t> idVector;\n+\tvector<float>   dataset;\n+\tvector<string> paramsList;\n+\tstring indexDescription = \"HNSW32\";\n+\tfaiss::MetricType metric = faiss::METRIC_L2;\n+\tstd::unique_ptr<faiss::Index> indexWriter;\n+\tint dim = 0;\n+\ttry {\n+\t\t//---- ids\n+\t\tint* object_ids = NULL;\n+\t\tobject_ids = env->GetIntArrayElements(ids, 0);\n+\t\tfor(int i = 0; i < env->GetArrayLength(ids); ++i) {\n+\t\t\tidVector.push_back(object_ids[i]);\n+\t\t}\n+\t\tenv->ReleaseIntArrayElements(ids, object_ids, 0);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- vectors\n+\t\tfor (int i = 0; i < env->GetArrayLength(vectors); ++i) {\n+\t\t\tjfloatArray vectorArray = (jfloatArray)env->GetObjectArrayElement(vectors, i);\n+\t\t\tfloat* vector = env->GetFloatArrayElements(vectorArray, 0);\n+\t\t\tdim = env->GetArrayLength(vectorArray);\n+\t\t\tfor(int j = 0; j < dim; ++j) {\n+\t\t\t\tdataset.push_back(vector[j]);\n+\t\t\t}\n+\t\t\tenv->ReleaseFloatArrayElements(vectorArray, vector, 0);\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+\n+\t\t//---- indexPath\n+\t\tconst char *indexString = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexString);\n+        env->ReleaseStringUTFChars(indexPath, indexString);\n+        has_exception_in_stack(env);\n+\n+\t\t//---- algoParams\n+\t\tint paramsCount = env->GetArrayLength(algoParams);\n+        for (int i=0; i<paramsCount; i++) {\n+            jstring param = (jstring) (env->GetObjectArrayElement(algoParams, i));\n+            const char *rawString = env->GetStringUTFChars(param, 0);\n+            paramsList.push_back(rawString);\n+\n+            int M = 32;\n+            if (sscanf(rawString, \"M=%d\", &M) == 1) {\n+                indexDescription=\"HNSW\"+std::to_string(M);\n+            }\n+            env->ReleaseStringUTFChars(param, rawString);\n+\n+        }\n+\t\thas_exception_in_stack(env);\n+\n+\n+\t\t//---- space\n+\t\tconst char *spaceTypeCStr = env->GetStringUTFChars(spaceType, 0);\n+        string spaceTypeString(spaceTypeCStr);\n+        env->ReleaseStringUTFChars(spaceType, spaceTypeCStr);\n+        has_exception_in_stack(env);\n+\t\t// space mapping faiss::MetricType\n+\t\tif(mapMetric.find(spaceTypeString) != mapMetric.end()) {\n+\t\t\tmetric = mapMetric[spaceTypeString];\n+\t\t}\n+\n+\t\t//---- Create IndexWriter from faiss index_factory\n+\t\tindexWriter.reset(faiss::index_factory(dim, indexDescription.data(), metric));\n+\n+\t\t//Preparation And TODO Verify IndexWriter\n+\t\t//Some Param Can not Create from IndexFactory, Like HNSW efSearch and efCOnstruction\n+\t\t//----FOR HNSW 1st PARAM: M(HNSW32->M=32), efConstruction, efSearch\n+\t\tif(indexDescription.find(\"HNSW\") != std::string::npos) {\n+\t\t    for(int i = 0; i < paramsCount; ++i) {\n+\t\t        const string& param = paramsList[i];\n+\t\t        int efConstruction = 40; //default\n+\t\t        int efSearch = 16;//default\n+\t\t        if(param.find(\"efConstruction\") != std::string::npos &&\n+\t\t            sscanf(param.data(), \"efConstruction=%d\", &efConstruction) == 1) {\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efConstruction = efConstruction;\n+\t\t        } else if (param.find(\"efSearch\") != std::string::npos &&\n+                            sscanf(param.data(), \"efSearch=%d\", &efSearch) == 1){\n+                        faiss::IndexHNSW* ihp = reinterpret_cast<faiss::IndexHNSW*>(indexWriter.get());\n+                        ihp->hnsw.efSearch = efSearch;\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\n+\t\t//---- Do Index\n+\t\t//----- 1. Train\n+        if(!indexWriter->is_trained) {\n+\t\t\t//TODO if we use like PQ, we have to train dataset\n+\t\t\t// but when a lucene segment only one document, it\n+\t\t\t// can not train the data.\n+\t\t}\n+\t\t//----- 2. Add IDMap\n+\t\t// default all use self defined IndexIDMap cause some class no add_with_ids\n+\t\tfaiss::IndexIDMap idMap =  faiss::IndexIDMap(indexWriter.get());\n+\t\tidMap.add_with_ids(idVector.size(), dataset.data(), idVector.data());\n+\n+\t\t//----- 3. WriteIndex\n+\t\tfaiss::write_index(&idMap, indexPathString.c_str());\n+\t\t\n+\t\t//Explicit delete object\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\n+\t}\n+\tcatch(...) {\n+\t\tfaiss::Index* indexPointer = indexWriter.release();\n+\t\tif(indexPointer) delete indexPointer;\n+\t\tcatch_cpp_exception_and_throw_java(env);\n+\t}\n+}\n+\n+\n+JNIEXPORT jobjectArray JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_queryIndex\n+(JNIEnv* env, jclass cls, jlong indexPointer, jfloatArray queryVector, jint k)\n+{\n+\tfaiss::Index *indexReader = nullptr;\n+\ttry {\n+\t\tindexReader = reinterpret_cast<faiss::Index*>(indexPointer);\n+\t\tfloat* rawQueryvector = env->GetFloatArrayElements(queryVector, 0);\n+\t\tint dim\t= env->GetArrayLength(queryVector);\n+\n+\t\tstd::vector<float> dis(k * dim);\n+\t\tstd::vector<faiss::Index::idx_t> ids( k * dim);\n+\t\tindexReader->search(1, rawQueryvector, k, dis.data(), ids.data());\n+\t\tenv->ReleaseFloatArrayElements(queryVector, rawQueryvector, 0);\n+\t\thas_exception_in_stack(env);\n+\n+\t\tint resultSize = k;\n+\t\t//if result is not enough, padded with -1s\n+\t\tfor(int i = 0; i < k; i++) {\n+\t\t\tif(ids[i] == -1) {\n+\t\t\t\tresultSize = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tjclass resultClass = env->FindClass(\"com/amazon/opendistroforelasticsearch/knn/index/KNNQueryResult\");\n+\t\tjmethodID allArgs = env->GetMethodID(resultClass, \"<init>\", \"(IF)V\");\n+\t\tjobjectArray results = env->NewObjectArray(resultSize, resultClass, NULL);\n+\t\tfor(int i = 0; i < resultSize; ++i) {\n+\t\t\tfloat distance = dis[i];\n+\t\t\tlong  id = ids[i];\n+\t\t\tenv->SetObjectArrayElement(results, i, env->NewObject(resultClass, allArgs, id, distance));\n+\t\t}\n+\t\thas_exception_in_stack(env);\n+        return results;\n+\n+\t}\n+\tcatch(...) {\n+\t\tif(indexReader) delete indexReader;\n+\t\tcatch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+JNIEXPORT jlong JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_init\n+(JNIEnv* env, jclass cls,  jstring indexPath, jobjectArray algoParams, jstring spaceType)\n+{\n+\n+\tfaiss::Index* indexReader = nullptr;\n+\ttry {\n+        const char *indexPathCStr = env->GetStringUTFChars(indexPath, 0);\n+        string indexPathString(indexPathCStr);\n+        env->ReleaseStringUTFChars(indexPath, indexPathCStr);\n+        has_exception_in_stack(env);\n+\t\t//whether set IO_FLAGS = 0 or IO_FLAG_READ_ONLYfaiss::IO_FLAG_READ_ONLY\n+\t\tindexReader = faiss::read_index(indexPathString.c_str(), faiss::IO_FLAG_READ_ONLY);\n+\t\treturn (jlong) indexReader;\n+\t} \n+\tcatch(...) {\n+        if (indexReader) delete indexReader;\n+        catch_cpp_exception_and_throw_java(env);\t\n+\t}\n+\treturn NULL;\n+}\n+\n+/**\n+ * When autoclose class do close, then delete the pointer\n+ * Method GC pointer\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_gc\n+(JNIEnv* env, jclass cls,  jlong indexPointer)\n+{\n+\ttry {\n+\t\tfaiss::Index *indexWrapper = reinterpret_cast<faiss::Index*>(indexPointer);\n+        has_exception_in_stack(env);\n+        delete indexWrapper;\n+        has_exception_in_stack(env);\n+    }\n+    catch (...) {\n+        catch_cpp_exception_and_throw_java(env);\n+    }\n+}\n+\n+/**\n+ * Method: Global Init\n+ *\n+ */\n+JNIEXPORT void JNICALL Java_com_amazon_opendistroforelasticsearch_knn_index_faiss_v164_KNNFIndex_initLibrary(JNIEnv *, jclass)\n+{\n+\t//set thread 1 cause ES has Search thread\n+\t//TODO make it different at search and write\n+//\tomp_set_num_threads(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NTcyMA=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NTA0MzIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjoyNToyMlrOIY3mBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMzowOTowNVrOIZ-PfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NzU4OA==", "bodyText": "Seems to me that knnIndex and knnFindex should inherit from some kind of abstract class.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r562947588", "createdAt": "2021-01-22T22:25:22Z", "author": {"login": "jmazanec15"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -320,22 +339,52 @@ public KNNIndexCacheEntry loadIndex(String indexPathUrl, String indexName) throw\n      * upon expiration of the cache.\n      */\n     private static class KNNIndexCacheEntry {\n+\n         private final KNNIndex knnIndex;\n+        private final KNNFIndex knnFindex;\n         private final String indexPathUrl;\n         private final String esIndexName;\n         private final WatcherHandle<FileWatcher> fileWatcherHandle;\n \n         private KNNIndexCacheEntry(final KNNIndex knnIndex, final String indexPathUrl, final String esIndexName,\n                                    final WatcherHandle<FileWatcher> fileWatcherHandle) {\n             this.knnIndex = knnIndex;\n+            this.knnFindex = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMxNzU1NQ==", "bodyText": "I see. I think we should add a different file extension for faiss graphs as opposed to nmslib graphs. Maybe .faiss_hnsw.\n\nin the latest commit, i use knnEngine name in the index file names like:\nString hnswFileName = String.format(\"%s_%s_%s%s\", \n    state.segmentInfo.name, \n    knnEngine.getLatestBuildVersion(),\n    field.name, \n    KNNCodecUtil.HNSW_EXTENSION);\n\n\nSeems to me that knnIndex and knnFindex should inherit from some kind of abstract class.\n\nyes, you are right. let me think about how to abstract this.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563317555", "createdAt": "2021-01-24T16:38:30Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -320,22 +339,52 @@ public KNNIndexCacheEntry loadIndex(String indexPathUrl, String indexName) throw\n      * upon expiration of the cache.\n      */\n     private static class KNNIndexCacheEntry {\n+\n         private final KNNIndex knnIndex;\n+        private final KNNFIndex knnFindex;\n         private final String indexPathUrl;\n         private final String esIndexName;\n         private final WatcherHandle<FileWatcher> fileWatcherHandle;\n \n         private KNNIndexCacheEntry(final KNNIndex knnIndex, final String indexPathUrl, final String esIndexName,\n                                    final WatcherHandle<FileWatcher> fileWatcherHandle) {\n             this.knnIndex = knnIndex;\n+            this.knnFindex = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NzU4OA=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUzNzYwNw==", "bodyText": "Seems to me that knnIndex and knnFindex should inherit from some kind of abstract class.\n\nI used KNNIndex as abstract class. KNNFaissIndex and KNNNmsLibIndex extends the KNNINdex.\nKNNIndexCacheEntry only save the KNNIndex.\nif you have any other idea, pls let me know", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r563537607", "createdAt": "2021-01-25T08:30:21Z", "author": {"login": "luyuncheng"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -320,22 +339,52 @@ public KNNIndexCacheEntry loadIndex(String indexPathUrl, String indexName) throw\n      * upon expiration of the cache.\n      */\n     private static class KNNIndexCacheEntry {\n+\n         private final KNNIndex knnIndex;\n+        private final KNNFIndex knnFindex;\n         private final String indexPathUrl;\n         private final String esIndexName;\n         private final WatcherHandle<FileWatcher> fileWatcherHandle;\n \n         private KNNIndexCacheEntry(final KNNIndex knnIndex, final String indexPathUrl, final String esIndexName,\n                                    final WatcherHandle<FileWatcher> fileWatcherHandle) {\n             this.knnIndex = knnIndex;\n+            this.knnFindex = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NzU4OA=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDEwNTA4NQ==", "bodyText": "I think that makes sense. Thanks for making the change!", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/285#discussion_r564105085", "createdAt": "2021-01-25T23:09:05Z", "author": {"login": "jmazanec15"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -320,22 +339,52 @@ public KNNIndexCacheEntry loadIndex(String indexPathUrl, String indexName) throw\n      * upon expiration of the cache.\n      */\n     private static class KNNIndexCacheEntry {\n+\n         private final KNNIndex knnIndex;\n+        private final KNNFIndex knnFindex;\n         private final String indexPathUrl;\n         private final String esIndexName;\n         private final WatcherHandle<FileWatcher> fileWatcherHandle;\n \n         private KNNIndexCacheEntry(final KNNIndex knnIndex, final String indexPathUrl, final String esIndexName,\n                                    final WatcherHandle<FileWatcher> fileWatcherHandle) {\n             this.knnIndex = knnIndex;\n+            this.knnFindex = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NzU4OA=="}, "originalCommit": {"oid": "d37a523a778eaed5959175fbe8d1e202721eafac"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2695, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}