{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NDk1MTk1", "number": 177, "title": "Performance tuning/Recommendations", "bodyText": "Issue #, if available:\n#64\nDescription of changes:\nAdds Performance tuning/Recommendations to improve indexing/search performance.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-07-24T21:19:15Z", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177", "merged": true, "mergeCommit": {"oid": "ac83e49c26d02d71ddcd2f9df3aa5b8689e90daf"}, "closed": true, "closedAt": "2020-07-28T22:41:30Z", "author": {"login": "vamshin"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc23UUhAH2gAyNDU2NDk1MTk1OjQ2NWUxZjA3ZDQxYzkxMDMyNGE2ZWVlMDM5NzE2MTIzNDc2NGZmNzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5dyIRAFqTQ1NzA2MDEyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "465e1f07d41c910324a6eee0397161234764ff78", "author": {"user": {"login": "vamshin", "name": "Vamshi Vijay Nakkirtha"}}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/465e1f07d41c910324a6eee0397161234764ff78", "committedDate": "2020-07-20T20:04:58Z", "message": "synced from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e29432b8335642fc4727617c7377115618605a51", "author": {"user": {"login": "vamshin", "name": "Vamshi Vijay Nakkirtha"}}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/e29432b8335642fc4727617c7377115618605a51", "committedDate": "2020-07-24T20:33:41Z", "message": "Merge branch 'master' of github.com:opendistro-for-elasticsearch/k-NN"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980", "author": {"user": {"login": "vamshin", "name": "Vamshi Vijay Nakkirtha"}}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/46330950b1d4197cd8ad88f53f8d3111f44c7980", "committedDate": "2020-07-24T21:17:43Z", "message": "add performance tuning doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTk4MDAy", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#pullrequestreview-455198002", "createdAt": "2020-07-24T21:35:09Z", "commit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMTozNTowOVrOG2-YgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMjo1ODozM1rOG2_0vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5ODM2OA==", "bodyText": "replace \"In this section\" with \"In this document,\"\nAlso, replace \"On a high level\" with \"From a high level,\"\nAlso, add a \":\" after principles.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460298368", "createdAt": "2020-07-24T21:35:09Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5ODgyNg==", "bodyText": "Remove the period at the end if it is a list item", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460298826", "createdAt": "2020-07-24T21:36:40Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5OTM0MQ==", "bodyText": "Same as above\nAlso instead of adding single quotes around k, just Italicize it like *k*. Do the same with size.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460299341", "createdAt": "2020-07-24T21:38:14Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwOTE1OQ==", "bodyText": "Start sentence with \"The\".", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460309159", "createdAt": "2020-07-24T22:10:24Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwOTM1MA==", "bodyText": "Could you add a sentence description here?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460309350", "createdAt": "2020-07-24T22:11:14Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwOTUxMg==", "bodyText": "Change this to \"Enable Replicas after indexing\"", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460309512", "createdAt": "2020-07-24T22:11:43Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwOTc2MQ==", "bodyText": "Is there any risk associated with not having replicas during indexing?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460309761", "createdAt": "2020-07-24T22:12:28Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMxODMxNg==", "bodyText": "I think I gave wrong information on this. I believe Lucene's IndexSearcher uses a threadpool to search over different segments concurrently, right?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460318316", "createdAt": "2020-07-24T22:43:45Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Might not needed but to ensure the buffer is cleared and all segments are up. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)\n+\n+* We can now enable replicas to copy the serialized graphs\n+\n+*  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+##Search Performance Tuning\n+\n+### Warm up\n+\n+The graphs are constructed during indexing, but they are loaded into memory during the first search. The way search works in Lucene is that each segment is searched sequentially (so, for k-NN, each segment returns up to k nearest neighbors of the query point) and the results are aggregated together and ranked based on the score of each result (higher score --> better result). ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMTQxNQ==", "bodyText": "So, say we have a somewhat sizeable shard, but within the Elasticsearch recommendation. Say 20 GB. In this case, it probably wouldn't make sense to have a single segment right? Would it be better to discuss the tradeoff instead of just saying 1 segment?\n\"Lucene's IndexSearcher will search over all of the segments in a shard to find the size best results. Searching over a large amount of smaller graphs and then selecting the top size results may result in higher recall than just searching over a smaller number of larger graphs. But, because the complexity of search for the HNSW algorithm is logarithmic with respect to the number of vectors, searching over 5 graphs with a 100 vectors each and then taking the top size results from 5*k results will take longer than searching over 1 graph with 500 vectors and then taking the top size results from k results (ignoring concurrency for the sake of example). That being said, it is important to understand your system's requirements for latency and accuracy, and then to choose the number of segments you want your index to have based on experimentation.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460321415", "createdAt": "2020-07-24T22:56:13Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMTU3Nw==", "bodyText": "has instead of have.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460321577", "createdAt": "2020-07-24T22:56:50Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMTY2MQ==", "bodyText": "Add comment here describing in more depth", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460321661", "createdAt": "2020-07-24T22:57:13Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMTgwNA==", "bodyText": "I dont think you will need to do this. If forcemerge times out, it will continue to run.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460321804", "createdAt": "2020-07-24T22:57:53Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMTkxNQ==", "bodyText": "Please add description for how this helps", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460321915", "createdAt": "2020-07-24T22:58:21Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Might not needed but to ensure the buffer is cleared and all segments are up. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMTk4MA==", "bodyText": "Could you add description here?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r460321980", "createdAt": "2020-07-24T22:58:33Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7a429f2820c67a61cd8656c17519e3a547feb68", "author": {"user": {"login": "vamshin", "name": "Vamshi Vijay Nakkirtha"}}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/a7a429f2820c67a61cd8656c17519e3a547feb68", "committedDate": "2020-07-25T05:54:19Z", "message": "incorporated comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a", "author": {"user": {"login": "vamshin", "name": "Vamshi Vijay Nakkirtha"}}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/330076a7c161280ab679c26226c2f44ec1e19d5a", "committedDate": "2020-07-27T23:15:58Z", "message": "incorporated comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MjA5NzE5", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#pullrequestreview-456209719", "createdAt": "2020-07-27T23:48:28Z", "commit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzo0ODoyOFrOG33ftQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzo0OTo1N1rOG33hdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNDEwMQ==", "bodyText": "Ah so I think whats confusing on this point is that it references \"the following steps\", but they are bullet points. So, its more about the workflow that should be followed as opposed to independent tips.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461234101", "createdAt": "2020-07-27T23:48:28Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMTY2MQ=="}, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNDU1MA==", "bodyText": "Is there documentation for this?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461234550", "createdAt": "2020-07-27T23:49:57Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Might not needed but to ensure the buffer is cleared and all segments are up. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)\n+\n+* We can now enable replicas to copy the serialized graphs\n+\n+*  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+##Search Performance Tuning\n+\n+### Warm up\n+\n+The graphs are constructed during indexing, but they are loaded into memory during the first search. The way search works in Lucene is that each segment is searched sequentially (so, for k-NN, each segment returns up to k nearest neighbors of the query point) and the results are aggregated together and ranked based on the score of each result (higher score --> better result). ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMxODMxNg=="}, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2OTA3MDI0", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#pullrequestreview-456907024", "createdAt": "2020-07-28T18:40:00Z", "commit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODo0MDowMFrOG4ZmHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxOTowMjo0NlrOG4aYXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5Mjc5Ng==", "bodyText": "Add space between # and KNN", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461792796", "createdAt": "2020-07-28T18:40:00Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,157 @@\n+#KNN Performance Tuning", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5MjkwMg==", "bodyText": "Add Space", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461792902", "createdAt": "2020-07-28T18:40:12Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,157 @@\n+#KNN Performance Tuning\n+\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+##Indexing Performance Tuning", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5Mzk1OQ==", "bodyText": "If we already called force merge, we dont need to call refresh, correct?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461793959", "createdAt": "2020-07-28T18:42:12Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,157 @@\n+#KNN Performance Tuning\n+\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+##Indexing Performance Tuning\n+\n+The following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+\n+* Disable Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied. Having no replicas means that losing \n+    a node(s) may incur data loss, so it is important that the data lives elsewhere \n+    so that this initial load can be retried in case of an issue.\n+ ```\n+More details [here](https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_disable_replicas_for_initial_loads)\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose has multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5NTU2MQ==", "bodyText": "Add space", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461795561", "createdAt": "2020-07-28T18:45:08Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,157 @@\n+#KNN Performance Tuning\n+\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+##Indexing Performance Tuning\n+\n+The following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+\n+* Disable Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied. Having no replicas means that losing \n+    a node(s) may incur data loss, so it is important that the data lives elsewhere \n+    so that this initial load can be retried in case of an issue.\n+ ```\n+More details [here](https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_disable_replicas_for_initial_loads)\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose has multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Calling refresh ensure the buffer is cleared and all segments are created so that documents are available for search. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)\n+ \n+ This will make replica shards come up with the already serialized graphs created on the primary shards during indexing. This way \n+ we avoid duplicate graph construction.\n+\n+* We can now enable replicas to copy the serialized graphs\n+\n+*  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+##Search Performance Tuning\n+\n+To improve Search performance it is necessary to keep the number of segments under control. Lucene's IndexSearcher will search over all of the segments in a shard to find the 'size' best results. But, because the complexity of search for the HNSW algorithm is logarithmic with respect to the number of vectors, searching over 5 graphs with a 100 vectors each and then taking the top size results from ```5*k``` results will take longer than searching over 1 graph with 500 vectors and then taking the top size results from k results. \n+Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We could configure index to have multiple shards to aviod having giant shards and achieve more parallelism.\n+\n+We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval.\n+\n+### Warm up\n+\n+The graphs are constructed during indexing, but they are loaded into memory during the first search. The way search works in Lucene is that each segment is searched sequentially (so, for k-NN, each segment returns up to k nearest neighbors of the query point) and the results are aggregated together and ranked based on the score of each result (higher score --> better result). \n+\n+Once a graph is loaded(graphs are loaded outside Elasticsearch JVM), we cache the graphs in memory. So the initial queries would be expensive in the order of few seconds and subsequent queries should be faster in the order of milliseconds(assuming knn circuit breaker is not hit).\n+\n+In order to avoid this latency penalty during your first queries, a user should use the warmup API on the indices they want to search. The API looks like this:\n+\n+GET /_opendistro/_knn/warmup/index1,index2,index3?pretty\n+{\n+  \"_shards\" : {\n+    \"total\" : 6,\n+    \"successful\" : 6,\n+    \"failed\" : 0\n+  }\n+}\n+\n+The API loads all of the graphs for all of the shards (primaries and replicas) for the specified indices into the cache. Thus, there will be no penalty to load graphs during initial searches. *Note \u2014 * this API only loads the segments of the indices it sees into the cache. If a merge or refresh operation finishes after this API is ran or if new documents are added, this API will need to be re-ran to load those graphs into memory.\n+\n+### Avoid reading stored fields\n+\n+If the use case is to just read the nearest neighbors Ids and scores, then we could disable reading stored fields which could save some time retrieving the vectors from stored fields. \n+To understand more about stored fields, \n+please refer this [page.](https://discuss.elastic.co/t/what-does-it-mean-to-store-a-field/5893/5)\n+```\n+{\n+ \"size\": 5,\n+ \"stored_fields\": \"_none_\",\n+ \"docvalue_fields\": [\"_id\"],\n+ \"query\": {\n+   \"knn\": {\n+    \"v\": {\n+      \"vector\": [-0.16490704,-0.047262248,-0.078923926],\n+      \"k\": 50\n+     }       \n+   }\n+ }\n+}\n+```\n+##Improving Recall ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5NTYzOQ==", "bodyText": "Add space", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461795639", "createdAt": "2020-07-28T18:45:17Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,157 @@\n+#KNN Performance Tuning\n+\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+##Indexing Performance Tuning\n+\n+The following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+\n+* Disable Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied. Having no replicas means that losing \n+    a node(s) may incur data loss, so it is important that the data lives elsewhere \n+    so that this initial load can be retried in case of an issue.\n+ ```\n+More details [here](https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_disable_replicas_for_initial_loads)\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose has multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Calling refresh ensure the buffer is cleared and all segments are created so that documents are available for search. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)\n+ \n+ This will make replica shards come up with the already serialized graphs created on the primary shards during indexing. This way \n+ we avoid duplicate graph construction.\n+\n+* We can now enable replicas to copy the serialized graphs\n+\n+*  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+##Search Performance Tuning\n+\n+To improve Search performance it is necessary to keep the number of segments under control. Lucene's IndexSearcher will search over all of the segments in a shard to find the 'size' best results. But, because the complexity of search for the HNSW algorithm is logarithmic with respect to the number of vectors, searching over 5 graphs with a 100 vectors each and then taking the top size results from ```5*k``` results will take longer than searching over 1 graph with 500 vectors and then taking the top size results from k results. \n+Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We could configure index to have multiple shards to aviod having giant shards and achieve more parallelism.\n+\n+We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval.\n+\n+### Warm up\n+\n+The graphs are constructed during indexing, but they are loaded into memory during the first search. The way search works in Lucene is that each segment is searched sequentially (so, for k-NN, each segment returns up to k nearest neighbors of the query point) and the results are aggregated together and ranked based on the score of each result (higher score --> better result). \n+\n+Once a graph is loaded(graphs are loaded outside Elasticsearch JVM), we cache the graphs in memory. So the initial queries would be expensive in the order of few seconds and subsequent queries should be faster in the order of milliseconds(assuming knn circuit breaker is not hit).\n+\n+In order to avoid this latency penalty during your first queries, a user should use the warmup API on the indices they want to search. The API looks like this:\n+\n+GET /_opendistro/_knn/warmup/index1,index2,index3?pretty\n+{\n+  \"_shards\" : {\n+    \"total\" : 6,\n+    \"successful\" : 6,\n+    \"failed\" : 0\n+  }\n+}\n+\n+The API loads all of the graphs for all of the shards (primaries and replicas) for the specified indices into the cache. Thus, there will be no penalty to load graphs during initial searches. *Note \u2014 * this API only loads the segments of the indices it sees into the cache. If a merge or refresh operation finishes after this API is ran or if new documents are added, this API will need to be re-ran to load those graphs into memory.\n+\n+### Avoid reading stored fields\n+\n+If the use case is to just read the nearest neighbors Ids and scores, then we could disable reading stored fields which could save some time retrieving the vectors from stored fields. \n+To understand more about stored fields, \n+please refer this [page.](https://discuss.elastic.co/t/what-does-it-mean-to-store-a-field/5893/5)\n+```\n+{\n+ \"size\": 5,\n+ \"stored_fields\": \"_none_\",\n+ \"docvalue_fields\": [\"_id\"],\n+ \"query\": {\n+   \"knn\": {\n+    \"v\": {\n+      \"vector\": [-0.16490704,-0.047262248,-0.078923926],\n+      \"k\": 50\n+     }       \n+   }\n+ }\n+}\n+```\n+##Improving Recall \n+\n+Recall could depend on multiple factors like number of vectors, number of dimensions, segments etc. Searching over large number of small segments and aggregating the results leads better recall than searching over small number of large segments and aggregating results. The larger the graph the more chances of losing recall if sticking to smaller algorithm parameters. \n+Choosing larger values for algorithm params should help solve this issue but at the cost of search latency and indexing time. That being said, it is important to understand your system's requirements for latency and accuracy, and then to choose the number of segments you want your index to have based on experimentation.\n+\n+Recall can be configured by adjusting the algorithm parameters of hnsw algorithm exposed through index settings. Algorithm params that control the recall are *m, ef_construction, ef_search*. For more details on influence of algorithm parameters on the indexing, search recall, please refer this  doc (https://github.com/nmslib/hnswlib/blob/master/ALGO_PARAMS.md).  Increasing these values could help recall(better search results) but at the cost of higher memory utilization and increased indexing time. Our default values work on a broader set of use cases from our experiments but we encourage users to run their own experiments on their data sets and choose the appropriate values. You could refer to these settings in this section (https://github.com/opendistro-for-elasticsearch/k-NN#index-level-settings). We will add details on our experiments shortly here.\n+\n+##Memory Estimation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5NTcxMg==", "bodyText": "Add space", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461795712", "createdAt": "2020-07-28T18:45:25Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,157 @@\n+#KNN Performance Tuning\n+\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+##Indexing Performance Tuning\n+\n+The following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+\n+* Disable Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied. Having no replicas means that losing \n+    a node(s) may incur data loss, so it is important that the data lives elsewhere \n+    so that this initial load can be retried in case of an issue.\n+ ```\n+More details [here](https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_disable_replicas_for_initial_loads)\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose has multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Calling refresh ensure the buffer is cleared and all segments are created so that documents are available for search. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)\n+ \n+ This will make replica shards come up with the already serialized graphs created on the primary shards during indexing. This way \n+ we avoid duplicate graph construction.\n+\n+* We can now enable replicas to copy the serialized graphs\n+\n+*  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+##Search Performance Tuning\n+\n+To improve Search performance it is necessary to keep the number of segments under control. Lucene's IndexSearcher will search over all of the segments in a shard to find the 'size' best results. But, because the complexity of search for the HNSW algorithm is logarithmic with respect to the number of vectors, searching over 5 graphs with a 100 vectors each and then taking the top size results from ```5*k``` results will take longer than searching over 1 graph with 500 vectors and then taking the top size results from k results. \n+Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We could configure index to have multiple shards to aviod having giant shards and achieve more parallelism.\n+\n+We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval.\n+\n+### Warm up\n+\n+The graphs are constructed during indexing, but they are loaded into memory during the first search. The way search works in Lucene is that each segment is searched sequentially (so, for k-NN, each segment returns up to k nearest neighbors of the query point) and the results are aggregated together and ranked based on the score of each result (higher score --> better result). \n+\n+Once a graph is loaded(graphs are loaded outside Elasticsearch JVM), we cache the graphs in memory. So the initial queries would be expensive in the order of few seconds and subsequent queries should be faster in the order of milliseconds(assuming knn circuit breaker is not hit).\n+\n+In order to avoid this latency penalty during your first queries, a user should use the warmup API on the indices they want to search. The API looks like this:\n+\n+GET /_opendistro/_knn/warmup/index1,index2,index3?pretty\n+{\n+  \"_shards\" : {\n+    \"total\" : 6,\n+    \"successful\" : 6,\n+    \"failed\" : 0\n+  }\n+}\n+\n+The API loads all of the graphs for all of the shards (primaries and replicas) for the specified indices into the cache. Thus, there will be no penalty to load graphs during initial searches. *Note \u2014 * this API only loads the segments of the indices it sees into the cache. If a merge or refresh operation finishes after this API is ran or if new documents are added, this API will need to be re-ran to load those graphs into memory.\n+\n+### Avoid reading stored fields\n+\n+If the use case is to just read the nearest neighbors Ids and scores, then we could disable reading stored fields which could save some time retrieving the vectors from stored fields. \n+To understand more about stored fields, \n+please refer this [page.](https://discuss.elastic.co/t/what-does-it-mean-to-store-a-field/5893/5)\n+```\n+{\n+ \"size\": 5,\n+ \"stored_fields\": \"_none_\",\n+ \"docvalue_fields\": [\"_id\"],\n+ \"query\": {\n+   \"knn\": {\n+    \"v\": {\n+      \"vector\": [-0.16490704,-0.047262248,-0.078923926],\n+      \"k\": 50\n+     }       \n+   }\n+ }\n+}\n+```\n+##Improving Recall \n+\n+Recall could depend on multiple factors like number of vectors, number of dimensions, segments etc. Searching over large number of small segments and aggregating the results leads better recall than searching over small number of large segments and aggregating results. The larger the graph the more chances of losing recall if sticking to smaller algorithm parameters. \n+Choosing larger values for algorithm params should help solve this issue but at the cost of search latency and indexing time. That being said, it is important to understand your system's requirements for latency and accuracy, and then to choose the number of segments you want your index to have based on experimentation.\n+\n+Recall can be configured by adjusting the algorithm parameters of hnsw algorithm exposed through index settings. Algorithm params that control the recall are *m, ef_construction, ef_search*. For more details on influence of algorithm parameters on the indexing, search recall, please refer this  doc (https://github.com/nmslib/hnswlib/blob/master/ALGO_PARAMS.md).  Increasing these values could help recall(better search results) but at the cost of higher memory utilization and increased indexing time. Our default values work on a broader set of use cases from our experiments but we encourage users to run their own experiments on their data sets and choose the appropriate values. You could refer to these settings in this section (https://github.com/opendistro-for-elasticsearch/k-NN#index-level-settings). We will add details on our experiments shortly here.\n+\n+##Memory Estimation\n+\n+AWS Elasticsearch Service clusters allocate 50% of available RAM in the Instance capped around 32GB (because of JVM GC performance limit). Graphs part of k-NN are loaded outside the Elasticsearch process JVM. We have circuit breakers to limit graph usage to 50% of the left over RAM space for the graphs.\n+\n+* Memory required for graphs =   1.1 *((4* dimensions) + (8 * M)) *Bytes/vector*\n+    * (4 bytes/float * dimension float/vector)\n+    * (8 * M) = 4 bytes/edge * 2 levels/node *  M edge/level\n+        * Note \u2014 as an estimation, each node will have membership in roughly 2 layers, and, on each layer, it will have M edges\n+    * 1.1 = an extra 10% buffer for other meta data in the data structure\n+* Example:- Let us assume\n+    * 1 Million vectors \n+    * 256 Dimensions (2^8)\n+    * M = 16 (default setting of HNSW)\n+        * Memory required for !M vectors = 1.1*(4*256 + 8*16) *1M Bytes =~ 1.26GB \n+\n+##Monitoring ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNDMyOQ==", "bodyText": "Interesting, makes sense thanks", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461804329", "createdAt": "2020-07-28T19:00:29Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,147 @@\n+#KNN Performance Tuning\n+\n+\n+In this section we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  On a high level k-NN works on following principles\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query). \n+* Each graph in the segment returns \u2018k\u2019 neighbors and the size results with the highest score is returned by the coordinating node. Note that size can be greater or smaller than k.\n+\n+To improve performance it is necessary to keep the number of segments under control. Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We can achieve more parallelism by having more shards per index. We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval, increasing the flush threshold OR force-merging to 1 segment after all the indexing finishes and before searches.\n+\n+##Indexing Performance Tuning\n+\n+Following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+* Disable flush\n+ ```\n+    Increase the \"index.translog.flush_threshold_size\" to some bigger value lets say \"10gb\", default is 512MB\n+ ```\n+* No Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied.\n+ ```\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose have multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Might not needed but to ensure the buffer is cleared and all segments are up. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)\n+\n+* We can now enable replicas to copy the serialized graphs\n+\n+*  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+##Search Performance Tuning\n+\n+### Warm up\n+\n+The graphs are constructed during indexing, but they are loaded into memory during the first search. The way search works in Lucene is that each segment is searched sequentially (so, for k-NN, each segment returns up to k nearest neighbors of the query point) and the results are aggregated together and ranked based on the score of each result (higher score --> better result). ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMxODMxNg=="}, "originalCommit": {"oid": "46330950b1d4197cd8ad88f53f8d3111f44c7980"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNDQzOA==", "bodyText": "Add space", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461804438", "createdAt": "2020-07-28T19:00:40Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,157 @@\n+#KNN Performance Tuning\n+\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+##Indexing Performance Tuning\n+\n+The following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+\n+* Disable Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied. Having no replicas means that losing \n+    a node(s) may incur data loss, so it is important that the data lives elsewhere \n+    so that this initial load can be retried in case of an issue.\n+ ```\n+More details [here](https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_disable_replicas_for_initial_loads)\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose has multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Calling refresh ensure the buffer is cleared and all segments are created so that documents are available for search. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)\n+ \n+ This will make replica shards come up with the already serialized graphs created on the primary shards during indexing. This way \n+ we avoid duplicate graph construction.\n+\n+* We can now enable replicas to copy the serialized graphs\n+\n+*  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+##Search Performance Tuning", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNTY2Mg==", "bodyText": "This needs a header like the other sections. Also, good explanation. I think adding a link to this newly created section from the force merge section would be helpful.", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461805662", "createdAt": "2020-07-28T19:02:46Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,157 @@\n+#KNN Performance Tuning\n+\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+##Indexing Performance Tuning\n+\n+The following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+* Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+\n+* Disable Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied. Having no replicas means that losing \n+    a node(s) may incur data loss, so it is important that the data lives elsewhere \n+    so that this initial load can be retried in case of an issue.\n+ ```\n+More details [here](https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_disable_replicas_for_initial_loads)\n+    \n+* Increase number of indexing threads\n+  ```\n+    If the hardware we choose has multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+* Index all docs (Perform bulk indexing)\n+\n+* Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+* Call refresh \n+\n+ Calling refresh ensure the buffer is cleared and all segments are created so that documents are available for search. \n+ ```\n+  POST /twitter/_refresh\n+```\n+* Add replicas (replica shards)\n+ \n+ This will make replica shards come up with the already serialized graphs created on the primary shards during indexing. This way \n+ we avoid duplicate graph construction.\n+\n+* We can now enable replicas to copy the serialized graphs\n+\n+*  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+##Search Performance Tuning\n+\n+To improve Search performance it is necessary to keep the number of segments under control. Lucene's IndexSearcher will search over all of the segments in a shard to find the 'size' best results. But, because the complexity of search for the HNSW algorithm is logarithmic with respect to the number of vectors, searching over 5 graphs with a 100 vectors each and then taking the top size results from ```5*k``` results will take longer than searching over 1 graph with 500 vectors and then taking the top size results from k results. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330076a7c161280ab679c26226c2f44ec1e19d5a"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55687171edb3a1e60e21ea9a0d3de00e0718242a", "author": {"user": {"login": "vamshin", "name": "Vamshi Vijay Nakkirtha"}}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/55687171edb3a1e60e21ea9a0d3de00e0718242a", "committedDate": "2020-07-28T19:35:51Z", "message": "incorporated comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0e889c7428d6c059236bacdaa0ffeb6055301c1", "author": {"user": {"login": "vamshin", "name": "Vamshi Vijay Nakkirtha"}}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/d0e889c7428d6c059236bacdaa0ffeb6055301c1", "committedDate": "2020-07-28T20:01:20Z", "message": "incorporated comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDIxMDkz", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#pullrequestreview-457021093", "createdAt": "2020-07-28T21:19:32Z", "commit": {"oid": "d0e889c7428d6c059236bacdaa0ffeb6055301c1"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMToxOTozMlrOG4fSkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMToyMDowOVrOG4fTsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NjA5Ng==", "bodyText": "Minor: wrap in code block", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461886096", "createdAt": "2020-07-28T21:19:32Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# KNN Performance Tuning\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+## Indexing Performance Tuning\n+\n+The following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+1 Disable refresh interval  (Default = 1 sec)\n+ \n+ Disable refresh interval or set a long duration for refresh interval to avoid creating multiple smaller segments\n+  ```  \n+    PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"-1\"\n+            }\n+        }\n+  ```\n+2 Disable Replicas (No Elasticsearch replica shard)\n+ ```\n+    Having replication set to 0, will avoid duplicate construction of graphs in \n+    both primary and replicas. When we enable replicas after the indexing, the \n+    serialized graphs are directly copied. Having no replicas means that losing \n+    a node(s) may incur data loss, so it is important that the data lives elsewhere \n+    so that this initial load can be retried in case of an issue.\n+ ```\n+More details [here](https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_disable_replicas_for_initial_loads)\n+    \n+3 Increase number of indexing threads\n+  ```\n+    If the hardware we choose has multiple cores, we could allow multiple threads \n+    in graph construction and there by speed up the indexing process. You could determine\n+    the number of threads to be alloted by using the following setting   \n+    https://github.com/opendistro-for-elasticsearch/k-NN#knnalgo_paramindex_thread_qty.\n+     \n+    Please keep an eye on CPU utilization and choose right number of threads. Since graph\n+    construction is costly, having multiple threads can put additional load on CPU. \n+  ```\n+    \n+4 Index all docs (Perform bulk indexing)\n+\n+5 Forcemerge \n+  \n+ Forcemerge is a costly operation and could take a while depending on number of segments and size of the segments.\n+ To ensure force merge is completed, we could keep calling forcemerge with 5 minute interval till you get 200 response.\n+    \n+    curl -X POST \"localhost:9200/myindex/_forcemerge?max_num_segments=1&pretty\"\n+    \n+6 Call refresh \n+\n+ Calling refresh ensure the buffer is cleared and all segments are created so that documents are available for search. \n+ ```\n+  POST /twitter/_refresh\n+```\n+7 Enable replicas \n+ \n+ This will make replica shards come up with the already serialized graphs created on the primary shards during indexing. This way \n+ we avoid duplicate graph construction.\n+\n+8  Enable refresh interval\n+ ```\n+      PUT /<index_name>/_settings\n+        {\n+            \"index\" : {\n+                \"refresh_interval\" : \"1m\"\n+            }\n+        }\n+ ```\n+\n+Please refer following doc (https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html) for more details on improving indexing performance in general.\n+\n+## Search Performance Tuning\n+\n+### Fewer Segments\n+To improve Search performance it is necessary to keep the number of segments under control. Lucene's IndexSearcher will search over all of the segments in a shard to find the 'size' best results. But, because the complexity of search for the HNSW algorithm is logarithmic with respect to the number of vectors, searching over 5 graphs with a 100 vectors each and then taking the top size results from ```5*k``` results will take longer than searching over 1 graph with 500 vectors and then taking the top size results from k results. \n+Ideally having 1 segment per shard will give the optimal performance with respect to search latency. We could configure index to have multiple shards to aviod having giant shards and achieve more parallelism.\n+\n+We can control the number of segments either during indexing by asking Elasticsearch to slow down the segment creation by disabling the refresh interval or choosing larger refresh interval.\n+\n+### Warm up\n+\n+The graphs are constructed during indexing, but they are loaded into memory during the first search. The way search works in Lucene is that each segment is searched sequentially (so, for k-NN, each segment returns up to k nearest neighbors of the query point) and the top ```size``` number of results based on the score would be returned from all of the results returned by segements at a shard level(higher score --> better result). \n+\n+Once a graph is loaded(graphs are loaded outside Elasticsearch JVM), we cache the graphs in memory. So the initial queries would be expensive in the order of few seconds and subsequent queries should be faster in the order of milliseconds(assuming knn circuit breaker is not hit).\n+\n+In order to avoid this latency penalty during your first queries, a user should use the warmup API on the indices they want to search. The API looks like this:\n+\n+GET /_opendistro/_knn/warmup/index1,index2,index3?pretty", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e889c7428d6c059236bacdaa0ffeb6055301c1"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NjM4Ng==", "bodyText": "Minor: add \".\" after numbering", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#discussion_r461886386", "createdAt": "2020-07-28T21:20:09Z", "author": {"login": "jmazanec15"}, "path": "PerformanceTuning.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# KNN Performance Tuning\n+\n+In this document we provide recommendations for performance tuning to improve indexing/search performance with the k-NN plugin.  From a high level k-NN works on following principles:\n+\n+* Graphs are created per (Lucene) segment\n+* Queries execute on segments sequentially inside the shard (same as any other Elasticsearch query) \n+* Each graph in the segment returns *<=k* neighbors. \n+* Coordinator node picks up final *size* number of neighbors from the neighbors returned by each shard\n+\n+## Indexing Performance Tuning\n+\n+The following steps could help improve indexing performance especially when you plan to index large number of vectors at once. \n+\n+1 Disable refresh interval  (Default = 1 sec)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e889c7428d6c059236bacdaa0ffeb6055301c1"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "296a3689369e892f44a70d4d0f219169017de02f", "author": {"user": {"login": "vamshin", "name": "Vamshi Vijay Nakkirtha"}}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/296a3689369e892f44a70d4d0f219169017de02f", "committedDate": "2020-07-28T21:28:35Z", "message": "incorporated comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDYwMTIy", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/177#pullrequestreview-457060122", "createdAt": "2020-07-28T22:01:46Z", "commit": {"oid": "296a3689369e892f44a70d4d0f219169017de02f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1255, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}