{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMDIyMzM3", "number": 36, "title": "Fix a leak where FileWatchers are added but never removed", "bodyText": "Description\nFix a leak where FileWatchers are added but never removed upon being expired from the cache, and some minor updates to privatize the cache by calling the public API in consumers\nPrior to this change, FileWatchers to track when a KNN index is deleted are added to the ResourceWatcherService but never removed even after indexes have been deleted, which causes the set of watchers to grow unbounded over time. This change updates the logic to clean up FileWatchers upon cache eviction.", "createdAt": "2020-02-04T19:56:20Z", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36", "merged": true, "mergeCommit": {"oid": "777db2a24fea5682d1c69c5e004ea0f6d9e5ca1a"}, "closed": true, "closedAt": "2020-02-05T00:51:52Z", "author": {"login": "jschmitz28"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBHEDRAH2gAyMzcxMDIyMzM3OjQwMTZkZjY3OGMxZDIzYTJjNjcwZWUwNzUwNWQwYzkyOGUzMjY0NjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBK6rcgFqTM1MzM5NTcxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4016df678c1d23a2c670ee07505d0c928e326463", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/4016df678c1d23a2c670ee07505d0c928e326463", "committedDate": "2020-02-04T19:53:46Z", "message": "Fix a leak where FileWatchers are added but never removed upon being expired from the cache, and some minor updates to privatize the cache by calling the public API in consumers\n\nPrior to this change, FileWatchers to track when a KNN index is deleted are added to the ResourceWatcherService but never\nremoved even after indexes have been deleted, which causes the set of watchers to grow unbounded over time. This change\nupdates the logic to clean up FileWatchers upon cache eviction."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/b6d7eb2ff49b10e1f91068b24435c590a39ad8a8", "committedDate": "2020-02-04T20:02:08Z", "message": "Fix javadoc to not declare @throws IOException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99923b1ac56f75d02f36d8414601e95e93f0df20", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/99923b1ac56f75d02f36d8414601e95e93f0df20", "committedDate": "2020-02-04T20:22:28Z", "message": "Fix NPE on initialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcec9c82b8b785d6483d96b6d31834a2ae3e292f", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/fcec9c82b8b785d6483d96b6d31834a2ae3e292f", "committedDate": "2020-02-04T20:47:45Z", "message": "Initialize ResourceWatcherService in integ test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjc5NTcw", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#pullrequestreview-353279570", "createdAt": "2020-02-04T20:30:28Z", "commit": {"oid": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDozMzo1NVrOFliiQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDo1NjozMVrOFljK9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwNzQ1Ng==", "bodyText": "Minor: java doc for class", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374907456", "createdAt": "2020-02-04T20:33:55Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -175,18 +178,57 @@ public void setCacheCapacityReached(Boolean value) {\n      * Loads hnsw index to memory. Registers the location of the serialized graph with ResourceWatcher.\n      *\n      * @param indexPathUrl path for serialized hnsw graph\n-     * @param algoParams hnsw algoparams\n+     * @param algoParams hnsw algorithm parameters\n      * @return KNNIndex holding the heap pointer of the loaded graph\n      * @throws Exception Exception could occur when registering the index path\n      * to Resource watcher or if the JNI call throws\n      */\n-    public KNNIndex loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n+    public KNNIndexCacheEntry loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n         if(Strings.isNullOrEmpty(indexPathUrl))\n             throw new IllegalStateException(\"indexPath is null while performing load index\");\n         logger.debug(\"Loading index on cache miss .. {}\", indexPathUrl);\n         Path indexPath = Paths.get(indexPathUrl);\n-        knnIndexFileListener.register(indexPath);\n-        return KNNIndex.loadIndex(indexPathUrl, algoParams);\n+        FileWatcher fileWatcher = new FileWatcher(indexPath);\n+        fileWatcher.addListener(KNN_INDEX_FILE_DELETED_LISTENER);\n+\n+        // Calling init() on the FileWatcher will bootstrap initial state that indicates whether or not the file\n+        // is present. If it is not present at time of init(), then KNNIndex.loadIndex will fail and we won't cache\n+        // the entry\n+        fileWatcher.init();\n+\n+        final KNNIndex knnIndex = KNNIndex.loadIndex(indexPathUrl, algoParams);\n+\n+        // TODO verify that this is safe - ideally we'd explicitly ensure that the FileWatcher is only checked\n+        // after the guava cache has finished loading the key to avoid a race condition where the watcher\n+        // causes us to invalidate an entry before the key has been fully loaded.\n+        final WatcherHandle<FileWatcher> watcherHandle = resourceWatcherService.add(fileWatcher);\n+\n+        return new KNNIndexCacheEntry(knnIndex, watcherHandle);\n     }\n-}\n \n+    private static class KNNIndexCacheEntry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwODMwMw==", "bodyText": "Should we add try/finally block and move knnIndexCacheEntry.getFileWatcherHandle().stop(); to finally block to ensure the watcher is removed as file is deleted at this point?", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374908303", "createdAt": "2020-02-04T20:35:46Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -103,10 +106,12 @@ public synchronized void rebuild() {\n      *\n      * @param removalNotification key, value that got evicted.\n      */\n-    private void onRemoval(RemovalNotification<String, KNNIndex> removalNotification) {\n-        KNNIndex knnIndex = removalNotification.getValue();\n+    private void onRemoval(RemovalNotification<String, KNNIndexCacheEntry> removalNotification) {\n+        KNNIndexCacheEntry knnIndexCacheEntry = removalNotification.getValue();\n+\n+        knnIndexCacheEntry.getFileWatcherHandle().stop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNDM2MA==", "bodyText": "I think we should first do  resourceWatcherService.add and then load the index.\n\nresourceWatcherService.add seems to already call init() on the filewatcher.  So no explicit call to init()\nthis will also address the case of  index not loaded if file is only present", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374914360", "createdAt": "2020-02-04T20:48:59Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -175,18 +178,57 @@ public void setCacheCapacityReached(Boolean value) {\n      * Loads hnsw index to memory. Registers the location of the serialized graph with ResourceWatcher.\n      *\n      * @param indexPathUrl path for serialized hnsw graph\n-     * @param algoParams hnsw algoparams\n+     * @param algoParams hnsw algorithm parameters\n      * @return KNNIndex holding the heap pointer of the loaded graph\n      * @throws Exception Exception could occur when registering the index path\n      * to Resource watcher or if the JNI call throws\n      */\n-    public KNNIndex loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n+    public KNNIndexCacheEntry loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n         if(Strings.isNullOrEmpty(indexPathUrl))\n             throw new IllegalStateException(\"indexPath is null while performing load index\");\n         logger.debug(\"Loading index on cache miss .. {}\", indexPathUrl);\n         Path indexPath = Paths.get(indexPathUrl);\n-        knnIndexFileListener.register(indexPath);\n-        return KNNIndex.loadIndex(indexPathUrl, algoParams);\n+        FileWatcher fileWatcher = new FileWatcher(indexPath);\n+        fileWatcher.addListener(KNN_INDEX_FILE_DELETED_LISTENER);\n+\n+        // Calling init() on the FileWatcher will bootstrap initial state that indicates whether or not the file\n+        // is present. If it is not present at time of init(), then KNNIndex.loadIndex will fail and we won't cache\n+        // the entry\n+        fileWatcher.init();\n+\n+        final KNNIndex knnIndex = KNNIndex.loadIndex(indexPathUrl, algoParams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNzg3OQ==", "bodyText": "I think guava cache takes the lock when loading the entry for the key. So when invalidate happens, it should happen after the graph is loaded?\nhttps://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java#L91", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374917879", "createdAt": "2020-02-04T20:56:31Z", "author": {"login": "vamshin"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -175,18 +178,57 @@ public void setCacheCapacityReached(Boolean value) {\n      * Loads hnsw index to memory. Registers the location of the serialized graph with ResourceWatcher.\n      *\n      * @param indexPathUrl path for serialized hnsw graph\n-     * @param algoParams hnsw algoparams\n+     * @param algoParams hnsw algorithm parameters\n      * @return KNNIndex holding the heap pointer of the loaded graph\n      * @throws Exception Exception could occur when registering the index path\n      * to Resource watcher or if the JNI call throws\n      */\n-    public KNNIndex loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n+    public KNNIndexCacheEntry loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n         if(Strings.isNullOrEmpty(indexPathUrl))\n             throw new IllegalStateException(\"indexPath is null while performing load index\");\n         logger.debug(\"Loading index on cache miss .. {}\", indexPathUrl);\n         Path indexPath = Paths.get(indexPathUrl);\n-        knnIndexFileListener.register(indexPath);\n-        return KNNIndex.loadIndex(indexPathUrl, algoParams);\n+        FileWatcher fileWatcher = new FileWatcher(indexPath);\n+        fileWatcher.addListener(KNN_INDEX_FILE_DELETED_LISTENER);\n+\n+        // Calling init() on the FileWatcher will bootstrap initial state that indicates whether or not the file\n+        // is present. If it is not present at time of init(), then KNNIndex.loadIndex will fail and we won't cache\n+        // the entry\n+        fileWatcher.init();\n+\n+        final KNNIndex knnIndex = KNNIndex.loadIndex(indexPathUrl, algoParams);\n+\n+        // TODO verify that this is safe - ideally we'd explicitly ensure that the FileWatcher is only checked\n+        // after the guava cache has finished loading the key to avoid a race condition where the watcher\n+        // causes us to invalidate an entry before the key has been fully loaded.\n+        final WatcherHandle<FileWatcher> watcherHandle = resourceWatcherService.add(fileWatcher);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64173ce80f8bda50cbc339a11f03fff1c7890f67", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/64173ce80f8bda50cbc339a11f03fff1c7890f67", "committedDate": "2020-02-04T23:52:30Z", "message": "Add javadoc, disable resource watcher service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01abb18daa28cbf9a196314cacefa1febda7e516", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/01abb18daa28cbf9a196314cacefa1febda7e516", "committedDate": "2020-02-04T23:56:43Z", "message": "Remove unused import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzg5NDk5", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#pullrequestreview-353389499", "createdAt": "2020-02-05T00:05:11Z", "commit": {"oid": "01abb18daa28cbf9a196314cacefa1febda7e516"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzkyMTMx", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#pullrequestreview-353392131", "createdAt": "2020-02-05T00:13:09Z", "commit": {"oid": "01abb18daa28cbf9a196314cacefa1febda7e516"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwMDoxMzowOVrOFln8Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwMDoxMzowOVrOFln8Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5NjAzMA==", "bodyText": "Why not just do:\nreturn cache.get(key, () -> loadIndex(key, algoParams)).getKnnIndex();", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374996030", "createdAt": "2020-02-05T00:13:09Z", "author": {"login": "jmazanec15"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -121,15 +126,13 @@ private void onRemoval(RemovalNotification<String, KNNIndex> removalNotification\n      * Loads corresponding index for the given key to memory and returns the index object.\n      *\n      * @param key indexPath where the serialized hnsw graph is stored\n-     * @param algoParams hnsw algoparams\n-     * @return KNNIndex holding the heap pointer of the loaded graph or empty if there was\n-     * a failure to load the\n-     * @throws RuntimeException if there's an unexpected failure in loading, which implies that the value for\n-     * the key will be both out of the cache and the underlying index will not be loaded\n+     * @param algoParams hnsw algorithm parameters\n+     * @return KNNIndex holding the heap pointer of the loaded graph\n      */\n     public KNNIndex getIndex(String key, final String[] algoParams) {\n         try {\n-            return cache.get(key, () -> loadIndex(key, algoParams));\n+            final KNNIndexCacheEntry knnIndexCacheEntry = cache.get(key, () -> loadIndex(key, algoParams));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01abb18daa28cbf9a196314cacefa1febda7e516"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzk1NzEx", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#pullrequestreview-353395711", "createdAt": "2020-02-05T00:23:09Z", "commit": {"oid": "01abb18daa28cbf9a196314cacefa1febda7e516"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1314, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}