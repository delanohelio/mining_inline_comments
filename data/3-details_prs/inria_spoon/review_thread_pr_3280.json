{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNDc0NDU0", "number": 3280, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOTozODozMVrODl6rBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOTozODozMVrODl6rBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDg1MTg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/spoon/processing/AbstractParallelProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOTozODozMVrOFzE87A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo0MTo1NFrOFzIVmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEwMjgyOA==", "bodyText": "neat API!", "url": "https://github.com/INRIA/spoon/pull/3280#discussion_r389102828", "createdAt": "2020-03-06T19:38:31Z", "author": {"login": "monperrus"}, "path": "src/main/java/spoon/processing/AbstractParallelProcessor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (C) 2006-2019 INRIA and contributors\n+ *\n+ * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n+ */\n+package spoon.processing;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Consumer;\n+import java.util.stream.StreamSupport;\n+\n+import spoon.SpoonException;\n+import spoon.reflect.declaration.CtElement;\n+\n+/**\n+ * AbstractParallelProcessor allows using multiple threads for concurrent\n+ * processing with {@link AbstractProcessor}.\n+ *\n+ * <b> This class should only be used if all processors do the same.</b>\n+ * Otherwise the result may vary from the expected result. All processors <b>\n+ * must </b> synchronize shared fields like Collections by themselves. Multiple\n+ * constructors exist for different approaches creating this. You can create\n+ * this processor with either a Iterable of processors or a Consumer.\n+ *\n+ * For creating and managing threads a {@link Executors#newFixedThreadPool()} is\n+ * used. Creating more threads then cores can harm the performance. Using a\n+ * different thread pool could increase the performance, but this class should\n+ * be general usage. If you need better performance you may want to use an own\n+ * class with different parallel approach.\n+ */\n+public abstract class AbstractParallelProcessor<E extends CtElement> extends AbstractProcessor<E> {\n+\n+\tprivate ExecutorService service;\n+\tprivate ArrayBlockingQueue<Processor<E>> processorQueue;\n+\n+\t/**\n+\t * Creates a new AbstractParallelProcessor from given iterable. The iterable is\n+\t * fully consumed. Giving an endless iterable of processors will result in\n+\t * errors. The processors must follow the guidelines given in the class\n+\t * description.\n+\t *\n+\t * @param processors iterable of processors.\n+\t * @throws IllegalArgumentException if size of iterable is less than 1.\n+\t *\n+\t */\n+\tpublic AbstractParallelProcessor(Iterable<Processor<E>> processors) {\n+\t\t// added cast because constructors need int\n+\t\tint processorNumber = (int) StreamSupport.stream(processors.spliterator(), false).count();\n+\t\tprocessorQueue = new ArrayBlockingQueue<>(processorNumber);\n+\t\tprocessors.forEach(processorQueue::add);\n+\t\tservice = Executors.newFixedThreadPool(processorNumber);\n+\t}\n+\n+\t/**\n+\t * Creates a new AbstractParallelProcessor from given iterable. The processors\n+\t * must follow the guidelines given in the class description.\n+\t *\n+\t * @param processors         iterable of processors.\n+\t * @param numberOfProcessors number consumed from the iterable added to the\n+\t *                           active processors.\n+\t * @throws SpoonException           if iterable has less values then\n+\t *                                  numberOfProcessors.\n+\t * @throws IllegalArgumentException if numberOfProcessors is less than 1.\n+\t *\n+\t */\n+\tpublic AbstractParallelProcessor(Iterable<Processor<E>> processors, int numberOfProcessors) {\n+\t\tprocessorQueue = new ArrayBlockingQueue<>(numberOfProcessors);\n+\t\tservice = Executors.newFixedThreadPool(numberOfProcessors);\n+\t\tIterator<Processor<E>> it = processors.iterator();\n+\t\tfor (int i = 0; i < numberOfProcessors; i++) {\n+\t\t\tif (!it.hasNext()) {\n+\t\t\t\tthrow new SpoonException(\"not enough elements provided, iterable is already empty\");\n+\t\t\t}\n+\t\t\tprocessorQueue.add(it.next());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Creates a new AbstractParallelProcessor from given consumer. The processors\n+\t * must follow the guidelines given in the class description.\n+\t *\n+\t * @param processFunction    Represents an operation that accepts a single\n+\t *                           element E and returns no result.\n+\t * @param numberOfProcessors number of concurrent running processors.\n+\t * @throws IllegalArgumentException if numberOfProcessors is less than 1.\n+\t */\n+\tpublic AbstractParallelProcessor(Consumer<E> processFunction, int numberOfProcessors) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a1f48dea87ee2d5c814648ae0974b93702df4d"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1ODI5Nw==", "bodyText": "thanks", "url": "https://github.com/INRIA/spoon/pull/3280#discussion_r389158297", "createdAt": "2020-03-06T21:41:54Z", "author": {"login": "MartinWitt"}, "path": "src/main/java/spoon/processing/AbstractParallelProcessor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (C) 2006-2019 INRIA and contributors\n+ *\n+ * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n+ */\n+package spoon.processing;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Consumer;\n+import java.util.stream.StreamSupport;\n+\n+import spoon.SpoonException;\n+import spoon.reflect.declaration.CtElement;\n+\n+/**\n+ * AbstractParallelProcessor allows using multiple threads for concurrent\n+ * processing with {@link AbstractProcessor}.\n+ *\n+ * <b> This class should only be used if all processors do the same.</b>\n+ * Otherwise the result may vary from the expected result. All processors <b>\n+ * must </b> synchronize shared fields like Collections by themselves. Multiple\n+ * constructors exist for different approaches creating this. You can create\n+ * this processor with either a Iterable of processors or a Consumer.\n+ *\n+ * For creating and managing threads a {@link Executors#newFixedThreadPool()} is\n+ * used. Creating more threads then cores can harm the performance. Using a\n+ * different thread pool could increase the performance, but this class should\n+ * be general usage. If you need better performance you may want to use an own\n+ * class with different parallel approach.\n+ */\n+public abstract class AbstractParallelProcessor<E extends CtElement> extends AbstractProcessor<E> {\n+\n+\tprivate ExecutorService service;\n+\tprivate ArrayBlockingQueue<Processor<E>> processorQueue;\n+\n+\t/**\n+\t * Creates a new AbstractParallelProcessor from given iterable. The iterable is\n+\t * fully consumed. Giving an endless iterable of processors will result in\n+\t * errors. The processors must follow the guidelines given in the class\n+\t * description.\n+\t *\n+\t * @param processors iterable of processors.\n+\t * @throws IllegalArgumentException if size of iterable is less than 1.\n+\t *\n+\t */\n+\tpublic AbstractParallelProcessor(Iterable<Processor<E>> processors) {\n+\t\t// added cast because constructors need int\n+\t\tint processorNumber = (int) StreamSupport.stream(processors.spliterator(), false).count();\n+\t\tprocessorQueue = new ArrayBlockingQueue<>(processorNumber);\n+\t\tprocessors.forEach(processorQueue::add);\n+\t\tservice = Executors.newFixedThreadPool(processorNumber);\n+\t}\n+\n+\t/**\n+\t * Creates a new AbstractParallelProcessor from given iterable. The processors\n+\t * must follow the guidelines given in the class description.\n+\t *\n+\t * @param processors         iterable of processors.\n+\t * @param numberOfProcessors number consumed from the iterable added to the\n+\t *                           active processors.\n+\t * @throws SpoonException           if iterable has less values then\n+\t *                                  numberOfProcessors.\n+\t * @throws IllegalArgumentException if numberOfProcessors is less than 1.\n+\t *\n+\t */\n+\tpublic AbstractParallelProcessor(Iterable<Processor<E>> processors, int numberOfProcessors) {\n+\t\tprocessorQueue = new ArrayBlockingQueue<>(numberOfProcessors);\n+\t\tservice = Executors.newFixedThreadPool(numberOfProcessors);\n+\t\tIterator<Processor<E>> it = processors.iterator();\n+\t\tfor (int i = 0; i < numberOfProcessors; i++) {\n+\t\t\tif (!it.hasNext()) {\n+\t\t\t\tthrow new SpoonException(\"not enough elements provided, iterable is already empty\");\n+\t\t\t}\n+\t\t\tprocessorQueue.add(it.next());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Creates a new AbstractParallelProcessor from given consumer. The processors\n+\t * must follow the guidelines given in the class description.\n+\t *\n+\t * @param processFunction    Represents an operation that accepts a single\n+\t *                           element E and returns no result.\n+\t * @param numberOfProcessors number of concurrent running processors.\n+\t * @throws IllegalArgumentException if numberOfProcessors is less than 1.\n+\t */\n+\tpublic AbstractParallelProcessor(Consumer<E> processFunction, int numberOfProcessors) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEwMjgyOA=="}, "originalCommit": {"oid": "d2a1f48dea87ee2d5c814648ae0974b93702df4d"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3690, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}