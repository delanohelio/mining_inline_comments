{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzODQ2Njg2", "number": 3282, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNToyNjowNlrODrfs_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNToyOToyMVrODrfvPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2OTM0NzgyOnYy", "diffSide": "RIGHT", "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNToyNjowNlrOF730Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwOTowMjoyMFrOF79E-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDc3MA==", "bodyText": "what does the \"4\" mean here?", "url": "https://github.com/INRIA/spoon/pull/3282#discussion_r398324770", "createdAt": "2020-03-26T05:26:06Z", "author": {"login": "monperrus"}, "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package spoon.smpl;\n+\n+import fr.inria.controlflow.ControlFlowNode;\n+import org.junit.Before;\n+import org.junit.Test;\n+import spoon.smpl.formula.*;\n+import spoon.smpl.metavars.ConstantConstraint;\n+import spoon.smpl.metavars.ExpressionConstraint;\n+import spoon.smpl.metavars.IdentifierConstraint;\n+import spoon.smpl.metavars.TypeConstraint;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static spoon.smpl.TestUtils.*;\n+import static spoon.smpl.TestUtils.parseReturnStatement;\n+\n+/**\n+ * This is essentially an integration test of most of the SmPL stack, leaving out the parser.\n+ */\n+public class MetavarsTest {\n+    @Before\n+    public void resetControlFlowNodeCounter() {\n+        // needed for consistent IDs in CFGModels\n+        try {\n+            Field field = ControlFlowNode.class.getDeclaredField(\"count\");\n+            field.setAccessible(true);\n+            ControlFlowNode.count = 0;\n+        } catch (Exception e) {\n+            fail(\"Unable to reset ControlFlowNode id counter\");\n+        }\n+    }\n+\n+    private static Formula stmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    private static Formula retstmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseReturnStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    @Test\n+    public void testCompatibleBindings() {\n+\n+        // contract: metavariables bound to \"same thing\" in different nodes are joined under AND\n+        // TODO: add tests for other formula connectors such as OR\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return x; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640ae6ddf18ed277473df615c6e42f5fbd8fa4ef"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNDI5MQ==", "bodyText": "It's the ID of a state that satisfied the formula. For a CFGModel, each node in the CFG corresponds to a state and the state IDs are determined by the node IDs (ControlFlowNode::getId). A handy way to get a picture of the node IDs is to take the GraphViz output available from ControlFlowGraph::toGraphVisText and rendering it: example", "url": "https://github.com/INRIA/spoon/pull/3282#discussion_r398334291", "createdAt": "2020-03-26T06:01:25Z", "author": {"login": "mkforsb"}, "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package spoon.smpl;\n+\n+import fr.inria.controlflow.ControlFlowNode;\n+import org.junit.Before;\n+import org.junit.Test;\n+import spoon.smpl.formula.*;\n+import spoon.smpl.metavars.ConstantConstraint;\n+import spoon.smpl.metavars.ExpressionConstraint;\n+import spoon.smpl.metavars.IdentifierConstraint;\n+import spoon.smpl.metavars.TypeConstraint;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static spoon.smpl.TestUtils.*;\n+import static spoon.smpl.TestUtils.parseReturnStatement;\n+\n+/**\n+ * This is essentially an integration test of most of the SmPL stack, leaving out the parser.\n+ */\n+public class MetavarsTest {\n+    @Before\n+    public void resetControlFlowNodeCounter() {\n+        // needed for consistent IDs in CFGModels\n+        try {\n+            Field field = ControlFlowNode.class.getDeclaredField(\"count\");\n+            field.setAccessible(true);\n+            ControlFlowNode.count = 0;\n+        } catch (Exception e) {\n+            fail(\"Unable to reset ControlFlowNode id counter\");\n+        }\n+    }\n+\n+    private static Formula stmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    private static Formula retstmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseReturnStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    @Test\n+    public void testCompatibleBindings() {\n+\n+        // contract: metavariables bound to \"same thing\" in different nodes are joined under AND\n+        // TODO: add tests for other formula connectors such as OR\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return x; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDc3MA=="}, "originalCommit": {"oid": "640ae6ddf18ed277473df615c6e42f5fbd8fa4ef"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQxMTAwMw==", "bodyText": "very interesting. could you add this explanation as comment in the test?", "url": "https://github.com/INRIA/spoon/pull/3282#discussion_r398411003", "createdAt": "2020-03-26T09:02:20Z", "author": {"login": "monperrus"}, "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package spoon.smpl;\n+\n+import fr.inria.controlflow.ControlFlowNode;\n+import org.junit.Before;\n+import org.junit.Test;\n+import spoon.smpl.formula.*;\n+import spoon.smpl.metavars.ConstantConstraint;\n+import spoon.smpl.metavars.ExpressionConstraint;\n+import spoon.smpl.metavars.IdentifierConstraint;\n+import spoon.smpl.metavars.TypeConstraint;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static spoon.smpl.TestUtils.*;\n+import static spoon.smpl.TestUtils.parseReturnStatement;\n+\n+/**\n+ * This is essentially an integration test of most of the SmPL stack, leaving out the parser.\n+ */\n+public class MetavarsTest {\n+    @Before\n+    public void resetControlFlowNodeCounter() {\n+        // needed for consistent IDs in CFGModels\n+        try {\n+            Field field = ControlFlowNode.class.getDeclaredField(\"count\");\n+            field.setAccessible(true);\n+            ControlFlowNode.count = 0;\n+        } catch (Exception e) {\n+            fail(\"Unable to reset ControlFlowNode id counter\");\n+        }\n+    }\n+\n+    private static Formula stmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    private static Formula retstmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseReturnStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    @Test\n+    public void testCompatibleBindings() {\n+\n+        // contract: metavariables bound to \"same thing\" in different nodes are joined under AND\n+        // TODO: add tests for other formula connectors such as OR\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return x; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDc3MA=="}, "originalCommit": {"oid": "640ae6ddf18ed277473df615c6e42f5fbd8fa4ef"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2OTM1MjI1OnYy", "diffSide": "RIGHT", "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNToyODozMlrOF732lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNjowNjowNlrOF74eZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTM5OQ==", "bodyText": "seems already tested in the previous test. If yes, should be removed here, so that the reader can clearly see the focus on the last assertion?", "url": "https://github.com/INRIA/spoon/pull/3282#discussion_r398325399", "createdAt": "2020-03-26T05:28:32Z", "author": {"login": "monperrus"}, "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package spoon.smpl;\n+\n+import fr.inria.controlflow.ControlFlowNode;\n+import org.junit.Before;\n+import org.junit.Test;\n+import spoon.smpl.formula.*;\n+import spoon.smpl.metavars.ConstantConstraint;\n+import spoon.smpl.metavars.ExpressionConstraint;\n+import spoon.smpl.metavars.IdentifierConstraint;\n+import spoon.smpl.metavars.TypeConstraint;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static spoon.smpl.TestUtils.*;\n+import static spoon.smpl.TestUtils.parseReturnStatement;\n+\n+/**\n+ * This is essentially an integration test of most of the SmPL stack, leaving out the parser.\n+ */\n+public class MetavarsTest {\n+    @Before\n+    public void resetControlFlowNodeCounter() {\n+        // needed for consistent IDs in CFGModels\n+        try {\n+            Field field = ControlFlowNode.class.getDeclaredField(\"count\");\n+            field.setAccessible(true);\n+            ControlFlowNode.count = 0;\n+        } catch (Exception e) {\n+            fail(\"Unable to reset ControlFlowNode id counter\");\n+        }\n+    }\n+\n+    private static Formula stmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    private static Formula retstmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseReturnStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    @Test\n+    public void testCompatibleBindings() {\n+\n+        // contract: metavariables bound to \"same thing\" in different nodes are joined under AND\n+        // TODO: add tests for other formula connectors such as OR\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return x; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());\n+\n+        retstmt(\"return z;\", meta).accept(checkerA);\n+        assertEquals(\"[(5, {z=x})]\", checkerA.getResult().toString());\n+\n+        new And(stmt(\"int z = 1;\", meta),\n+                new AllNext(retstmt(\"return z;\", meta))).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());\n+    }\n+\n+    @Test\n+    public void testIncompatibleBindings() {\n+\n+        // contract: metavariables bound to different things are rejected under AND\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return y; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640ae6ddf18ed277473df615c6e42f5fbd8fa4ef"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTU4OA==", "bodyText": "Agreed, will remove.", "url": "https://github.com/INRIA/spoon/pull/3282#discussion_r398335588", "createdAt": "2020-03-26T06:06:06Z", "author": {"login": "mkforsb"}, "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package spoon.smpl;\n+\n+import fr.inria.controlflow.ControlFlowNode;\n+import org.junit.Before;\n+import org.junit.Test;\n+import spoon.smpl.formula.*;\n+import spoon.smpl.metavars.ConstantConstraint;\n+import spoon.smpl.metavars.ExpressionConstraint;\n+import spoon.smpl.metavars.IdentifierConstraint;\n+import spoon.smpl.metavars.TypeConstraint;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static spoon.smpl.TestUtils.*;\n+import static spoon.smpl.TestUtils.parseReturnStatement;\n+\n+/**\n+ * This is essentially an integration test of most of the SmPL stack, leaving out the parser.\n+ */\n+public class MetavarsTest {\n+    @Before\n+    public void resetControlFlowNodeCounter() {\n+        // needed for consistent IDs in CFGModels\n+        try {\n+            Field field = ControlFlowNode.class.getDeclaredField(\"count\");\n+            field.setAccessible(true);\n+            ControlFlowNode.count = 0;\n+        } catch (Exception e) {\n+            fail(\"Unable to reset ControlFlowNode id counter\");\n+        }\n+    }\n+\n+    private static Formula stmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    private static Formula retstmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseReturnStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    @Test\n+    public void testCompatibleBindings() {\n+\n+        // contract: metavariables bound to \"same thing\" in different nodes are joined under AND\n+        // TODO: add tests for other formula connectors such as OR\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return x; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());\n+\n+        retstmt(\"return z;\", meta).accept(checkerA);\n+        assertEquals(\"[(5, {z=x})]\", checkerA.getResult().toString());\n+\n+        new And(stmt(\"int z = 1;\", meta),\n+                new AllNext(retstmt(\"return z;\", meta))).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());\n+    }\n+\n+    @Test\n+    public void testIncompatibleBindings() {\n+\n+        // contract: metavariables bound to different things are rejected under AND\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return y; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTM5OQ=="}, "originalCommit": {"oid": "640ae6ddf18ed277473df615c6e42f5fbd8fa4ef"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2OTM1MzU5OnYy", "diffSide": "RIGHT", "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNToyOToyMVrOF733Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwOTowMjozMlrOF79FZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTU5NQ==", "bodyText": "it seems that we have two contracts here. what about splitting this test in two: the first two assertions, and then the final one (contract on And)?", "url": "https://github.com/INRIA/spoon/pull/3282#discussion_r398325595", "createdAt": "2020-03-26T05:29:21Z", "author": {"login": "monperrus"}, "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package spoon.smpl;\n+\n+import fr.inria.controlflow.ControlFlowNode;\n+import org.junit.Before;\n+import org.junit.Test;\n+import spoon.smpl.formula.*;\n+import spoon.smpl.metavars.ConstantConstraint;\n+import spoon.smpl.metavars.ExpressionConstraint;\n+import spoon.smpl.metavars.IdentifierConstraint;\n+import spoon.smpl.metavars.TypeConstraint;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static spoon.smpl.TestUtils.*;\n+import static spoon.smpl.TestUtils.parseReturnStatement;\n+\n+/**\n+ * This is essentially an integration test of most of the SmPL stack, leaving out the parser.\n+ */\n+public class MetavarsTest {\n+    @Before\n+    public void resetControlFlowNodeCounter() {\n+        // needed for consistent IDs in CFGModels\n+        try {\n+            Field field = ControlFlowNode.class.getDeclaredField(\"count\");\n+            field.setAccessible(true);\n+            ControlFlowNode.count = 0;\n+        } catch (Exception e) {\n+            fail(\"Unable to reset ControlFlowNode id counter\");\n+        }\n+    }\n+\n+    private static Formula stmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    private static Formula retstmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseReturnStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    @Test\n+    public void testCompatibleBindings() {\n+\n+        // contract: metavariables bound to \"same thing\" in different nodes are joined under AND\n+        // TODO: add tests for other formula connectors such as OR\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return x; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());\n+\n+        retstmt(\"return z;\", meta).accept(checkerA);\n+        assertEquals(\"[(5, {z=x})]\", checkerA.getResult().toString());\n+\n+        new And(stmt(\"int z = 1;\", meta),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640ae6ddf18ed277473df615c6e42f5fbd8fa4ef"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNzgyOQ==", "bodyText": "I like seeing the first two assertions there since the And essentially joins those two results, but I agree it distracts from the contract and the repetition is bad. I'll try to restructure.", "url": "https://github.com/INRIA/spoon/pull/3282#discussion_r398337829", "createdAt": "2020-03-26T06:14:08Z", "author": {"login": "mkforsb"}, "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package spoon.smpl;\n+\n+import fr.inria.controlflow.ControlFlowNode;\n+import org.junit.Before;\n+import org.junit.Test;\n+import spoon.smpl.formula.*;\n+import spoon.smpl.metavars.ConstantConstraint;\n+import spoon.smpl.metavars.ExpressionConstraint;\n+import spoon.smpl.metavars.IdentifierConstraint;\n+import spoon.smpl.metavars.TypeConstraint;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static spoon.smpl.TestUtils.*;\n+import static spoon.smpl.TestUtils.parseReturnStatement;\n+\n+/**\n+ * This is essentially an integration test of most of the SmPL stack, leaving out the parser.\n+ */\n+public class MetavarsTest {\n+    @Before\n+    public void resetControlFlowNodeCounter() {\n+        // needed for consistent IDs in CFGModels\n+        try {\n+            Field field = ControlFlowNode.class.getDeclaredField(\"count\");\n+            field.setAccessible(true);\n+            ControlFlowNode.count = 0;\n+        } catch (Exception e) {\n+            fail(\"Unable to reset ControlFlowNode id counter\");\n+        }\n+    }\n+\n+    private static Formula stmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    private static Formula retstmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseReturnStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    @Test\n+    public void testCompatibleBindings() {\n+\n+        // contract: metavariables bound to \"same thing\" in different nodes are joined under AND\n+        // TODO: add tests for other formula connectors such as OR\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return x; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());\n+\n+        retstmt(\"return z;\", meta).accept(checkerA);\n+        assertEquals(\"[(5, {z=x})]\", checkerA.getResult().toString());\n+\n+        new And(stmt(\"int z = 1;\", meta),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTU5NQ=="}, "originalCommit": {"oid": "640ae6ddf18ed277473df615c6e42f5fbd8fa4ef"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQxMTExMQ==", "bodyText": "perfect", "url": "https://github.com/INRIA/spoon/pull/3282#discussion_r398411111", "createdAt": "2020-03-26T09:02:32Z", "author": {"login": "monperrus"}, "path": "spoon-smpl/src/test/java/spoon/smpl/MetavarsTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package spoon.smpl;\n+\n+import fr.inria.controlflow.ControlFlowNode;\n+import org.junit.Before;\n+import org.junit.Test;\n+import spoon.smpl.formula.*;\n+import spoon.smpl.metavars.ConstantConstraint;\n+import spoon.smpl.metavars.ExpressionConstraint;\n+import spoon.smpl.metavars.IdentifierConstraint;\n+import spoon.smpl.metavars.TypeConstraint;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static spoon.smpl.TestUtils.*;\n+import static spoon.smpl.TestUtils.parseReturnStatement;\n+\n+/**\n+ * This is essentially an integration test of most of the SmPL stack, leaving out the parser.\n+ */\n+public class MetavarsTest {\n+    @Before\n+    public void resetControlFlowNodeCounter() {\n+        // needed for consistent IDs in CFGModels\n+        try {\n+            Field field = ControlFlowNode.class.getDeclaredField(\"count\");\n+            field.setAccessible(true);\n+            ControlFlowNode.count = 0;\n+        } catch (Exception e) {\n+            fail(\"Unable to reset ControlFlowNode id counter\");\n+        }\n+    }\n+\n+    private static Formula stmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    private static Formula retstmt(String code, Map<String, ParameterPostProcessStrategy> metavars) {\n+        return new StatementPattern(makePattern(parseReturnStatement(code), new ArrayList<>(metavars.keySet())), metavars);\n+    }\n+\n+    @Test\n+    public void testCompatibleBindings() {\n+\n+        // contract: metavariables bound to \"same thing\" in different nodes are joined under AND\n+        // TODO: add tests for other formula connectors such as OR\n+\n+        Model modelA = new CFGModel(methodCfg(parseMethod(\"int m() { int x = 1; return x; }\")));\n+        ModelChecker checkerA = new ModelChecker(modelA);\n+        //System.out.println(((CFGModel) modelA).getCfg().toGraphVisText());\n+\n+        Map<String, ParameterPostProcessStrategy> meta = metavars(\"z\", new IdentifierConstraint());\n+\n+        stmt(\"int z = 1;\", meta).accept(checkerA);\n+        assertEquals(\"[(4, {z=x})]\", checkerA.getResult().toString());\n+\n+        retstmt(\"return z;\", meta).accept(checkerA);\n+        assertEquals(\"[(5, {z=x})]\", checkerA.getResult().toString());\n+\n+        new And(stmt(\"int z = 1;\", meta),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTU5NQ=="}, "originalCommit": {"oid": "640ae6ddf18ed277473df615c6e42f5fbd8fa4ef"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3693, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}