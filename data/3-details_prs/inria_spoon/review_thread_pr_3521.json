{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1MDA4OTg3", "number": 3521, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQxMzo0NjoxMVrOEWe7IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQxMzo0OToxNFrOEWe8Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMDEwNzg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQxMzo0NjoxMVrOG9z5Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQxMzo0NjoxMVrOG9z5Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjU3MA==", "bodyText": "refactor the else block in getOverriddenMethodForIntersectionType?", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r467466570", "createdAt": "2020-08-08T13:46:11Z", "author": {"login": "monperrus"}, "path": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "diffHunk": "@@ -101,7 +105,32 @@ public String getSimpleName() {\n \t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n \t\t\treturn null;\n \t\t}\n-\t\tCtType<T> lambdaType = lambdaTypeRef.getTypeDeclaration();\n+\t\tCtMethod<?> lambdaExecutableMethod = null;\n+\t\tif (!(lambdaTypeRef instanceof CtIntersectionTypeReference)) {\n+\t\t\treturn getOverriddenAux(lambdaTypeRef);\n+\t\t} else {\n+\t\t\tCtElement parent = lambdaTypeRef.getParent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d816c9fe1ad55486267b051e2ce934ddf6e266e2"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMDEwODYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQxMzo0NzoxNVrOG9z5nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwOToyMzoyMVrOHBJBGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjY1NQ==", "bodyText": "do we need to move this check here? could we keep it at the previous place?", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r467466655", "createdAt": "2020-08-08T13:47:15Z", "author": {"login": "monperrus"}, "path": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "diffHunk": "@@ -101,7 +105,32 @@ public String getSimpleName() {\n \t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n \t\t\treturn null;\n \t\t}\n-\t\tCtType<T> lambdaType = lambdaTypeRef.getTypeDeclaration();\n+\t\tCtMethod<?> lambdaExecutableMethod = null;\n+\t\tif (!(lambdaTypeRef instanceof CtIntersectionTypeReference)) {\n+\t\t\treturn getOverriddenAux(lambdaTypeRef);\n+\t\t} else {\n+\t\t\tCtElement parent = lambdaTypeRef.getParent();\n+\t\t\tCtTypeReference<?> parentTypeReference = null;\n+\t\t\tif (parent != null && parent instanceof CtLocalVariable) {\n+\t\t\t\tparentTypeReference = ((CtLocalVariable) parent).getType();\n+\t\t\t} else if (parent != null && parent instanceof CtAssignment) {\n+\t\t\t\tparentTypeReference = ((CtAssignment) parent).getAssigned().getType();\n+\t\t\t}\n+\t\t\tfor (CtTypeReference<?> ctTypeReference : ((CtIntersectionTypeReference<?>) lambdaTypeRef).getBounds()) {\n+\t\t\t\tCtMethod<?> tmp = getOverriddenAux(ctTypeReference);\n+\t\t\t\tif (tmp != null && (lambdaExecutableMethod == null || ctTypeReference.equals(parentTypeReference))) {\n+\t\t\t\t\tlambdaExecutableMethod = tmp;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (lambdaExecutableMethod == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d816c9fe1ad55486267b051e2ce934ddf6e266e2"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU5MTc1Mw==", "bodyText": "It follows the standard compiler behavior.\nThat is, at least one interface should have one method,\nthus, some of these interfaces might not even declare any methods.\nBut as a side note, I just match the type that will be taken by the lambda in its parent,\nbut I did not implement a real type intersection, thus I am less strict than the compiler.\nA great improvement would be to implement this type intersection in spoon.\nBut it is too complicated for me :/ and I would not be useful for my use case.", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r470591753", "createdAt": "2020-08-14T12:24:23Z", "author": {"login": "quentinLeDilavrec"}, "path": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "diffHunk": "@@ -101,7 +105,32 @@ public String getSimpleName() {\n \t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n \t\t\treturn null;\n \t\t}\n-\t\tCtType<T> lambdaType = lambdaTypeRef.getTypeDeclaration();\n+\t\tCtMethod<?> lambdaExecutableMethod = null;\n+\t\tif (!(lambdaTypeRef instanceof CtIntersectionTypeReference)) {\n+\t\t\treturn getOverriddenAux(lambdaTypeRef);\n+\t\t} else {\n+\t\t\tCtElement parent = lambdaTypeRef.getParent();\n+\t\t\tCtTypeReference<?> parentTypeReference = null;\n+\t\t\tif (parent != null && parent instanceof CtLocalVariable) {\n+\t\t\t\tparentTypeReference = ((CtLocalVariable) parent).getType();\n+\t\t\t} else if (parent != null && parent instanceof CtAssignment) {\n+\t\t\t\tparentTypeReference = ((CtAssignment) parent).getAssigned().getType();\n+\t\t\t}\n+\t\t\tfor (CtTypeReference<?> ctTypeReference : ((CtIntersectionTypeReference<?>) lambdaTypeRef).getBounds()) {\n+\t\t\t\tCtMethod<?> tmp = getOverriddenAux(ctTypeReference);\n+\t\t\t\tif (tmp != null && (lambdaExecutableMethod == null || ctTypeReference.equals(parentTypeReference))) {\n+\t\t\t\t\tlambdaExecutableMethod = tmp;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (lambdaExecutableMethod == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjY1NQ=="}, "originalCommit": {"oid": "d816c9fe1ad55486267b051e2ce934ddf6e266e2"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1ODM2Mg==", "bodyText": "OK for me, thanks.", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r470958362", "createdAt": "2020-08-15T09:23:21Z", "author": {"login": "monperrus"}, "path": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "diffHunk": "@@ -101,7 +105,32 @@ public String getSimpleName() {\n \t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n \t\t\treturn null;\n \t\t}\n-\t\tCtType<T> lambdaType = lambdaTypeRef.getTypeDeclaration();\n+\t\tCtMethod<?> lambdaExecutableMethod = null;\n+\t\tif (!(lambdaTypeRef instanceof CtIntersectionTypeReference)) {\n+\t\t\treturn getOverriddenAux(lambdaTypeRef);\n+\t\t} else {\n+\t\t\tCtElement parent = lambdaTypeRef.getParent();\n+\t\t\tCtTypeReference<?> parentTypeReference = null;\n+\t\t\tif (parent != null && parent instanceof CtLocalVariable) {\n+\t\t\t\tparentTypeReference = ((CtLocalVariable) parent).getType();\n+\t\t\t} else if (parent != null && parent instanceof CtAssignment) {\n+\t\t\t\tparentTypeReference = ((CtAssignment) parent).getAssigned().getType();\n+\t\t\t}\n+\t\t\tfor (CtTypeReference<?> ctTypeReference : ((CtIntersectionTypeReference<?>) lambdaTypeRef).getBounds()) {\n+\t\t\t\tCtMethod<?> tmp = getOverriddenAux(ctTypeReference);\n+\t\t\t\tif (tmp != null && (lambdaExecutableMethod == null || ctTypeReference.equals(parentTypeReference))) {\n+\t\t\t\t\tlambdaExecutableMethod = tmp;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (lambdaExecutableMethod == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjY1NQ=="}, "originalCommit": {"oid": "d816c9fe1ad55486267b051e2ce934ddf6e266e2"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMDExMDEwOnYy", "diffSide": "RIGHT", "path": "src/test/java/spoon/test/lambda/LambdaTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQxMzo0OToxNFrOG9z6Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQxMzo0OToxNFrOG9z6Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjgzNQ==", "bodyText": "could you add a one line comment stating the test intention in natural language:\n// contract: intersection types on lambda parameters are supported", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r467466835", "createdAt": "2020-08-08T13:49:14Z", "author": {"login": "monperrus"}, "path": "src/test/java/spoon/test/lambda/LambdaTest.java", "diffHunk": "@@ -458,6 +458,16 @@ public void testLambdaWithGenericExtendingMultipleInterfaces() {\n \t\tassertIsWellPrinted(\"( elt) -> elt.test()\", lambda);\n \t}\n \n+\t@Test\n+\tpublic void testCastLambdaWithIntersection() {\n+\t\tfinal CtLambda<?> lambda1 = intersection.getElements(new TypeFilter<CtLambda<?>>(CtLambda.class)).get(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d816c9fe1ad55486267b051e2ce934ddf6e266e2"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3640, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}