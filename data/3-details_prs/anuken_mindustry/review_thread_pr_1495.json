{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwMjMyNTE4", "number": 1495, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToxMzowNFrODcmMmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNTozNDo1MlrODcrKBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzEyNTM2OnYy", "diffSide": "RIGHT", "path": "core/src/mindustry/world/modules/ItemModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToxMzowNFrOFkt7Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToxMzowNFrOFkt7Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0NTUyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \t\t\t// save the next position so the next call to take() can resume from there.\n          \n          \n            \n                \t\t// save the next position so the next call to take() can resume from there.", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374045523", "createdAt": "2020-02-03T11:13:04Z", "author": {"login": "Quezler"}, "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t\t// save the next position so the next call to take() can resume from there.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d4a6d3d0c9a887dd1b3c6b1f4c3f20c31c962e7"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzEyNjA1OnYy", "diffSide": "RIGHT", "path": "core/src/mindustry/world/modules/ItemModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToxMzoxOFrOFkt7uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToxMzoxOFrOFkt7uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0NTYyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \t\t\t// save the next position so the next call to take() can resume from there.\n          \n          \n            \n                \t\t// save the next position so the next call to take() can resume from there.", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374045625", "createdAt": "2020-02-03T11:13:18Z", "author": {"login": "Quezler"}, "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t\t// save the next position so the next call to take() can resume from there.\n+                takeRotation = (i + 1) % items.length;\n+                return content.item(i);\n+            }\n+        }\n+\n+        // Then start a new lap which ends where the call started from if empty.\n+        for(int i = 0; i < takeRotation; i++){\n             if(items[i] > 0){\n                 items[i]--;\n                 total--;\n+    \t\t\t// save the next position so the next call to take() can resume from there.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d4a6d3d0c9a887dd1b3c6b1f4c3f20c31c962e7"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzkzNzEwOnYy", "diffSide": "RIGHT", "path": "core/src/mindustry/world/modules/ItemModule.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNTozNDozOFrOFk1mOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMTowMTozOVrOFlFKCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTE5Mw==", "bodyText": "This method can be written as a single loop.\nfor(int i = 0; i < items.length; i++){\n    int index = (i + takeRotation) % items.length;\n    if(items[index] > 0){\n        items[index] --;\n        total --;\n        takeRotation = (index + 1) % items.length;\n        return content.item(i);\n    }\n}", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374171193", "createdAt": "2020-02-03T15:34:38Z", "author": {"login": "Anuken"}, "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t// save the next position so the next call to take() can resume from there.\n+                takeRotation = (i + 1) % items.length;\n+                return content.item(i);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da52696d7e734ebb05fdc5d10470277d5d5e820"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMxNTI0Nw==", "bodyText": "Sure, it can, though modulo remains an extremely expensive instruction on modern hardware (from 15-25 cycles for IDIV/r8 to 50-70 cycles for /r64 vs less than one cycle effective cost for most other 1-5 cycles ALU instructions due to pipelined superscalar execution) and depending on how the java compiler re-factors this, you can conceivably spend more CPU time waiting for IDIV to produce the remainder the rest of the loop depends on than doing useful work in tight loops like that.\nAs a mostly low-level/bare-metal ASM/C/C++/VHDL programmer, putting an exceptionally expensive operation in an otherwise trivial loop's control path when it can so easily be avoided bothers me.\nHope you found this bit of low-level hardware perspective enlightening.", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374315247", "createdAt": "2020-02-03T20:10:13Z", "author": {"login": "InvalidError404"}, "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t// save the next position so the next call to take() can resume from there.\n+                takeRotation = (i + 1) % items.length;\n+                return content.item(i);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTE5Mw=="}, "originalCommit": {"oid": "5da52696d7e734ebb05fdc5d10470277d5d5e820"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM0OTg3Nw==", "bodyText": "I am aware that modulo is generally considered expensive, but in this case there isn't much of a benefit to splitting things up into two loops. Adding an extra loop adds more code and makes this method harder to read and modify.\nYou also have to consider the fact that this is extremely premature optimization. take() is a method that is called only once per frame for every input bridge and unloader. Considering that most active games have few amounts of these blocks being used, it really doesn't matter which implementation is slower, because the difference is only going to be on the order of a few nanoseconds. I would rather have more readable code than something that's ugly and imperceptibly faster.\nThat being said, I tried benchmarking both versions to see how significant the speed difference was, and the performance difference (with random items) for these two is about ~12 ns, with the non-modulo one taking 30 and the other taking 42. Rewriting the mod implementation to mostly use subtraction instead of modulo actually made it run faster than yours, with 21 ns taken per invocation. This benchmark probably isn't too accurate, but when dealing with nanoseconds, I don't think it'll matter too much.\nCode:\n            for(int i = 0; i < items.length; i++){\n                int index = (i + takeRotation);\n                if(index >= items.length) index -= items.length; //conditional instead of mod\n                if(items[index] > 0){\n                    items[index] --;\n                    total --;\n                    takeRotation = index + 1;\n                    return content.item(index % items.length); //called rarely so it doesn't really matter here, according to benchmarks\n                }\n            }\n\n            return null;", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374349877", "createdAt": "2020-02-03T21:26:35Z", "author": {"login": "Anuken"}, "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t// save the next position so the next call to take() can resume from there.\n+                takeRotation = (i + 1) % items.length;\n+                return content.item(i);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTE5Mw=="}, "originalCommit": {"oid": "5da52696d7e734ebb05fdc5d10470277d5d5e820"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjEyMQ==", "bodyText": "Guessing this is speculative execution at work: branch prediction may not like my front loop having a pseudo-random starting point so your more predictable loop ends up cheaper overall despite having an extra test.\nAs for being imperceptibly faster, imperceptibly faster bits of code add up over time.", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374426121", "createdAt": "2020-02-04T01:01:39Z", "author": {"login": "InvalidError404"}, "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t// save the next position so the next call to take() can resume from there.\n+                takeRotation = (i + 1) % items.length;\n+                return content.item(i);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTE5Mw=="}, "originalCommit": {"oid": "5da52696d7e734ebb05fdc5d10470277d5d5e820"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzkzNzk2OnYy", "diffSide": "RIGHT", "path": "core/src/mindustry/world/modules/ItemModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNTozNDo1MlrOFk1myg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMDoxNzoxNlrOFk-mLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTMzOA==", "bodyText": "Instance variables should always be declared at the top of a class.", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374171338", "createdAt": "2020-02-03T15:34:52Z", "author": {"login": "Anuken"}, "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da52696d7e734ebb05fdc5d10470277d5d5e820"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMxODYzNw==", "bodyText": "Of course, sorry about that.\nJust wanted to put the tweak out for people to try and hopefully see the modified behavior or something resembling it make it into a future release.", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374318637", "createdAt": "2020-02-03T20:17:16Z", "author": {"login": "InvalidError404"}, "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTMzOA=="}, "originalCommit": {"oid": "5da52696d7e734ebb05fdc5d10470277d5d5e820"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4325, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}