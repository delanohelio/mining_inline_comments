{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NDM4MTI1", "number": 8711, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODo0ODo1OVrODlilxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODo1NDowMlrODlisjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjkwNjMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mule/runtime/core/api/util/ClassUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODo0OTowMFrOFyflbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMToxNTozNlrOFykaaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDYwNA==", "bodyText": "what's the purpose of this method if most of the dirty work has to be done by the caller?", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388490604", "createdAt": "2020-03-05T18:49:00Z", "author": {"login": "elrodro83"}, "path": "core/src/main/java/org/mule/runtime/core/api/util/ClassUtils.java", "diffHunk": "@@ -957,17 +971,49 @@ public static void withContextClassLoader(ClassLoader classLoader, Runnable runn\n     }\n   }\n \n+  /**\n+   * Sets {@code newClassLoader} as the context class loader for the {@code thread}, as long as said classloader is not the\n+   * same instance as {@code currentClassLoader}.\n+   * <p>\n+   * Since obtaining and setting the context classloader from a thread are expensive operations, the purpose of this method\n+   * is to avoid performing those operations when possible, which is why the two classloaders are tested not to be the same\n+   * before performing the set operation. For this method to make sense, {@code currentClassLoader} should actually be the\n+   * current context classloader from the {@code thread}.\n+   * <p>\n+   * This is how a typical use should look like:\n+   * <pre>\n+   *   Thread thread = Thread.currentThread();\n+   *   ClassLoader currentClassLoader = thread.getContextClassLoader();\n+   *   ClassLoader newClassLoader = getNewContextClassLoader(); // this one depends on your logic\n+   *   ClassUtils.setContextClassLoader(thread, currentClassLoader, newClassLoader);\n+   *   try {\n+   *     // execute your logic\n+   *   } finally {\n+   *     // set things back as they were by reversing the arguments order\n+   *     ClassUtils.setContextClassLoader(thread, newClassLoader, currentClassLoader);\n+   *   }\n+   * </pre>\n+   *\n+   * @param thread             the thread which context classloader is to be changed\n+   * @param currentClassLoader the thread's current context classloader\n+   * @param newClassLoader     the new classloader to be set\n+   * @since 4.3.0\n+   */\n+  public static void setContextClassLoader(Thread thread, ClassLoader currentClassLoader, ClassLoader newClassLoader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2OTM4Ng==", "bodyText": "basically? the if... do not switch if the target classloader is the same as the current", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388569386", "createdAt": "2020-03-05T21:14:55Z", "author": {"login": "marianogonzalez"}, "path": "core/src/main/java/org/mule/runtime/core/api/util/ClassUtils.java", "diffHunk": "@@ -957,17 +971,49 @@ public static void withContextClassLoader(ClassLoader classLoader, Runnable runn\n     }\n   }\n \n+  /**\n+   * Sets {@code newClassLoader} as the context class loader for the {@code thread}, as long as said classloader is not the\n+   * same instance as {@code currentClassLoader}.\n+   * <p>\n+   * Since obtaining and setting the context classloader from a thread are expensive operations, the purpose of this method\n+   * is to avoid performing those operations when possible, which is why the two classloaders are tested not to be the same\n+   * before performing the set operation. For this method to make sense, {@code currentClassLoader} should actually be the\n+   * current context classloader from the {@code thread}.\n+   * <p>\n+   * This is how a typical use should look like:\n+   * <pre>\n+   *   Thread thread = Thread.currentThread();\n+   *   ClassLoader currentClassLoader = thread.getContextClassLoader();\n+   *   ClassLoader newClassLoader = getNewContextClassLoader(); // this one depends on your logic\n+   *   ClassUtils.setContextClassLoader(thread, currentClassLoader, newClassLoader);\n+   *   try {\n+   *     // execute your logic\n+   *   } finally {\n+   *     // set things back as they were by reversing the arguments order\n+   *     ClassUtils.setContextClassLoader(thread, newClassLoader, currentClassLoader);\n+   *   }\n+   * </pre>\n+   *\n+   * @param thread             the thread which context classloader is to be changed\n+   * @param currentClassLoader the thread's current context classloader\n+   * @param newClassLoader     the new classloader to be set\n+   * @since 4.3.0\n+   */\n+  public static void setContextClassLoader(Thread thread, ClassLoader currentClassLoader, ClassLoader newClassLoader) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDYwNA=="}, "originalCommit": {"oid": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2OTcwNA==", "bodyText": "switching the TCCL is expensive", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388569704", "createdAt": "2020-03-05T21:15:36Z", "author": {"login": "marianogonzalez"}, "path": "core/src/main/java/org/mule/runtime/core/api/util/ClassUtils.java", "diffHunk": "@@ -957,17 +971,49 @@ public static void withContextClassLoader(ClassLoader classLoader, Runnable runn\n     }\n   }\n \n+  /**\n+   * Sets {@code newClassLoader} as the context class loader for the {@code thread}, as long as said classloader is not the\n+   * same instance as {@code currentClassLoader}.\n+   * <p>\n+   * Since obtaining and setting the context classloader from a thread are expensive operations, the purpose of this method\n+   * is to avoid performing those operations when possible, which is why the two classloaders are tested not to be the same\n+   * before performing the set operation. For this method to make sense, {@code currentClassLoader} should actually be the\n+   * current context classloader from the {@code thread}.\n+   * <p>\n+   * This is how a typical use should look like:\n+   * <pre>\n+   *   Thread thread = Thread.currentThread();\n+   *   ClassLoader currentClassLoader = thread.getContextClassLoader();\n+   *   ClassLoader newClassLoader = getNewContextClassLoader(); // this one depends on your logic\n+   *   ClassUtils.setContextClassLoader(thread, currentClassLoader, newClassLoader);\n+   *   try {\n+   *     // execute your logic\n+   *   } finally {\n+   *     // set things back as they were by reversing the arguments order\n+   *     ClassUtils.setContextClassLoader(thread, newClassLoader, currentClassLoader);\n+   *   }\n+   * </pre>\n+   *\n+   * @param thread             the thread which context classloader is to be changed\n+   * @param currentClassLoader the thread's current context classloader\n+   * @param newClassLoader     the new classloader to be set\n+   * @since 4.3.0\n+   */\n+  public static void setContextClassLoader(Thread thread, ClassLoader currentClassLoader, ClassLoader newClassLoader) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDYwNA=="}, "originalCommit": {"oid": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjkwODA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mule/runtime/core/internal/execution/MuleMessageProcessingManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODo0OTozNFrOFyfmlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODo0OTozNFrOFyfmlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDkwMQ==", "bodyText": "see?", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388490901", "createdAt": "2020-03-05T18:49:34Z", "author": {"login": "elrodro83"}, "path": "core/src/main/java/org/mule/runtime/core/internal/execution/MuleMessageProcessingManager.java", "diffHunk": "@@ -38,8 +39,15 @@ public void initialise() throws InitialisationException {\n   @Override\n   public void processMessage(FlowProcessTemplate messageProcessTemplate,\n                              MessageProcessContext messageProcessContext) {\n-    withContextClassLoader(messageProcessContext.getExecutionClassLoader(),\n-                           () -> mediator.process(messageProcessTemplate, messageProcessContext, this));\n+    Thread currentThread = currentThread();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjkyMzY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/interceptor/ReactiveInterceptorAdapter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODo1NDowMlrOFyfwaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTo0MToyMlrOFylLvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzQxNg==", "bodyText": ":O", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388493416", "createdAt": "2020-03-05T18:54:02Z", "author": {"login": "elrodro83"}, "path": "core/src/main/java/org/mule/runtime/core/internal/processor/interceptor/ReactiveInterceptorAdapter.java", "diffHunk": "@@ -127,15 +128,22 @@ protected ReactiveProcessor doApply(Processor component, ReactiveProcessor next,\n         LOGGER.debug(\"Calling before() for '{}' in processor '{}'...\", interceptor,\n                      component.getLocation().getLocation());\n       }\n-\n       try {\n-        withContextClassLoader(interceptor.getClass().getClassLoader(),\n-                               () -> interceptor.before(component.getLocation(),\n-                                                        getResolvedParams(eventWithResolvedParams),\n-                                                        interceptionEvent));\n+        Thread currentThread = currentThread();\n+        ClassLoader currentClassLoader = currentThread.getContextClassLoader();\n+        ClassLoader contextClassLoader = interceptor.getClass().getClassLoader();\n+        setContextClassLoader(currentThread, currentClassLoader, contextClassLoader);\n+        try {\n+          interceptor.before(component.getLocation(),\n+                             getResolvedParams(eventWithResolvedParams),\n+                             interceptionEvent);\n+        } finally {\n+          setContextClassLoader(currentThread, contextClassLoader, currentClassLoader);\n+        }\n+\n         return interceptionEvent.resolve();\n       } catch (Exception e) {\n-        throw propagate(new MessagingException(interceptionEvent.resolve(), e.getCause(), component));\n+        throw propagate(new MessagingException(interceptionEvent.resolve(), e, component));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MjMzMw==", "bodyText": "this is because the functional idiom was wrapping the exception into a MuleRuntimeException, which is why the exception was being unwrapped", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388582333", "createdAt": "2020-03-05T21:41:22Z", "author": {"login": "marianogonzalez"}, "path": "core/src/main/java/org/mule/runtime/core/internal/processor/interceptor/ReactiveInterceptorAdapter.java", "diffHunk": "@@ -127,15 +128,22 @@ protected ReactiveProcessor doApply(Processor component, ReactiveProcessor next,\n         LOGGER.debug(\"Calling before() for '{}' in processor '{}'...\", interceptor,\n                      component.getLocation().getLocation());\n       }\n-\n       try {\n-        withContextClassLoader(interceptor.getClass().getClassLoader(),\n-                               () -> interceptor.before(component.getLocation(),\n-                                                        getResolvedParams(eventWithResolvedParams),\n-                                                        interceptionEvent));\n+        Thread currentThread = currentThread();\n+        ClassLoader currentClassLoader = currentThread.getContextClassLoader();\n+        ClassLoader contextClassLoader = interceptor.getClass().getClassLoader();\n+        setContextClassLoader(currentThread, currentClassLoader, contextClassLoader);\n+        try {\n+          interceptor.before(component.getLocation(),\n+                             getResolvedParams(eventWithResolvedParams),\n+                             interceptionEvent);\n+        } finally {\n+          setContextClassLoader(currentThread, contextClassLoader, currentClassLoader);\n+        }\n+\n         return interceptionEvent.resolve();\n       } catch (Exception e) {\n-        throw propagate(new MessagingException(interceptionEvent.resolve(), e.getCause(), component));\n+        throw propagate(new MessagingException(interceptionEvent.resolve(), e, component));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzQxNg=="}, "originalCommit": {"oid": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 61, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}