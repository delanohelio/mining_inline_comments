{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0OTExNDAw", "number": 8647, "title": "MULE-18020: Fix reconnection for Paged Operations that fail after the first page.", "bodyText": "", "createdAt": "2020-02-13T14:52:33Z", "url": "https://github.com/mulesoft/mule/pull/8647", "merged": true, "mergeCommit": {"oid": "bcc34a17b231011c03a3a06f78401fa63d0712c7"}, "closed": true, "closedAt": "2020-02-20T21:24:28Z", "author": {"login": "SebaElizalde"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDrR9DgH2gAyMzc0OTExNDAwOmMyZDcyMWY0Yzk0MWFmYzAzNGEzZDkxYjBmNjYwNDI2ZjRmYjZkMmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGR7pjAFqTM2MjI0MzM2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c2d721f4c941afc034a3d91b0f660426f4fb6d2a", "author": {"user": {"login": "SebaElizalde", "name": "Sebastian Elizalde"}}, "url": "https://github.com/mulesoft/mule/commit/c2d721f4c941afc034a3d91b0f660426f4fb6d2a", "committedDate": "2020-02-12T19:13:23Z", "message": "fix +  tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9bd7a1c4eeb10a7db7af2972afbc8736f478d88", "author": {"user": {"login": "SebaElizalde", "name": "Sebastian Elizalde"}}, "url": "https://github.com/mulesoft/mule/commit/a9bd7a1c4eeb10a7db7af2972afbc8736f478d88", "committedDate": "2020-02-12T19:13:50Z", "message": "refactored tests to avoid issues when the whole suite was run"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "def818d5b8da6787d2ccbf887386889c26dc2f6f", "author": {"user": {"login": "SebaElizalde", "name": "Sebastian Elizalde"}}, "url": "https://github.com/mulesoft/mule/commit/def818d5b8da6787d2ccbf887386889c26dc2f6f", "committedDate": "2020-02-13T14:51:23Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0910f63f4ff3ac84aeece0f83cace5961080979c", "author": {"user": {"login": "SebaElizalde", "name": "Sebastian Elizalde"}}, "url": "https://github.com/mulesoft/mule/commit/0910f63f4ff3ac84aeece0f83cace5961080979c", "committedDate": "2020-02-17T21:50:37Z", "message": "boom"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd303d2c83d06ef609e1e91a1ca3a6efc4468e49", "author": {"user": {"login": "SebaElizalde", "name": "Sebastian Elizalde"}}, "url": "https://github.com/mulesoft/mule/commit/dd303d2c83d06ef609e1e91a1ca3a6efc4468e49", "committedDate": "2020-02-17T22:03:18Z", "message": "minor changes (pr polish)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "author": {"user": {"login": "SebaElizalde", "name": "Sebastian Elizalde"}}, "url": "https://github.com/mulesoft/mule/commit/76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "committedDate": "2020-02-18T16:07:14Z", "message": "schemas and refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjgyMjkw", "url": "https://github.com/mulesoft/mule/pull/8647#pullrequestreview-360682290", "createdAt": "2020-02-18T21:23:08Z", "commit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMToyMzowOFrOFrS54Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMTozMjozNFrOFrTLug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MjgxNw==", "bodyText": "use the ExpectedException rule and assert on the cause being THE SAME instance you are expecting and the actual exception being of the correct type", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380942817", "createdAt": "2020-02-18T21:23:08Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -106,13 +108,13 @@ public void getInlineRetryPolicyTemplate() throws Exception {\n   public void reconnectAfterConnectionExceptionOnFirstPage() throws Exception {\n     resetCounters();\n     Iterator<ReconnectableConnection> iterator = getCursor(\"pagedOperation\", 1, CONNECTIVITY);\n-    ReconnectableConnection firstPage = iterator.next();\n-    assertThat(\"Connection was not disconnected.\", firstPage.getDisconnectCalls(), is(1));\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n     assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n   }\n \n-  @Test\n-  public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n+  @Test(expected = IllegalArgumentException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0Mjk1Mg==", "bodyText": "replace all of this with the expectedException rule", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380942952", "createdAt": "2020-02-18T21:23:26Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -123,18 +125,83 @@ public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n       assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n       assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n       assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e.getCause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MzA3MQ==", "bodyText": "same as before", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380943071", "createdAt": "2020-02-18T21:23:40Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -123,18 +125,83 @@ public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n       assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n       assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n       assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e.getCause();\n+    }\n+  }\n+\n+  @Test\n+  public void reconnectionDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator = getCursor(\"pagedOperation\", 2, CONNECTIVITY);\n+\n+    iterator.next();\n+    assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void doNotReconnectAfterOtherExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator;\n+    try {\n+      iterator = getCursor(\"pagedOperation\", 2, VALIDATION);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(IllegalArgumentException.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MzEyMQ==", "bodyText": "same as before", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380943121", "createdAt": "2020-02-18T21:23:47Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -123,18 +125,83 @@ public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n       assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n       assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n       assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e.getCause();\n+    }\n+  }\n+\n+  @Test\n+  public void reconnectionDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator = getCursor(\"pagedOperation\", 2, CONNECTIVITY);\n+\n+    iterator.next();\n+    assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void doNotReconnectAfterOtherExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator;\n+    try {\n+      iterator = getCursor(\"pagedOperation\", 2, VALIDATION);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(IllegalArgumentException.class));\n+      assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n+      assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(0));\n+      assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e;\n     }\n   }\n \n   @Test\n   public void stickyConnectionIsClosedAndReconnectedDuringConnectionExceptionOnFirstPage() throws Exception {\n     resetCounters();\n     Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 1, CONNECTIVITY);\n-    ReconnectableConnection firstPage = iterator.next();\n-    assertThat(\"Connection was not disconnected.\", firstPage.getDisconnectCalls(), is(1));\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n     assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n   }\n \n+  @Test(expected = ModuleException.class)\n+  public void stickyConnectionIsNotReconnectedDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    try {\n+      Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 2, CONNECTIVITY);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(ModuleException.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MzE3Nw==", "bodyText": "same as before", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380943177", "createdAt": "2020-02-18T21:23:54Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -123,18 +125,83 @@ public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n       assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n       assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n       assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e.getCause();\n+    }\n+  }\n+\n+  @Test\n+  public void reconnectionDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator = getCursor(\"pagedOperation\", 2, CONNECTIVITY);\n+\n+    iterator.next();\n+    assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void doNotReconnectAfterOtherExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator;\n+    try {\n+      iterator = getCursor(\"pagedOperation\", 2, VALIDATION);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(IllegalArgumentException.class));\n+      assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n+      assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(0));\n+      assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e;\n     }\n   }\n \n   @Test\n   public void stickyConnectionIsClosedAndReconnectedDuringConnectionExceptionOnFirstPage() throws Exception {\n     resetCounters();\n     Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 1, CONNECTIVITY);\n-    ReconnectableConnection firstPage = iterator.next();\n-    assertThat(\"Connection was not disconnected.\", firstPage.getDisconnectCalls(), is(1));\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n     assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n   }\n \n+  @Test(expected = ModuleException.class)\n+  public void stickyConnectionIsNotReconnectedDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    try {\n+      Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 2, CONNECTIVITY);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(ModuleException.class));\n+      assertThat(e.getCause(), instanceOf(ConnectionException.class));\n+      assertThat(e.getCause().getMessage(), is(\"Failed to retrieve Page\"));\n+      assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(0));\n+      assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n+      throw e;\n+    }\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void stickyConnectionIsNotReconnectedDuringOtherExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    try {\n+      Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 2, VALIDATION);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(IllegalArgumentException.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NDkwNQ==", "bodyText": "Define constant in org.mule.runtime.module.extension.internal.ExtensionProperties. Also the key should start with the proper prefix.", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380944905", "createdAt": "2020-02-18T21:27:34Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/streaming/PagingProviderProducer.java", "diffHunk": "@@ -91,27 +101,58 @@ public int getSize() {\n    * @return\n    */\n   private <R> R performWithConnection(Function<Object, R> function) {\n+    Optional<MutableConfigurationStats> stats = getMutableConfigurationStats(executionContext);\n+    RetryPolicyTemplate retryPolicy =\n+        (RetryPolicyTemplate) executionContext.getRetryPolicyTemplate().orElseGet(NoRetryPolicyTemplate::new);\n+    CompletableFuture<R> future = retryPolicy.applyPolicy(() -> completedFuture(withConnection(function)),\n+                                                          e -> !isFirstPage && !delegate.useStickyConnections()\n+                                                              && shouldRetry(e, executionContext),\n+                                                          e -> {\n+                                                          },\n+                                                          e -> stats.ifPresent(s -> s.discountInflightOperation()),\n+                                                          identity(),\n+                                                          executionContext.getCurrentScheduler());\n+    try {\n+      return future.get();\n+    } catch (ExecutionException e) {\n+      if (e.getCause() instanceof RuntimeException) {\n+        throw (RuntimeException) e.getCause();\n+      }\n+      throw new MuleRuntimeException(createStaticMessage(COULD_NOT_EXECUTE), e.getCause());\n+    } catch (InterruptedException e) {\n+      throw new MuleRuntimeException(createStaticMessage(COULD_NOT_EXECUTE), e);\n+    }\n+  }\n+\n+  private <R> R withConnection(Function<Object, R> function) {\n     ConnectionSupplier connectionSupplier = getConnectionSupplier();\n     Object connection = getConnection(connectionSupplier);\n     try {\n       R result = function.apply(connection);\n       return result;\n-    } catch (Exception exception) {\n+    } catch (Exception caughtException) {\n       if (isFirstPage) {\n         safely(() -> delegate.close(connection), e -> LOGGER.debug(\"Found exception closing paging provider\", e));\n       }\n-      extractConnectionException(exception).ifPresent(ex -> {\n-        if (isTransactional()) {\n-          executionContext.setVariable(DO_NOT_RETRY, \"true\");\n-        }\n-        connectionSupplier.invalidateConnection();\n-      });\n-      throw exception;\n+      extractConnectionException(caughtException).ifPresent(e -> handleConnectionException(e, connectionSupplier));\n+      throw caughtException;\n     } finally {\n       safely(connectionSupplier::close, e -> LOGGER.debug(\"Found exception closing the connection supplier\", e));\n     }\n   }\n \n+  private void handleConnectionException(ConnectionException connectionException, ConnectionSupplier connectionSupplier) {\n+    Optional<String> exceptionConfigName =\n+        executionContext.getConfiguration().map(config -> ((ConfigurationInstance) config).getName());\n+    if (isTransactional()) {\n+      connectionException.addInfo(\"wasTransactional\", true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NTMwMA==", "bodyText": "same", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380945300", "createdAt": "2020-02-18T21:28:22Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/streaming/PagingProviderProducer.java", "diffHunk": "@@ -91,27 +101,58 @@ public int getSize() {\n    * @return\n    */\n   private <R> R performWithConnection(Function<Object, R> function) {\n+    Optional<MutableConfigurationStats> stats = getMutableConfigurationStats(executionContext);\n+    RetryPolicyTemplate retryPolicy =\n+        (RetryPolicyTemplate) executionContext.getRetryPolicyTemplate().orElseGet(NoRetryPolicyTemplate::new);\n+    CompletableFuture<R> future = retryPolicy.applyPolicy(() -> completedFuture(withConnection(function)),\n+                                                          e -> !isFirstPage && !delegate.useStickyConnections()\n+                                                              && shouldRetry(e, executionContext),\n+                                                          e -> {\n+                                                          },\n+                                                          e -> stats.ifPresent(s -> s.discountInflightOperation()),\n+                                                          identity(),\n+                                                          executionContext.getCurrentScheduler());\n+    try {\n+      return future.get();\n+    } catch (ExecutionException e) {\n+      if (e.getCause() instanceof RuntimeException) {\n+        throw (RuntimeException) e.getCause();\n+      }\n+      throw new MuleRuntimeException(createStaticMessage(COULD_NOT_EXECUTE), e.getCause());\n+    } catch (InterruptedException e) {\n+      throw new MuleRuntimeException(createStaticMessage(COULD_NOT_EXECUTE), e);\n+    }\n+  }\n+\n+  private <R> R withConnection(Function<Object, R> function) {\n     ConnectionSupplier connectionSupplier = getConnectionSupplier();\n     Object connection = getConnection(connectionSupplier);\n     try {\n       R result = function.apply(connection);\n       return result;\n-    } catch (Exception exception) {\n+    } catch (Exception caughtException) {\n       if (isFirstPage) {\n         safely(() -> delegate.close(connection), e -> LOGGER.debug(\"Found exception closing paging provider\", e));\n       }\n-      extractConnectionException(exception).ifPresent(ex -> {\n-        if (isTransactional()) {\n-          executionContext.setVariable(DO_NOT_RETRY, \"true\");\n-        }\n-        connectionSupplier.invalidateConnection();\n-      });\n-      throw exception;\n+      extractConnectionException(caughtException).ifPresent(e -> handleConnectionException(e, connectionSupplier));\n+      throw caughtException;\n     } finally {\n       safely(connectionSupplier::close, e -> LOGGER.debug(\"Found exception closing the connection supplier\", e));\n     }\n   }\n \n+  private void handleConnectionException(ConnectionException connectionException, ConnectionSupplier connectionSupplier) {\n+    Optional<String> exceptionConfigName =\n+        executionContext.getConfiguration().map(config -> ((ConfigurationInstance) config).getName());\n+    if (isTransactional()) {\n+      connectionException.addInfo(\"wasTransactional\", true);\n+    }\n+    if (isFirstPage) {\n+      exceptionConfigName.ifPresent(name -> connectionException.addInfo(\"operationConfigName\", name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NjQ3Ng==", "bodyText": "return Objects.equals(operaetionConfigName, contextConfigName)", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380946476", "createdAt": "2020-02-18T21:30:42Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/util/ReconnectionUtils.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.extension.internal.util;\n+\n+import static java.lang.Boolean.parseBoolean;\n+import static org.mule.runtime.core.api.transaction.TransactionCoordination.isTransactionActive;\n+import static org.mule.runtime.core.api.util.ExceptionUtils.extractConnectionException;\n+import static org.mule.runtime.module.extension.internal.ExtensionProperties.DO_NOT_RETRY;\n+\n+import org.mule.runtime.api.connection.ConnectionException;\n+import org.mule.runtime.core.api.transaction.Transaction;\n+import org.mule.runtime.core.api.transaction.TransactionCoordination;\n+import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n+import org.mule.runtime.module.extension.api.runtime.privileged.ExecutionContextAdapter;\n+import org.mule.runtime.module.extension.internal.runtime.transaction.ExtensionTransactionKey;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Utilities for handling reconnection on operations that use a connection.\n+ *\n+ * @since 4.2.3\n+ */\n+public class ReconnectionUtils {\n+\n+  /**\n+   * @param t the {@link Throwable} thrown during the execution of the operation\n+   * @param context the {@link ExecutionContextAdapter} that contains the context information about the operation's execution\n+   * @return whether or not the operation should be retried\n+   */\n+  public static boolean shouldRetry(Throwable t, ExecutionContextAdapter<?> context) {\n+    Optional<String> contextConfigName = context.getConfiguration().map(ConfigurationInstance::getName);\n+    Optional<ConnectionException> connectionException = extractConnectionException(t);\n+    if (Boolean.valueOf(context.getVariable(DO_NOT_RETRY)) || !connectionException.isPresent()) {\n+      return false;\n+    }\n+\n+    if (isTransactionActive()) {\n+      Transaction tx = TransactionCoordination.getInstance().getTransaction();\n+\n+      return !tx.hasResource(new ExtensionTransactionKey(context.getConfiguration().get()));\n+    }\n+\n+    return validateConnectionException(connectionException.get(), contextConfigName.orElse(null));\n+  }\n+\n+  private static boolean validateConnectionException(ConnectionException connectionException, String contextConfigName) {\n+    Boolean wasTransactional = (Boolean) connectionException.getInfo().get(\"wasTransactional\");\n+    if (wasTransactional != null && wasTransactional) {\n+      return false;\n+    }\n+    Object operationConfigName = connectionException.getInfo().get(\"operationConfigName\");\n+    if (operationConfigName != null && contextConfigName != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NzM4Ng==", "bodyText": "a boolean method should not start with validate. Give this a more meaningful name and add a comment explaining why this is necessary", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380947386", "createdAt": "2020-02-18T21:32:34Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/util/ReconnectionUtils.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.extension.internal.util;\n+\n+import static java.lang.Boolean.parseBoolean;\n+import static org.mule.runtime.core.api.transaction.TransactionCoordination.isTransactionActive;\n+import static org.mule.runtime.core.api.util.ExceptionUtils.extractConnectionException;\n+import static org.mule.runtime.module.extension.internal.ExtensionProperties.DO_NOT_RETRY;\n+\n+import org.mule.runtime.api.connection.ConnectionException;\n+import org.mule.runtime.core.api.transaction.Transaction;\n+import org.mule.runtime.core.api.transaction.TransactionCoordination;\n+import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n+import org.mule.runtime.module.extension.api.runtime.privileged.ExecutionContextAdapter;\n+import org.mule.runtime.module.extension.internal.runtime.transaction.ExtensionTransactionKey;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Utilities for handling reconnection on operations that use a connection.\n+ *\n+ * @since 4.2.3\n+ */\n+public class ReconnectionUtils {\n+\n+  /**\n+   * @param t the {@link Throwable} thrown during the execution of the operation\n+   * @param context the {@link ExecutionContextAdapter} that contains the context information about the operation's execution\n+   * @return whether or not the operation should be retried\n+   */\n+  public static boolean shouldRetry(Throwable t, ExecutionContextAdapter<?> context) {\n+    Optional<String> contextConfigName = context.getConfiguration().map(ConfigurationInstance::getName);\n+    Optional<ConnectionException> connectionException = extractConnectionException(t);\n+    if (Boolean.valueOf(context.getVariable(DO_NOT_RETRY)) || !connectionException.isPresent()) {\n+      return false;\n+    }\n+\n+    if (isTransactionActive()) {\n+      Transaction tx = TransactionCoordination.getInstance().getTransaction();\n+\n+      return !tx.hasResource(new ExtensionTransactionKey(context.getConfiguration().get()));\n+    }\n+\n+    return validateConnectionException(connectionException.get(), contextConfigName.orElse(null));\n+  }\n+\n+  private static boolean validateConnectionException(ConnectionException connectionException, String contextConfigName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cecc385141e4af20237cc6f42f2415a15af7578", "author": {"user": {"login": "SebaElizalde", "name": "Sebastian Elizalde"}}, "url": "https://github.com/mulesoft/mule/commit/5cecc385141e4af20237cc6f42f2415a15af7578", "committedDate": "2020-02-18T22:05:24Z", "message": "refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "559d62af7b2a3d2af9d694b2f6a043a9fa49a9dc", "author": {"user": {"login": "SebaElizalde", "name": "Sebastian Elizalde"}}, "url": "https://github.com/mulesoft/mule/commit/559d62af7b2a3d2af9d694b2f6a043a9fa49a9dc", "committedDate": "2020-02-19T18:56:57Z", "message": "pr changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a55dcbc2a6fc3624bc134fc9ba7e22bd8aeef34d", "author": {"user": {"login": "marianogonzalez", "name": "Mariano Gonzalez"}}, "url": "https://github.com/mulesoft/mule/commit/a55dcbc2a6fc3624bc134fc9ba7e22bd8aeef34d", "committedDate": "2020-02-20T21:10:30Z", "message": "fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjQzMzY0", "url": "https://github.com/mulesoft/mule/pull/8647#pullrequestreview-362243364", "createdAt": "2020-02-20T21:23:10Z", "commit": {"oid": "a55dcbc2a6fc3624bc134fc9ba7e22bd8aeef34d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 967, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}