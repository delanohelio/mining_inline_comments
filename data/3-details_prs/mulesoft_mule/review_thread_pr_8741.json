{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjI4NTc0", "number": 8741, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOTo0MjozM1rODpQPhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOTo0MjozM1rODpQPhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTg0MzI2OnYy", "diffSide": "RIGHT", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOTo0MjozM1rOF4UPlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxOTo0Nzo1M1rOF4UaQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU5NjI0NA==", "bodyText": "is it correct to throw the exception even if the if resolved to true and the errorSink received the next() call?", "url": "https://github.com/mulesoft/mule/pull/8741#discussion_r394596244", "createdAt": "2020-03-18T19:42:33Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -311,8 +311,25 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n             .map(event -> {\n               try {\n                 return addContextToEvent(event, ctx);\n-              } catch (MuleException t) {\n-                throw propagateWrappingFatal(localOperatorErrorHook.apply(t, event));\n+              } catch (Exception t) {\n+                // Force the error mapper from the chain to be used.\n+                // When using Mono.create with sink.error, the error mapper from the\n+                // context is ignored, so it has to be explicitly used here.\n+                final Throwable mapped = localOperatorErrorHook.apply(t, event);\n+\n+                if (outerFluxTerminationTimeout < 0\n+                    // When there is a mono involved in some part of the chain, we cannot use the termination timeout because that\n+                    // would\n+                    // impose a timeout in the operation, which we don't want to.\n+                    // In this case, the flux will be complete when there are no more inflight operations.\n+                    || ctx.getOrDefault(WITHIN_PROCESS_TO_APPLY, false)) {\n+                  // if `sink.error` is called here, it will cancel the flux altogether.\n+                  // That's why an `Either` is used here,\n+                  // so the error can be propagated afterwards in a way consistent with our expected error handling.\n+                  errorSwitchSinkSinkRef.next(left(mapped, CoreEvent.class));\n+                }\n+\n+                throw propagateWrappingFatal(mapped);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ac0b415042445d44b7dbbd3f4218df17b404d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU5NzM2NA==", "bodyText": "yes, it will depend on what pipeline is using this component to determine if the exception is needed (Monos) or the result in the callback (Fluxes). In either case, it is a map, so it needs to return a mapped event, or in this case propagate the exception.", "url": "https://github.com/mulesoft/mule/pull/8741#discussion_r394597364", "createdAt": "2020-03-18T19:44:55Z", "author": {"login": "elrodro83"}, "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -311,8 +311,25 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n             .map(event -> {\n               try {\n                 return addContextToEvent(event, ctx);\n-              } catch (MuleException t) {\n-                throw propagateWrappingFatal(localOperatorErrorHook.apply(t, event));\n+              } catch (Exception t) {\n+                // Force the error mapper from the chain to be used.\n+                // When using Mono.create with sink.error, the error mapper from the\n+                // context is ignored, so it has to be explicitly used here.\n+                final Throwable mapped = localOperatorErrorHook.apply(t, event);\n+\n+                if (outerFluxTerminationTimeout < 0\n+                    // When there is a mono involved in some part of the chain, we cannot use the termination timeout because that\n+                    // would\n+                    // impose a timeout in the operation, which we don't want to.\n+                    // In this case, the flux will be complete when there are no more inflight operations.\n+                    || ctx.getOrDefault(WITHIN_PROCESS_TO_APPLY, false)) {\n+                  // if `sink.error` is called here, it will cancel the flux altogether.\n+                  // That's why an `Either` is used here,\n+                  // so the error can be propagated afterwards in a way consistent with our expected error handling.\n+                  errorSwitchSinkSinkRef.next(left(mapped, CoreEvent.class));\n+                }\n+\n+                throw propagateWrappingFatal(mapped);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU5NjI0NA=="}, "originalCommit": {"oid": "247ac0b415042445d44b7dbbd3f4218df17b404d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU5ODk3OA==", "bodyText": "ok.. i'll trust you... but I'm looking at you with suspicious eyes...\nhttps://i.pinimg.com/originals/48/4f/42/484f42995f748050bd50574d42aa0610.gif", "url": "https://github.com/mulesoft/mule/pull/8741#discussion_r394598978", "createdAt": "2020-03-18T19:47:53Z", "author": {"login": "marianogonzalez"}, "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -311,8 +311,25 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n             .map(event -> {\n               try {\n                 return addContextToEvent(event, ctx);\n-              } catch (MuleException t) {\n-                throw propagateWrappingFatal(localOperatorErrorHook.apply(t, event));\n+              } catch (Exception t) {\n+                // Force the error mapper from the chain to be used.\n+                // When using Mono.create with sink.error, the error mapper from the\n+                // context is ignored, so it has to be explicitly used here.\n+                final Throwable mapped = localOperatorErrorHook.apply(t, event);\n+\n+                if (outerFluxTerminationTimeout < 0\n+                    // When there is a mono involved in some part of the chain, we cannot use the termination timeout because that\n+                    // would\n+                    // impose a timeout in the operation, which we don't want to.\n+                    // In this case, the flux will be complete when there are no more inflight operations.\n+                    || ctx.getOrDefault(WITHIN_PROCESS_TO_APPLY, false)) {\n+                  // if `sink.error` is called here, it will cancel the flux altogether.\n+                  // That's why an `Either` is used here,\n+                  // so the error can be propagated afterwards in a way consistent with our expected error handling.\n+                  errorSwitchSinkSinkRef.next(left(mapped, CoreEvent.class));\n+                }\n+\n+                throw propagateWrappingFatal(mapped);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU5NjI0NA=="}, "originalCommit": {"oid": "247ac0b415042445d44b7dbbd3f4218df17b404d"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 83, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}