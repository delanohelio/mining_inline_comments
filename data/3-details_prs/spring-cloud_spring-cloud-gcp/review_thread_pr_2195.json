{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTI4NDQ2", "number": 2195, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTowMzoyN1rODf6yhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxODoyMjoxMFrODj6HLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Nzk1NjU0OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTowMzoyN1rOFp5fgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTowMToyMlrOFuRVOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ3Nzg5MQ==", "bodyText": "getSecretBytes perhaps?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r379477891", "createdAt": "2020-02-14T15:03:27Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, payload);\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as byte[]\n+\t */\n+\tpublic byte[] getSecretPayload(String secretId, String versionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2Mjc3OA==", "bodyText": "Done.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384062778", "createdAt": "2020-02-25T19:01:22Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, payload);\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as byte[]\n+\t */\n+\tpublic byte[] getSecretPayload(String secretId, String versionName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ3Nzg5MQ=="}, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Nzk2MjE1OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTowNTowN1rOFp5jEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTowMTozMlrOFuRVmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ3ODgwMA==", "bodyText": "I know it's a private method, but maybe even make it public?\nAlso for naming consistency: getSecretByteString?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r379478800", "createdAt": "2020-02-14T15:05:07Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, payload);\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as byte[]\n+\t */\n+\tpublic byte[] getSecretPayload(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toByteArray();\n+\t}\n+\n+\tprivate ByteString getSecretVersion(String secretId, String versionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2Mjg3NQ==", "bodyText": "Done.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384062875", "createdAt": "2020-02-25T19:01:32Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, payload);\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as byte[]\n+\t */\n+\tpublic byte[] getSecretPayload(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toByteArray();\n+\t}\n+\n+\tprivate ByteString getSecretVersion(String secretId, String versionName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ3ODgwMA=="}, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Nzk3MTQ2OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTowNzo0NVrOFp5oyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTowMTo0M1rOFuRWIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4MDI2NA==", "bodyText": "Why do we need to expose it?\nIt's a bean in the application context anyway.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r379480264", "createdAt": "2020-02-14T15:07:45Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, payload);\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as byte[]\n+\t */\n+\tpublic byte[] getSecretPayload(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toByteArray();\n+\t}\n+\n+\tprivate ByteString getSecretVersion(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Returns the lower-level {@link SecretManagerServiceClient} client object for making API\n+\t * calls to Secret Manager service.\n+\t *\n+\t * <p>\n+\t * Useful for executing more advanced use-cases that are not covered by\n+\t * {@link SecretManagerTemplate}.\n+\t *\n+\t * @return the {@link SecretManagerServiceClient} client object.\n+\t */\n+\tpublic SecretManagerServiceClient getSecretManagerServiceClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MzAwOA==", "bodyText": "Done. Removed.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384063008", "createdAt": "2020-02-25T19:01:43Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, payload);\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as byte[]\n+\t */\n+\tpublic byte[] getSecretPayload(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toByteArray();\n+\t}\n+\n+\tprivate ByteString getSecretVersion(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Returns the lower-level {@link SecretManagerServiceClient} client object for making API\n+\t * calls to Secret Manager service.\n+\t *\n+\t * <p>\n+\t * Useful for executing more advanced use-cases that are not covered by\n+\t * {@link SecretManagerTemplate}.\n+\t *\n+\t * @return the {@link SecretManagerServiceClient} client object.\n+\t */\n+\tpublic SecretManagerServiceClient getSecretManagerServiceClient() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4MDI2NA=="}, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Nzk3Njg2OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTowOToyNlrOFp5sLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxMTo1MFrOFuRqrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4MTEzMg==", "bodyText": "Why not just have two overloaded methods: one with String and one with byte[]?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r379481132", "createdAt": "2020-02-14T15:09:26Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2ODI2OQ==", "bodyText": "Done.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384068269", "createdAt": "2020-02-25T19:11:50Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4MTEzMg=="}, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Nzk4MTU5OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNToxMDo0MlrOFp5u-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxMTo1NlrOFuRq7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4MTg0OQ==", "bodyText": "You can get rid of this method if instead you rely on the two possible types: String and byte[].", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r379481849", "createdAt": "2020-02-14T15:10:42Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, payload);\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as byte[]\n+\t */\n+\tpublic byte[] getSecretPayload(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toByteArray();\n+\t}\n+\n+\tprivate ByteString getSecretVersion(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Returns the lower-level {@link SecretManagerServiceClient} client object for making API\n+\t * calls to Secret Manager service.\n+\t *\n+\t * <p>\n+\t * Useful for executing more advanced use-cases that are not covered by\n+\t * {@link SecretManagerTemplate}.\n+\t *\n+\t * @return the {@link SecretManagerServiceClient} client object.\n+\t */\n+\tpublic SecretManagerServiceClient getSecretManagerServiceClient() {\n+\t\treturn this.secretManagerServiceClient;\n+\t}\n+\n+\t/**\n+\t * Create a new version of the secret with the specified payload under a {@link Secret}.\n+\t */\n+\tprivate void createNewSecretVersion(String secretId, Object rawPayload) {\n+\t\tByteString payload = convertToByteString(rawPayload);\n+\n+\t\tSecretName name = SecretName.of(projectIdProvider.getProjectId(), secretId);\n+\t\tSecretPayload payloadObject = SecretPayload.newBuilder()\n+\t\t\t\t.setData(payload)\n+\t\t\t\t.build();\n+\n+\t\tAddSecretVersionRequest payloadRequest = AddSecretVersionRequest.newBuilder()\n+\t\t\t\t.setParent(name.toString())\n+\t\t\t\t.setPayload(payloadObject)\n+\t\t\t\t.build();\n+\t\tsecretManagerServiceClient.addSecretVersion(payloadRequest);\n+\t}\n+\n+\t/**\n+\t * Creates a new secret for the GCP Project.\n+\t *\n+\t * <p>\n+\t * Note that the {@link Secret} object does not contain the secret payload. You must\n+\t * create versions of the secret which stores the payload of the secret.\n+\t */\n+\tprivate void createSecret(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(projectIdProvider.getProjectId());\n+\n+\t\tSecret secret = Secret.newBuilder()\n+\t\t\t\t.setReplication(\n+\t\t\t\t\t\tReplication.newBuilder()\n+\t\t\t\t\t\t\t\t.setAutomatic(Replication.Automatic.newBuilder().build())\n+\t\t\t\t\t\t\t\t.build())\n+\t\t\t\t.build();\n+\t\tCreateSecretRequest request = CreateSecretRequest.newBuilder()\n+\t\t\t\t.setParent(projectName.toString())\n+\t\t\t\t.setSecretId(secretId)\n+\t\t\t\t.setSecret(secret)\n+\t\t\t\t.build();\n+\t\tthis.secretManagerServiceClient.createSecret(request);\n+\t}\n+\n+\t/**\n+\t * Returns true if there already exists a secret under the GCP project with the\n+\t * {@code secretId}.\n+\t */\n+\tprivate boolean secretExists(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(this.projectIdProvider.getProjectId());\n+\t\tListSecretsPagedResponse listSecretsResponse = this.secretManagerServiceClient.listSecrets(projectName);\n+\n+\t\treturn StreamSupport.stream(listSecretsResponse.iterateAll().spliterator(), false)\n+\t\t\t\t.anyMatch(secret -> secret.getName().contains(secretId));\n+\t}\n+\n+\tprivate ByteString convertToByteString(Object rawPayload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2ODMzMg==", "bodyText": "Done.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384068332", "createdAt": "2020-02-25T19:11:56Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with\n+\t * the secret {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload; supported payload types: (UTF-8 encoded) String and\n+\t *     byte[].\n+\t */\n+\tpublic void createSecret(String secretId, Object payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, payload);\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as byte[]\n+\t */\n+\tpublic byte[] getSecretPayload(String secretId, String versionName) {\n+\t\treturn getSecretVersion(secretId, versionName).toByteArray();\n+\t}\n+\n+\tprivate ByteString getSecretVersion(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Returns the lower-level {@link SecretManagerServiceClient} client object for making API\n+\t * calls to Secret Manager service.\n+\t *\n+\t * <p>\n+\t * Useful for executing more advanced use-cases that are not covered by\n+\t * {@link SecretManagerTemplate}.\n+\t *\n+\t * @return the {@link SecretManagerServiceClient} client object.\n+\t */\n+\tpublic SecretManagerServiceClient getSecretManagerServiceClient() {\n+\t\treturn this.secretManagerServiceClient;\n+\t}\n+\n+\t/**\n+\t * Create a new version of the secret with the specified payload under a {@link Secret}.\n+\t */\n+\tprivate void createNewSecretVersion(String secretId, Object rawPayload) {\n+\t\tByteString payload = convertToByteString(rawPayload);\n+\n+\t\tSecretName name = SecretName.of(projectIdProvider.getProjectId(), secretId);\n+\t\tSecretPayload payloadObject = SecretPayload.newBuilder()\n+\t\t\t\t.setData(payload)\n+\t\t\t\t.build();\n+\n+\t\tAddSecretVersionRequest payloadRequest = AddSecretVersionRequest.newBuilder()\n+\t\t\t\t.setParent(name.toString())\n+\t\t\t\t.setPayload(payloadObject)\n+\t\t\t\t.build();\n+\t\tsecretManagerServiceClient.addSecretVersion(payloadRequest);\n+\t}\n+\n+\t/**\n+\t * Creates a new secret for the GCP Project.\n+\t *\n+\t * <p>\n+\t * Note that the {@link Secret} object does not contain the secret payload. You must\n+\t * create versions of the secret which stores the payload of the secret.\n+\t */\n+\tprivate void createSecret(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(projectIdProvider.getProjectId());\n+\n+\t\tSecret secret = Secret.newBuilder()\n+\t\t\t\t.setReplication(\n+\t\t\t\t\t\tReplication.newBuilder()\n+\t\t\t\t\t\t\t\t.setAutomatic(Replication.Automatic.newBuilder().build())\n+\t\t\t\t\t\t\t\t.build())\n+\t\t\t\t.build();\n+\t\tCreateSecretRequest request = CreateSecretRequest.newBuilder()\n+\t\t\t\t.setParent(projectName.toString())\n+\t\t\t\t.setSecretId(secretId)\n+\t\t\t\t.setSecret(secret)\n+\t\t\t\t.build();\n+\t\tthis.secretManagerServiceClient.createSecret(request);\n+\t}\n+\n+\t/**\n+\t * Returns true if there already exists a secret under the GCP project with the\n+\t * {@code secretId}.\n+\t */\n+\tprivate boolean secretExists(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(this.projectIdProvider.getProjectId());\n+\t\tListSecretsPagedResponse listSecretsResponse = this.secretManagerServiceClient.listSecrets(projectName);\n+\n+\t\treturn StreamSupport.stream(listSecretsResponse.iterateAll().spliterator(), false)\n+\t\t\t\t.anyMatch(secret -> secret.getName().contains(secretId));\n+\t}\n+\n+\tprivate ByteString convertToByteString(Object rawPayload) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4MTg0OQ=="}, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Nzk4NTM0OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNToxMTozOFrOFp5xRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxMTo1OVrOFuRrAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4MjQzNw==", "bodyText": "Typically we would create an interface as well called SecretManagerOperations.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r379482437", "createdAt": "2020-02-14T15:11:38Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2ODM1Mw==", "bodyText": "Done.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384068353", "createdAt": "2020-02-25T19:11:59Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4MjQzNw=="}, "originalCommit": {"oid": "5fba0ae7a1d01b81363a8e278701f129016d48e7"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODUyMjMzOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDowMzoxMlrOFuTWZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNDoyNlrOFuXvww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NTg0NA==", "bodyText": "\"Creates a new secret or a new version of existing secret\"?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384095844", "createdAt": "2020-02-25T20:03:12Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Describes supported operations that one can perform on the Secret Manager API.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public interface SecretManagerOperations {\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload string.\n+\t */\n+\tvoid createSecret(String secretId, String payload);\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2Nzg3NQ==", "bodyText": "Done.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384167875", "createdAt": "2020-02-25T22:34:26Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Describes supported operations that one can perform on the Secret Manager API.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public interface SecretManagerOperations {\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload string.\n+\t */\n+\tvoid createSecret(String secretId, String payload);\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NTg0NA=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODUyNTU5OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDowNDoxMlrOFuTYTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozMzozN1rOFuXucg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjMzMw==", "bodyText": "I wonder if setSecret is more precise, since the secret could be created or updated.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384096333", "createdAt": "2020-02-25T20:04:12Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Describes supported operations that one can perform on the Secret Manager API.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public interface SecretManagerOperations {\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload string.\n+\t */\n+\tvoid createSecret(String secretId, String payload);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyNTk3OA==", "bodyText": "Ah, so in Secret Manager previous versions of secrets are never deleted; i.e. the Secret is like a container/parent, and then you create SecretVersions under the Secret. I think \"create\" would be correct, but not sure if there may be better choices for what is being created; like do you feel createSecretVersion may be more clear?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384125978", "createdAt": "2020-02-25T21:06:41Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Describes supported operations that one can perform on the Secret Manager API.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public interface SecretManagerOperations {\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload string.\n+\t */\n+\tvoid createSecret(String secretId, String payload);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjMzMw=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyOTQ0Mg==", "bodyText": "I think it's okay to leave it as is.\nI thought about createSecretVersion but that takes focus off \"secret\" and onto \"version\", which is also not ideal.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384129442", "createdAt": "2020-02-25T21:13:52Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Describes supported operations that one can perform on the Secret Manager API.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public interface SecretManagerOperations {\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload string.\n+\t */\n+\tvoid createSecret(String secretId, String payload);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjMzMw=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NzUzOA==", "bodyText": "Sounds good, will leave as is.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384167538", "createdAt": "2020-02-25T22:33:37Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Describes supported operations that one can perform on the Secret Manager API.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public interface SecretManagerOperations {\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload string.\n+\t */\n+\tvoid createSecret(String secretId, String payload);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjMzMw=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODUyOTYwOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDowNTozMVrOFuTarg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNzo0NVrOFuX1jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Njk0Mg==", "bodyText": "Does it make sense to just ask for getSecretString(String secretId) without specifying a version and getting back latest label by default? It feels like the most common usecase.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384096942", "createdAt": "2020-02-25T20:05:31Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Describes supported operations that one can perform on the Secret Manager API.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public interface SecretManagerOperations {\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload string.\n+\t */\n+\tvoid createSecret(String secretId, String payload);\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload as a byte array.\n+\t */\n+\tvoid createSecret(String secretId, byte[] payload);\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tString getSecretString(String secretId, String versionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2OTM1OQ==", "bodyText": "I added an overloaded method which omits versionName to return the latest.\nAccording to a secret manager dev defulting to accessing the latest version may not be a \"production best practice\" so I think we ought to keep a method that accepts versions. #2168 (comment)", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384169359", "createdAt": "2020-02-25T22:37:45Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerOperations.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Describes supported operations that one can perform on the Secret Manager API.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public interface SecretManagerOperations {\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload string.\n+\t */\n+\tvoid createSecret(String secretId, String payload);\n+\n+\t/**\n+\t * Creates a new secret using the provided {@code secretId} and creates a new version of\n+\t * the secret with the provided {@code payload}.\n+\t *\n+\t * <p>\n+\t * If there is already a secret saved in SecretManager with the specified\n+\t * {@code secretId}, then it simply creates a new version under the secret with the secret\n+\t * {@code payload}.\n+\t *\n+\t * @param secretId the secret ID of the secret to create.\n+\t * @param payload the secret payload as a byte array.\n+\t */\n+\tvoid createSecret(String secretId, byte[] payload);\n+\n+\t/**\n+\t * Gets the secret payload of the specified {@code secretId} at version\n+\t * {@code versionName}.\n+\t *\n+\t * @param secretId unique identifier of your secret in Secret Manager.\n+\t * @param versionName which version of the secret to load. The version can be a version\n+\t *     number as a string (e.g. \"5\") or an alias (e.g. \"latest\").\n+\t * @return The secret payload as String\n+\t */\n+\tString getSecretString(String secretId, String versionName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Njk0Mg=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODU1MTgzOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDoxMjozOVrOFuTopA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozOTo0NFrOFuX46A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMDUxNg==", "bodyText": "since we know whether a secret is new or existing, would it make sense to return a boolean flag, an enum or a version number indicating the result?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384100516", "createdAt": "2020-02-25T20:12:39Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MDIxNg==", "bodyText": "I prefer void just to keep it simple for now; but definitely open to implementing this if users request for it in the future.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384170216", "createdAt": "2020-02-25T22:39:44Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMDUxNg=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODU1NjE0OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDoxMzo1N1rOFuTrOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozOTo1M1rOFuX5IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMTE3Nw==", "bodyText": "This is not a large amount of logic, but it is repeated between the different overloaded versions of this method.\nI think I'd call createSecret(String, byte[]) right away and not do any version determination in this method.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384101177", "createdAt": "2020-02-25T20:13:57Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {\n+\t\tif (!secretExists(secretId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MDI3Mw==", "bodyText": "Done.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384170273", "createdAt": "2020-02-25T22:39:53Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {\n+\t\tif (!secretExists(secretId)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMTE3Nw=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODU2NDY3OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDoxNjozNFrOFuTwVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozOTo1OFrOFuX5Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMjQ4Ng==", "bodyText": "You can remove the intermediate build() calls -- proto builders usually take ether a final object or its builder.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384102486", "createdAt": "2020-02-25T20:16:34Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFromUtf8(payload));\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, byte[] payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFrom(payload));\n+\t}\n+\n+\t@Override\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getSecretBytes(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toByteArray();\n+\t}\n+\n+\t@Override\n+\tpublic ByteString getSecretByteString(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Create a new version of the secret with the specified payload under a {@link Secret}.\n+\t */\n+\tprivate void createNewSecretVersion(String secretId, ByteString byteStringPayload) {\n+\t\tSecretName name = SecretName.of(projectIdProvider.getProjectId(), secretId);\n+\t\tSecretPayload payloadObject = SecretPayload.newBuilder()\n+\t\t\t\t.setData(byteStringPayload)\n+\t\t\t\t.build();\n+\n+\t\tAddSecretVersionRequest payloadRequest = AddSecretVersionRequest.newBuilder()\n+\t\t\t\t.setParent(name.toString())\n+\t\t\t\t.setPayload(payloadObject)\n+\t\t\t\t.build();\n+\t\tsecretManagerServiceClient.addSecretVersion(payloadRequest);\n+\t}\n+\n+\t/**\n+\t * Creates a new secret for the GCP Project.\n+\t *\n+\t * <p>\n+\t * Note that the {@link Secret} object does not contain the secret payload. You must\n+\t * create versions of the secret which stores the payload of the secret.\n+\t */\n+\tprivate void createSecret(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(projectIdProvider.getProjectId());\n+\n+\t\tSecret secret = Secret.newBuilder()\n+\t\t\t\t.setReplication(\n+\t\t\t\t\t\tReplication.newBuilder()\n+\t\t\t\t\t\t\t\t.setAutomatic(Replication.Automatic.newBuilder().build())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MDMxNQ==", "bodyText": "Done.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384170315", "createdAt": "2020-02-25T22:39:58Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFromUtf8(payload));\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, byte[] payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFrom(payload));\n+\t}\n+\n+\t@Override\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getSecretBytes(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toByteArray();\n+\t}\n+\n+\t@Override\n+\tpublic ByteString getSecretByteString(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Create a new version of the secret with the specified payload under a {@link Secret}.\n+\t */\n+\tprivate void createNewSecretVersion(String secretId, ByteString byteStringPayload) {\n+\t\tSecretName name = SecretName.of(projectIdProvider.getProjectId(), secretId);\n+\t\tSecretPayload payloadObject = SecretPayload.newBuilder()\n+\t\t\t\t.setData(byteStringPayload)\n+\t\t\t\t.build();\n+\n+\t\tAddSecretVersionRequest payloadRequest = AddSecretVersionRequest.newBuilder()\n+\t\t\t\t.setParent(name.toString())\n+\t\t\t\t.setPayload(payloadObject)\n+\t\t\t\t.build();\n+\t\tsecretManagerServiceClient.addSecretVersion(payloadRequest);\n+\t}\n+\n+\t/**\n+\t * Creates a new secret for the GCP Project.\n+\t *\n+\t * <p>\n+\t * Note that the {@link Secret} object does not contain the secret payload. You must\n+\t * create versions of the secret which stores the payload of the secret.\n+\t */\n+\tprivate void createSecret(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(projectIdProvider.getProjectId());\n+\n+\t\tSecret secret = Secret.newBuilder()\n+\t\t\t\t.setReplication(\n+\t\t\t\t\t\tReplication.newBuilder()\n+\t\t\t\t\t\t\t\t.setAutomatic(Replication.Automatic.newBuilder().build())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMjQ4Ng=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODU4MDI5OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDoyMTo0N1rOFuT6AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjo0MDoyM1rOFuX55w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNDk2MA==", "bodyText": "This can be a lot of secrets.\nCan getSecret() be used instead to retrieve the specific secret?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384104960", "createdAt": "2020-02-25T20:21:47Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFromUtf8(payload));\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, byte[] payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFrom(payload));\n+\t}\n+\n+\t@Override\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getSecretBytes(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toByteArray();\n+\t}\n+\n+\t@Override\n+\tpublic ByteString getSecretByteString(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Create a new version of the secret with the specified payload under a {@link Secret}.\n+\t */\n+\tprivate void createNewSecretVersion(String secretId, ByteString byteStringPayload) {\n+\t\tSecretName name = SecretName.of(projectIdProvider.getProjectId(), secretId);\n+\t\tSecretPayload payloadObject = SecretPayload.newBuilder()\n+\t\t\t\t.setData(byteStringPayload)\n+\t\t\t\t.build();\n+\n+\t\tAddSecretVersionRequest payloadRequest = AddSecretVersionRequest.newBuilder()\n+\t\t\t\t.setParent(name.toString())\n+\t\t\t\t.setPayload(payloadObject)\n+\t\t\t\t.build();\n+\t\tsecretManagerServiceClient.addSecretVersion(payloadRequest);\n+\t}\n+\n+\t/**\n+\t * Creates a new secret for the GCP Project.\n+\t *\n+\t * <p>\n+\t * Note that the {@link Secret} object does not contain the secret payload. You must\n+\t * create versions of the secret which stores the payload of the secret.\n+\t */\n+\tprivate void createSecret(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(projectIdProvider.getProjectId());\n+\n+\t\tSecret secret = Secret.newBuilder()\n+\t\t\t\t.setReplication(\n+\t\t\t\t\t\tReplication.newBuilder()\n+\t\t\t\t\t\t\t\t.setAutomatic(Replication.Automatic.newBuilder().build())\n+\t\t\t\t\t\t\t\t.build())\n+\t\t\t\t.build();\n+\t\tCreateSecretRequest request = CreateSecretRequest.newBuilder()\n+\t\t\t\t.setParent(projectName.toString())\n+\t\t\t\t.setSecretId(secretId)\n+\t\t\t\t.setSecret(secret)\n+\t\t\t\t.build();\n+\t\tthis.secretManagerServiceClient.createSecret(request);\n+\t}\n+\n+\t/**\n+\t * Returns true if there already exists a secret under the GCP project with the\n+\t * {@code secretId}.\n+\t */\n+\tprivate boolean secretExists(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(this.projectIdProvider.getProjectId());\n+\t\tListSecretsPagedResponse listSecretsResponse = this.secretManagerServiceClient.listSecrets(projectName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MDQ3MQ==", "bodyText": "Done! The getSecret approach is now being used; requires a try/catch style.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r384170471", "createdAt": "2020-02-25T22:40:23Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import java.util.stream.StreamSupport;\n+\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient.ListSecretsPagedResponse;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFromUtf8(payload));\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, byte[] payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFrom(payload));\n+\t}\n+\n+\t@Override\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getSecretBytes(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toByteArray();\n+\t}\n+\n+\t@Override\n+\tpublic ByteString getSecretByteString(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Create a new version of the secret with the specified payload under a {@link Secret}.\n+\t */\n+\tprivate void createNewSecretVersion(String secretId, ByteString byteStringPayload) {\n+\t\tSecretName name = SecretName.of(projectIdProvider.getProjectId(), secretId);\n+\t\tSecretPayload payloadObject = SecretPayload.newBuilder()\n+\t\t\t\t.setData(byteStringPayload)\n+\t\t\t\t.build();\n+\n+\t\tAddSecretVersionRequest payloadRequest = AddSecretVersionRequest.newBuilder()\n+\t\t\t\t.setParent(name.toString())\n+\t\t\t\t.setPayload(payloadObject)\n+\t\t\t\t.build();\n+\t\tsecretManagerServiceClient.addSecretVersion(payloadRequest);\n+\t}\n+\n+\t/**\n+\t * Creates a new secret for the GCP Project.\n+\t *\n+\t * <p>\n+\t * Note that the {@link Secret} object does not contain the secret payload. You must\n+\t * create versions of the secret which stores the payload of the secret.\n+\t */\n+\tprivate void createSecret(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(projectIdProvider.getProjectId());\n+\n+\t\tSecret secret = Secret.newBuilder()\n+\t\t\t\t.setReplication(\n+\t\t\t\t\t\tReplication.newBuilder()\n+\t\t\t\t\t\t\t\t.setAutomatic(Replication.Automatic.newBuilder().build())\n+\t\t\t\t\t\t\t\t.build())\n+\t\t\t\t.build();\n+\t\tCreateSecretRequest request = CreateSecretRequest.newBuilder()\n+\t\t\t\t.setParent(projectName.toString())\n+\t\t\t\t.setSecretId(secretId)\n+\t\t\t\t.setSecret(secret)\n+\t\t\t\t.build();\n+\t\tthis.secretManagerServiceClient.createSecret(request);\n+\t}\n+\n+\t/**\n+\t * Returns true if there already exists a secret under the GCP project with the\n+\t * {@code secretId}.\n+\t */\n+\tprivate boolean secretExists(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(this.projectIdProvider.getProjectId());\n+\t\tListSecretsPagedResponse listSecretsResponse = this.secretManagerServiceClient.listSecrets(projectName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNDk2MA=="}, "originalCommit": {"oid": "898dd93b34d25e2b9f02a5331f1731c7e0139c76"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTQ1ODEwOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNToxNjoyMVrOFvVWbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMToxMjo0N1rOFvhXZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE3NzE5Nw==", "bodyText": "Could it be useful as a public method?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r385177197", "createdAt": "2020-02-27T15:16:21Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.api.gax.rpc.NotFoundException;\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFromUtf8(payload));\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, byte[] payload) {\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFrom(payload));\n+\t}\n+\n+\t@Override\n+\tpublic String getSecretString(String secretId) {\n+\t\treturn getSecretString(secretId, \"latest\");\n+\t}\n+\n+\t@Override\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getSecretBytes(String secretId) {\n+\t\treturn getSecretBytes(secretId, \"latest\");\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getSecretBytes(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toByteArray();\n+\t}\n+\n+\t@Override\n+\tpublic ByteString getSecretByteString(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Create a new version of the secret with the specified payload under a {@link Secret}.\n+\t * Will also create the parent secret if it does not already exist.\n+\t */\n+\tprivate void createNewSecretVersion(String secretId, ByteString payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tSecretName name = SecretName.of(projectIdProvider.getProjectId(), secretId);\n+\t\tAddSecretVersionRequest payloadRequest = AddSecretVersionRequest.newBuilder()\n+\t\t\t\t.setParent(name.toString())\n+\t\t\t\t.setPayload(SecretPayload.newBuilder().setData(payload))\n+\t\t\t\t.build();\n+\t\tsecretManagerServiceClient.addSecretVersion(payloadRequest);\n+\t}\n+\n+\t/**\n+\t * Creates a new secret for the GCP Project.\n+\t *\n+\t * <p>\n+\t * Note that the {@link Secret} object does not contain the secret payload. You must\n+\t * create versions of the secret which stores the payload of the secret.\n+\t */\n+\tprivate void createSecret(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(projectIdProvider.getProjectId());\n+\n+\t\tSecret secret = Secret.newBuilder()\n+\t\t\t\t.setReplication(\n+\t\t\t\t\t\tReplication.newBuilder().setAutomatic(\n+\t\t\t\t\t\t\t\tReplication.Automatic.getDefaultInstance()))\n+\t\t\t\t.build();\n+\t\tCreateSecretRequest request = CreateSecretRequest.newBuilder()\n+\t\t\t\t.setParent(projectName.toString())\n+\t\t\t\t.setSecretId(secretId)\n+\t\t\t\t.setSecret(secret)\n+\t\t\t\t.build();\n+\t\tthis.secretManagerServiceClient.createSecret(request);\n+\t}\n+\n+\t/**\n+\t * Returns true if there already exists a secret under the GCP project with the\n+\t * {@code secretId}.\n+\t */\n+\tprivate boolean secretExists(String secretId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d4a3743adb340f20f05aedd8cfed42734510bc6"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3NDA1NA==", "bodyText": "Done; made public.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r385374054", "createdAt": "2020-02-27T21:12:47Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/src/main/java/org/springframework/cloud/gcp/secretmanager/SecretManagerTemplate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.secretmanager;\n+\n+import com.google.api.gax.rpc.NotFoundException;\n+import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;\n+import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;\n+import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;\n+import com.google.cloud.secretmanager.v1beta1.ProjectName;\n+import com.google.cloud.secretmanager.v1beta1.Replication;\n+import com.google.cloud.secretmanager.v1beta1.Secret;\n+import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;\n+import com.google.cloud.secretmanager.v1beta1.SecretName;\n+import com.google.cloud.secretmanager.v1beta1.SecretPayload;\n+import com.google.cloud.secretmanager.v1beta1.SecretVersionName;\n+import com.google.protobuf.ByteString;\n+\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+\n+/**\n+ * Offers convenience methods for performing common operations on Secret Manager including\n+ * creating and reading secrets.\n+ *\n+ * @author Daniel Zou\n+ * @since 1.3\n+ */\n+public class SecretManagerTemplate implements SecretManagerOperations {\n+\n+\tprivate final SecretManagerServiceClient secretManagerServiceClient;\n+\n+\tprivate final GcpProjectIdProvider projectIdProvider;\n+\n+\tpublic SecretManagerTemplate(\n+\t\t\tSecretManagerServiceClient secretManagerServiceClient,\n+\t\t\tGcpProjectIdProvider projectIdProvider) {\n+\t\tthis.secretManagerServiceClient = secretManagerServiceClient;\n+\t\tthis.projectIdProvider = projectIdProvider;\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, String payload) {\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFromUtf8(payload));\n+\t}\n+\n+\t@Override\n+\tpublic void createSecret(String secretId, byte[] payload) {\n+\t\tcreateNewSecretVersion(secretId, ByteString.copyFrom(payload));\n+\t}\n+\n+\t@Override\n+\tpublic String getSecretString(String secretId) {\n+\t\treturn getSecretString(secretId, \"latest\");\n+\t}\n+\n+\t@Override\n+\tpublic String getSecretString(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toStringUtf8();\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getSecretBytes(String secretId) {\n+\t\treturn getSecretBytes(secretId, \"latest\");\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getSecretBytes(String secretId, String versionName) {\n+\t\treturn getSecretByteString(secretId, versionName).toByteArray();\n+\t}\n+\n+\t@Override\n+\tpublic ByteString getSecretByteString(String secretId, String versionName) {\n+\t\tSecretVersionName secretVersionName = SecretVersionName.of(\n+\t\t\t\tthis.projectIdProvider.getProjectId(),\n+\t\t\t\tsecretId,\n+\t\t\t\tversionName);\n+\n+\t\tAccessSecretVersionResponse response = secretManagerServiceClient.accessSecretVersion(secretVersionName);\n+\n+\t\treturn response.getPayload().getData();\n+\t}\n+\n+\t/**\n+\t * Create a new version of the secret with the specified payload under a {@link Secret}.\n+\t * Will also create the parent secret if it does not already exist.\n+\t */\n+\tprivate void createNewSecretVersion(String secretId, ByteString payload) {\n+\t\tif (!secretExists(secretId)) {\n+\t\t\tcreateSecret(secretId);\n+\t\t}\n+\n+\t\tSecretName name = SecretName.of(projectIdProvider.getProjectId(), secretId);\n+\t\tAddSecretVersionRequest payloadRequest = AddSecretVersionRequest.newBuilder()\n+\t\t\t\t.setParent(name.toString())\n+\t\t\t\t.setPayload(SecretPayload.newBuilder().setData(payload))\n+\t\t\t\t.build();\n+\t\tsecretManagerServiceClient.addSecretVersion(payloadRequest);\n+\t}\n+\n+\t/**\n+\t * Creates a new secret for the GCP Project.\n+\t *\n+\t * <p>\n+\t * Note that the {@link Secret} object does not contain the secret payload. You must\n+\t * create versions of the secret which stores the payload of the secret.\n+\t */\n+\tprivate void createSecret(String secretId) {\n+\t\tProjectName projectName = ProjectName.of(projectIdProvider.getProjectId());\n+\n+\t\tSecret secret = Secret.newBuilder()\n+\t\t\t\t.setReplication(\n+\t\t\t\t\t\tReplication.newBuilder().setAutomatic(\n+\t\t\t\t\t\t\t\tReplication.Automatic.getDefaultInstance()))\n+\t\t\t\t.build();\n+\t\tCreateSecretRequest request = CreateSecretRequest.newBuilder()\n+\t\t\t\t.setParent(projectName.toString())\n+\t\t\t\t.setSecretId(secretId)\n+\t\t\t\t.setSecret(secret)\n+\t\t\t\t.build();\n+\t\tthis.secretManagerServiceClient.createSecret(request);\n+\t}\n+\n+\t/**\n+\t * Returns true if there already exists a secret under the GCP project with the\n+\t * {@code secretId}.\n+\t */\n+\tprivate boolean secretExists(String secretId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE3NzE5Nw=="}, "originalCommit": {"oid": "9d4a3743adb340f20f05aedd8cfed42734510bc6"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTc4ODYzOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-secretmanager/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxODoyMjoxMFrOFv-Z8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxODoyMzo0MVrOFv-czw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0OTg0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <version>1.3.0.BUILD-SNAPSHOT</version>\n          \n          \n            \n                <version>1.2.2.BUILD-SNAPSHOT</version>", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r385849842", "createdAt": "2020-02-28T18:22:10Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-secretmanager/pom.xml", "diffHunk": "@@ -0,0 +1,29 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <artifactId>spring-cloud-gcp</artifactId>\n+    <groupId>org.springframework.cloud</groupId>\n+    <version>1.3.0.BUILD-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a1708453c09ec49869be11ee4773a44a20f9d2a"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1MDU3NQ==", "bodyText": "Nice catch, thanks.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2195#discussion_r385850575", "createdAt": "2020-02-28T18:23:41Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-secretmanager/pom.xml", "diffHunk": "@@ -0,0 +1,29 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <artifactId>spring-cloud-gcp</artifactId>\n+    <groupId>org.springframework.cloud</groupId>\n+    <version>1.3.0.BUILD-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0OTg0Mg=="}, "originalCommit": {"oid": "4a1708453c09ec49869be11ee4773a44a20f9d2a"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2245, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}