{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMzExNjU5", "number": 2227, "title": "Making Pub/Sub reactive pull non-blocking", "bodyText": "Please note that this pull request is a proposal and it is not ready yet to be merged.\nThe current PubSubReactiveFactory is based on blocking calls to PubSubTemplate, to be able to reactively pull messages from Pub/Sub. This isn't as efficient as it could be. Because, the Google Pub/Sub client does offer the ability to do non-blocking asynchronous pulling off messages. However, the current PubSubTemplate doesn't offer any pull methods which use this ability and thus the PubSubReactiveFactory can't make use of it.\nIn this draft pull request I propose changes that makes the PubSubReactiveFactory.poll(...) non-blocking, without breaking its backwards compatibility (except for the exception handling, see note below). I make this possible by adding a PubSubTemplate.pullFuture method, which returns a ListenableFuture instead of blocking while it requests the messages.\nI did some testing with this code against the Pub/Sub service, processing millions of messages, and comparing it to the blocking variant. It doesn't seem to have any performance downside. It does reduces the number of threads that need to be used (as there is one less thread pool that comes in to play), and doesn't do any blocking of threads.\nIf you think this change makes sense, then I will be happy to finish the work so that it is ready to be merged. If you have any concerns then I will happy to discuss them.\nThe following things are currently missing or may need to change, before this pull request is ready:\n\nI am not a big fan of the method name pullFuture. It is not in line with the other methods, but I need a different name for pull as it gives a different return type. The future in the name does clearly state what you will get...\nThere are other pull related methods in PubSubTemplate for which a version should be offered that return a ListenableFuture and that don't block.\nIn PubSubTemplate.pullFuture the ApiFutures.addCallback call now uses the MoreExecutors.directExecutor() executor. Because if it, the callback will be handled by the same thread that handles the response from the PubSub client.  I am wondering if this is ok or that we should make this configurable like it is already configurable for the ack, nack and modifyAckDeadline methods. I don't see much benefit in having another thread pool that must be managed by default, though. If it needs to go into a different thread pool then it would be great if we could use something generic, for CPU bound processing, like the Reactor parallel thread pool. Something to discuss.\n\nNote: In the current implementation of the PubSubReactiveFactory, what I can see and what I have tested, the implementation doesn't correctly deal with exceptions being thrown by the PubSubTemplate or the Google PubSub client. The exceptions aren't passed upstream to the sink. Also, when doing a backpressure based poll, an exception will result in a \"dead\" flux, as any exception in the BlockingLimitedDemandPullTask will kill the task and no messages will ever be put in the sink anymore. The Flux doesn't know that it is dead and will simply keep on waiting for messages that will never arrive. This is because the BlockingLimitedDemandPullTask doesn't catch and forward the exception to the sink.\nIn the implementation of this pull request, we forward all exceptions to the sink. A retry can then be used on the Flux, returned by poll, to make sure exceptions don't result in a dead stream.\nThe issue in the current implementation PubSubReactiveFactory should probably be solved independent of this pull request, if there is a chance that this pull request will take a long time or will never be merged. I can create a ticket for it and a separate pull request, if desired.", "createdAt": "2020-03-02T10:48:50Z", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227", "merged": true, "mergeCommit": {"oid": "2adf4328c819a634a3ad7a1627426badf198c4fb"}, "closed": true, "closedAt": "2020-03-12T16:44:23Z", "author": {"login": "mzeijen"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJoQnSgH2gAyMzgyMzExNjU5OjM3ZDgwODRmZGY3NmMxZjEyYzlhMTIyMTJlNDQ4OTAyZTQ2MWE0YTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcM-ei1gFqTM3MzcyMTk4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "37d8084fdf76c1f12c9a12212e448902e461a4a2", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/37d8084fdf76c1f12c9a12212e448902e461a4a2", "committedDate": "2020-03-02T07:05:45Z", "message": "Added a future returning pull method to PubSubSubscriberOperations, and its implementation, allowing for asynchronous and non-blocking pull of messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39d6bc68a500e533eecd5fc6f805a24abe475dd2", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/39d6bc68a500e533eecd5fc6f805a24abe475dd2", "committedDate": "2020-03-02T07:07:49Z", "message": "Reimplemented the PubSubReactiveFactory to utilize the asynchronous pullFuture method of the PubSubReactiveFactory, making it non-blocking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd4247507e38df57128e3974bdb46808b6604e4e", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/bd4247507e38df57128e3974bdb46808b6604e4e", "committedDate": "2020-03-02T09:46:58Z", "message": "Added unit test for the pullFuture method of PubSubSubscriberTemplate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e7e9d480fc0da1ff0f5f68d13ead378247f07b7", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/8e7e9d480fc0da1ff0f5f68d13ead378247f07b7", "committedDate": "2020-03-02T09:54:07Z", "message": "Bumped copyright year to 2020, for those files this change touches"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c2a162571457c3df186437dff02a3e613d9f9b8", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/7c2a162571457c3df186437dff02a3e613d9f9b8", "committedDate": "2020-03-02T11:02:10Z", "message": "Fixed imports according to code style"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDk0MDQ0", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-367494044", "createdAt": "2020-03-02T20:12:19Z", "commit": {"oid": "7c2a162571457c3df186437dff02a3e613d9f9b8"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5138fd511f1cd5638bd036b884bc24cd34d73e1", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/f5138fd511f1cd5638bd036b884bc24cd34d73e1", "committedDate": "2020-03-03T14:10:32Z", "message": "Merge remote-tracking branch 'upstream/master' into pubsub-nonblocking-pull\n\n# Conflicts:\n#\tspring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java\n#\tspring-cloud-gcp-pubsub/src/test/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactoryTests.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12554df1578c3d1433a8b22ba4f620e353570454", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/12554df1578c3d1433a8b22ba4f620e353570454", "committedDate": "2020-03-03T14:36:40Z", "message": "Renamed `PubSubSubscriberOperations.pullFuture` to `PubSubSubscriberOperations.pullAsync`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e43a90a84cccb93bc086fc22f311d24fe85a4a23", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/e43a90a84cccb93bc086fc22f311d24fe85a4a23", "committedDate": "2020-03-04T07:37:30Z", "message": "Made the executor for the async pull configurable, and added javadoc to its new setter and the class. Also added some javadoc to other setter methods that had no javadoc yet."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "418b5fc068dd6008e13b5f4de82dda58a349330c", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/418b5fc068dd6008e13b5f4de82dda58a349330c", "committedDate": "2020-03-04T07:38:20Z", "message": "Deduplicated code that creates a list of PulledAcknowledgeablePubsubMessage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4b9b0707eb5f5e23154cee7d07ed84c5afe1895", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/a4b9b0707eb5f5e23154cee7d07ed84c5afe1895", "committedDate": "2020-03-04T08:14:59Z", "message": "Added and implemented PubSubSubscriberOperations.pullAndAckAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c07031ab63e0176a2514d41f42f941c99ce44cb8", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/c07031ab63e0176a2514d41f42f941c99ce44cb8", "committedDate": "2020-03-04T08:29:23Z", "message": "Corrected test name after pullFuture changed into pullAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20386a835043cd43ad4526be785cb44ab447231d", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/20386a835043cd43ad4526be785cb44ab447231d", "committedDate": "2020-03-04T08:31:36Z", "message": "Added and implemented PubSubSubscriberOperations.pullAndConvertAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92cf4698045903ca6d9e18f8aad24e75c27a5285", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/92cf4698045903ca6d9e18f8aad24e75c27a5285", "committedDate": "2020-03-04T09:14:16Z", "message": "Added and implemented PubSubSubscriberOperations.pullNextAsync. Also added tests for PubSubSubscriberOperations.pullNext, because they where missing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "403fd31c64666a9a365017630d7d90d0a2b96e87", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/403fd31c64666a9a365017630d7d90d0a2b96e87", "committedDate": "2020-03-04T09:20:22Z", "message": "Fixed some checkstyle issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd9cc2b9f7b09cd0c0ae3b6d8c897c5ebd6b7ea3", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/cd9cc2b9f7b09cd0c0ae3b6d8c897c5ebd6b7ea3", "committedDate": "2020-03-04T09:37:03Z", "message": "Made the `PubSubSubscriberTemplate.asyncPullExecutor` configurable via autoconfiguration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00acef213acfc84eda947df1af1c95bd191dd16f", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/00acef213acfc84eda947df1af1c95bd191dd16f", "committedDate": "2020-03-04T12:34:50Z", "message": "Added information on the scheduler to the PubSubReactiveFactory class javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17179edca1018680990ec1d396a55d4c68fa2ac7", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/17179edca1018680990ec1d396a55d4c68fa2ac7", "committedDate": "2020-03-04T12:35:35Z", "message": "Refactored the infinite/poll pull method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "committedDate": "2020-03-04T12:36:02Z", "message": "Added my name to the tests that I also significantly extended"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNDE0NzM1", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-371414735", "createdAt": "2020-03-09T18:10:16Z", "commit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoxMDoxNlrOFzzz3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMjo1MDo0OVrOFz_1mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MDU1Nw==", "bodyText": "@bsideup What would you recommend here? We need a scheduler for kicking off asynchronous service calls at fixed time intervals. The calls used to be blocking before this PR, so the parallel scheduler was a bad fit then, and we used Schedulers.newElastic at Stephane's advice. Now, though, the calls are asynchronous -- is Schedulers.parallel() appropriate to use now?\nAt minimum using the boundedElastic() instead of elastic makes sense, but I am less confident about using Schedulers.parallel(). I am concerned that using the shared parallel scheduler, if there is a bug, we could use up all N processor-bound threads and it won't be obvious in the client application where the issue came from. With threads from a named scheduler, the culprit code is obvious. Is this valid reasoning or are there better ways to identify bad reactive actors?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389870557", "createdAt": "2020-03-09T18:10:16Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/pubsub/GcpPubSubReactiveAutoConfiguration.java", "diffHunk": "@@ -49,30 +47,14 @@\n \t\tmatchIfMissing = true)\n public class GcpPubSubReactiveAutoConfiguration {\n \n-\tprivate Scheduler defaultPubSubReactiveScheduler;\n-\n \t@Bean\n \t@ConditionalOnMissingBean\n \tpublic PubSubReactiveFactory pubSubReactiveFactory(\n \t\t\tPubSubSubscriberTemplate subscriberTemplate,\n \t\t\t@Qualifier(\"pubSubReactiveScheduler\") Optional<Scheduler> userProvidedScheduler) {\n \n-\t\tScheduler scheduler = null;\n-\t\tif (userProvidedScheduler.isPresent()) {\n-\t\t\tscheduler = userProvidedScheduler.get();\n-\t\t}\n-\t\telse {\n-\t\t\tthis.defaultPubSubReactiveScheduler = Schedulers.newElastic(\"pubSubReactiveScheduler\");\n-\t\t\tscheduler = this.defaultPubSubReactiveScheduler;\n-\t\t}\n+\t\tScheduler scheduler = userProvidedScheduler.orElseGet(() -> Schedulers.parallel());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNTA1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return the converter to set\n          \n          \n            \n            \t * @return the currently used converter", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389925056", "createdAt": "2020-03-09T19:53:39Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -100,21 +110,48 @@ public PubSubSubscriberTemplate(SubscriberFactory subscriberFactory) {\n \t\tthis.subscriberStub = this.subscriberFactory.createSubscriberStub();\n \t}\n \n+\t/**\n+\t * Get the converter used to convert a message payload to the desired type.\n+\t *\n+\t * @return the converter to set", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNjI4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Sets a custom {@link Executor} can be injected to control the threads that process\n          \n          \n            \n            \t * Set a custom {@link Executor} to control the threads that process", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389926287", "createdAt": "2020-03-09T19:56:01Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -100,21 +110,48 @@ public PubSubSubscriberTemplate(SubscriberFactory subscriberFactory) {\n \t\tthis.subscriberStub = this.subscriberFactory.createSubscriberStub();\n \t}\n \n+\t/**\n+\t * Get the converter used to convert a message payload to the desired type.\n+\t *\n+\t * @return the converter to set\n+\t */\n \tpublic PubSubMessageConverter getMessageConverter() {\n \t\treturn this.pubSubMessageConverter;\n \t}\n \n+\t/**\n+\t * Set the converter used to convert a message payload to the desired type.\n+\t *\n+\t * @param pubSubMessageConverter the converter to set\n+\t */\n \tpublic void setMessageConverter(PubSubMessageConverter pubSubMessageConverter) {\n \t\tAssert.notNull(pubSubMessageConverter, \"The pubSubMessageConverter can't be null.\");\n \n \t\tthis.pubSubMessageConverter = pubSubMessageConverter;\n \t}\n \n+\t/**\n+\t * Sets the {@link Executor} to control per-subscription batch\n+\t * parallelization in acknowledgement and deadline operations.\n+\t *\n+\t * @param ackExecutor the executor to set\n+\t */\n \tpublic void setAckExecutor(Executor ackExecutor) {\n \t\tAssert.notNull(ackExecutor, \"ackExecutor can't be null.\");\n \t\tthis.ackExecutor = ackExecutor;\n \t}\n \n+\t/**\n+\t * Sets a custom {@link Executor} can be injected to control the threads that process", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyOTc4NA==", "bodyText": "toAcknowledgeablePubsubMessageList can get its own this.subscriberFactory.getProjectId(); it does not need to be a parameter. This will also help get rid of the extra final variable projectId in pullAsync.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389929784", "createdAt": "2020-03-09T20:03:07Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -173,13 +210,56 @@ public Subscriber subscribe(String subscription,\n \t\tAssert.notNull(pullRequest, \"The pull request can't be null.\");\n \n \t\tPullResponse pullResponse = this.subscriberStub.pullCallable().call(pullRequest);\n-\t\treturn pullResponse.getReceivedMessagesList().stream()\n-\t\t\t\t\t\t.map((message) -> new PulledAcknowledgeablePubsubMessage(\n-\t\t\t\t\t\t\t\tPubSubSubscriptionUtils.toProjectSubscriptionName(pullRequest.getSubscription(),\n-\t\t\t\t\t\t\t\t\t\tthis.subscriberFactory.getProjectId()),\n-\t\t\t\t\t\t\t\tmessage.getMessage(),\n-\t\t\t\t\t\t\t\tmessage.getAckId()))\n-\t\t\t\t\t\t.collect(Collectors.toList());\n+\t\treturn toAcknowledgeablePubsubMessageList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1MDQ2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * created per instance of the {@link PubSubSubscriberOperations}.\n          \n          \n            \n             * created per instance of the {@link PubSubSubscriberTemplate}.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389950469", "createdAt": "2020-03-09T20:44:05Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -64,13 +65,20 @@\n  *\n  * A custom {@link Executor} can be injected to control per-subscription batch\n  * parallelization in acknowledgement and deadline operations.\n+ * By default, this is a single thread executor,\n+ * created per instance of the {@link PubSubSubscriberOperations}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1MjU0NQ==", "bodyText": "Since Runnable::run is already the default async executor in PubSubSubscriberTemplate, this autoconfiguration bean can be removed and the parameter of pubSubSubscriberTemplate() changed to Optional<Executor> asyncPullExecutor.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389952545", "createdAt": "2020-03-09T20:48:04Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/pubsub/GcpPubSubAutoConfiguration.java", "diffHunk": "@@ -153,6 +153,12 @@ public PubSubPublisherTemplate pubSubPublisherTemplate(PublisherFactory publishe\n \t\treturn pubSubPublisherTemplate;\n \t}\n \n+\t@Bean\n+\t@ConditionalOnMissingBean(name = \"pubSubAsynchronousPullExecutor\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NTQzMg==", "bodyText": "The intermediate .build() can be omitted -- proto setter fields have setter overloads that take builders.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389955432", "createdAt": "2020-03-09T20:53:42Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/test/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplateTests.java", "diffHunk": "@@ -158,21 +163,33 @@ public void setUp() {\n \t\twhen(this.subscriberStub.acknowledgeCallable()).thenReturn(this.ackCallable);\n \t\twhen(this.subscriberStub.modifyAckDeadlineCallable()).thenReturn(this.modifyAckDeadlineCallable);\n \n-\t\twhen(this.ackCallable.futureCall(any(AcknowledgeRequest.class))).thenReturn(this.apiFuture);\n+\t\twhen(this.ackCallable.futureCall(any(AcknowledgeRequest.class))).thenReturn(this.ackApiFuture);\n \n-\t\twhen(this.modifyAckDeadlineCallable.futureCall(any(ModifyAckDeadlineRequest.class))).thenReturn(this.apiFuture);\n+\t\twhen(this.modifyAckDeadlineCallable.futureCall(any(ModifyAckDeadlineRequest.class))).thenReturn(this.ackApiFuture);\n \n \t\tdoAnswer((invocation) -> {\n \t\t\tRunnable runnable = invocation.getArgument(0);\n \t\t\trunnable.run();\n \t\t\treturn null;\n-\t\t}).when(this.apiFuture).addListener(any(Runnable.class), any(Executor.class));\n+\t\t}).when(this.ackApiFuture).addListener(any(Runnable.class), any(Executor.class));\n \n-\t\twhen(this.apiFuture.isDone()).thenReturn(true);\n+\t\twhen(this.ackApiFuture.isDone()).thenReturn(true);\n \n \t\tdoNothing().when(this.ackReplyConsumer).ack();\n \t\tdoNothing().when(this.ackReplyConsumer).nack();\n \n+\t\t// for pull future\n+\t\twhen(this.pullCallable.futureCall(any(PullRequest.class))).thenReturn(this.pullApiFuture);\n+\n+\t\tdoAnswer((invocation) -> {\n+\t\t\tRunnable runnable = invocation.getArgument(0);\n+\t\t\trunnable.run();\n+\t\t\treturn null;\n+\t\t}).when(this.pullApiFuture).addListener(any(Runnable.class), any(Executor.class));\n+\t\twhen(this.pullApiFuture.isDone()).thenReturn(true);\n+\t\twhen(this.pullApiFuture.get()).thenReturn(PullResponse.newBuilder()\n+\t\t\t\t.addReceivedMessages(ReceivedMessage.newBuilder().setMessage(this.pubsubMessage).build()).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2NzYxMA==", "bodyText": "Ironically, one of the early versions of what became PubSubReactiveFactory took this recursive-like approach, together with using futureCall. We moved away from it for two reasons:\n\nto avoid too many recursive calls. But now that I think about this again, this is not really a recursive call; by the time the callback is invoked, the original invocation of backpressurePull is long gone.\nI was concerned that multiple subscription.request() calls and each will spawn an asynchronous Pub/Sub pull call with returnImmediately = false, and then once the call returns, an additional asynchronous call will be made for the remaining demand, there will be multiple simultaneous outstanding asynchronous calls pending. But looking at what I ended up doing, it has the same behavior of generating multiple outstanding calls, just with scheduled tasks.\n\n@meltsufin do you have strong opinions either way?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390067610", "createdAt": "2020-03-10T02:50:49Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "diffHunk": "@@ -77,116 +86,62 @@ public PubSubReactiveFactory(PubSubSubscriberOperations subscriberOperations, Sc\n \tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs) {\n \n \t\treturn Flux.create(sink -> {\n-\n-\t\t\tScheduler.Worker subscriptionWorker = this.scheduler.createWorker();\n-\n \t\t\tsink.onRequest((numRequested) -> {\n \t\t\t\tif (numRequested == Long.MAX_VALUE) {\n-\t\t\t\t\t// unlimited demand\n-\t\t\t\t\tsubscriptionWorker.schedulePeriodically(\n-\t\t\t\t\t\t\tnew NonBlockingUnlimitedDemandPullTask(subscriptionName, sink), 0, pollingPeriodMs, TimeUnit.MILLISECONDS);\n+\t\t\t\t\tpollingPull(subscriptionName, pollingPeriodMs, sink);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tsubscriptionWorker.schedule(new BlockingLimitedDemandPullTask(subscriptionName, numRequested, sink));\n+\t\t\t\t\tbackpressurePull(subscriptionName, numRequested, sink);\n \t\t\t\t}\n \t\t\t});\n-\n-\t\t\tsink.onDispose(subscriptionWorker);\n-\n \t\t});\n \t}\n \n-\tprivate abstract class PubSubPullTask implements Runnable {\n-\n-\t\tprotected final String subscriptionName;\n-\n-\t\tprotected final FluxSink<AcknowledgeablePubsubMessage> sink;\n-\n-\t\tPubSubPullTask(String subscriptionName, FluxSink<AcknowledgeablePubsubMessage> sink) {\n-\t\t\tthis.subscriptionName = subscriptionName;\n-\t\t\tthis.sink = sink;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Retrieve up to a specified number of messages, sending them to the subscription.\n-\t\t * @param demand maximum number of messages to retrieve\n-\t\t * @param block whether to wait for the first message to become available\n-\t\t * @return number of messages retrieved\n-\t\t */\n-\t\tprotected int pullToSink(int demand, boolean block) {\n-\n-\t\t\tList<AcknowledgeablePubsubMessage> messages =\n-\t\t\t\t\tPubSubReactiveFactory.this.subscriberOperations.pull(this.subscriptionName, demand, !block);\n-\n-\t\t\tif (!this.sink.isCancelled()) {\n-\t\t\t\tmessages.forEach(sink::next);\n-\t\t\t}\n-\n-\t\t\treturn messages.size();\n-\t\t}\n+\tprivate void pollingPull(String subscriptionName, long pollingPeriodMs,\n+\t\t\tFluxSink<AcknowledgeablePubsubMessage> sink) {\n+\t\tDisposable disposable = Flux\n+\t\t\t\t.interval(Duration.ZERO, Duration.ofMillis(pollingPeriodMs), scheduler)\n+\t\t\t\t.flatMap(ignore -> pullAll(subscriptionName))\n+\t\t\t\t.subscribe(sink::next, sink::error);\n \n+\t\tsink.onDispose(disposable);\n \t}\n \n-\t/**\n-\t * Runnable task issuing blocking Pub/Sub Pull requests until the specified number of\n-\t * messages has been retrieved.\n-\t */\n-\tprivate class BlockingLimitedDemandPullTask extends PubSubPullTask {\n+\tprivate Flux<AcknowledgeablePubsubMessage> pullAll(String subscriptionName) {\n+\t\tCompletableFuture<List<AcknowledgeablePubsubMessage>> pullResponseFuture = this.subscriberOperations\n+\t\t\t\t.pullAsync(subscriptionName, Integer.MAX_VALUE, true).completable();\n \n-\t\tprivate final long initialDemand;\n-\n-\t\tBlockingLimitedDemandPullTask(String subscriptionName, long initialDemand, FluxSink<AcknowledgeablePubsubMessage> sink) {\n-\t\t\tsuper(subscriptionName, sink);\n-\t\t\tthis.initialDemand = initialDemand;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void run() {\n-\t\t\ttry {\n-\t\t\t\tlong demand = this.initialDemand;\n-\t\t\t\tList<AcknowledgeablePubsubMessage> messages;\n+\t\treturn Mono.fromFuture(pullResponseFuture).flatMapMany(Flux::fromIterable);\n+\t}\n \n-\t\t\t\twhile (demand > 0 && !this.sink.isCancelled()) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tint intDemand = demand > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) demand;\n-\t\t\t\t\t\tdemand -= pullToSink(intDemand, true);\n+\tprivate void backpressurePull(String subscriptionName, long numRequested,\n+\t\t\tFluxSink<AcknowledgeablePubsubMessage> sink) {\n+\t\tint intDemand = numRequested > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) numRequested;\n+\t\tthis.subscriberOperations.pullAsync(subscriptionName, intDemand, false).addCallback(\n+\t\t\t\tmessages -> {\n+\t\t\t\t\tif (!sink.isCancelled()) {\n+\t\t\t\t\t\tmessages.forEach(sink::next);\n \t\t\t\t\t}\n-\t\t\t\t\tcatch (DeadlineExceededException e) {\n+\t\t\t\t\tif (!sink.isCancelled()) {\n+\t\t\t\t\t\tlong numToPull = numRequested - messages.size();\n+\t\t\t\t\t\tif (numToPull > 0) {\n+\t\t\t\t\t\t\tbackpressurePull(subscriptionName, numToPull, sink);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd6d81492b75e809182b916b7df72a1af148e9f3", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/dd6d81492b75e809182b916b7df72a1af148e9f3", "committedDate": "2020-03-10T06:05:52Z", "message": "Update spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java\n\nCo-Authored-By: Elena Felder <41136058+elefeint@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d250e0b7723c3e22d323270eda481232d04286c4", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/d250e0b7723c3e22d323270eda481232d04286c4", "committedDate": "2020-03-10T06:06:05Z", "message": "Update spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java\n\nCo-Authored-By: Elena Felder <41136058+elefeint@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0466c780d3d8a16d07acdcd29102ab97382b4378", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/0466c780d3d8a16d07acdcd29102ab97382b4378", "committedDate": "2020-03-10T06:06:23Z", "message": "Update spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java\n\nCo-Authored-By: Elena Felder <41136058+elefeint@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6996cfc74ec341b3727faabcf858a15ad187da1a", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/6996cfc74ec341b3727faabcf858a15ad187da1a", "committedDate": "2020-03-10T06:21:33Z", "message": "Removed passing around projectId to `toAcknowledgeablePubsubMessageList`, as itself can get the project id"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "809086c8d3ac4e90e838eaf242533a05051c8368", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/809086c8d3ac4e90e838eaf242533a05051c8368", "committedDate": "2020-03-10T06:27:59Z", "message": "Removed the `pubSubAsynchronousPullExecutor` bean in favour of using a ObjectProvider<Executor> for the pubSubSubscriberTemplate bean method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f99d11fb2cea76a40f5b385eba160aa66bbd77b", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/4f99d11fb2cea76a40f5b385eba160aa66bbd77b", "committedDate": "2020-03-10T06:28:12Z", "message": "Merge remote-tracking branch 'upstream/master' into pubsub-nonblocking-pull"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eea5e531e538bd711eeac930773ac827fa731d00", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/eea5e531e538bd711eeac930773ac827fa731d00", "committedDate": "2020-03-10T07:24:21Z", "message": "Removed the intermediate build calls for protobuf objects"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMDU3NjY5", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-372057669", "createdAt": "2020-03-10T15:23:23Z", "commit": {"oid": "eea5e531e538bd711eeac930773ac827fa731d00"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNToyMzoyM1rOF0T9OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTozMjo1MVrOF0UaTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NzI0MQ==", "bodyText": "If we're using the ObjectProvider for the asyncPullExecutor, why doesn't it apply to ackExecutor?\nBoth approaches might be valid, but we should try to be consistent.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390397241", "createdAt": "2020-03-10T15:23:23Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/pubsub/GcpPubSubAutoConfiguration.java", "diffHunk": "@@ -167,10 +167,12 @@ public Executor pubSubAcknowledgementExecutor() {\n \t@ConditionalOnMissingBean\n \tpublic PubSubSubscriberTemplate pubSubSubscriberTemplate(SubscriberFactory subscriberFactory,\n \t\t\tObjectProvider<PubSubMessageConverter> pubSubMessageConverter,\n-\t\t\t@Qualifier(\"pubSubAcknowledgementExecutor\") Executor executor) {\n+\t\t\t@Qualifier(\"pubSubAsynchronousPullExecutor\") ObjectProvider<Executor> asyncPullExecutor,\n+\t\t\t@Qualifier(\"pubSubAcknowledgementExecutor\") Executor ackExecutor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea5e531e538bd711eeac930773ac827fa731d00"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwMTA5Mw==", "bodyText": "Does our new default Scheduler.parallel() scheduler not need closing anymore?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390401093", "createdAt": "2020-03-10T15:28:10Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/pubsub/GcpPubSubReactiveAutoConfiguration.java", "diffHunk": "@@ -49,30 +47,14 @@\n \t\tmatchIfMissing = true)\n public class GcpPubSubReactiveAutoConfiguration {\n \n-\tprivate Scheduler defaultPubSubReactiveScheduler;\n-\n \t@Bean\n \t@ConditionalOnMissingBean\n \tpublic PubSubReactiveFactory pubSubReactiveFactory(\n \t\t\tPubSubSubscriberTemplate subscriberTemplate,\n \t\t\t@Qualifier(\"pubSubReactiveScheduler\") Optional<Scheduler> userProvidedScheduler) {\n \n-\t\tScheduler scheduler = null;\n-\t\tif (userProvidedScheduler.isPresent()) {\n-\t\t\tscheduler = userProvidedScheduler.get();\n-\t\t}\n-\t\telse {\n-\t\t\tthis.defaultPubSubReactiveScheduler = Schedulers.newElastic(\"pubSubReactiveScheduler\");\n-\t\t\tscheduler = this.defaultPubSubReactiveScheduler;\n-\t\t}\n+\t\tScheduler scheduler = userProvidedScheduler.orElseGet(() -> Schedulers.parallel());\n \t\treturn new PubSubReactiveFactory(subscriberTemplate, scheduler);\n \t}\n \n-\t@PreDestroy\n-\tpublic void closeScheduler() {\n-\t\tif (this.defaultPubSubReactiveScheduler != null) {\n-\t\t\tthis.defaultPubSubReactiveScheduler.dispose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea5e531e538bd711eeac930773ac827fa731d00"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwNDY4Ng==", "bodyText": "All of the code above this line in the method is shared with pullAndAck. Can we try to reduce the code duplication?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390404686", "createdAt": "2020-03-10T15:32:51Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -214,19 +314,63 @@ public Subscriber subscribe(String subscription,\n \n \t\tList<AcknowledgeablePubsubMessage> ackableMessages = pull(pullRequest);\n \n-\t\tif (ackableMessages.size() > 0) {\n+\t\tif (!ackableMessages.isEmpty()) {\n \t\t\tack(ackableMessages);\n \t\t}\n \n \t\treturn ackableMessages.stream().map(AcknowledgeablePubsubMessage::getPubsubMessage)\n \t\t\t\t.collect(Collectors.toList());\n \t}\n \n+\t@Override\n+\tpublic ListenableFuture<List<PubsubMessage>> pullAndAckAsync(String subscription, Integer maxMessages,\n+\t\t\tBoolean returnImmediately) {\n+\t\tAssert.hasText(subscription, \"The subscription can't be null or empty.\");\n+\n+\t\tif (maxMessages != null) {\n+\t\t\tAssert.isTrue(maxMessages > 0, \"The maxMessages must be greater than 0.\");\n+\t\t}\n+\n+\t\tPullRequest pullRequest = this.subscriberFactory.createPullRequest(\n+\t\t\t\tsubscription, maxMessages, returnImmediately);\n+\n+\t\tfinal SettableListenableFuture<List<PubsubMessage>> settableFuture = new SettableListenableFuture<>();\n+\n+\t\tthis.pullAsync(pullRequest).addCallback(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea5e531e538bd711eeac930773ac827fa731d00"}, "originalPosition": 217}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/3ee9f531fab2dedda3869e0648eb71af81e43187", "committedDate": "2020-03-11T08:25:59Z", "message": "Reduced amount of duplicate code in `pullAndAck` and `pullAndAckAsync` by moving the validation into `SubscriberFactory.createPullRequest` (where it partially already was)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNTUzNTI1", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-372553525", "createdAt": "2020-03-11T08:30:17Z", "commit": {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODozMDoxN1rOF0tH7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODozMDoxN1rOF0tH7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwOTU4Mw==", "bodyText": "Side note: I think it is a mistake that maxMessage can be set to null, because according to the Google PubSub API docs it must always have a positive number (see: https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pullrequest). I believe that if it isn't set, then a default value of 0 is used.\nShall I report it as a bug?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390809583", "createdAt": "2020-03-11T08:30:17Z", "author": {"login": "mzeijen"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/support/DefaultSubscriberFactory.java", "diffHunk": "@@ -227,6 +227,8 @@ public PullRequest createPullRequest(String subscriptionName, Integer maxMessage\n \t\t\t\t\t\tPubSubSubscriptionUtils.toProjectSubscriptionName(subscriptionName, this.projectId).toString());\n \n \t\tif (maxMessages != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNTU1ODM2", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-372555836", "createdAt": "2020-03-11T08:34:16Z", "commit": {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODozNDoxNlrOF0tPwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODozNDoxNlrOF0tPwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxMTU4NA==", "bodyText": "side note: use true for the third argument, defines the return_immediately as true. However according to the Google PubSub API docs, this is not recommended and the argument is actually deprecated (see https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pullrequest).\nWhat to do with it? Separate bug?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390811584", "createdAt": "2020-03-11T08:34:16Z", "author": {"login": "mzeijen"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "diffHunk": "@@ -77,116 +86,62 @@ public PubSubReactiveFactory(PubSubSubscriberOperations subscriberOperations, Sc\n \tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs) {\n \n \t\treturn Flux.create(sink -> {\n-\n-\t\t\tScheduler.Worker subscriptionWorker = this.scheduler.createWorker();\n-\n \t\t\tsink.onRequest((numRequested) -> {\n \t\t\t\tif (numRequested == Long.MAX_VALUE) {\n-\t\t\t\t\t// unlimited demand\n-\t\t\t\t\tsubscriptionWorker.schedulePeriodically(\n-\t\t\t\t\t\t\tnew NonBlockingUnlimitedDemandPullTask(subscriptionName, sink), 0, pollingPeriodMs, TimeUnit.MILLISECONDS);\n+\t\t\t\t\tpollingPull(subscriptionName, pollingPeriodMs, sink);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tsubscriptionWorker.schedule(new BlockingLimitedDemandPullTask(subscriptionName, numRequested, sink));\n+\t\t\t\t\tbackpressurePull(subscriptionName, numRequested, sink);\n \t\t\t\t}\n \t\t\t});\n-\n-\t\t\tsink.onDispose(subscriptionWorker);\n-\n \t\t});\n \t}\n \n-\tprivate abstract class PubSubPullTask implements Runnable {\n-\n-\t\tprotected final String subscriptionName;\n-\n-\t\tprotected final FluxSink<AcknowledgeablePubsubMessage> sink;\n-\n-\t\tPubSubPullTask(String subscriptionName, FluxSink<AcknowledgeablePubsubMessage> sink) {\n-\t\t\tthis.subscriptionName = subscriptionName;\n-\t\t\tthis.sink = sink;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Retrieve up to a specified number of messages, sending them to the subscription.\n-\t\t * @param demand maximum number of messages to retrieve\n-\t\t * @param block whether to wait for the first message to become available\n-\t\t * @return number of messages retrieved\n-\t\t */\n-\t\tprotected int pullToSink(int demand, boolean block) {\n-\n-\t\t\tList<AcknowledgeablePubsubMessage> messages =\n-\t\t\t\t\tPubSubReactiveFactory.this.subscriberOperations.pull(this.subscriptionName, demand, !block);\n-\n-\t\t\tif (!this.sink.isCancelled()) {\n-\t\t\t\tmessages.forEach(sink::next);\n-\t\t\t}\n-\n-\t\t\treturn messages.size();\n-\t\t}\n+\tprivate void pollingPull(String subscriptionName, long pollingPeriodMs,\n+\t\t\tFluxSink<AcknowledgeablePubsubMessage> sink) {\n+\t\tDisposable disposable = Flux\n+\t\t\t\t.interval(Duration.ZERO, Duration.ofMillis(pollingPeriodMs), scheduler)\n+\t\t\t\t.flatMap(ignore -> pullAll(subscriptionName))\n+\t\t\t\t.subscribe(sink::next, sink::error);\n \n+\t\tsink.onDispose(disposable);\n \t}\n \n-\t/**\n-\t * Runnable task issuing blocking Pub/Sub Pull requests until the specified number of\n-\t * messages has been retrieved.\n-\t */\n-\tprivate class BlockingLimitedDemandPullTask extends PubSubPullTask {\n+\tprivate Flux<AcknowledgeablePubsubMessage> pullAll(String subscriptionName) {\n+\t\tCompletableFuture<List<AcknowledgeablePubsubMessage>> pullResponseFuture = this.subscriberOperations\n+\t\t\t\t.pullAsync(subscriptionName, Integer.MAX_VALUE, true).completable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyOTUxNDAw", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-372951400", "createdAt": "2020-03-11T17:00:09Z", "commit": {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNzowMDowOVrOF1AMNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNzowMDowOVrOF1AMNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMTk3Mg==", "bodyText": "I'd skip the \"can be null\". It's a required field in the proto, so the request will fail. You are right that our validation exempting null is a bug.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391121972", "createdAt": "2020-03-11T17:00:09Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/support/SubscriberFactory.java", "diffHunk": "@@ -53,7 +53,8 @@\n \t * Create a {@link PullRequest} for synchronously pulling a number of messages from\n \t * a Google Cloud Pub/Sub subscription.\n \t * @param subscriptionName the name of the subscription\n-\t * @param maxMessages the maximum number of pulled messages\n+\t * @param maxMessages the maximum number of pulled messages,\n+\t * which can be null or must be a positive number", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyOTU1OTgw", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-372955980", "createdAt": "2020-03-11T17:05:37Z", "commit": {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec3d15fb2c62848b07aa65789e4b12eacef43e12", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/ec3d15fb2c62848b07aa65789e4b12eacef43e12", "committedDate": "2020-03-12T15:13:56Z", "message": "Removed the javadoc statement that maxMessages can be null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46a528431661e161e8a1f8457f2f9e9c357c32c4", "author": {"user": {"login": "mzeijen", "name": "Maurice Zeijen"}}, "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/46a528431661e161e8a1f8457f2f9e9c357c32c4", "committedDate": "2020-03-12T15:31:19Z", "message": "Correct since javadoc annotation, updated copyright year and added myself as author to all files where I hadn't added myself yet."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzE3NTQx", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-373717541", "createdAt": "2020-03-12T16:35:14Z", "commit": {"oid": "46a528431661e161e8a1f8457f2f9e9c357c32c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzIxOTg2", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#pullrequestreview-373721986", "createdAt": "2020-03-12T16:40:39Z", "commit": {"oid": "46a528431661e161e8a1f8457f2f9e9c357c32c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 563, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}