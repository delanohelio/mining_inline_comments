{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2OTAxNTcy", "number": 2441, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoyMjo0OVrOEIXRRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxODowODo0MFrOEIeU8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjA1MzE2OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoyMjo0OVrOGoR32g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoyMjo0OVrOGoR32g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4OTA1MA==", "bodyText": "Could you exclude 0, as well? Underlying API requires a positive integer.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2441#discussion_r444889050", "createdAt": "2020-06-24T13:22:49Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "diffHunk": "@@ -72,23 +72,29 @@ public PubSubReactiveFactory(PubSubSubscriberOperations subscriberOperations, Sc\n \t * batches of up to the requested number of messages until the full demand is fulfilled\n \t * or subscription terminated.\n \t * <p>For unlimited demand, the underlying subscription will be polled at a regular interval,\n-\t * requesting up to {@code Integer.MAX_VALUE} messages at each poll.\n+\t * requesting up to {@code maxMessages} messages at each poll.\n \t * <p>For specific demand, as many messages as are available will be returned immediately,\n \t * with remaining demand being fulfilled in the future.\n \t * Pub/Sub timeout will cause a retry with the same demand.\n \t * <p>Any exceptions that are thrown by the Pub/Sub client will be passed as an error to the stream.\n \t * The error handling operators, like {@link Flux#retry()},\n \t * can be used to recover and continue streaming messages.\n \t * @param subscriptionName subscription from which to retrieve messages.\n-\t * @param pollingPeriodMs how frequently to poll the source subscription in case of unlimited demand, in milliseconds.\n+\t * @param pollingPeriodMs how frequently to poll the source subscription in case of\n+\t * unlimited demand, in milliseconds.\n+\t * @param maxMessages max number of messages that may be pulled from the source\n+\t * subscription in case of unlimited demand.\n \t * @return infinite stream of {@link AcknowledgeablePubsubMessage} objects.\n+\t * @throws IllegalArgumentException if {@code maxMessages < 0}\n \t */\n-\tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs) {\n-\n+\tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs, int maxMessages) {\n+\t\tif (maxMessages < 0) {\n+\t\t\tthrow new IllegalArgumentException(\"maxMessages cannot be less than 0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b1b51ba0c7593dbba5c07866a13b3cfdcd36e30"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzIwOTQ1OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxODowODo0MFrOGodb8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMzo0NzoyNFrOGomx9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3ODUxMw==", "bodyText": "Methods with multiple numeric parameters can get confusing (we have String, long, int here). I think I'd prefer to set maxMessages in an overloaded PubSubReactiveFactory constructor.\nUpsides:\n\nwe get to keep a single poll() method.\nmaxMessages can be autoconfigured to current max int value by default and overridden with a property, keeping it backwards compatible and consistent with how we configure other functionality.\nmaxMessages won't need to be propagated from poll() to pollingPull() to pullAll().\n\nDownside:\n\ndifferent instances of the factory have to be created if different maxMessages settings are required in a single application. This is mitigated by how lightweight PubSubReactiveFactory is; it's just a wrapper around PubSubTemplate and a reactor scheduler.\n\n@meltsufin What do you think?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2441#discussion_r445078513", "createdAt": "2020-06-24T18:08:40Z", "author": {"login": "elefeint"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "diffHunk": "@@ -72,23 +72,29 @@ public PubSubReactiveFactory(PubSubSubscriberOperations subscriberOperations, Sc\n \t * batches of up to the requested number of messages until the full demand is fulfilled\n \t * or subscription terminated.\n \t * <p>For unlimited demand, the underlying subscription will be polled at a regular interval,\n-\t * requesting up to {@code Integer.MAX_VALUE} messages at each poll.\n+\t * requesting up to {@code maxMessages} messages at each poll.\n \t * <p>For specific demand, as many messages as are available will be returned immediately,\n \t * with remaining demand being fulfilled in the future.\n \t * Pub/Sub timeout will cause a retry with the same demand.\n \t * <p>Any exceptions that are thrown by the Pub/Sub client will be passed as an error to the stream.\n \t * The error handling operators, like {@link Flux#retry()},\n \t * can be used to recover and continue streaming messages.\n \t * @param subscriptionName subscription from which to retrieve messages.\n-\t * @param pollingPeriodMs how frequently to poll the source subscription in case of unlimited demand, in milliseconds.\n+\t * @param pollingPeriodMs how frequently to poll the source subscription in case of\n+\t * unlimited demand, in milliseconds.\n+\t * @param maxMessages max number of messages that may be pulled from the source\n+\t * subscription in case of unlimited demand.\n \t * @return infinite stream of {@link AcknowledgeablePubsubMessage} objects.\n+\t * @throws IllegalArgumentException if {@code maxMessages < 0}\n \t */\n-\tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs) {\n-\n+\tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs, int maxMessages) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b1b51ba0c7593dbba5c07866a13b3cfdcd36e30"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA5MjAzOQ==", "bodyText": "Makes sense, I see the maxMessages setting being something not changed too frequently so setting in constructor seems appropriate.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2441#discussion_r445092039", "createdAt": "2020-06-24T18:33:17Z", "author": {"login": "dzou"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "diffHunk": "@@ -72,23 +72,29 @@ public PubSubReactiveFactory(PubSubSubscriberOperations subscriberOperations, Sc\n \t * batches of up to the requested number of messages until the full demand is fulfilled\n \t * or subscription terminated.\n \t * <p>For unlimited demand, the underlying subscription will be polled at a regular interval,\n-\t * requesting up to {@code Integer.MAX_VALUE} messages at each poll.\n+\t * requesting up to {@code maxMessages} messages at each poll.\n \t * <p>For specific demand, as many messages as are available will be returned immediately,\n \t * with remaining demand being fulfilled in the future.\n \t * Pub/Sub timeout will cause a retry with the same demand.\n \t * <p>Any exceptions that are thrown by the Pub/Sub client will be passed as an error to the stream.\n \t * The error handling operators, like {@link Flux#retry()},\n \t * can be used to recover and continue streaming messages.\n \t * @param subscriptionName subscription from which to retrieve messages.\n-\t * @param pollingPeriodMs how frequently to poll the source subscription in case of unlimited demand, in milliseconds.\n+\t * @param pollingPeriodMs how frequently to poll the source subscription in case of\n+\t * unlimited demand, in milliseconds.\n+\t * @param maxMessages max number of messages that may be pulled from the source\n+\t * subscription in case of unlimited demand.\n \t * @return infinite stream of {@link AcknowledgeablePubsubMessage} objects.\n+\t * @throws IllegalArgumentException if {@code maxMessages < 0}\n \t */\n-\tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs) {\n-\n+\tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs, int maxMessages) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3ODUxMw=="}, "originalCommit": {"oid": "3b1b51ba0c7593dbba5c07866a13b3cfdcd36e30"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIzMTYwNQ==", "bodyText": "Overloaded constructor or overloaded poll methods would work. Since it affects multiple methods, constructor is probably preferred.\nEither way, the way it is now, is not good because it would causes a breaking change.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2441#discussion_r445231605", "createdAt": "2020-06-24T23:47:24Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "diffHunk": "@@ -72,23 +72,29 @@ public PubSubReactiveFactory(PubSubSubscriberOperations subscriberOperations, Sc\n \t * batches of up to the requested number of messages until the full demand is fulfilled\n \t * or subscription terminated.\n \t * <p>For unlimited demand, the underlying subscription will be polled at a regular interval,\n-\t * requesting up to {@code Integer.MAX_VALUE} messages at each poll.\n+\t * requesting up to {@code maxMessages} messages at each poll.\n \t * <p>For specific demand, as many messages as are available will be returned immediately,\n \t * with remaining demand being fulfilled in the future.\n \t * Pub/Sub timeout will cause a retry with the same demand.\n \t * <p>Any exceptions that are thrown by the Pub/Sub client will be passed as an error to the stream.\n \t * The error handling operators, like {@link Flux#retry()},\n \t * can be used to recover and continue streaming messages.\n \t * @param subscriptionName subscription from which to retrieve messages.\n-\t * @param pollingPeriodMs how frequently to poll the source subscription in case of unlimited demand, in milliseconds.\n+\t * @param pollingPeriodMs how frequently to poll the source subscription in case of\n+\t * unlimited demand, in milliseconds.\n+\t * @param maxMessages max number of messages that may be pulled from the source\n+\t * subscription in case of unlimited demand.\n \t * @return infinite stream of {@link AcknowledgeablePubsubMessage} objects.\n+\t * @throws IllegalArgumentException if {@code maxMessages < 0}\n \t */\n-\tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs) {\n-\n+\tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs, int maxMessages) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3ODUxMw=="}, "originalCommit": {"oid": "3b1b51ba0c7593dbba5c07866a13b3cfdcd36e30"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2163, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}