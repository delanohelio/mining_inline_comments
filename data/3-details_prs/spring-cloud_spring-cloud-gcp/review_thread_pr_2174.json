{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMDk1NzIy", "number": 2174, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozNjozMVrODdYIRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0NjoyNlrODgz48w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTMwNjMwOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozNjozMVrOFl8X4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozNjozMVrOFl8X4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzMDc4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Otherwise an SQL will be wrapped to eager-load lists with {@link Interleaved#lazy()} equals fo \"false\".\n          \n          \n            \n            \t * Otherwise an SQL will be wrapped to eager-load lists with {@link Interleaved#lazy()} equals to {@code false} .", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375330785", "createdAt": "2020-02-05T15:36:31Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "diffHunk": "@@ -51,4 +52,11 @@\n \t * query method is executed as a DML query.\n \t */\n \tboolean dmlStatement() default false;\n+\n+\t/**\n+\t * When {@code false} then any {@link Interleaved} lists of the fetched entity will be lazy-loaded.\n+\t * Otherwise an SQL will be wrapped to eager-load lists with {@link Interleaved#lazy()} equals fo \"false\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTMxMzgwOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozODoxNFrOFl8cYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozODoxNFrOFl8cYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzMTkzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return {@code false} if {@link Interleaved} lists should be skipped.\n          \n          \n            \n            \t * @return {@code true} if {@link Interleaved} lists should be fetched eagerly.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375331936", "createdAt": "2020-02-05T15:38:14Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "diffHunk": "@@ -51,4 +52,11 @@\n \t * query method is executed as a DML query.\n \t */\n \tboolean dmlStatement() default false;\n+\n+\t/**\n+\t * When {@code false} then any {@link Interleaved} lists of the fetched entity will be lazy-loaded.\n+\t * Otherwise an SQL will be wrapped to eager-load lists with {@link Interleaved#lazy()} equals fo \"false\".\n+\t * @return {@code false} if {@link Interleaved} lists should be skipped.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTM1MjgyOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTo0Nzo0NFrOFl80mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMjoxMzozM1rOFmJBOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzODEzOQ==", "bodyText": "I think we should call it fetchInterleavedEagerly to make the name more precise.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375338139", "createdAt": "2020-02-05T15:47:44Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "diffHunk": "@@ -51,4 +52,11 @@\n \t * query method is executed as a DML query.\n \t */\n \tboolean dmlStatement() default false;\n+\n+\t/**\n+\t * When {@code false} then any {@link Interleaved} lists of the fetched entity will be lazy-loaded.\n+\t * Otherwise an SQL will be wrapped to eager-load lists with {@link Interleaved#lazy()} equals fo \"false\".\n+\t * @return {@code false} if {@link Interleaved} lists should be skipped.\n+\t */\n+\tboolean fetchInterleaved() default false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyMjMwOA==", "bodyText": "Well, it still not a perfect name. I hear it like \"fetchAnyInterleavedAlwaysEagerly\". And the fetchInterleavedEagerly is still a very long name.\nIn the worst situation, any interleaved will be proxied and lazy-fetched in any case.\nHow about to rename it to eagerFetch? it sounds like - by default we have a lazy-fetch but we can enable eager-fetch when needed.\n\"There are only two hard things in Computer Science: cache invalidation and naming things.\"\n-- Phil Karlton", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375522308", "createdAt": "2020-02-05T21:38:24Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "diffHunk": "@@ -51,4 +52,11 @@\n \t * query method is executed as a DML query.\n \t */\n \tboolean dmlStatement() default false;\n+\n+\t/**\n+\t * When {@code false} then any {@link Interleaved} lists of the fetched entity will be lazy-loaded.\n+\t * Otherwise an SQL will be wrapped to eager-load lists with {@link Interleaved#lazy()} equals fo \"false\".\n+\t * @return {@code false} if {@link Interleaved} lists should be skipped.\n+\t */\n+\tboolean fetchInterleaved() default false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzODEzOQ=="}, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzNzk3OQ==", "bodyText": "I'm OK with fetchInterleaved. I would just ask to create an integration test that uses @Query(.... fetchInterleaved=true) directly on an actual repository.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375537979", "createdAt": "2020-02-05T22:13:33Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "diffHunk": "@@ -51,4 +52,11 @@\n \t * query method is executed as a DML query.\n \t */\n \tboolean dmlStatement() default false;\n+\n+\t/**\n+\t * When {@code false} then any {@link Interleaved} lists of the fetched entity will be lazy-loaded.\n+\t * Otherwise an SQL will be wrapped to eager-load lists with {@link Interleaved#lazy()} equals fo \"false\".\n+\t * @return {@code false} if {@link Interleaved} lists should be skipped.\n+\t */\n+\tboolean fetchInterleaved() default false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzODEzOQ=="}, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTM4MTYwOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTo1NDozMFrOFl9Gqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTo1NDozMFrOFl9Gqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0Mjc2Mg==", "bodyText": "move \" \" + persistentEntity.tableName() to the line where you initialize final String subquery, then you could just use .append(subquery) here", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375342762", "createdAt": "2020-02-05T15:54:30Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -131,24 +131,29 @@ private SpannerStatementQueryExecutor() {\n \t * @param sql the sql that will be wrapped with sorting and paging options.\n \t * @param mappingContext a mapping context to convert between Cloud Spanner column names\n \t *     and underlying property names.\n+\t * @param fetchInterleaved when {@code true} additional subqueries will be added\n+\t *     to fetch eager-Interleaved lists with a single query.   .\n \t * @param <T> the domain type.\n \t * @return the final SQL string with paging and sorting applied.\n \t */\n \tpublic static <T> String applySortingPagingQueryOptions(Class<T> entityClass,\n \t\t\tSpannerPageableQueryOptions options, String sql,\n-\t\t\tSpannerMappingContext mappingContext) {\n+\t\t\tSpannerMappingContext mappingContext, boolean fetchInterleaved) {\n \t\tSpannerPersistentEntity<?> persistentEntity = mappingContext\n \t\t\t\t.getPersistentEntity(entityClass);\n \n \t\t// Cloud Spanner does not preserve the order of derived tables so we must not wrap the\n \t\t// derived table\n \t\t// in SELECT * FROM () if there is no overriding pageable param.\n \t\tif ((options.getSort() == null || options.getSort().isUnsorted()) && options.getLimit() == null\n-\t\t\t\t&& options.getOffset() == null) {\n+\t\t\t\t&& options.getOffset() == null && !fetchInterleaved) {\n \t\t\treturn sql;\n \t\t}\n-\t\tStringBuilder sb = SpannerStatementQueryExecutor.applySort(options.getSort(),\n-\t\t\t\tnew StringBuilder(\"SELECT * FROM (\").append(sql).append(\")\"), (o) -> {\n+\t\tfinal String subquery = fetchInterleaved ? getChildrenSubquery(persistentEntity, mappingContext) : \"\";\n+\t\tStringBuilder sb = applySort(options.getSort(),\n+\t\t\t\tnew StringBuilder(\"SELECT *\").append(subquery)\n+\t\t\t\t\t\t.append(\" FROM (\").append(sql).append(\")\")\n+\t\t\t\t\t\t.append(subquery.isEmpty() ? \"\" : \" \" + persistentEntity.tableName()), (o) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTQwNjcwOnYy", "diffSide": "LEFT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjowMDoyNVrOFl9WXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzowMToyOVrOFmi4hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0Njc4Mg==", "bodyText": "why was String.join(\", \", spannerPersistentEntity.columns()) removed?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375346782", "createdAt": "2020-02-05T16:00:25Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -303,18 +308,23 @@ private static void bindParameter(ValueBinder<Statement.Builder> bind,\n \n \tpublic static String getColumnsStringForSelect(\n \t\t\tSpannerPersistentEntity<?> spannerPersistentEntity, SpannerMappingContext mappingContext) {\n+\t\treturn String.join(\", \", spannerPersistentEntity.columns())\n+\t\t\t\t+ getChildrenSubquery(spannerPersistentEntity, mappingContext);\n+\t}\n+\n+\tprivate static String getChildrenSubquery(\n+\t\t\tSpannerPersistentEntity<?> spannerPersistentEntity, SpannerMappingContext mappingContext) {\n \t\tStringJoiner joiner = new StringJoiner(\", \");\n \t\tspannerPersistentEntity.doWithInterleavedProperties(spannerPersistentProperty -> {\n \t\t\tif (spannerPersistentProperty.isEagerInterleaved()) {\n \t\t\t\tClass childType = spannerPersistentProperty.getColumnInnerType();\n \t\t\t\tSpannerPersistentEntity childPersistentEntity = mappingContext.getPersistentEntity(childType);\n \t\t\t\tjoiner.add(getChildrenStructsQuery(\n-\t\t\t\t\tchildPersistentEntity, spannerPersistentEntity, mappingContext, spannerPersistentProperty.getColumnName()));\n+\t\t\t\t\t\tchildPersistentEntity, spannerPersistentEntity, mappingContext, spannerPersistentProperty.getColumnName()));\n \t\t\t}\n \t\t});\n-\t\tString childrenSubquery = joiner.toString();\n-\t\treturn String.join(\", \", spannerPersistentEntity.columns())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNTI0Nw==", "bodyText": "It is not removed - I've split an old method getColumnsStringForSelect on two - a new method getChildrenSubquery + old method getColumnsStringForSelect\nSo the old method now looks like\n\tpublic static String getColumnsStringForSelect(\n\t\t\tSpannerPersistentEntity<?> spannerPersistentEntity, SpannerMappingContext mappingContext) {\n\t\treturn String.join(\", \", spannerPersistentEntity.columns())\n\t\t\t\t+ getChildrenSubquery(spannerPersistentEntity, mappingContext);\n\t}\nand all \"joins\" are in place", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375525247", "createdAt": "2020-02-05T21:44:36Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -303,18 +308,23 @@ private static void bindParameter(ValueBinder<Statement.Builder> bind,\n \n \tpublic static String getColumnsStringForSelect(\n \t\t\tSpannerPersistentEntity<?> spannerPersistentEntity, SpannerMappingContext mappingContext) {\n+\t\treturn String.join(\", \", spannerPersistentEntity.columns())\n+\t\t\t\t+ getChildrenSubquery(spannerPersistentEntity, mappingContext);\n+\t}\n+\n+\tprivate static String getChildrenSubquery(\n+\t\t\tSpannerPersistentEntity<?> spannerPersistentEntity, SpannerMappingContext mappingContext) {\n \t\tStringJoiner joiner = new StringJoiner(\", \");\n \t\tspannerPersistentEntity.doWithInterleavedProperties(spannerPersistentProperty -> {\n \t\t\tif (spannerPersistentProperty.isEagerInterleaved()) {\n \t\t\t\tClass childType = spannerPersistentProperty.getColumnInnerType();\n \t\t\t\tSpannerPersistentEntity childPersistentEntity = mappingContext.getPersistentEntity(childType);\n \t\t\t\tjoiner.add(getChildrenStructsQuery(\n-\t\t\t\t\tchildPersistentEntity, spannerPersistentEntity, mappingContext, spannerPersistentProperty.getColumnName()));\n+\t\t\t\t\t\tchildPersistentEntity, spannerPersistentEntity, mappingContext, spannerPersistentProperty.getColumnName()));\n \t\t\t}\n \t\t});\n-\t\tString childrenSubquery = joiner.toString();\n-\t\treturn String.join(\", \", spannerPersistentEntity.columns())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0Njc4Mg=="}, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk2MTczMg==", "bodyText": "I see, makes sense", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375961732", "createdAt": "2020-02-06T17:01:29Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -303,18 +308,23 @@ private static void bindParameter(ValueBinder<Statement.Builder> bind,\n \n \tpublic static String getColumnsStringForSelect(\n \t\t\tSpannerPersistentEntity<?> spannerPersistentEntity, SpannerMappingContext mappingContext) {\n+\t\treturn String.join(\", \", spannerPersistentEntity.columns())\n+\t\t\t\t+ getChildrenSubquery(spannerPersistentEntity, mappingContext);\n+\t}\n+\n+\tprivate static String getChildrenSubquery(\n+\t\t\tSpannerPersistentEntity<?> spannerPersistentEntity, SpannerMappingContext mappingContext) {\n \t\tStringJoiner joiner = new StringJoiner(\", \");\n \t\tspannerPersistentEntity.doWithInterleavedProperties(spannerPersistentProperty -> {\n \t\t\tif (spannerPersistentProperty.isEagerInterleaved()) {\n \t\t\t\tClass childType = spannerPersistentProperty.getColumnInnerType();\n \t\t\t\tSpannerPersistentEntity childPersistentEntity = mappingContext.getPersistentEntity(childType);\n \t\t\t\tjoiner.add(getChildrenStructsQuery(\n-\t\t\t\t\tchildPersistentEntity, spannerPersistentEntity, mappingContext, spannerPersistentProperty.getColumnName()));\n+\t\t\t\t\t\tchildPersistentEntity, spannerPersistentEntity, mappingContext, spannerPersistentProperty.getColumnName()));\n \t\t\t}\n \t\t});\n-\t\tString childrenSubquery = joiner.toString();\n-\t\treturn String.join(\", \", spannerPersistentEntity.columns())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0Njc4Mg=="}, "originalCommit": {"oid": "bcd27c37d9057cfd65d9aababce1ddea11d41a27"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzEyMTE5OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "isResolved": true, "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMzowMDoyNFrOFmN-9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjoxMzoxOVrOFmsDOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw==", "bodyText": "The test fails on line 279 - the \"lazy-fetch\" is not work as expected (as it was before merge PR #2132) and the t.getSubTrades() returns an empty collection. Is it OK?\nThe Mockito.verify on line 280 also fails - a \"lazy-load-logic\" is not invoked.\nI did a separate local branch from rev 26e9adf and run a similar test against it.\nIn that brach, the followed test passed fine\n\t\tMockito.clearInvocations(spannerTemplate);\n\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n\t\t\t\t.isNotEmpty()\n\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n\t\tMockito.verify(spannerTemplate, Mockito.times(2))\n\t\t\t\t.executeQuery(any(Statement.class), any());\n\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n\t\t\t\t.query(eq(Trade.class), any(Statement.class), any(SpannerQueryOptions.class));\nI think the PR #2132 did a bug with @query annotation.\nWill try to find & fix it with next commits", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375619317", "createdAt": "2020-02-06T03:00:24Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg5MjAyNg==", "bodyText": "the Trade has default value for subTrades field like\n\t@Interleaved\n\tprivate List<SubTrade> subTrades = Collections.emptyList();\nThan is why such non-null validation in class SpannerTemplate line 588 is not enouph\n\t\t\t\t\t//an interleaved property can only be List\n\t\t\t\t\tList propertyValue = (List) accessor.getProperty(spannerPersistentProperty);\n\t\t\t\t\tif (propertyValue != null) {\n\t\t\t\t\t\tresolveChildEntities(propertyValue, null);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\nIt was added after the rev: 26e9adf", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375892026", "createdAt": "2020-02-06T15:12:17Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk2MjkzMA==", "bodyText": "Good catch. How do you think that can be fixed?\nMaybe we should nullify the laze loaded fields on the parent entity retrieval?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375962930", "createdAt": "2020-02-06T17:03:29Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MTcxOA==", "bodyText": "I've tried to tell about this problem we could potentially have before but my Eng is not so fluent to be clear, sorry.\nI have no clever idea yet :(\nI think the most strong solution could be to have some additional flag in aspannerPersistentProperty that it has been populated already.\n\"nulling\" of fields is not a good idea - the field could be created by Lombok builder and it could be a business logic (like enty-to-json transformers) that expect the field can never be null", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375971718", "createdAt": "2020-02-06T17:19:37Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk5OTExMQ==", "bodyText": "Discussing with @dmitry-s offline, he pointed out that it would just be null until someone tries to access it, at which point it will be lazy-loaded. So, no one should ever see it as null.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r375999111", "createdAt": "2020-02-06T18:13:21Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAwMDk2OQ==", "bodyText": "It sounds like a hack.\nWhat the next step should be? Are we going to merge this PR and will do a fix later or we can collaborate somehow in another way?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r376000969", "createdAt": "2020-02-06T18:17:11Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0NzQ5OA==", "bodyText": "I will add a fix in this branch.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r376047498", "createdAt": "2020-02-06T19:51:31Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0OTUxMA==", "bodyText": "so few I know about the GitHub : (", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r376049510", "createdAt": "2020-02-06T19:55:47Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwMzMwNA==", "bodyText": "Sorry, my test was wrong. You are right, it is because of the default value.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r376103304", "createdAt": "2020-02-06T21:53:52Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwNDQ3NQ==", "bodyText": "in theory, we can to some \"magic proxy\" for each interleaved ... but it seems to be too complex to be stable", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r376104475", "createdAt": "2020-02-06T21:56:24Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwNzEyMw==", "bodyText": "we can do a very simple decision - if the code reached line 593 of SpannerTemplate line it means that any eager-interleaved is already fetched so any other should be a proxy for \"lazy-interleaved\"\nI think the only scenario when it is not true - it is @query(fetchInterleaved=false)\nIs not it?\nProbably I'm wrong...", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r376107123", "createdAt": "2020-02-06T22:02:18Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjExMTkyOQ==", "bodyText": "in my implementation of PR #2132 I built an SQL-query (ResultSet) and a function to process it at the same time in parallel - it was a \"pair\". So when I'm started to process RS I had only to invoke a function.\nYour PR is much simple so it is better, but there is a single place here where it is difficult to understand which fields are populated already.\nI don't understand how this magic method works (ConverterAwareMappingSpannerEntityProcessor#mapToList(com.google.cloud.spanner.ResultSet, java.lang.Class, java.util.Set<java.lang.String>, boolean))\nentityReader.read(entityClass,\n\tresultSet.getCurrentRowAsStruct(),\n\tincludeColumns,\n\tallowMissingColumns)\n\nAnd I can't propose any solution yet :(\nBut this method is a good place to mark any Interleaved as 'populated' at processing of it", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r376111929", "createdAt": "2020-02-06T22:13:19Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/test/java/org/springframework/cloud/gcp/data/spanner/repository/it/SpannerRepositoryIntegrationTests.java", "diffHunk": "@@ -246,6 +255,28 @@ public void queryMethodsTest() {\n \t\tassertThat(this.subTradeRepository.count()).isEqualTo(2);\n \t\tassertThat(this.subTradeComponentRepository.count()).isEqualTo(3);\n \n+\t\t// test eager-fetch in @Query\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tfinal Trade aTrade = someTrade;\n+\t\tassertThat(tradeRepository.fetchByIdEagerly(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));\n+\t\tMockito.verify(spannerTemplate, Mockito.times(1))\n+\t\t\t\t.executeQuery(any(Statement.class), any(SpannerQueryOptions.class));\n+\n+\t\tMockito.clearInvocations(spannerTemplate);\n+\t\tassertThat(tradeRepository.fetchByIdLazy(aTrade.getId()))\n+\t\t\t\t.isNotEmpty()\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getId()).isEqualTo(aTrade.getId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getTraderId()).isEqualTo(aTrade.getTraderId()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSymbol()).isEqualTo(aTrade.getSymbol()))\n+\t\t\t\t.hasValueSatisfying(t -> assertThat(t.getSubTrades()).hasSize(aTrade.getSubTrades().size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxOTMxNw=="}, "originalCommit": {"oid": "e70f46fc9240e72e2cabcffc6a3f8a530b45555d"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA3Mjg2OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNjowMlrOFn0ZHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMzozODoxOFrOFrCmSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ==", "bodyText": "Could you clarify what is this method for?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377297181", "createdAt": "2020-02-10T20:26:02Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY1NDk1Nw==", "bodyText": "The method name is probably bad, but...\nThe initial idea of interleaved eager-fetching was to use wrapped query SELECT *, <interlieved-sub-select> FROM (<initial query>) in the same way as the method applySort at line 160. It was fine until we decided to use the fetchInterleaved as permanently true. After a number of failed integration tests and attempts to fix them, I understood that the wrapped query will not work in general. Mainly because of Spanner does not preserve sort ordering of wrapped queries.\nThen I concluded - when the user has created an SQL with a complete list of fields to select it is not really good idea to add some more fields with additional sub-selects - it could really affect performance to select fields that were not requested. But when the query is like \"select * from Table ...\" - it is the best candidate to split it into two parts an add interleaved fields into the middle. Like \"select *, \" + <interlieved> + \" from Table ...\" and it does not break any skip\\limit or sorting conditions.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377654957", "createdAt": "2020-02-11T14:07:57Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4ODgyNA==", "bodyText": "I don't really like that we have to rely on SELECT_ALL_PATTERN, there could be cases where it doesn't work and that would lead to inconsistent behavior. It is not transparent and would be hard to detect.\nIs there a way to avoid regex matching? What if we use joins instead of sub-queries?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377788824", "createdAt": "2020-02-11T17:34:42Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5MDY2NA==", "bodyText": "To clarify, the query I'm thinking about would be something like that:\nSELECT    singers.*,\n          array_agg(struct(albumid, albumtitle, array\n          (\n                 select as struct *\n                 FROM   songs\n                 WHERE  songs.singerid = albums.singerid\n                 AND    songs.albumid = albums.albumid))) AS albums\nFROM      (\n                 SELECT *\n                 FROM   singers\n                 WHERE  singerid = 1) AS singers\nLEFT JOIN albums\nON        albums.singerid = singers.singerid\nGROUP BY  singers.singerid,\n          singers.name \nLIMIT      10\nOFFSET     30 \n\nwhere SELECT * FROM   singers WHERE  singerid = 1 is the user-provided query.\nWhat do you think about that approach?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379090664", "createdAt": "2020-02-13T20:06:24Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNDI1OQ==", "bodyText": "I understood\nIt looks more complex but the main - it is not clear how to process such resultset", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379114259", "createdAt": "2020-02-13T20:57:26Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyMzI4MA==", "bodyText": "the new version is better :)", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379123280", "createdAt": "2020-02-13T21:17:20Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMjI1MQ==", "bodyText": "here we have original SQL as a source for a new query - it is pointed in \"... FROM (SELECT * FROM   singers WHERE  singerid = 1)\".\nBut the sort order of such SQL is not preserved", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379132251", "createdAt": "2020-02-13T21:36:57Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NTU3Mw==", "bodyText": "Does it preserve order in current implementation? I believe we wrap the user-provided query in SELECT * FROM (<query>) LIMIT .. OFFSET ..", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379165573", "createdAt": "2020-02-13T22:55:45Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM1NjAwNA==", "bodyText": "No, it does not.\nThat is a major problem. :(\nWe have an integration test that will fail.\nWith such \"wrapping\" some test from SpannerRepositoryIntegrationTests#queryMethodsTest line ~ 192 could fails unpredictable on assertions isGreaterThan like\n\t\tList<Trade> buyTradesRetrieved = this.tradeRepository\n\t\t\t\t.annotatedTradesByAction(\"BUY\");\n\t\tassertThat(buyTradesRetrieved).containsExactlyInAnyOrderElementsOf(trader1BuyTrades);\n\t\tassertThat(buyTradesRetrieved.get(0).getId()).isGreaterThan(buyTradesRetrieved.get(1).getId());\n\t\tassertThat(buyTradesRetrieved.get(1).getId()).isGreaterThan(buyTradesRetrieved.get(2).getId());", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379356004", "createdAt": "2020-02-14T10:26:21Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM1OTE5MA==", "bodyText": "We really wrap the user-provided queries by SELECT * FROM (<query>) LIMIT .. OFFSET ... We doing it ONLY when we have a SpannerPageableQueryOptions parameter - in such case any \"sorting\" from it will overwrite the pointed by the SQL itself. And we should at least specify it in the documentation I believe.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379359190", "createdAt": "2020-02-14T10:33:12Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwODM2MQ==", "bodyText": "I think we should just accept the fact that the sort order in custom @Querys will not be preserved. The solutions is to pass in the sort order in the Pageable argument. This is definitely something that needs to be in our refdoc.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379508361", "createdAt": "2020-02-14T15:57:07Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUxODg3OA==", "bodyText": "@s13o I think it's ok if ordering is not preserved. We apply ordering from Pageable, and that's how it should be passed.\nCould you roll back changes that introduced regexp?\nI think after that we should be able to merge this PR.\nThanks", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379518878", "createdAt": "2020-02-14T16:16:42Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1NzEyOA==", "bodyText": "oops, will try\nbut I'll have to change the test SpannerRepositoryIntegrationTests#queryMethodsTest line ~ 192", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379557128", "createdAt": "2020-02-14T17:35:48Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2MDc0Mg==", "bodyText": "May I ask you, why you don't like the idea to inject child-subquery after \"select *\"? It seems to be simple enough. I can't really imagine a case when it could fail. Right now - the only leading spaces can affect it. Ok, the regex could be like\nPattern.compile(\"^\\\\s+?select(\\\\s+?all|\\\\s+?distinct)*(?<star>\\\\s+?\\\\*)\", Pattern.CASE_INSENSITIVE);\nThe query is parsed only once, it is from an annotation, so we can cache the result and it should not affect performance.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379560742", "createdAt": "2020-02-14T17:44:03Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2MTE2NA==", "bodyText": "Sounds good. The sort order should be determined by the Pageable that is passed to the method. That is:\nPageRequest.of(2, 2, org.springframework.data.domain.Sort.by(Order.asc(\"id\")))\n\nlines 188-189", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379561164", "createdAt": "2020-02-14T17:45:07Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2MjI2MQ==", "bodyText": "but you didn't answer me about the regex.\nYou probably don't like Pearl :)", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379562261", "createdAt": "2020-02-14T17:47:39Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2MzMyNg==", "bodyText": "I need to have it merged so I'll revert the regex, but, please your opinion is very important to me.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379563326", "createdAt": "2020-02-14T17:50:15Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5MDM5OQ==", "bodyText": "@s13o We avoid parsing the SQL in principle. Experience has taught us that it's a rather risky option. Even augmenting queries is risky, but we decided to go with it in the absence of better alternatives.\nFor example, note that Spanner SQL may contain query hints. That's one situation where parsing can fall apart.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379590399", "createdAt": "2020-02-14T18:53:32Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5NDk5OQ==", "bodyText": "@s13o You don't have to merge it to undo a commit. I think git revert <commit hash> should do the trick.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379594999", "createdAt": "2020-02-14T19:03:54Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5NTQ3Ng==", "bodyText": "You goddamn right. I also hated the idea to parse the SQL from the beginning but saw no other alternative to satisfy failed IT tests.\nMany thanks for the beautiful explanation.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r379595476", "createdAt": "2020-02-14T19:05:07Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY3NTY1OA==", "bodyText": "@s13o You don't have to merge it to undo a commit. I think git revert <commit hash> should do the trick.\n\nFinally, I found a time to complete the PR!\nSorry for the delay, please review.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r380675658", "createdAt": "2020-02-18T13:38:18Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -162,6 +171,27 @@ private SpannerStatementQueryExecutor() {\n \t\treturn sb.toString();\n \t}\n \n+\tprivate static String fetchInterleaved(String sql,\n+\t\t\tSpannerPersistentEntity<?> persistentEntity, SpannerMappingContext mappingContext, boolean fetchInterleaved) {\n+\t\tif (!fetchInterleaved) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal String subquery = getChildrenSubquery(persistentEntity, mappingContext);\n+\t\tif (subquery.isEmpty()) {\n+\t\t\treturn sql;\n+\t\t}\n+\n+\t\tfinal Pair<String, String> parts = splitSelectAll(sql);\n+\t\treturn parts.getSecond().isEmpty() ? sql : parts.getFirst() + subquery + parts.getSecond();\n+\t}\n+\n+\tprivate static Pair<String, String> splitSelectAll(String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzE4MQ=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA3NTA5OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNjo0NFrOFn0afA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMzo0NzowNlrOFoJgBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzUzMg==", "bodyText": "T is never used, please remove", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377297532", "createdAt": "2020-02-10T20:26:44Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY0MzAxNQ==", "bodyText": "Inherited from the SpannerOperations", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377643015", "createdAt": "2020-02-11T13:47:06Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzUzMg=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA3NTM2OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNjo0OVrOFn0aqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMzo0NjoyMlrOFoJecg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzU3Nw==", "bodyText": "T is never used, please remove", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377297577", "createdAt": "2020-02-10T20:26:49Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {\n \t\tapplyDeleteMutations(entityClass, KeySet.newBuilder().addKey(key).build(),\n \t\t\t\tCollections.singletonList(this.mutationFactory.delete(entityClass, key)));\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, KeySet keys) {\n+\tpublic <T> void delete(Class<T> entityClass, KeySet keys) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY0MjYxMA==", "bodyText": "Inherited from the SpannerOperations", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377642610", "createdAt": "2020-02-11T13:46:22Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {\n \t\tapplyDeleteMutations(entityClass, KeySet.newBuilder().addKey(key).build(),\n \t\t\t\tCollections.singletonList(this.mutationFactory.delete(entityClass, key)));\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, KeySet keys) {\n+\tpublic <T> void delete(Class<T> entityClass, KeySet keys) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzU3Nw=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA3NTc1OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNjo1N1rOFn0a4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNjo1N1rOFn0a4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzYzNQ==", "bodyText": "T is never used, please remove", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377297635", "createdAt": "2020-02-10T20:26:57Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {\n \t\tapplyDeleteMutations(entityClass, KeySet.newBuilder().addKey(key).build(),\n \t\t\t\tCollections.singletonList(this.mutationFactory.delete(entityClass, key)));\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, KeySet keys) {\n+\tpublic <T> void delete(Class<T> entityClass, KeySet keys) {\n \t\tapplyDeleteMutations(entityClass, keys, Collections\n \t\t\t\t.singletonList(this.mutationFactory.delete(entityClass, keys)));\n \t}\n \n-\tprivate void applyDeleteMutations(Class entityClass, KeySet keys, List<Mutation> mutations) {\n+\tprivate <T> void applyDeleteMutations(Class<T> entityClass, KeySet keys, List<Mutation> mutations) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA3NjEwOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNzowMlrOFn0bEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMjowMjo1NVrOFn3OHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzY4Mg==", "bodyText": "T is never used, please remove", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377297682", "createdAt": "2020-02-10T20:27:02Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {\n \t\tapplyDeleteMutations(entityClass, KeySet.newBuilder().addKey(key).build(),\n \t\t\t\tCollections.singletonList(this.mutationFactory.delete(entityClass, key)));\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, KeySet keys) {\n+\tpublic <T> void delete(Class<T> entityClass, KeySet keys) {\n \t\tapplyDeleteMutations(entityClass, keys, Collections\n \t\t\t\t.singletonList(this.mutationFactory.delete(entityClass, keys)));\n \t}\n \n-\tprivate void applyDeleteMutations(Class entityClass, KeySet keys, List<Mutation> mutations) {\n+\tprivate <T> void applyDeleteMutations(Class<T> entityClass, KeySet keys, List<Mutation> mutations) {\n \t\tmaybeEmitEvent(new BeforeDeleteEvent(mutations, null, keys, entityClass));\n \t\tapplyMutations(mutations);\n \t\tmaybeEmitEvent(new AfterDeleteEvent(mutations, null, keys, entityClass));\n \t}\n \n \t@Override\n-\tpublic long count(Class entityClass) {\n+\tpublic <T> long count(Class<T> entityClass) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTMxMQ==", "bodyText": "np, but it was declared in SpannerOperations.\nIt was done mainly to remove the warning with code inspection about \"Raw use of parametrized class 'Class'\".\nStill, remove?", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377301311", "createdAt": "2020-02-10T20:35:00Z", "author": {"login": "s13o"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {\n \t\tapplyDeleteMutations(entityClass, KeySet.newBuilder().addKey(key).build(),\n \t\t\t\tCollections.singletonList(this.mutationFactory.delete(entityClass, key)));\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, KeySet keys) {\n+\tpublic <T> void delete(Class<T> entityClass, KeySet keys) {\n \t\tapplyDeleteMutations(entityClass, keys, Collections\n \t\t\t\t.singletonList(this.mutationFactory.delete(entityClass, keys)));\n \t}\n \n-\tprivate void applyDeleteMutations(Class entityClass, KeySet keys, List<Mutation> mutations) {\n+\tprivate <T> void applyDeleteMutations(Class<T> entityClass, KeySet keys, List<Mutation> mutations) {\n \t\tmaybeEmitEvent(new BeforeDeleteEvent(mutations, null, keys, entityClass));\n \t\tapplyMutations(mutations);\n \t\tmaybeEmitEvent(new AfterDeleteEvent(mutations, null, keys, entityClass));\n \t}\n \n \t@Override\n-\tpublic long count(Class entityClass) {\n+\tpublic <T> long count(Class<T> entityClass) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzY4Mg=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMjM4OQ==", "bodyText": "Matching what's in SpannerOperations makes sense to me.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377302389", "createdAt": "2020-02-10T20:37:30Z", "author": {"login": "meltsufin"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {\n \t\tapplyDeleteMutations(entityClass, KeySet.newBuilder().addKey(key).build(),\n \t\t\t\tCollections.singletonList(this.mutationFactory.delete(entityClass, key)));\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, KeySet keys) {\n+\tpublic <T> void delete(Class<T> entityClass, KeySet keys) {\n \t\tapplyDeleteMutations(entityClass, keys, Collections\n \t\t\t\t.singletonList(this.mutationFactory.delete(entityClass, keys)));\n \t}\n \n-\tprivate void applyDeleteMutations(Class entityClass, KeySet keys, List<Mutation> mutations) {\n+\tprivate <T> void applyDeleteMutations(Class<T> entityClass, KeySet keys, List<Mutation> mutations) {\n \t\tmaybeEmitEvent(new BeforeDeleteEvent(mutations, null, keys, entityClass));\n \t\tapplyMutations(mutations);\n \t\tmaybeEmitEvent(new AfterDeleteEvent(mutations, null, keys, entityClass));\n \t}\n \n \t@Override\n-\tpublic long count(Class entityClass) {\n+\tpublic <T> long count(Class<T> entityClass) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzY4Mg=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM0MzUxNg==", "bodyText": "Makes sense, let's keep it.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r377343516", "createdAt": "2020-02-10T22:02:55Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -352,25 +352,25 @@ private void applyDeleteMutations(Iterable<?> objects, List<Mutation> mutations)\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, Key key) {\n+\tpublic <T> void delete(Class<T> entityClass, Key key) {\n \t\tapplyDeleteMutations(entityClass, KeySet.newBuilder().addKey(key).build(),\n \t\t\t\tCollections.singletonList(this.mutationFactory.delete(entityClass, key)));\n \t}\n \n \t@Override\n-\tpublic void delete(Class entityClass, KeySet keys) {\n+\tpublic <T> void delete(Class<T> entityClass, KeySet keys) {\n \t\tapplyDeleteMutations(entityClass, keys, Collections\n \t\t\t\t.singletonList(this.mutationFactory.delete(entityClass, keys)));\n \t}\n \n-\tprivate void applyDeleteMutations(Class entityClass, KeySet keys, List<Mutation> mutations) {\n+\tprivate <T> void applyDeleteMutations(Class<T> entityClass, KeySet keys, List<Mutation> mutations) {\n \t\tmaybeEmitEvent(new BeforeDeleteEvent(mutations, null, keys, entityClass));\n \t\tapplyMutations(mutations);\n \t\tmaybeEmitEvent(new AfterDeleteEvent(mutations, null, keys, entityClass));\n \t}\n \n \t@Override\n-\tpublic long count(Class entityClass) {\n+\tpublic <T> long count(Class<T> entityClass) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NzY4Mg=="}, "originalCommit": {"oid": "025386048f0175c53d25bdda0f81ff6fb81446ab"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzI5NTY3OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0MToxMlrOFrN8RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0MToxMlrOFrN8RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2MTUwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * <p/>Please, pay attention that sorting conditions should be passed by a {@link Pageable} parameter\n          \n          \n            \n            \t * <p/>Please note that sorting options should be passed by a {@link Pageable} parameter", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r380861508", "createdAt": "2020-02-18T18:41:12Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "diffHunk": "@@ -40,6 +41,9 @@\n \t/**\n \t * Takes a Cloud Spanner SQL string to define the actual query to be executed. This one will\n \t * take precedence over the method name then.\n+\t * <p/>Please, pay attention that sorting conditions should be passed by a {@link Pageable} parameter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfdeafe2dcdadb923ea42e57f407a9ca6d1b219a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzI5ODUwOnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0MjoxM1rOFrN-IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0MjoxM1rOFrN-IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2MTk4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * instead of the query part. Otherwise, with the current implementation, the sorting could be broken\n          \n          \n            \n            \t * instead of the query. Otherwise the sorting could be broken", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r380861985", "createdAt": "2020-02-18T18:42:13Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "diffHunk": "@@ -40,6 +41,9 @@\n \t/**\n \t * Takes a Cloud Spanner SQL string to define the actual query to be executed. This one will\n \t * take precedence over the method name then.\n+\t * <p/>Please, pay attention that sorting conditions should be passed by a {@link Pageable} parameter\n+\t * instead of the query part. Otherwise, with the current implementation, the sorting could be broken", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfdeafe2dcdadb923ea42e57f407a9ca6d1b219a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzMwMzM1OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0Mzo0M1rOFrOBSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0Mzo0M1rOFrOBSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2Mjc5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * by a logic that fetches eager-interleaved fields when they are in the query result.\n          \n          \n            \n            \t * by logic that fetches eager-interleaved fields.", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r380862795", "createdAt": "2020-02-18T18:43:43Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/Query.java", "diffHunk": "@@ -40,6 +41,9 @@\n \t/**\n \t * Takes a Cloud Spanner SQL string to define the actual query to be executed. This one will\n \t * take precedence over the method name then.\n+\t * <p/>Please, pay attention that sorting conditions should be passed by a {@link Pageable} parameter\n+\t * instead of the query part. Otherwise, with the current implementation, the sorting could be broken\n+\t * by a logic that fetches eager-interleaved fields when they are in the query result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfdeafe2dcdadb923ea42e57f407a9ca6d1b219a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzMxMTg3OnYy", "diffSide": "RIGHT", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0NjoyNlrOFrOGjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo0NjoyNlrOFrOGjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2NDE0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t *     Please, pay attention there is no sense to pass it as {@code true} when the {@param sql} already contains\n          \n          \n            \n            \t *     Please note there is no sense to pass it as {@code true} when the {@param sql} already contains", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2174#discussion_r380864143", "createdAt": "2020-02-18T18:46:26Z", "author": {"login": "dmitry-s"}, "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -131,24 +131,33 @@ private SpannerStatementQueryExecutor() {\n \t * @param sql the sql that will be wrapped with sorting and paging options.\n \t * @param mappingContext a mapping context to convert between Cloud Spanner column names\n \t *     and underlying property names.\n+\t * @param fetchInterleaved when {@code true} additional subqueries will be added\n+\t *     to fetch eager-Interleaved lists with a single query.\n+\t *     Please, pay attention there is no sense to pass it as {@code true} when the {@param sql} already contains", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfdeafe2dcdadb923ea42e57f407a9ca6d1b219a"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2228, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}